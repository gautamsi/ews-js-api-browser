// Copyright (c) 2014-2017 Gautam Singh
// MIT License; Full text at - https://github.com/gautamsi/ews-javascript-api/blob/master/LICENSE
// Packages license notices pending

import * as b64 from 'base64-js';
import * as uuid from 'uuid';
import * as moment from 'moment-timezone';


export interface IndexerWithStringKey<TValue> {
    [index: string]: TValue;
}
export interface IndexerWithNumericKey<TValue> {
    [index: number]: TValue;
}


export interface KeyValuePair<TKey, TValue> {
    key: TKey;
    value: TValue;
}
interface StringPropertyDefinitionArray<TKey, TValue> {
    [index: string]: TValue;
}
export interface StringKeyPicker<TValue> {
    (value: TValue): string;
}
export class Dictionary<TKey, TValue>{
    private keys: string[] = [];
    private keysToObjs: IndexerWithStringKey<TKey> = {}
    private objects: IndexerWithStringKey<TValue> = {};// {[key:string]:TValue};
    private keyPicker: StringKeyPicker<TKey>;
    
    
    /** get all keys */
    get Keys(): TKey[] {
        var keys: TKey[] = [];
        for (var key of this.keys) {
            keys.push(this.keysToObjs[key]);
        }
        return keys;
    }
    /**get all items in key,value pair array */
    get Items(): KeyValuePair<TKey, TValue>[] {
        var items: KeyValuePair<TKey, TValue>[] = [];
        for (var k of this.keys) {
            items.push({ key: this.keysToObjs[k], value: this.objects[k] });
        }
        return items;
    }
    
    /** get all values */
    get Values(): TValue[] {
        var ret: TValue[] = [];
        for (var key of this.keys) {
            ret.push(this.objects[key]);
        }
        return ret;
    }
    
    /** get number of objects in dictionary */
    get length(): number { return this.keys.length; }
    /** get number of objects in the dictionary */
    get Count(): number { return this.length; }

    constructor(keyPickerFunc: StringKeyPicker<TKey>) {
        if (typeof keyPickerFunc !== 'function')
            throw new Error("Dictionary - keyPickerFunc must be a function");

        this.keyPicker = keyPickerFunc;

    }
    
    /** get string values of all keys */
    getStringKeys(): string[] { return this.keys; }
    
    
    /** add value or update the value for key */
    Add(key: TKey, value: TValue): void { return this.addUpdate(key, value); }
    /** add value or update the value for key */
    addUpdate(key: TKey, value: TValue): void {
        var strKey = this.keyPicker(key);
        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key object, keyPicker return null");

        if (!this.containsKey(strKey)) {
            this.keys.push(strKey);
        }
        this.keysToObjs[strKey] = key;
        this.objects[strKey] = value;
    }
    
    /** Set value for key */
    set(key: TKey, value: TValue): void {
        this.addUpdate(key, value);
    }

    /** sets the new entry with old value or optionally new value, use isnull parameter to make sure you are setting a null value instead of old value */
    setEntry(oldKey: string, newKey: TKey): void;
    setEntry(oldKey: TKey, newKey: TKey): void;
    setEntry(oldKey: string | TKey, newKey: TKey): void {
        var strKey: string = <any>oldKey;
        if (typeof oldKey !== 'string')
            strKey = this.keyPicker(oldKey);

        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key object, keyPicker return null");

        if (this.containsKey(strKey)) {
            throw new Error("Dictionary - does not contain old key");
        }
        var oldval = this.objects[strKey];
        //oldval =   null:value;
        this.remove(strKey);
        this.addUpdate(newKey, oldval);
    }
    /** get value for key */
    get(key: string): TValue;
    get(key: TKey): TValue;
    get(key: string | TKey): TValue {
        var strKey: string = <any>key;
        if (typeof key !== 'string')
            strKey = this.keyPicker(key);

        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key object, keyPicker return null");

        return this.objects[strKey];

    }
    /**try get value for key or return exception in IOutParam.exception */
    tryGetValue(key: string, outValue: IOutParam<TValue>): boolean;
    tryGetValue(key: TKey, outValue: IOutParam<TValue>): boolean;
    tryGetValue(key: string | TKey, outValue: IOutParam<TValue>): boolean {
        outValue.outValue = null;
        outValue.success = false;

        var strKey: string = <any>key;
        if (typeof key !== 'string')
            strKey = this.keyPicker(key);

        if (StringHelper.IsNullOrEmpty(strKey)) {
            outValue.exception = new Error("Dictionary - invalid key,not a string value or keyPicker return null");
            return false;
        }
        if (this.containsKey(strKey)) {
            outValue.outValue = this.objects[strKey]
            outValue.success = true;
            return true;
        }

        return false;
    }
    /**remove key and value for key */
    remove(key: string): boolean;
    remove(key: TKey): boolean;
    remove(key: string | TKey): boolean {
        var strKey: string = <any>key;
        if (typeof key !== 'string')
            strKey = this.keyPicker(key);
        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key,not a string value or keyPicker return null");
        if (!this.containsKey(strKey))
            return false;

        var keyindex = this.keys.indexOf(strKey);
        var delKeyAr: string[] = this.keys.splice(keyindex, 1);

        var delkeyObj: boolean = delete this.keysToObjs[strKey];
        var delObj: boolean = delete this.objects[strKey];
        return delKeyAr.length > 0 && delkeyObj && delObj;
    }
    
    /** check if key exist */
    containsKey(key: string): boolean;
    containsKey(key: TKey): boolean;
    containsKey(key: string | TKey): boolean {
        var strKey: string = <any>key;
        if (typeof key !== 'string')
            strKey = this.keyPicker(key);

        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key object, keyPicker return null");

        if (this.keys.indexOf(strKey) >= 0)
            return true;

        return false;
    }
    /** clear dictionary */
    clear(): void {

        this.keys = [];
        this.keysToObjs = {};
        this.objects = {};
    }
}

/**@internal */
export class StringPropertyDefinitionBaseDictionary<TKey extends string, TValue extends PropertyDefinitionBase> extends Dictionary<string, TValue>{
    //private keys: string[] = [];
    //private objects: StringPropertyDefinitionArray<TKey, TValue> = {};// {[key:string]:TValue};

    
}

/**@internal */
export class PropertyDefinitionDictionary extends StringPropertyDefinitionBaseDictionary<string, PropertyDefinitionBase>{
}

export interface IndexerWithEnumKey<TKey, TValue> {
    [index: number]: TValue;
}
interface PropDictionaryKey {
    name?: string;
    key?: string;
    id?: string;
}
interface PropDictionaryValue<TKey, TValue> {
    key: string;
    keyObject: TKey;
    value: TValue;

}
interface StringArray<TKey, TValue> {
    [index: string]: PropDictionaryValue<TKey, TValue>;
}

/**@internal */
export class DictionaryWithStringKey<TValue> extends Dictionary<string, TValue>{
    constructor() {
        super((value) => value);
    }
}

/**@internal */
export class DictionaryWithNumericKey<TValue> extends Dictionary<number, TValue>{
    constructor() {
        super((value) => value.toString());
    }
}
/**@internal */
export class DictionaryWithPropertyDefitionKey<TKey extends { Name?: string }, TValue> extends Dictionary<TKey, TValue>{
    constructor() {
        super((value: TKey) => value.Name);
    }
}

class PropDictionary2<TKey extends { Name?: string }, TValue>{
    private keys: string[] = [];
    private objects: StringArray<TKey, TValue> = {};// {[key:string]:TValue};

    get KeyNames(): string[] { return this.keys; }
    get Keys(): TKey[] {
        var ret: TKey[] = [];
        for (var key in this.objects) {
            ret.push(this.objects[key].keyObject);
        }
        return ret;
    }
    get Items(): KeyValuePair<TKey, TValue>[] {
        var all: any[] = [];
        for (var obj in this.objects) {
            all.push({ key: this.objects[obj].keyObject, value: this.objects[obj].value });
        }
        return all;
    }
    get Values(): TValue[] {
        var ret: TValue[] = [];
        for (var key in this.objects) {
            ret.push(this.objects[key].value);
        }
        return ret;
    }
    get length(): number { return this.keys.length; }
    constructor() {
    }

    add(key: TKey, value: TValue): void {
        var keyString = key.Name;
        if (this.keys.indexOf(key.Name) == -1) {
            this.keys.push(keyString);
        }
        this.objects[keyString] = { key: keyString, keyObject: key, value: value };
    }
    set(key: TKey, value: TValue): void {
        this.add(key, value);
    }
    setEntry(oldKeyString: string, oldKey: TKey, value?: TValue, isNull: boolean = false): void {

        if (this.keys.indexOf(oldKeyString) == -1 || typeof this.objects[oldKeyString] === 'undefined') {
            throw new Error("invalid old keystring");
        }
        var oldval = isNull ? null : value || this.objects[oldKeyString].value;
        //oldval =   null:value;
        this.objects[oldKeyString] = { key: oldKey.Name, keyObject: oldKey, value: value || oldval };
    }
    get(key: TKey): TValue {
        if (StringHelper.IsNullOrEmpty(key.Name))
            throw new Error("invalid operation, object does not have valid Name property");

        //if(this.keys.indexOf(key.Name)>=0)
        var val = this.objects[key.Name]
        return val ? val.value : undefined;
    }

    tryGet(key: TKey, outValue: IOutParam<TValue>): boolean {
        outValue.outValue = null;
        outValue.success = false;

        if (StringHelper.IsNullOrEmpty(key.Name))
            outValue.exception = new Error("invalid operation, object does not have valid Name property");

        if (this.containsKey(key)) {
            var val = this.objects[key.Name]
            outValue.outValue = val ? val.value : null;
            return true;
        }

        return false;
    }

    remove(key: TKey): boolean {
        if (StringHelper.IsNullOrEmpty(key.Name)) throw new Error("missing keyString")
        return delete this.objects[key.Name];
    }

    containsKey(key: TKey): boolean {
        if (this.keys.indexOf(key.Name) >= 0 || typeof this.objects[key.Name] !== 'undefined')
            return true;

        return false;
    }

    clear(): void {

        this.keys = [];
        this.objects = {};
    }
}


export class ConfigurationApi {

    static ConfigureXHR(xhrApi: IXHRApi) {
        XHRFactory.xhrHelper = xhrApi;
    }

    static ConfigurePromise(promise: PromiseConstructor) {
        ConfigurePromise(promise);
    }
}


const ticksToEpoch: number = 621355968000000000; //can be used when calculating ticks/ms from Windows date to unix date
export const msToEpoch: number = 62135596800000;

const invalidDateTimeMessage = {
    "years": "year is less than 1 or greater than 9999.",
    "months": "month is less than 1 or greater than 12.",
    "days": "day is less than 1 or greater than the number of days in month.",
    "hours": "hour is less than 0 or greater than 23.",
    "minutes": "minute is less than 0 or greater than 59.",
    "seconds": "second is less than 0 or greater than 59.",
    "milliseconds": "millisecond is less than 0 or greater than 999."
};

export enum DateTimeKind {
    Unspecified = 0,
    Utc = 1,
    Local = 2,
}

/**
 * DateTime - basic date time based on moment.js
 */
export class DateTime {

    private static readonly DaysToMonth365: number[] = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
    private static readonly DaysToMonth366: number[] = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];

    kind: DateTimeKind = DateTimeKind.Unspecified;
    get MomentDate(): moment.Moment { return this.momentDate; }
    get currentUtcOffset(): number { return this.momentDate.utcOffset(); }
    private get momentDate(): moment.Moment { return this.getMomentDate(); }
    private getMomentDate: Function
    private setMomentDate: Function
    private originalDateInput: any = null;

    public static get Now(): DateTime {
        return new DateTime(moment());
    }

    public static get UtcNow(): DateTime {
        return new DateTime(moment.utc());
    }
    get TotalMilliSeconds(): number {
        return this.momentDate.valueOf()
    }

    constructor(ms: number);
    constructor(date: DateTime);
    constructor(momentInput: moment.MomentInput);
    constructor(ms: number, kind: DateTimeKind);
    constructor(year: number, month: number, day: number);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, kind: DateTimeKind);

    constructor(msOrDateOrMomentOrYear?: number | DateTime | moment.MomentInput,
        monthOrKind?: number | DateTimeKind,
        day?: number,
        hour?: number,
        minute?: number,
        second?: number,
        millisecond?: number,
        kind: DateTimeKind = DateTimeKind.Unspecified) {


        let argsLength = arguments.length;
        let momentdate: moment.Moment = moment();

        this.kind = kind;

        if (argsLength === 1) {
            if (msOrDateOrMomentOrYear instanceof DateTime) {
                momentdate = msOrDateOrMomentOrYear.MomentDate.clone();
                this.kind = msOrDateOrMomentOrYear.kind;
            }
            else {
                momentdate = moment(msOrDateOrMomentOrYear);
                this.originalDateInput = msOrDateOrMomentOrYear;
            }
        }
        else if (argsLength === 2) {
            if (monthOrKind === DateTimeKind.Utc && !(msOrDateOrMomentOrYear instanceof moment)) {
                momentdate = moment.utc(<any>msOrDateOrMomentOrYear);
            }
            else {
                momentdate = moment(<any>msOrDateOrMomentOrYear);
            }
            this.kind = monthOrKind;
            if (this.kind === DateTimeKind.Unspecified && !(msOrDateOrMomentOrYear instanceof moment)) {
                this.originalDateInput = msOrDateOrMomentOrYear;
            }
        }
        else {
            let momentInput: moment.MomentInputObject = {};
            if (argsLength >= 3) {
                momentInput.year = <number>msOrDateOrMomentOrYear;
                momentInput.month = monthOrKind - 1;
                momentInput.day = day;
            }
            if (argsLength >= 6) {
                momentInput.hour = hour;
                momentInput.minute = minute;
                momentInput.second = second;
            }

            if (argsLength >= 7) {
                momentInput.millisecond = millisecond;
            }

            momentdate = moment(momentInput);

        }
        if (momentdate && !momentdate.isValid()) {
            let invalid = momentdate.invalidAt();
            throw new ArgumentOutOfRangeException(momentValidity[invalid], invalidDateTimeMessage[momentValidity[invalid]]);
        }

        // if (momentdate.isUtc()) {
        //     this.kind = DateTimeKind.Utc
        // }
        // else if (momentdate.isLocal()) {
        //     this.kind = DateTimeKind.Local;
        // }

        this.getMomentDate = () => momentdate;
        this.setMomentDate = (value) => momentdate = value;
    }


    Add(ts: TimeSpan, ): DateTime;
    Add(quantity: number, unit: moment.unitOfTime.Base): DateTime;
    Add(quantity: number | TimeSpan, unit: moment.unitOfTime.Base = "ms"): DateTime {
        if (typeof quantity !== 'number') {
            quantity = quantity.TotalMilliseconds;
            unit = "ms"
        }
        var date: moment.Moment = moment(this.momentDate);
        date.add(quantity, unit);
        return new DateTime(date);
    }

    static Compare(x: DateTime, y: DateTime): number {
        var diff: number = x.momentDate.diff(y.momentDate);
        if (diff === 0) return 0;
        if (diff < 0) return -1;
        return 1;
    }

    CompareTo(toDate: DateTime): number {
        return DateTime.Compare(this, toDate);
    }

    Difference(toDate: DateTime): TimeSpan {
        return new TimeSpan(toDate.momentDate.diff(this.momentDate));
    }

    Format(formatting: string): string {
        return this.momentDate.format(formatting);
    }

    private static getKindfromMoment(m: moment.Moment): DateTimeKind {
        if (m.isUTC()) {
            return DateTimeKind.Utc;
        }
        if (m.isLocal()) {
            return DateTimeKind.Local;
        }
        return DateTimeKind.Unspecified;
    }
    static Parse(value: any, kind: DateTimeKind = DateTimeKind.Unspecified): DateTime {
        let mdate = moment(value);
        let tempDate: DateTime = null;
        if (mdate.isValid()) {
            switch (kind) {
                case DateTimeKind.Local:
                    tempDate = new DateTime(mdate.local());
                    tempDate.kind = kind;
                    return tempDate;
                case DateTimeKind.Utc:
                    tempDate = new DateTime(moment.utc(value));
                    tempDate.kind = kind;
                    return tempDate;
                default:
                    tempDate = new DateTime(mdate);
                    tempDate.originalDateInput = value;
                    tempDate.kind = kind;
                    return tempDate;
            }
        }
        else {
            throw new ArgumentException("invalid date value");
        }
    }

    ToISOString(): string {
        return this.momentDate.toISOString();
    }

    toString(): string {
        return this.momentDate.toString();
    }

    utcOffset(value: number) {
        this.momentDate.utcOffset(value);
    }

    static DateimeStringToTimeZone(dtStr: string, zoneStr: string): DateTime {
        return new DateTime(moment.tz(dtStr, zoneStr));
    }

    static DateTimeToXSDateTime(dateTime: DateTime): string {
        var format = 'YYYY-MM-DDTHH:mm:ss.SSSZ';//using moment format for c#->"yyyy-MM-ddTHH:mm:ss.fff";

        // switch (dateTime.Kind) {
        // 	case DateTimeKind.Utc:
        // 		format += "Z";
        // 		break;
        // 	case DateTimeKind.Local:
        // 		format += "zzz";
        // 		break;
        // 	default:
        // 		break;
        // }

        // Depending on the current culture, DateTime formatter will replace ':' with 
        // the DateTimeFormatInfo.TimeSeparator property which may not be ':'. Force the proper string
        // to be used by using the InvariantCulture.
        return dateTime.Format(format);//, CultureInfo.InvariantCulture);
    }
    static DateTimeToXSDate(date: DateTime): string {
        var format = 'YYYY-MM-DDZ';//using moment format for c#->"yyyy-MM-dd";

        // switch (date.Kind) {
        // 	case DateTimeKind.Utc:
        // 		format = "yyyy-MM-ddZ";
        // 		break;
        // 	case DateTimeKind.Unspecified:
        // 		format = "yyyy-MM-dd";
        // 		break;
        // 	default: // DateTimeKind.Local is remaining
        // 		format = "yyyy-MM-ddzzz";
        // 		break;
        // }

        // Depending on the current culture, DateTime formatter will 
        // translate dates from one culture to another (e.g. Gregorian to Lunar).  The server
        // however, considers all dates to be in Gregorian, so using the InvariantCulture will
        // ensure this.
        return date.Format(format);//, CultureInfo.InvariantCulture);
    }
    static MinValue: DateTime = new DateTime('0001-01-01T00:00:00+00:00');
    static MaxValue: DateTime = new DateTime("9999-12-31T23:59:59.9999999+00:00");

    /* c# DateTime properties */

    public get Date(): DateTime {
        if (this === DateTime.MaxValue || this === DateTime.MinValue) {
            return new DateTime(this.momentDate.utc().format("YYYY-MM-DD"))
        }
        return new DateTime(this.momentDate.format("YYYY-MM-DD"));
    }
    public get Day(): number {
        return this.momentDate.date();
    }
    public get DayOfWeek(): DayOfWeek {
        return this.momentDate.day();
    }
    public get DayOfYear(): number {
        return this.momentDate.dayOfYear();
    }
    public get Hour(): number {
        return this.momentDate.hour();
    }
    public get Kind(): DateTimeKind {
        return this.kind;
    }
    public get Millisecond(): number {
        return this.momentDate.millisecond();
    }
    public get Minute(): number {
        return this.momentDate.minute();
    }
    public get Month(): number {
        return this.momentDate.month() + 1;
    }

    public get Second(): number {
        return this.momentDate.second();
    }
    //  public get Ticks(): {
    //      return this.
    //  }
    public get TimeOfDay(): TimeSpan {
        return TimeSpan.FromMilliseconds(this.momentDate.millisecond());
    }
    public get Today(): DateTime {
        return new DateTime(moment(this.momentDate.format("LL"), "LL"));
    }
    public get Year(): number {
        return this.momentDate.year();
    }

    /* c# DateTime Methods */

    //CompareTo

    public AddDays(days: number): DateTime {
        return this.Add(days, unitOfTime.days);
    }

    public AddHours(hours: number): DateTime {
        return this.Add(hours, unitOfTime.hours);
    }
    public AddMilliseconds(ms: number): DateTime {
        return this.Add(ms, unitOfTime.ms);
    }
    public AddMinutes(minutes: number): DateTime {
        return this.Add(minutes, unitOfTime.minutes);
    }
    public AddMonths(months: number): DateTime {
        return this.Add(months, unitOfTime.months);
    }
    public AddSeconds(seconds: number): DateTime {
        return this.Add(seconds, unitOfTime.seconds);
    }
    // public AddTicks(ticks: number): DateTime {
    //     return this.Add(ticks, unitOfTime.);
    // }
    public AddYears(years: number): DateTime {
        return this.Add(years, unitOfTime.years);
    }

    public static DaysInMonth(year: number, month: number) {
        if (month < 1 || month > 12)
            throw new ArgumentOutOfRangeException("month", invalidDateTimeMessage["months"]);
        // IsLeapYear checks the year argument
        let days: number[] = DateTime.IsLeapYear(year) ? DateTime.DaysToMonth366 : DateTime.DaysToMonth365;
        return days[month] - days[month - 1];
    }
    Equals(value: any | DateTime): boolean {
        if (value instanceof DateTime) {
            return value.TotalMilliSeconds === this.TotalMilliSeconds;
        }
        return false;
    }
    public static Equals(t1: DateTime, t2: DateTime): boolean {
        return t1.TotalMilliSeconds === t2.TotalMilliSeconds;
    }
    // FromBinary
    // FromFileTime
    // FromFileTimeUtc
    // FromOADate

    // GetHashCode

    IsDaylightSavingTime(): boolean {
        return this.momentDate.isDST();
    }

    /**
     *  Checks whether a given year is a leap year. This method returns true if year is a leap year, or false if not.
     * @param {number}  year 
     */
    public static IsLeapYear(year: number): boolean {
        if (year < 1 || year > 9999) {
            throw new ArgumentOutOfRangeException("year", invalidDateTimeMessage["years"]);
        }
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
    }


    // ParseExact

    public static SpecifyKind(value: DateTime, kind: DateTimeKind) {
        return new DateTime(value.TotalMilliSeconds, kind);
    }

    Subtract(date: DateTime): TimeSpan;
    Subtract(ts: TimeSpan): DateTime;
    Subtract(dateTime: DateTime | TimeSpan): DateTime | TimeSpan {
        if (dateTime instanceof DateTime) {
            return new TimeSpan(this.TotalMilliSeconds - dateTime.TotalMilliSeconds);
        }
        else {
            return new DateTime(this.TotalMilliSeconds - dateTime.TotalMilliseconds);
        }
    }

    // ToBinary
    // ToFileTime
    // ToFileTimeUtc

    ToLocalTime(): DateTime {
        return new DateTime(this.momentDate.local());
    }

    ToLongDateString(): string {
        return this.momentDate.format("dddd, MMMM D, YYYY");
    }

    ToLongTimeString(): string {
        return this.momentDate.format("LTS");
    }

    // ToOADate


    ToShortDateString(): string {
        return this.MomentDate.format("l");
    }

    ToShortTimeString(): string {
        return this.MomentDate.format("LT");
    }

    ToString(): string {
        return this.toString();
    }


    ToUniversalTime(): DateTime {
        return new DateTime(this.MomentDate.utc());
    }

    static TryParse(s: string | moment.MomentInput, outDate: IOutParam<DateTime>) {
        try {
            outDate.outValue = DateTime.Parse(s);
            outDate.outValue.kind = this.getKindfromMoment(outDate.outValue.momentDate);
            return true;
        } catch (error) {
            outDate.exception = error;
        }
        return false;
    }

    // TryParseExact
    valueOf(): number {
        return this.TotalMilliSeconds;
    }
}

//
// Summary:
//     Defines the formatting options that customize string parsing for some date and
//     time parsing methods.
export enum DateTimeStyles {
    //
    // Summary:
    //     Default formatting options must be used. This value represents the default style
    //     for the System.DateTime.Parse(System.String), System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider),
    //     and System.DateTime.TryParse(System.String,System.DateTime@) methods.
    None = 0,
    //
    // Summary:
    //     Leading white-space characters must be ignored during parsing, except if they
    //     occur in the System.Globalization.DateTimeFormatInfo format patterns.
    AllowLeadingWhite = 1,
    //
    // Summary:
    //     Trailing white-space characters must be ignored during parsing, except if they
    //     occur in the System.Globalization.DateTimeFormatInfo format patterns.
    AllowTrailingWhite = 2,
	/**
	 * Summary:
	 *	    Extra white-space characters in the middle of the string must be ignored during
	 *	    parsing, except if they occur in the System.Globalization.DateTimeFormatInfo
	 *	    format patterns.
	 */
    AllowInnerWhite = 4,

	/**
	 * 	Summary:
	 *	    Extra white-space characters anywhere in the string must be ignored during parsing,
	 *	    except if they occur in the System.Globalization.DateTimeFormatInfo format patterns.
	 *	    This value is a combination of the System.Globalization.DateTimeStyles.AllowLeadingWhite,
	 *	    System.Globalization.DateTimeStyles.AllowTrailingWhite, and System.Globalization.DateTimeStyles.AllowInnerWhite
	 *	    values.
	 */
    AllowWhiteSpaces = 7,
    //
    // Summary:
    //     If the parsed string contains only the time and not the date, the parsing methods
    //     assume the Gregorian date with year = 1, month = 1, and day = 1. If this value
    //     is not used, the current date is assumed.
    NoCurrentDateDefault = 8,
    //
    // Summary:
    //     Date and time are returned as a Coordinated Universal Time (UTC). If the input
    //     string denotes a local time, through a time zone specifier or System.Globalization.DateTimeStyles.AssumeLocal,
    //     the date and time are converted from the local time to UTC. If the input string
    //     denotes a UTC time, through a time zone specifier or System.Globalization.DateTimeStyles.AssumeUniversal,
    //     no conversion occurs. If the input string does not denote a local or UTC time,
    //     no conversion occurs and the resulting System.DateTime.Kind property is System.DateTimeKind.Unspecified.
    AdjustToUniversal = 16,
    //
    // Summary:
    //     If no time zone is specified in the parsed string, the string is assumed to denote
    //     a local time.
    AssumeLocal = 32,
    //
    // Summary:
    //     If no time zone is specified in the parsed string, the string is assumed to denote
    //     a UTC.
    AssumeUniversal = 64,
    //
    // Summary:
    //     The System.DateTimeKind field of a date is preserved when a System.DateTime object
    //     is converted to a string using the "o" or "r" standard format specifier, and
    //     the string is then converted back to a System.DateTime object.
    RoundtripKind = 128
}

export var unitOfTime = {
    "year": <moment.unitOfTime.Base>"year",
    "years": <moment.unitOfTime.Base>"years",
    "y": <moment.unitOfTime.Base>"y",
    "month": <moment.unitOfTime.Base>"month",
    "months": <moment.unitOfTime.Base>"months",
    "M": <moment.unitOfTime.Base>"M",
    "week": <moment.unitOfTime.Base>"week",
    "weeks": <moment.unitOfTime.Base>"weeks",
    "w": <moment.unitOfTime.Base>"w",
    "day": <moment.unitOfTime.Base>"day",
    "days": <moment.unitOfTime.Base>"days",
    "d": <moment.unitOfTime.Base>"d",
    "hour": <moment.unitOfTime.Base>"hour",
    "hours": <moment.unitOfTime.Base>"hours",
    "h": <moment.unitOfTime.Base>"h",
    "minute": <moment.unitOfTime.Base>"minute",
    "minutes": <moment.unitOfTime.Base>"minutes",
    "m": <moment.unitOfTime.Base>"m",
    "second": <moment.unitOfTime.Base>"second",
    "seconds": <moment.unitOfTime.Base>"seconds",
    "s": <moment.unitOfTime.Base>"s",
    "millisecond": <moment.unitOfTime.Base>"millisecond",
    "milliseconds": <moment.unitOfTime.Base>"milliseconds",
    "ms": <moment.unitOfTime.Base>"ms",
}

enum momentValidity {
    years,
    months,
    days,
    hours,
    minutes,
    seconds,
    milliseconds,
}

/// <reference path="../../typings/base64-js.d.ts" />


export module StringHelper {
    export function IsNullOrEmpty(str: string): boolean {
        return str == null || typeof str === 'undefined' || str === '';
    }
    /*
    * @author electricessence / https://github.com/electricessence/
    * Liscensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE
      part System.Text at above library
    */
    export function Format(source: string, ...args: any[]) {
        for (var i = 0; i < args.length; i++)
            source = source.replace("{" + i + "}", args[i]);
        return source;
    }

    export var Empty = "";

    export function Repeat(str: string = "", times: number = 1): string {
        return new Array(times + 1).join(str);
    }
    export function Tabs(times: number = 0): string {
        return Repeat("\t", times);
    }
    export function Compare(lhs: string, rhs: string, ignoreCase: boolean = false): number {
        if (ignoreCase) {
            return lhs.toLocaleLowerCase().localeCompare(rhs.toLocaleLowerCase());
        }
        else {
            return lhs.localeCompare(rhs);
        }
    }
}

export module EnumHelper {
    export function HasFlag(flags: number, checkFlag: number): boolean {
        return (flags & checkFlag) == checkFlag;
    }

    /**
     * Writes "," separated values from Enumertion anf enum Flags
     * 
     * @export
     * @param {*} enumObj The Enumeration Object itself, for example 'ExchangeVersion' as the parameter Value.
     * @param {number} checkFlag Flag value(s) to convert to string
     * @param {boolean} [includeZero=false] include the default 0 value in the string, usually false
     * @returns {string} returns the coma "," separated string representation of Flags
     */
    export function ToString(enumObj: any, checkFlag: number, includeZero: boolean = false): string {
        if ((checkFlag & (checkFlag - 1)) == 0)
            return enumObj[checkFlag];
        var result: string[] = [];
        var diff = checkFlag;

        var largestFlag = 0;// = Math.pow(2, Math.floor(Math.pow(checkFlag, (1 / 2))));
        while (diff > 1) {
            largestFlag = Math.pow(2, Math.floor(Math.log(diff) / Math.log(2)));
            diff = diff - largestFlag;
            var largestValue = enumObj[largestFlag];
            if (largestValue === undefined) return undefined;
            result.push(largestValue);
        }
        if (diff == 1) result.push(enumObj[1]);
        if (includeZero && enumObj[0]) result.push(enumObj[0]);

        result.reverse();
        return result.join(", ");
    }
}

module object {

    function getPrototypeChain(ctor: Function): any[] {
        //unused
        //http://typescript.codeplex.com/discussions/468576
        var chain: any[] = [];
        var proto = ctor.prototype;
        while (proto) {
            chain.push(proto.constructor)
            proto = Object.getPrototypeOf(proto);
        }
        return chain;
        //var ste = JSON.stringify(ste);
    }
}

/**
 * explicitly checks if the obj is null or undefined
 * @param obj input to be checked
 */
export function isNullOrUndefined(obj: any): boolean {
    return obj === undefined || obj === null;
}

/**
 * explicitly checks if the obj has value and it is NOT null or undefined
 * @param obj input to be checked
 */
export function hasValue(obj: any): boolean {
    return !isNullOrUndefined(obj);
}

export module ArrayHelper {
    export function AddRange<T>(array: Array<T>, items: Array<T>, uniqueOnly: boolean = false): void {
        if (Object.prototype.toString.call(array) !== "[object Array]")
            throw new Error("input obj is not an array")
        if (Object.prototype.toString.call(items) !== "[object Array]")
            throw new Error("input range is not an array")
        for (var item of items) {
            if (!(uniqueOnly && array.indexOf(item) >= 0)) {
                array.push(item);
            }
        }
    }

    export function RemoveEntry<T>(array: Array<T>, entry: T, comparer: (T) => boolean = null): boolean {
        let index = array.indexOf(entry);
        if (comparer) {
            let entry = ArrayHelper.Find(array, comparer);
            index = array.indexOf(entry);
        }
        let lastLength = array.length;
        if (index >= 0) {
            array.splice(index, 1);
            return lastLength - array.length === 1;
        }
        else {
            return false
        }
    }

    export function Find<T>(array: Array<T>, comparer: (item: T) => boolean): T {
        for (var entry of array) {
            if (comparer(entry)) {
                return entry;
            }
        }
        return null;
    }

    export function IndexOf<T>(array: Array<T>, comparer: (item: T) => boolean): number {
        let item = ArrayHelper.Find(array, comparer);
        return array.indexOf(item);
    }

    export function OfType<T, U>(array: Array<T>, comparer: (item: T) => boolean): U[] {
        var result: U[] = [];
        for (var entry of array) {
            if (comparer(entry)) {
                result.push(<U><any>entry);
            }
        }
        return result;
    }
    /**dirty calculation of max dimension, will return more than one if array contains any array element in first testElementCount items */
    export function Rank(array: any[], testElementCount: number = 4): number {
        var rank: number = 1;
        if (array.length === 0) {
            return rank;
        }
        var length = array.length <= testElementCount ? array.length : testElementCount;
        var maxDepthRank: number = 0;
        for (var index = 0; index < length; index++) {
            var element = array[index];
            if (Array.isArray(element)) {
                var _tRank = Rank(element, testElementCount);
                maxDepthRank = _tRank > maxDepthRank ? _tRank : maxDepthRank;
            }
        }
        rank += maxDepthRank;
        return rank;
    }
    export function isArray<T>(obj: any): obj is T[] {
        return Object.prototype.toString.call(obj) === "[object Array]";
    }
}

export class TypeSystem {
    static GetProperties(obj: any) {
        var props = new Array<string>();

        for (var s in obj) {
            if (typeof (obj[s]) != "function") {
                props[props.length] = s;
            }
        }

        return props;
    }

    static GetMethods(obj: any) {
        var methods = new Array<string>();

        for (var s in obj) {
            if (typeof (obj[s]) == "function") {
                methods[methods.length] = s;
            }
        }

        return methods
    }

    static GetObjectStaticPropertiesByClassName(className: string): string[] {

        var obj = this.GetObjectByClassName(className);

        //if (prototype)
        //    obj = obj.prototype;
        if (obj == null || typeof (obj) == undefined)
            return [];//throw new Error("can not determine type");



        return this.GetProperties(obj);
    }

    static GetObjectMethodsByClassName(className: string, instanceMethod: boolean = true): string[] {
        var obj = this.GetObjectByClassName(className);

        if (obj == null || typeof (obj) == undefined)
            return [];// throw new Error("can not determine type");
        else if (instanceMethod)
            obj = obj.prototype || obj;

        return this.GetMethods(obj);
    }

    static GetObjectByClassName(className: string): any {
        var obj: any;
        if (className.indexOf(".") > 0) {
            var objs = className.split(".");
            obj = window[objs[0]];

            for (var i = 1; i < objs.length; i++) {
                obj = obj[objs[i]];
            }
        }
        else
            obj = window[className];

        //if (prototype)
        //    obj = obj.prototype;

        return obj;
    }

    static GetJsObjectTypeName(obj: any): string {
        var keys = Object.keys(obj);
        if (keys && keys.indexOf("__type") >= 0)
            return obj["__type"];

        return undefined;

    }

    static GetJsObjectOnlyChildName(obj: any): string {
        for (var key in obj) {
            if (key.indexOf("__") >= 0)
                continue;
            return key;
        }
        return null;

    }

    static GetJsObjectTypeName_old(obj: any): string {

        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                var element = obj[key];
                if (element["__type"]) return element["__type"];
            }
        }
        return undefined;

    }

    static IsGenericType(value: any): boolean {
        if (value === null || typeof value === 'undefined') {
            return false;
        }
        let valueType = typeof value;
        return valueType === 'string' || valueType === 'boolean' || valueType === 'number';
    }
}

//use this class to to work with node - https://github.com/jindw/xmldom - tested working with commit f053be7ceb. 
//This library creates DOMParser object like functionality in node.For browsers, skip xmldom library and use inbuilt browser object
//var DOMParser = require('xmldom').DOMParser;
//var dom = new DOMParser().parseFromString("xml data", 'text/xml');
//ewslogging.log(JSON.stringify(xmlToJson(dom.documentElement)));
export class xml2JsObject {
    typeIncludedNS: string[] = [
        "http://schemas.microsoft.com/exchange/services/2006/types",
        "http://schemas.microsoft.com/exchange/services/2006/messages"
    ];

    parseXMLNode(xmlNode: Node, soapMode: boolean = false, xmlnsRoot: any = undefined): any {
        var obj: any = {};
        if (!xmlnsRoot) xmlnsRoot = obj;
        if (typeof (xmlNode) === 'undefined') return obj;
        var textNodeName: any = undefined;
        const PREFIX_STR: string = "__prefix";
        const TYPE_STR: string = "__type";
        const TEXT_STR: string = "__text";
        switch (xmlNode.nodeType) {
            case 1 /*Node.ELEMENT_NODE*/:
                if ((<Element>xmlNode).prefix && xmlNode.localName !== xmlNode.nodeName)
                    obj[PREFIX_STR] = (<Element>xmlNode).prefix;

                if (this.typeIncludedNS.indexOf(xmlNode.namespaceURI) >= 0) {
                    obj[TYPE_STR] = xmlNode.localName;
                }
                var nonGenericAttributeCount = 0;
                for (var i = 0; i < xmlNode["attributes"].length; i++) {
                    nonGenericAttributeCount++;
                    var attr: Attr = xmlNode["attributes"].item(i);
                    if (attr.prefix)
                        if (attr.prefix === 'xmlns') {
                            this.addXMLNS(xmlnsRoot, attr.localName, attr.value);
                            nonGenericAttributeCount--;
                        }
                        else if (this.containsXMLNS(xmlnsRoot, attr.prefix))
                            obj[attr.localName] = attr.value;
                        else
                            obj[attr.name] = attr.value;
                    else if (attr.localName === 'xmlns') {
                        if (xmlNode.namespaceURI !== attr.value && typeof obj[TYPE_STR] === <any>'undefiend') {
                            obj[TYPE_STR] = attr.value;
                        }
                        nonGenericAttributeCount--;
                    }
                    else
                        obj[attr.localName] = attr.value;
                }

                if (soapMode) {
                    if (nonGenericAttributeCount === 0 && xmlNode.childNodes.length === 0)
                        return null;
                    if (xmlNode.childNodes.length === 1 && xmlNode.firstChild.nodeType === 3/*Node.TEXT_NODE*/) {
                        if (xmlNode.firstChild.nodeValue.trim() !== '') {
                            if (nonGenericAttributeCount === 0) {
                                return xmlNode.firstChild.nodeValue.trim();
                            }
                            else {
                                obj[xmlNode.localName] = xmlNode.firstChild.nodeValue.trim();
                                return obj;
                            }
                        }
                    }
                    if (soapMode && obj["nil"] && obj["nil"] === 'true') {
                        return null;
                    }
                }
                break;
            case 2/*Node.ATTRIBUTE_NODE*/:

                break;
            case 3/*Node.TEXT_NODE*/:
                return xmlNode.nodeValue;
                break;
            default:
                return obj;
        }


        if (xmlNode.childNodes.length > 0) {
            var skip = false;
            if (soapMode && xmlNode.childNodes.length === 1 && xmlNode.firstChild.nodeType === 3/*Node.TEXT_NODE*/)
                skip = true;

            if (!skip) {
                for (var i = 0; i < xmlNode.childNodes.length; i++) {
                    var node: Node = xmlNode.childNodes.item(i);
                    var localName = node.localName || TEXT_STR;
                    if (localName === TEXT_STR && node.nodeValue.trim() === "") continue;
                    var nodeObj = this.parseXMLNode(node, soapMode, xmlnsRoot);
                    if (obj[localName])
                        if (Object.prototype.toString.call(obj[localName]) === "[object Array]")
                            obj[localName].push(nodeObj);
                        else {
                            var old = obj[localName];
                            obj[localName] = [];
                            obj[localName].push(old);
                            obj[localName].push(nodeObj);
                        }
                    else
                        obj[localName] = nodeObj;
                }
            }
        }

        return obj;
    }

    private addXMLNS(xmlnsObj: any, xmlnsName: string, xmlnsValue: string, xmlnsAttrName: string = "__xmlns"): void {
        if (!xmlnsObj[xmlnsAttrName]) xmlnsObj[xmlnsAttrName] = {};
        (xmlnsObj[xmlnsAttrName])[xmlnsName] = xmlnsValue;
    }
    private containsXMLNS(obj: any, xmlnsName: string, xmlnsAttrName: string = "__xmlns"): boolean {
        if (obj[xmlnsAttrName]) return typeof ((obj[xmlnsAttrName])[xmlnsName]) !== 'undefined';
        return false;
    }
}

module Parsers {

}
export interface ParsedUrl {
    scheme: string;
    authority: string;
    path: string;
    query: string;
    fragment: string;
}
export class UriHelper {
    //RFC Appendix B - http://www.ietf.org/rfc/rfc3986.txt 
    /*    Appendix B.  Parsing a URI Reference with a Regular Expression
    
       As the "first-match-wins" algorithm is identical to the "greedy"
       disambiguation method used by POSIX regular expressions, it is
       natural and commonplace to use a regular expression for parsing the
       potential five components of a URI reference.
    
       The following line is the regular expression for breaking-down a
       well-formed URI reference into its components.
    
    
    
    Berners-Lee, et al.         Standards Track                    [Page 50]
    
    RFC 3986                   URI Generic Syntax               January 2005
    
    
          ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
           12            3  4          5       6  7        8 9
    
       The numbers in the second line above are only to assist readability;
       they indicate the reference points for each subexpression (i.e., each
       paired parenthesis).  We refer to the value matched for subexpression
       <n> as $<n>.  For example, matching the above expression to
    
          http://www.ics.uci.edu/pub/ietf/uri/#Related
    
       results in the following subexpression matches:
    
          $1 = http:
          $2 = http
          $3 = //www.ics.uci.edu
          $4 = www.ics.uci.edu
          $5 = /pub/ietf/uri/
          $6 = <undefined>
          $7 = <undefined>
          $8 = #Related
          $9 = Related
    
       where <undefined> indicates that the component is not present, as is
       the case for the query component in the above example.  Therefore, we
       can determine the value of the five components as
    
          scheme    = $2
          authority = $4
          path      = $5
          query     = $7
          fragment  = $9
    
       Going in the opposite direction, we can recreate a URI reference from
       its components by using the algorithm of Section 5.3.
    */
    static parseString(url: string): ParsedUrl {
        var regex = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        var parts = url.match(regex);
        return {
            scheme: parts[2],
            authority: parts[4],
            path: parts[5],
            query: parts[7],
            fragment: parts[9]
        };
    }
    static getDomain(url: string): string {
        return this.parseString(url).authority;
    }
    static getHost(url: string): string {
        return this.getDomain(url);
    }

}

declare var window: any;
var isNode = (typeof window === 'undefined')
var dp: any = undefined;
declare var Buffer: any;
declare var require: any;

// if (isNode) {

//     var dr: any = require('xmldom');
//     dp = dr.DOMParser;
// } else {
    dp = window.DOMParser;
// }

export var DOMParser = dp;

export class Convert {
    static toInt(value: any, zeroIfError: boolean = true): number {
        var result: number = 0;
        try {
            result = parseInt(value);
        }
        catch (ex) {
            if (!zeroIfError)
                throw ex;
        }
        return result;
    }

    static toNumber(value: any): number {
        return Number(value);
    }
    static toBool(value: any, truefalseString = true, throwIfNotBool = false) {
        if (typeof value === 'boolean') return value;
        var num = Number(value);
        if (!isNaN(num)) {
            return num !== 0;
        }
        if (truefalseString) {
            return (<string>value).toLowerCase() === 'true'
        }

        if (throwIfNotBool) throw new Error("not a boolean");
        return false;
    }
    // static FromBase64String(encodedStr: string): string {
    //     return base64Helper.atob(encodedStr);
    // }
    // static ToBase64String(str: string): string {
    //     return base64Helper.btoa(str);
    // }
    static FromBase64String(encodedStr: string): number[] {
        return b64.toByteArray(encodedStr);
    }
    static ToBase64String(byteArray: number[]): string {
        return b64.fromByteArray(byteArray);
    }
}

export module base64Helper {

    export function btoa(textToEncode: string): string {
        if (isNode) {
            var b = new Buffer.from(textToEncode);
            return b.toString('base64');
        } else {
            return window.btoa(textToEncode);
        }
    }
    export function atob(textToDecode: string): string {
        if (isNode) {
            var b = new Buffer.from(textToDecode, 'base64');
            return b.toString();
        } else {
            return window.atob(textToDecode);
        }
    }
}


/** Guid proxy class */
export class Guid {

	static ParseStrict: boolean = false;

	static Empty: Guid = new Guid();
	private guid: string = '00000000-0000-0000-0000-000000000000';
	//private regx = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
	//private regx_withoutdash = /^[0-9a-f]{8}[0-9a-f]{4}[1-5][0-9a-f]{3}[89ab][0-9a-f]{3}[0-9a-f]{12}$/i;

	constructor();
	constructor(str: string);
	constructor(str?: string) {
		let regxStrict = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
		let regxRelax = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
		if (arguments.length > 0) {
			if (StringHelper.IsNullOrEmpty(str) || str === null) {
				throw new TypeError("Guid.ctor - invalid input");
			}
			//str = str.replace("-", "").replace("{", "").replace("}", "").toLowerCase();
			str = str.replace("{", "").replace("}", "").toLowerCase();
			if (regxStrict.test(str)) {
				this.guid = str;
			} else {
				if (!Guid.ParseStrict && regxRelax.test(str)) {
					EwsLogging.DebugLog("info: Guid.ctor - guid is in generic format. if you want to error on non uuid v4 format, set `Guid.ParseStrict = true`")
					this.guid = str;
				}
				else {
					throw new TypeError("Guid.ctor - invalid input, input not of type uuid v4");
				}
			}
		}
	}
	ToString() {
		return this.guid;
	}
	toString() {
		return this.guid;
	}

	static NewGuid(): Guid {
		return new Guid(uuid.v4());
	}
	static Parse(str: string): Guid {
		return new Guid(str);
	}

	static TryParse(str, _parsed_output: { guid: Guid } = { guid: null }) {
		try {
			_parsed_output.guid = new Guid(str);
			return true;
		} catch (error) {
			return false;
		}
	}
}

export interface IXHROptions {
	type?: string;
	url: string;
	user?: string;
	password?: string;
	headers?: any;
	data?: any;
	responseType?: string;
	customRequestInitializer?: (request: XMLHttpRequest) => void;
}

export interface IXHRProgress {
	type: 'data' | 'header' | 'end' | 'error'
	data?: string;
	chunk?: string;
	progress?: number;
	done?: boolean;
	headers?: any;
	originalHeaders?: any;
	error?: any;
}

export interface IXHRApi {
	xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
	xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
	disconnect(): void;
	apiName?: string;
}

/**
 * Represents the completion of an asynchronous operation
 * @typescript 2.1.1 lib.es6.d.ts Promise Description
 */
export interface Promise<T> {
    // /**
    //  * Attaches callbacks for the resolution and/or rejection of the Promise.
    //  * @param onfulfilled The callback to execute when the Promise is resolved.
    //  * @param onrejected The callback to execute when the Promise is rejected.
    //  * @returns A Promise for the completion of which ever callback is executed.
    //  */
    // then(onfulfilled?: ((value: T) => T | PromiseLike<T>) | undefined | null, onrejected?: ((reason: any) => T | PromiseLike<T>) | undefined | null): Promise<T>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult>(onfulfilled: ((value: T) => T | PromiseLike<T>) | undefined | null, onrejected: (reason: any) => TResult | PromiseLike<TResult>): Promise<T | TResult>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult>(onfulfilled: (value: T) => TResult | PromiseLike<TResult>, onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<TResult>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1, TResult2>(onfulfilled: (value: T) => TResult1 | PromiseLike<TResult1>, onrejected: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch(onrejected?: ((reason: any) => T | PromiseLike<T>) | undefined | null): Promise<T>;

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult>(onrejected: (reason: any) => TResult | PromiseLike<TResult>): Promise<T | TResult>;
}

export interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then(
        onfulfilled?: ((value: T) => T | PromiseLike<T>) | undefined | null,
        onrejected?: ((reason: any) => T | PromiseLike<T>) | undefined | null): PromiseLike<T>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult>(
        onfulfilled: ((value: T) => T | PromiseLike<T>) | undefined | null,
        onrejected: (reason: any) => TResult | PromiseLike<TResult>): PromiseLike<T | TResult>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult>(
        onfulfilled: (value: T) => TResult | PromiseLike<TResult>,
        onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): PromiseLike<TResult>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1, TResult2>(
        onfulfilled: (value: T) => TResult1 | PromiseLike<TResult1>,
        onrejected: (reason: any) => TResult2 | PromiseLike<TResult2>): PromiseLike<TResult1 | TResult2>;
}

export interface PromiseConstructor {
    /**
      * A reference to the prototype.
      */
    readonly prototype: Promise<any>;

    /**
     * Creates a new Promise.
     * @param executor A callback used to initialize the promise. This callback is passed two arguments:
     * a resolve callback used resolve the promise with a value or the result of another promise,
     * and a reject callback used to reject the promise with a provided reason or error.
     */
    new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;
    //new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onProgress?: (progress: any) => void) => void): Promise<T>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]): Promise<[T1, T2, T3, T4, T5]>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]): Promise<[T1, T2, T3, T4]>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;

    /**
     * Creates a Promise that is resolved with an array of results when all of the provided Promises
     * resolve, or rejected when any Promise is rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    all<T>(values: (T | PromiseLike<T>)[]): Promise<T[]>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<T1 | T2 | T3 | T4 | T5 | T6>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]): Promise<T1 | T2 | T3 | T4 | T5>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]): Promise<T1 | T2 | T3 | T4>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<T1 | T2 | T3>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<T1 | T2>;

    /**
     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
     * or rejected.
     * @param values An array of Promises.
     * @returns A new Promise.
     */
    race<T>(values: (T | PromiseLike<T>)[]): Promise<T>;

    /**
     * Creates a new rejected promise for the provided reason.
     * @param reason The reason the promise was rejected.
     * @returns A new rejected Promise.
     */
    reject(reason: any): Promise<never>;

    /**
     * Creates a new rejected promise for the provided reason.
     * @param reason The reason the promise was rejected.
     * @returns A new rejected Promise.
     */
    reject<T>(reason: any): Promise<T>;

    /**
      * Creates a new resolved promise for the provided value.
      * @param value A promise.
      * @returns A promise whose internal state matches the provided promise.
      */
    resolve<T>(value: T | PromiseLike<T>): Promise<T>;

    /**
     * Creates a new resolved promise .
     * @returns A resolved promise.
     */
    resolve(): Promise<void>;
}

export var Promise: PromiseConstructor = window.Promise;

// class PromiseType<T> {
//     constructor() {
//         throw new NotSupportedException("Promise implementation missing.\nPlease use ConfigurePromise function to assign Promise Object\n" +
//             "bluebird: ConfigurePromise(require('bluebird))\n" +
//             "Q: ConfigurePromise(require('q').Promise)\n" +
//             "winjs-node: ConfigurePromise(require('winjs-node').Promise)")
//     }
// }

// try {
//     var promise = require('bluebird');
//     Promise = promise;
// } catch (e) {
//     Promise = <any>PromiseType;
// }

export function ConfigurePromise(promise: PromiseConstructor) {
    Promise = promise;
}
export class Strings {
    static CannotRemoveSubscriptionFromLiveConnection: string = "Subscriptions can't be removed from an open connection.";
    static ReadAccessInvalidForNonCalendarFolder: string = "The Permission read access value {0} can't be used with a non-calendar folder.";
    static PropertyDefinitionPropertyMustBeSet: string = "The PropertyDefinition property must be set.";
    static ArgumentIsBlankString: string = "The argument contains only white space characters.";
    static InvalidAutodiscoverDomainsCount: string = "At least one domain name must be requested.";
    static MinutesMustBeBetween0And1439: string = "minutes must be between 0 and 1439, inclusive.";
    static DeleteInvalidForUnsavedUserConfiguration: string = "This user configuration object can't be deleted because it's never been saved.";
    static PeriodNotFound: string = "Invalid transition. A period with the specified Id couldn't be found: {0}";
    static InvalidAutodiscoverSmtpAddress: string = "A valid SMTP address must be specified.";
    static InvalidOAuthToken: string = "The given token is invalid.";
    static MaxScpHopsExceeded: string = "The number of SCP URL hops exceeded the limit.";
    static ContactGroupMemberCannotBeUpdatedWithoutBeingLoadedFirst: string = "The contact group's Members property must be reloaded before newly-added members can be updated.";
    static CurrentPositionNotElementStart: string = "The current position is not the start of an element.";
    static CannotConvertBetweenTimeZones: string = "Unable to convert {0} from {1} to {2}.";
    static FrequencyMustBeBetween1And1440: string = "The frequency must be a value between 1 and 1440.";
    static CannotSetDelegateFolderPermissionLevelToCustom: string = "This operation can't be performed because one or more folder permission levels were set to Custom.";
    static PartnerTokenIncompatibleWithRequestVersion: string = "TryGetPartnerAccess only supports {0} or a later version in Microsoft-hosted data center.";
    static InvalidAutodiscoverRequest: string = "Invalid Autodiscover request: '{0}'";
    static InvalidAsyncResult: string = "The IAsyncResult object was not returned from the corresponding asynchronous method of the original ExchangeService object.";
    static InvalidMailboxType: string = "The mailbox type isn't valid.";
    static AttachmentCollectionNotLoaded: string = "The attachment collection must be loaded.";
    static ParameterIncompatibleWithRequestVersion: string = "The parameter {0} is only valid for Exchange Server version {1} or a later version.";
    static DayOfWeekIndexMustBeSpecifiedForRecurrencePattern: string = "The recurrence pattern's DayOfWeekIndex property must be specified.";
    static WLIDCredentialsCannotBeUsedWithLegacyAutodiscover: string = "This type of credentials can't be used with this AutodiscoverService.";
    static PropertyCannotBeUpdated: string = "This property can't be updated.";
    static IncompatibleTypeForArray: string = "Type {0} can't be used as an array of type {1}.";
    static PercentCompleteMustBeBetween0And100: string = "PercentComplete must be between 0 and 100.";
    static AutodiscoverServiceIncompatibleWithRequestVersion: string = "The Autodiscover service only supports {0} or a later version.";
    static InvalidAutodiscoverSmtpAddressesCount: string = "At least one SMTP address must be requested.";
    static ServiceUrlMustBeSet: string = "The Url property on the ExchangeService object must be set.";
    static ItemTypeNotCompatible: string = "The item type returned by the service ({0}) isn't compatible with the requested item type ({1}).";
    static AttachmentItemTypeMismatch: string = "Can not update this attachment item since the item in the response has a different type.";
    static UnsupportedWebProtocol: string = "Protocol {0} isn't supported for service requests.";
    static EnumValueIncompatibleWithRequestVersion: string = "Enumeration value {0} in enumeration type {1} is only valid for Exchange version {2} or later.";
    static UnexpectedElement: string = "An element node '{0}:{1}' of the type {2} was expected, but node '{3}' of type {4} was found.";
    static InvalidOrderBy: string = "At least one of the property definitions in the OrderBy clause is null.";
    static NoAppropriateConstructorForItemClass: string = "No appropriate constructor could be found for this item class.";
    static SearchFilterAtIndexIsInvalid: string = "The search filter at index {0} is invalid.";
    static DeletingThisObjectTypeNotAuthorized: string = "Deleting this type of object isn't authorized.";
    static PropertyCannotBeDeleted: string = "This property can't be deleted.";
    static ValuePropertyMustBeSet: string = "The Value property must be set.";
    static TagValueIsOutOfRange: string = "The extended property tag value must be in the range of 0 to 65,535.";
    static ItemToUpdateCannotBeNullOrNew: string = "Items[{0}] is either null or does not have an Id.";
    static SearchParametersRootFolderIdsEmpty: string = "SearchParameters must contain at least one folder id.";
    static MailboxQueriesParameterIsNotSpecified: string = "The collection of query and mailboxes parameter is not specified.";
    static FolderPermissionHasInvalidUserId: string = "The UserId in the folder permission at index {0} is invalid. The StandardUser, PrimarySmtpAddress, or SID property must be set.";
    static InvalidAutodiscoverDomain: string = "The domain name must be specified.";
    static MailboxesParameterIsNotSpecified: string = "The array of mailboxes (in legacy DN) is not specified.";
    static ParentFolderDoesNotHaveId: string = "parentFolder doesn't have an Id.";
    static DayOfMonthMustBeSpecifiedForRecurrencePattern: string = "The recurrence pattern's DayOfMonth property must be specified.";
    static ClassIncompatibleWithRequestVersion: string = "Class {0} is only valid for Exchange version {1} or later.";
    static CertificateHasNoPrivateKey: string = "The given certificate does not have the private key. The private key is necessary to sign part of the request message.";
    static InvalidOrUnsupportedTimeZoneDefinition: string = "The time zone definition is invalid or unsupported.";
    static HourMustBeBetween0And23: string = "Hour must be between 0 and 23.";
    static TimeoutMustBeBetween1And1440: string = "Timeout must be a value between 1 and 1440.";
    static CredentialsRequired: string = "Credentials are required to make a service request.";
    static MustLoadOrAssignPropertyBeforeAccess: string = "You must load or assign this property before you can read its value.";
    static InvalidAutodiscoverServiceResponse: string = "The Autodiscover service response was invalid.";
    static CannotCallConnectDuringLiveConnection: string = "The connection has already opened.";
    static ObjectDoesNotHaveId: string = "This service object doesn't have an ID.";
    static CannotAddSubscriptionToLiveConnection: string = "Subscriptions can't be added to an open connection.";
    static MaxChangesMustBeBetween1And512: string = "MaxChangesReturned must be between 1 and 512.";
    static AttributeValueCannotBeSerialized: string = "Values of type '{0}' can't be used for the '{1}' attribute.";
    static NumberOfDaysMustBePositive: string = "NumberOfDays must be zero or greater. Zero indicates no limit.";
    static SearchFilterMustBeSet: string = "The SearchFilter property must be set.";
    static EndDateMustBeGreaterThanStartDate: string = "EndDate must be greater than StartDate.";
    static InvalidDateTime: string = "Invalid date and time: {0}.";
    static UpdateItemsDoesNotAllowAttachments: string = "This operation can't be performed because attachments have been added or deleted for one or more items.";
    static TimeoutMustBeGreaterThanZero: string = "Timeout must be greater than zero.";
    static AutodiscoverInvalidSettingForOutlookProvider: string = "The requested setting, '{0}', isn't supported by this Autodiscover endpoint.";
    static InvalidRedirectionResponseReturned: string = "The service returned an invalid redirection response.";
    static ExpectedStartElement: string = "The start element was expected, but node '{0}' of type {1} was found.";
    static DaysOfTheWeekNotSpecified: string = "The recurrence pattern's property DaysOfTheWeek must contain at least one day of the week.";
    static FolderToUpdateCannotBeNullOrNew: string = "Folders[{0}] is either null or does not have an Id.";
    static PartnerTokenRequestRequiresUrl: string = "TryGetPartnerAccess request requires the Url be set with the partner's autodiscover url first.";
    static NumberOfOccurrencesMustBeGreaterThanZero: string = "NumberOfOccurrences must be greater than 0.";
    static StartTimeZoneRequired: string = "StartTimeZone required when setting the Start, End, IsAllDayEvent, or Recurrence properties.  You must load or assign this property before attempting to update the appointment.";
    static PropertyAlreadyExistsInOrderByCollection: string = "Property {0} already exists in OrderByCollection.";
    static ItemAttachmentMustBeNamed: string = "The name of the item attachment at index {0} must be set.";
    static InvalidAutodiscoverSettingsCount: string = "At least one setting must be requested.";
    static LoadingThisObjectTypeNotSupported: string = "Loading this type of object is not supported.";
    static UserIdForDelegateUserNotSpecified: string = "The UserId in the DelegateUser hasn't been specified.";
    static PhoneCallAlreadyDisconnected: string = "The phone call has already been disconnected.";
    static OperationDoesNotSupportAttachments: string = "This operation isn't supported on attachments.";
    static UnsupportedTimeZonePeriodTransitionTarget: string = "The time zone transition target isn't supported.";
    static IEnumerableDoesNotContainThatManyObject: string = "The IEnumerable doesn't contain that many objects.";
    static UpdateItemsDoesNotSupportNewOrUnchangedItems: string = "This operation can't be performed because one or more items are new or unmodified.";
    static ValidationFailed: string = "Validation failed.";
    static InvalidRecurrencePattern: string = "Invalid recurrence pattern: ({0}).";
    static TimeWindowStartTimeMustBeGreaterThanEndTime: string = "The time window's end time must be greater than its start time.";
    static InvalidAttributeValue: string = "The invalid value '{0}' was specified for the '{1}' attribute.";
    static FileAttachmentContentIsNotSet: string = "The content of the file attachment at index {0} must be set.";
    static AutodiscoverDidNotReturnEwsUrl: string = "The Autodiscover service didn't return an appropriate URL that can be used for the ExchangeService Autodiscover URL.";
    static RecurrencePatternMustHaveStartDate: string = "The recurrence pattern's StartDate property must be specified.";
    static OccurrenceIndexMustBeGreaterThanZero: string = "OccurrenceIndex must be greater than 0.";
    static ServiceResponseDoesNotContainXml: string = "The response received from the service didn't contain valid XML.";
    static ItemIsOutOfDate: string = "The operation can't be performed because the item is out of date. Reload the item and try again.";
    static MinuteMustBeBetween0And59: string = "Minute must be between 0 and 59.";
    static NoSoapOrWsSecurityEndpointAvailable: string = "No appropriate Autodiscover SOAP or WS-Security endpoint is available.";
    static ElementNotFound: string = "The element '{0}' in namespace '{1}' wasn't found at the current position.";
    static IndexIsOutOfRange: string = "index is out of range.";
    static PropertyIsReadOnly: string = "This property is read-only and can't be set.";
    static AttachmentCreationFailed: string = "At least one attachment couldn't be created.";
    static DayOfMonthMustBeBetween1And31: string = "DayOfMonth must be between 1 and 31.";
    static ServiceRequestFailed: string = "The request failed. {0}";
    static DelegateUserHasInvalidUserId: string = "The UserId in the DelegateUser is invalid. The StandardUser, PrimarySmtpAddress or SID property must be set.";
    static SearchFilterComparisonValueTypeIsNotSupported: string = "Values of type '{0}' can't be used as comparison values in search filters.";
    static ElementValueCannotBeSerialized: string = "Values of type '{0}' can't be used for the '{1}' element.";
    static PropertyValueMustBeSpecifiedForRecurrencePattern: string = "The recurrence pattern's {0} property must be specified.";
    static NonSummaryPropertyCannotBeUsed: string = "The property {0} can't be used in {1} requests.";
    static HoldIdParameterIsNotSpecified: string = "The hold id parameter is not specified.";
    static TransitionGroupNotFound: string = "Invalid transition. A transition group with the specified ID couldn't be found: {0}";
    static ObjectTypeNotSupported: string = "Objects of type {0} can't be added to the dictionary. The following types are supported: array, byte array, boolean, byte, DateTime, integer, long,, unsigned integer, and unsigned long.";
    static InvalidTimeoutValue: string = "{0} is not a valid timeout value. Valid values range from 1 to 1440.";
    static AutodiscoverRedirectBlocked: string = "Autodiscover blocked a potentially insecure redirection to {0}. To allow Autodiscover to follow the redirection, use the AutodiscoverUrl(string, AutodiscoverRedirectionUrlValidationCallback) overload.";
    static PropertySetCannotBeModified: string = "This PropertySet is read-only and can't be modified.";
    static DayOfTheWeekMustBeSpecifiedForRecurrencePattern: string = "The recurrence pattern's property DayOfTheWeek must be specified.";
    static ServiceObjectAlreadyHasId: string = "This operation can't be performed because this service object already has an ID. To update this service object, use the Update() method instead.";
    static MethodIncompatibleWithRequestVersion: string = "Method {0} is only valid for Exchange Server version {1} or later.";
    static OperationNotSupportedForPropertyDefinitionType: string = "This operation isn't supported for property definition type {0}.";
    static InvalidElementStringValue: string = "The invalid value '{0}' was specified for the '{1}' element.";
    static CollectionIsEmpty: string = "The collection is empty.";
    static InvalidFrequencyValue: string = "{0} is not a valid frequency value. Valid values range from 1 to 1440.";
    static UnexpectedEndOfXmlDocument: string = "The XML document ended unexpectedly.";
    static FolderTypeNotCompatible: string = "The folder type returned by the service ({0}) isn't compatible with the requested folder type ({1}).";
    static RequestIncompatibleWithRequestVersion: string = "The service request {0} is only valid for Exchange version {1} or later.";
    static PropertyTypeIncompatibleWhenUpdatingCollection: string = "Can not update the existing collection item since the item in the response has a different type.";
    static ServerVersionNotSupported: string = "Exchange Server doesn't support the requested version.";
    static DurationMustBeSpecifiedWhenScheduled: string = "Duration must be specified when State is equal to Scheduled.";
    static NoError: string = "No error.";
    static CannotUpdateNewUserConfiguration: string = "This user configuration can't be updated because it's never been saved.";
    static ObjectTypeIncompatibleWithRequestVersion: string = "The object type {0} is only valid for Exchange Server version {1} or later versions.";
    static NullStringArrayElementInvalid: string = "The array contains at least one null element.";
    static HttpsIsRequired: string = "Https is required when partner token is expected.";
    static MergedFreeBusyIntervalMustBeSmallerThanTimeWindow: string = "MergedFreeBusyInterval must be smaller than the specified time window.";
    static SecondMustBeBetween0And59: string = "Second must be between 0 and 59.";
    static AtLeastOneAttachmentCouldNotBeDeleted: string = "At least one attachment couldn't be deleted.";
    static IdAlreadyInList: string = "The ID is already in the list.";
    static BothSearchFilterAndQueryStringCannotBeSpecified: string = "Both search filter and query can't be specified. One of them must be null.";
    static AdditionalPropertyIsNull: string = "The additional property at index {0} is null.";
    static InvalidEmailAddress: string = "The e-mail address is formed incorrectly.";
    static MaximumRedirectionHopsExceeded: string = "The maximum redirection hop count has been reached.";
    static AutodiscoverCouldNotBeLocated: string = "The Autodiscover service couldn't be located.";
    static NoSubscriptionsOnConnection: string = "You must add at least one subscription to this connection before it can be opened.";
    static PermissionLevelInvalidForNonCalendarFolder: string = "The Permission level value {0} can't be used with a non-calendar folder.";
    static InvalidAuthScheme: string = "The token auth scheme should be bearer.";
    static ValuePropertyNotLoaded: string = "This property was requested, but it wasn't returned by the server.";
    static PropertyIncompatibleWithRequestVersion: string = "The property {0} is valid only for Exchange {1} or later versions.";
    static OffsetMustBeGreaterThanZero: string = "The offset must be greater than 0.";
    static CreateItemsDoesNotAllowAttachments: string = "This operation doesn't support items that have attachments.";
    static PropertyDefinitionTypeMismatch: string = "Property definition type '{0}' and type parameter '{1}' aren't compatible.";
    static IntervalMustBeGreaterOrEqualToOne: string = "The interval must be greater than or equal to 1.";
    static CannotSetPermissionLevelToCustom: string = "The PermissionLevel property can't be set to FolderPermissionLevel.Custom. To define a custom permission, set its individual properties to the values you want.";
    static CannotAddRequestHeader: string = "HTTP header '{0}' isn't permitted. Only HTTP headers with the 'X-' prefix are permitted.";
    static ArrayMustHaveAtLeastOneElement: string = "The Array value must have at least one element.";
    static MonthMustBeSpecifiedForRecurrencePattern: string = "The recurrence pattern's Month property must be specified.";
    static ValueOfTypeCannotBeConverted: string = "The value '{0}' of type {1} can't be converted to a value of type {2}.";
    static ValueCannotBeConverted: string = "The value '{0}' couldn't be converted to type {1}.";
    static ServerErrorAndStackTraceDetails: string = "{0} -- Server Error: {1}: {2} {3}";
    static FolderPermissionLevelMustBeSet: string = "The permission level of the folder permission at index {0} must be set.";
    static AutodiscoverError: string = "The Autodiscover service returned an error.";
    static ArrayMustHaveSingleDimension: string = "The array value must have a single dimension.";
    static InvalidPropertyValueNotInRange: string = "{0} must be between {1} and {2}.";
    static RegenerationPatternsOnlyValidForTasks: string = "Regeneration patterns can only be used with Task items.";
    static ItemAttachmentCannotBeUpdated: string = "Item attachments can't be updated.";
    static EqualityComparisonFilterIsInvalid: string = "Either the OtherPropertyDefinition or the Value properties must be set.";
    static AutodiscoverServiceRequestRequiresDomainOrUrl: string = "This Autodiscover request requires that either the Domain or Url be specified.";
    static InvalidUser: string = "Invalid user: '{0}'";
    static AccountIsLocked: string = "This account is locked. Visit {0} to unlock it.";
    static InvalidDomainName: string = "'{0}' is not a valid domain name.";
    static TooFewServiceReponsesReturned: string = "The service was expected to return {1} responses of type '{0}', but {2} responses were received.";
    static CannotSubscribeToStatusEvents: string = "Status events can't be subscribed to.";
    static InvalidSortByPropertyForMailboxSearch: string = "Specified SortBy property '{0}' is invalid.";
    static UnexpectedElementType: string = "The expected XML node type was {0}, but the actual type is {1}.";
    static ValueMustBeGreaterThanZero: string = "The value must be greater than 0.";
    static AttachmentCannotBeUpdated: string = "Attachments can't be updated.";
    static CreateItemsDoesNotHandleExistingItems: string = "This operation can't be performed because at least one item already has an ID.";
    static MultipleContactPhotosInAttachment: string = "This operation only allows at most 1 file attachment with IsContactPhoto set.";
    static InvalidRecurrenceRange: string = "Invalid recurrence range: ({0}).";
    static CannotSetBothImpersonatedAndPrivilegedUser: string = "Can't set both impersonated user and privileged user in the ExchangeService object.";
    static NewMessagesWithAttachmentsCannotBeSentDirectly: string = "New messages with attachments can't be sent directly. You must first save the message and then send it.";
    static CannotCallDisconnectWithNoLiveConnection: string = "The connection is already closed.";
    static IdPropertyMustBeSet: string = "The Id property must be set.";
    static ValuePropertyNotAssigned: string = "You must assign this property before you can read its value.";
    static ZeroLengthArrayInvalid: string = "The array must contain at least one element.";
    static HoldMailboxesParameterIsNotSpecified: string = "The hold mailboxes parameter is not specified.";
    static CannotSaveNotNewUserConfiguration: string = "Calling Save isn't allowed because this user configuration isn't new. To apply local changes to this user configuration, call Update instead.";
    static ServiceObjectDoesNotHaveId: string = "This operation can't be performed because this service object doesn't have an Id.";
    static PropertyCollectionSizeMismatch: string = "The collection returned by the service has a different size from the current one.";
    static XsDurationCouldNotBeParsed: string = "The specified xsDuration argument couldn't be parsed.";
    static UnknownTimeZonePeriodTransitionType: string = "Unknown time zone transition type: {0}";
    static UserPhotoSizeNotSpecified: string = "The UserPhotoSize must be not be null or empty.";
    static JsonSerializationNotImplemented: string = "JSON Serialization is not implemented for this request.Please retry the request with the XML rendering method.";
    static JsonDeserializationNotImplemented: string = "JSON Deserialization is not implemented for this request.Please retry the request with the XML rendering method.";
}





/**
 * @internal TypeContainer  - contains Type as properties. Required to evade circular dependency. Initilized in ExchangeWebService.ts which is going to weave type objects.
 */
export class TypeContainer {
    constructor(parameters) {

    }
    /**
	 * Type object of ServiceObject (not instance)
	 */
    public static ServiceObject: any;
    /**
     * Type object of Folder (not instance)
     */
    public static Folder: any;
    /**
     * Type object of CalendarFolder (not instance)
     */
    public static CalendarFolder: any;
    /**
     * Type object of ContactsFolder (not instance)
     */
    public static ContactsFolder: any;
    /**
     * Type object of SearchFolder (not instance)
     */
    public static SearchFolder: any;
    /**
     * Type object of TasksFolder (not instance)
     */
    public static TasksFolder: any;
    /**
	 * Type object of ServiceObjectSchema (not instance)
	 */
    public static ServiceObjectSchema: ServiceObjectSchemaStatic;
	/**
	 * Type object of Appointment (not instance)
	 */
    public static Appointment: any;
	/**
	 * Type object of MeetingRequest (not instance)
	 */
    public static MeetingRequest: any;
	/**
	 * Type object of MeetingResponse (not instance)
	 */
    public static MeetingResponse: any;
	/**
	 * Type object of MeetingCancellation (not instance)
	 */
    public static MeetingCancellation: any;
	/**
	 * Type object of Item (not instance)
	 */
    public static Item: any;

    /**
     * Type object of ItemAttachment (not instance)
     */
    public static ItemAttachment: any;

    /**
     * Type object of ItemAttachmentOf **Generic Version of ItemAttachment** (not instance)
     */
    public static ItemAttachmentOf: any;

    /**
     * Type object of ExchangeService (not instance)
     */
    public static ExchangeService: any;


    /*
     * PropertyDefinitions
     */

    /**
     * IndexedPropertyDefinition
     */
    public static IndexedPropertyDefinition: typeof IndexedPropertyDefinition;

    /**
     * ExtendedPropertyDefinition
     */
    public static ExtendedPropertyDefinition: typeof ExtendedPropertyDefinition;


    /**
     * TimeZone
     */

    /**
     * Type object of AbsoluteDateTransition (not instance)
     */
    public static AbsoluteDateTransition: typeof AbsoluteDateTransition;

    /** 
     * Type object of AbsoluteDayOfMonthTransition (not instance)
    */
    public static AbsoluteDayOfMonthTransition: typeof AbsoluteDayOfMonthTransition;

    /** 
     * Type object of RelativeDayOfMonthTransition (not instance)
    */
    public static RelativeDayOfMonthTransition: typeof RelativeDayOfMonthTransition;
}
/**
* Uri: c# uri shim for js
*/
export class Uri {
    private url: string
    private m_scheme: string = null;
    /**returns string url component, no transformations yet */
    get AbsoluteUri(): string { return this.url; }
    get Host(): string { return UriHelper.getHost(this.url); }
    get Scheme(): string { return this.m_scheme; }
    constructor(url: string) {
        if (StringHelper.IsNullOrEmpty(url)) {
            throw new Error("Uri - ctor- argument is not string or it is null or empty")
        }
        this.url = url;
        var parsed = UriHelper.parseString(url)
        this.m_scheme = parsed.scheme.toLowerCase();
    }
    ToString(): string {
        return this.url;
    }
    
    toString(): string{
        return this.url;
    }
    
    // GetDomain(): string {
    //     return UriHelper.getDomain(this.url);
    // }
    // GetHost(url: string): string {
    //     return this.GetDomain();
    // }
    
    static ParseString(url: string) {
        return UriHelper.parseString(url);
    }

    static UriSchemeHttp: string = "http";
    static UriSchemeHttps: string = "https";

}

export class XHRFactory {

	static xhrHelper: IXHRApi;
	static get XHRApi() {
		if (typeof this.xhrHelper === 'undefined' || this.xhrHelper === null) {
			this.xhrHelper = new XHRBrowser();
		}
		return this.xhrHelper;
	}
}

let schemeRegex = /^(\w+)\:\/\//;

/** @internal */
export class XHRBrowser implements IXHRApi {
	req: XMLHttpRequest;
	private _canceled: boolean = false;
	xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
		return new Promise<XMLHttpRequest>((resolve, reject) => {
			this.req = new XMLHttpRequest();
			var isLocalRequest = false;
			var schemeMatch = schemeRegex.exec(xhroptions.url.toLowerCase());
			if (schemeMatch) {
				if (schemeMatch[1] === 'file') {
					isLocalRequest = true;
				}
			} else if (window.location.protocol === 'file:') {
				isLocalRequest = true;
			}

			this.req.onreadystatechange = () => {
				if (this._canceled) {
					this.req.onreadystatechange = noop;
					return;
				}

				if (this.req.readyState === 4) {
					if ((this.req.status >= 200 && this.req.status < 300) || (isLocalRequest && this.req.status === 0)) {
						resolve(this.req);
					} else {
						reject(this.req);
					}
					this.req.onreadystatechange = noop;
				}
			};

			this.req.addEventListener('error', x => {
				this.disconnect();
				reject(x);
			});

			this.req.open(
				xhroptions.type || "GET",
				xhroptions.url
			);
			// this.req.responseType = xhroptions.responseType || "";

			Object.keys(xhroptions.headers || {}).forEach((k) => {
				this.req.setRequestHeader(k, xhroptions.headers[k]);
			});

			if (xhroptions.customRequestInitializer) {
				xhroptions.customRequestInitializer(this.req);
			}

			if (xhroptions.data === undefined) {
				this.req.send();
			} else {
				this.req.send(xhroptions.data);
			}
		});
	}

	xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {

		return new Promise((resolve, reject) => {
			this.req = new XMLHttpRequest();
			var isLocalRequest = false;
			var schemeMatch = schemeRegex.exec(xhroptions.url.toLowerCase());
			if (schemeMatch) {
				if (schemeMatch[1] === 'file') {
					isLocalRequest = true;
				}
			} else if (window.location.protocol === 'file:') {
				isLocalRequest = true;
			}
			let lastChunk = '';
			this.req.onreadystatechange = () => {
				if (this._canceled) {
					this.req.onreadystatechange = noop;
					return;
				}

				if (this.req.readyState === 4) {
					if ((this.req.status >= 200 && this.req.status < 300) || (isLocalRequest && this.req.status === 0)) {
						resolve(this.req);
					} else {
						reject(this.req);
					}
					this.req.onreadystatechange = noop;
				} else if (this.req.readyState === 2) { // HEADERS_RECEIVED
					progressDelegate({ type: "header", headers: this.req.getAllResponseHeaders() });
				} else if (this.req.readyState === 3) { // LOADING - partial text, for streaming
					let chunk = this.req.responseText.substr(lastChunk.length);
					lastChunk = this.req.responseText;
					progressDelegate({ type: "data", data: chunk });
				}
			};
			this.req.addEventListener('error', error => {
				this.disconnect();
				progressDelegate({ type: "error", error: error });
				reject(error);
			});

			this.req.open(
				xhroptions.type || "GET",
				xhroptions.url
			);
			// this.req.responseType = xhroptions.responseType || "";

			Object.keys(xhroptions.headers || {}).forEach( (k) => {
				this.req.setRequestHeader(k, xhroptions.headers[k]);
			});

			if (xhroptions.customRequestInitializer) {
				xhroptions.customRequestInitializer(this.req);
			}

			if (xhroptions.data === undefined) {
				this.req.send();
			} else {
				this.req.send(xhroptions.data);
			}
		});
	}

	disconnect() {

		if (this.req) {
			try {
				this.req.onreadystatechange = noop;
				this._canceled = true;
				this.req.abort();
				setImmediate(() => { this.req = null })
			}
			catch (e) { }
		}
	}

	get apiName(): string {
		return "browser";
	}

	constructor() {
	}
}

function noop() {
}


export class TimeSpan {
    private get duration(): moment.Duration { return this.getMomentDuration(); }
    private getMomentDuration: () => moment.Duration;
    private setMomentDuration: (value) => void;

    constructor(ms: number);
    constructor(duration: moment.DurationInputArg1 | moment.DurationInputObject);
    constructor(hours: number, minutes: number, seconds);
    constructor(days: number, hours: number, minutes: number, seconds);
    constructor(days: number, hours: number, minutes: number, seconds: number, milliseconds);
    constructor(daysOrHoursOrMsOrDuration: number | moment.Duration,
        hoursOrMinutes?: number,
        minutesOrSeconds?: number,
        seconds?: number,
        milliseconds?: number) {

        let duration: moment.Duration = null;
        let argsLength = arguments.length;

        if (argsLength === 1) {
            duration = moment.duration(daysOrHoursOrMsOrDuration);
        }
        else {

            let momentInput: moment.DurationInputObject = {};

            if (argsLength === 3) {
                momentInput.hours = <number>daysOrHoursOrMsOrDuration;
                momentInput.minutes = hoursOrMinutes;
                momentInput.seconds = minutesOrSeconds;
            }
            if (argsLength >= 4) {
                momentInput.days = <number>daysOrHoursOrMsOrDuration;
                momentInput.hours = hoursOrMinutes;
                momentInput.minutes = minutesOrSeconds;
                momentInput.seconds = seconds;
            }
            if (argsLength === 5) {
                momentInput.millisecond = milliseconds;
            }
            duration = moment.duration(momentInput);
        }


        this.getMomentDuration = () => duration;
        this.setMomentDuration = (value) => duration = value;
    }

    humanize(withSuffix?: boolean): string { return this.duration.humanize(withSuffix); }

    as(units: moment.unitOfTime.Base): number { return this.duration.as(units); }

    get Milliseconds(): number {
        return this.duration.milliseconds();
    }
    get TotalMilliseconds(): number {
        return this.duration.asMilliseconds();
    }

    get Seconds(): number {
        return this.duration.seconds();
    }
    get TotalSeconds(): number {
        return this.duration.asSeconds();
    }

    get Minutes(): number {
        return this.duration.minutes();
    }
    get TotalMinutes(): number {
        return this.duration.asMinutes();
    }

    get Hours(): number {
        return this.duration.hours();
    }
    get TotalHours(): number {
        return this.duration.asHours();
    }

    get Days(): number {
        return this.duration.days();
    }
    get TotalDays(): number {
        return this.duration.asDays();
    }

    get Months(): number {
        return this.duration.months();
    }
    get TotalMonths(): number {
        return this.duration.asMonths();
    }

    get Years(): number {
        return this.duration.years();
    }
    get TotalYears(): number {
        return this.duration.asYears();
    }

    get Weeks(): number {
        return this.duration.weeks()
    }
    get Totalweeks(): number {
        return this.duration.asWeeks()
    }

    Add(num: number, unit: moment.unitOfTime.Base): TimeSpan;
    Add(ms: number): TimeSpan;
    Add(ts: TimeSpan): TimeSpan;
    Add(a: number | TimeSpan, p?: moment.unitOfTime.Base): TimeSpan {
        if (arguments.length === 1) {
            return new TimeSpan(typeof a === 'number' ? this.duration.add(a) : a.TotalMilliseconds);
        }
        else {
            return new TimeSpan(this.duration.add(a as number, p));
        }
    }

    Subtract(n: number, p: moment.unitOfTime.Base): TimeSpan;
    Subtract(n: number): TimeSpan;
    Subtract(d: TimeSpan): TimeSpan;
    Subtract(a: any, p?: moment.unitOfTime.Base): TimeSpan {
        if (arguments.length === 1) {
            return new TimeSpan(this.duration.subtract(a));
        }
        else {
            return new TimeSpan(this.duration.subtract(a, p));
        }
    }

    ToISOString(): string { return this.duration.toISOString(); }

    ToJSON(): string { return this.duration.toJSON(); }

    /** @internal */
    public static MillisPerSecond: number = 1000; //const
    /** @internal */
    public static MillisPerMinute: number = TimeSpan.MillisPerSecond * 60; //     60,000 //const
    /** @internal */
    public static MillisPerHour: number = TimeSpan.MillisPerMinute * 60;   //  3,600,000 //const
    /** @internal */
    public static MillisPerDay: number = TimeSpan.MillisPerHour * 24;      // 86,400,000 //const

    private static MaxSeconds: number = Number.MAX_VALUE / TimeSpan.MillisPerSecond;// TimeSpan.TicksPerSecond; //const
    private static MinSeconds: number = Number.MIN_VALUE / TimeSpan.MillisPerSecond;// TimeSpan.TicksPerSecond; //const

    private static MaxMilliSeconds: number = Number.MAX_VALUE;/// TimeSpan.TicksPerMillisecond; //const
    private static MinMilliSeconds: number = Number.MIN_VALUE;/// TimeSpan.TicksPerMillisecond; //const

    //private static  TicksPerTenthSecond:number = TimeSpan.TicksPerMillisecond * 100; //const

    public static readonly Zero: TimeSpan = new TimeSpan(0);//readonly

    public static readonly MaxValueTimeSpan = new TimeSpan(Number.MAX_VALUE);//readonly
    public static readonly MinValueTimeSpan = new TimeSpan(Number.MIN_VALUE);//readonly


    public static FromDays(value: number): TimeSpan {
        return new TimeSpan(value * TimeSpan.MillisPerDay);
    }
    public static FromHours(value: number): TimeSpan {
        return new TimeSpan(value * TimeSpan.MillisPerHour);
    }
    public static FromMilliseconds(value: number): TimeSpan {
        return new TimeSpan(value);
    }
    public static FromMinutes(value: number): TimeSpan {
        return new TimeSpan(value * TimeSpan.MillisPerMinute);
    }
    public static FromSeconds(value: number): TimeSpan {
        return new TimeSpan(value * TimeSpan.MillisPerSecond);
    }

    valueOf() {
        return this.duration.asMilliseconds();
    }
    toString() {
        return this.duration.toISOString();
    }    
}

module TimeSpan2 {
    /** TimeSpan basics from c# using momentjs */
    class TimeSpan {
        // non ticks use in js - public static     TicksPerMillisecond:number =  10000; //const
        // non ticks use in js - private static  MillisecondsPerTick:number = 1.0 / TimeSpan.TicksPerMillisecond; //const

        // non ticks use in js - public static  TicksPerSecond:number = TimeSpan.TicksPerMillisecond * 1000;   // 10,000,000 //const
        // non ticks use in js - private static  SecondsPerTick:number =  1.0 / TimeSpan.TicksPerSecond;         // 0.0001 //const

        // non ticks use in js - public static  TicksPerMinute:number = TimeSpan.TicksPerSecond * 60;         // 600,000,000 //const
        // non ticks use in js - private static  MinutesPerTick:number = 1.0 / TimeSpan.TicksPerMinute; // 1.6666666666667e-9 //const

        // non ticks use in js - public static  TicksPerHour:number = TimeSpan.TicksPerMinute * 60;        // 36,000,000,000 //const
        // non ticks use in js - private static  HoursPerTick:number = 1.0 / TimeSpan.TicksPerHour; // 2.77777777777777778e-11 //const

        // non ticks use in js - public static  TicksPerDay:number = TimeSpan.TicksPerHour * 24;          // 864,000,000,000 //const
        // non ticks use in js - private static  DaysPerTick:number = 1.0 / TimeSpan.TicksPerDay; // 1.1574074074074074074e-12 //const

        private static MillisPerSecond: number = 1000; //const
        private static MillisPerMinute: number = TimeSpan.MillisPerSecond * 60; //     60,000 //const
        private static MillisPerHour: number = TimeSpan.MillisPerMinute * 60;   //  3,600,000 //const
        private static MillisPerDay: number = TimeSpan.MillisPerHour * 24;      // 86,400,000 //const

        private static MaxSeconds: number = Number.MAX_VALUE / TimeSpan.MillisPerSecond;// TimeSpan.TicksPerSecond; //const
        private static MinSeconds: number = Number.MIN_VALUE / TimeSpan.MillisPerSecond;// TimeSpan.TicksPerSecond; //const

        private static MaxMilliSeconds: number = Number.MAX_VALUE;/// TimeSpan.TicksPerMillisecond; //const
        private static MinMilliSeconds: number = Number.MIN_VALUE;/// TimeSpan.TicksPerMillisecond; //const

        //private static  TicksPerTenthSecond:number = TimeSpan.TicksPerMillisecond * 100; //const

        public static Zero: TimeSpan = new TimeSpan(0);//readonly

        public static MaxValueTimeSpan = new TimeSpan(Number.MAX_VALUE);//readonly
        public static MinValueTimeSpan = new TimeSpan(Number.MIN_VALUE);//readonly

        private _millis: number = 0;

        public constructor(milliseconds: number);
        public constructor(hours: number, minutes: number, seconds: number);
        public constructor(days: number, hours: number, minutes: number, seconds: number);
        public constructor(days: number, hours: number, minutes: number, seconds: number, milliseconds: number);
        public constructor(millisOrHrsOrDays: number, minsOrHrs?: number, secsOrMins?: number, seconds?: number, milliseconds?: number) {
            let argsLength: number = arguments.length;
            let millis = 0;
            if (typeof milliseconds !== 'undefined')
                millis = milliseconds;

            switch (argsLength) {
                case 1:
                    this._millis = millisOrHrsOrDays;
                    break;
                case 3:
                    this._millis = TimeSpan.TimeToTicks(millisOrHrsOrDays, minsOrHrs, secsOrMins);
                    break;
                case 4:
                case 5:
                    let totalSeconds = millisOrHrsOrDays * 24 * 3600 + minsOrHrs * 3600 + secsOrMins * 60 + seconds;
                    if (totalSeconds > TimeSpan.MaxSeconds || totalSeconds < TimeSpan.MinSeconds)
                        throw new ArgumentOutOfRangeException("DateTime.ts - TimeSpan.ctor - Overflow_TimeSpanTooLong");
                    this._millis = totalSeconds * TimeSpan.MillisPerSecond + millis;
                    break
                default:
                    throw new Error("DateTime.ts - TimeSpan.ctor - invalid number of arguments");
            }

        }

        private static TimeToTicks(hour: number, minute: number, second: number): number {
            // totalSeconds is bounded by 2^31 * 2^12 + 2^31 * 2^8 + 2^31,
            // which is less than 2^44, meaning we won't overflow totalSeconds.
            let totalSeconds = hour * 3600 + minute * 60 + second;
            if (totalSeconds > this.MaxSeconds || totalSeconds < this.MinSeconds)
                throw new ArgumentOutOfRangeException("DateTime.ts - TimeSpan.TimeToTicks - Overflow_TimeSpanTooLong");
            return totalSeconds * this.MillisPerSecond;
        }

        public get Days(): number { return Math.floor(this._millis / TimeSpan.MillisPerDay); }
        public get Hours(): number { return Math.floor(this._millis / TimeSpan.MillisPerHour); }
        public get Milliseconds(): number { return Math.floor(this._millis); }
        public get Minutes(): number { return Math.floor(this._millis / TimeSpan.MillisPerMinute); }
        public get Seconds(): number { return Math.floor(this._millis / TimeSpan.MillisPerSecond); }
        //public get Ticks(): number { return Math.floor( this._millis / TimeSpan.); }
        public get TotalDays(): number { return this._millis / TimeSpan.MillisPerDay; }
        public get TotalHours(): number { return this._millis / TimeSpan.MillisPerHour; }
        public get TotalMilliseconds(): number { return this._millis; }
        public get TotalMinutes(): number { return this._millis / TimeSpan.MillisPerMinute; }
        public get TotalSeconds(): number { return this._millis / TimeSpan.MillisPerSecond; }
        // Compares two TimeSpan values, returning an integer that indicates their
        // relationship.
        //
        public static Compare(t1: TimeSpan, t2: TimeSpan): number {
            if (t1._millis > t2._millis) return 1;
            if (t1._millis < t2._millis) return -1;
            return 0;
        }
        public static Equals(t1: TimeSpan, t2: TimeSpan): boolean { return t1._millis === t2._millis; }
        public static FromDays(value: number): TimeSpan { return new TimeSpan(value * TimeSpan.MillisPerDay); }
        public static FromHours(value: number): TimeSpan { return new TimeSpan(value * TimeSpan.MillisPerHour); }
        public static FromMilliseconds(value: number): TimeSpan { return new TimeSpan(value); }
        public static FromMinutes(value: number): TimeSpan { return new TimeSpan(value * TimeSpan.MillisPerMinute); }
        public static FromSeconds(value: number): TimeSpan { return new TimeSpan(value * TimeSpan.MillisPerSecond); }
        //public static FromTicks(value: number): TimeSpan{ return new TimeSpan(value * TimeSpan.MillisPerDay); }
        public static Parse(s: string): TimeSpan {
            return null;
        }
        //public static Parse(input: string, formatProvider: IFormatProvider): TimeSpan;

        //public static ParseExact(string input, string[] formats, IFormatProvider formatProvider): TimeSpan;
        //public static ParseExact(string input, string format, IFormatProvider formatProvider): TimeSpan;
        //public static ParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles): TimeSpan;
        //public static ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles): TimeSpan;
        //public static TryParse(string s, out TimeSpan result): boolean;
        //public static TryParse(string input, IFormatProvider formatProvider, out TimeSpan result): boolean;
        //public static TryParseExact(string input, string[] formats, IFormatProvider formatProvider, out TimeSpan result): boolean;
        //public static TryParseExact(string input, string format, IFormatProvider formatProvider, out TimeSpan result): boolean;
        //public static TryParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result): boolean;
        //public static TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result): boolean { }
        public Add(ts: TimeSpan): TimeSpan {
            let result = this._millis + ts._millis;
            // Overflow if signs of operands was identical and result's sign was opposite.
            // >> 63 gives the sign bit (either 64 1's or 64 0's).
            if ((this._millis >>> 63 === ts._millis >> 63) && (this.Milliseconds >>> 63 !== result >> 63))
                throw new Error("Overflow_TimeSpanTooLong");//OverflowException
            return new TimeSpan(result);
        }
        public CompareTo(value: TimeSpan): number;
        public CompareTo(value: any): number;
        public CompareTo(value: any): number {
            if (!(value instanceof TimeSpan))
                throw new Error("Arg_MustBeTimeSpan");//ArgumentException
            let m: number = (<TimeSpan>value)._millis;
            if (this._millis > m) return 1;
            if (this._millis < m) return -1;
            return 0;
        }
        // public Duration(): TimeSpan;
        // public Equals(objTimeSpan): boolean;
        // public override bool Equals(object value);
        // public override int GetHashCode();
        // public Negate(): TimeSpan;
        // public Subtract(ts: TimeSpan): TimeSpan;
        // public ToString(): string;
        // public ToString(format: string): string;
        // public ToString(format: string, formatProvider: IFormatProvider): string;



        // public static TimeSpan operator + (TimeSpan t);
        // public static TimeSpan operator + (TimeSpan t1, TimeSpan t2);
        // public static TimeSpan operator - (TimeSpan t);
        // public static TimeSpan operator - (TimeSpan t1, TimeSpan t2);
        // public static bool operator == (TimeSpan t1, TimeSpan t2);
        // public static bool operator != (TimeSpan t1, TimeSpan t2);
        // public static bool operator <(TimeSpan t1, TimeSpan t2);
        // public static bool operator >(TimeSpan t1, TimeSpan t2);
        // public static bool operator <= (TimeSpan t1, TimeSpan t2);
        // public static bool operator >= (TimeSpan t1, TimeSpan t2);

    }
}
export let TimeZoneMappingData = {"America/Aruba":"SA Western Standard Time","Europe/Copenhagen":"Romance Standard Time","Europe/Brussels":"Romance Standard Time","Africa/Tunis":"W. Central Africa Standard Time","America/Pangnirtung":"Eastern Standard Time","Africa/Malabo":"W. Central Africa Standard Time","America/Guyana":"SA Western Standard Time","W. Mongolia Standard Time":[["Asia/Hovd"],"(UTC+07:00) Hovd","W. Mongolia Standard Time","W. Mongolia Daylight Time",true,420],"Russia Time Zone 10":[["Asia/Srednekolymsk"],"(UTC+11:00) Chokurdakh","Russia TZ 10 Standard Time","Russia TZ 10 Daylight Time",true,660],"Ekaterinburg Standard Time":[["Asia/Yekaterinburg"],"(UTC+05:00) Ekaterinburg","Russia TZ 4 Standard Time","Russia TZ 4 Daylight Time",true,300],"Australia/Lindeman":"E. Australia Standard Time","Asia/Famagusta":"Turkey Standard Time","America/Mendoza":"Argentina Standard Time","Indian/Cocos":"Myanmar Standard Time","America/North_Dakota/Beulah":"Central Standard Time","America/Los_Angeles":"Pacific Standard Time","Sakhalin Standard Time":[["Asia/Sakhalin"],"(UTC+11:00) Sakhalin","Sakhalin Standard Time","Sakhalin Daylight Time",true,660],"Altai Standard Time":[["Asia/Barnaul"],"(UTC+07:00) Barnaul, Gorno-Altaysk","Altai Standard Time","Altai Daylight Time",true,420],"Pacific/Guam":"West Pacific Standard Time","Pacific/Nauru":"UTC+12","Africa/Brazzaville":"W. Central Africa Standard Time","Europe/Jersey":"GMT Standard Time","Newfoundland Standard Time":[["America/St_Johns"],"(UTC-03:30) Newfoundland","Newfoundland Standard Time","Newfoundland Daylight Time",true,-210],"Europe/Vaduz":"W. Europe Standard Time","Pacific/Ponape":"Central Pacific Standard Time","America/Indiana/Knox":"Central Standard Time","America/Argentina/Ushuaia":"Argentina Standard Time","Tasmania Standard Time":[["Australia/Hobart","Australia/Currie"],"(UTC+10:00) Hobart","Tasmania Standard Time","Tasmania Daylight Time",true,600],"Asia/Jakarta":"SE Asia Standard Time","Europe/Vilnius":"FLE Standard Time","Africa/Kigali":"South Africa Standard Time","America/St_Kitts":"SA Western Standard Time","Indian/Kerguelen":"West Asia Standard Time","Africa/Libreville":"W. Central Africa Standard Time","West Pacific Standard Time":[["Pacific/Port_Moresby","Antarctica/DumontDUrville","Pacific/Truk","Pacific/Guam","Pacific/Saipan","Etc/GMT-10"],"(UTC+10:00) Guam, Port Moresby","West Pacific Standard Time","West Pacific Daylight Time",false,600],"Atlantic Standard Time":[["America/Halifax","Atlantic/Bermuda","America/Glace_Bay","America/Goose_Bay","America/Moncton","America/Thule"],"(UTC-04:00) Atlantic Time (Canada)","Atlantic Standard Time","Atlantic Daylight Time",true,-240],"W. Central Africa Standard Time":[["Africa/Lagos","Africa/Luanda","Africa/Porto-Novo","Africa/Kinshasa","Africa/Bangui","Africa/Brazzaville","Africa/Douala","Africa/Algiers","Africa/Libreville","Africa/Malabo","Africa/Niamey","Africa/Ndjamena","Africa/Tunis","Etc/GMT-1"],"(UTC+01:00) West Central Africa","W. Central Africa Standard Time","W. Central Africa Daylight Time",false,60],"Etc/GMT+8":"UTC-08","Atlantic/Faeroe":"GMT Standard Time","America/Sitka":"Alaskan Standard Time","UTC":[["Etc/GMT","America/Danmarkshavn","Etc/UTC"],"(UTC) Coordinated Universal Time","Coordinated Universal Time","Coordinated Universal Time",false,0],"Fiji Standard Time":[["Pacific/Fiji"],"(UTC+12:00) Fiji","Fiji Standard Time","Fiji Daylight Time",true,720],"Pacific/Kosrae":"Central Pacific Standard Time","West Asia Standard Time":[["Asia/Tashkent","Antarctica/Mawson","Asia/Oral","Asia/Aqtau","Asia/Aqtobe","Asia/Atyrau","Indian/Maldives","Indian/Kerguelen","Asia/Dushanbe","Asia/Ashgabat","Asia/Samarkand","Etc/GMT-5"],"(UTC+05:00) Ashgabat, Tashkent","West Asia Standard Time","West Asia Daylight Time",false,300],"Europe/Belgrade":"Central Europe Standard Time","Mid-Atlantic Standard Time":[null,"(UTC-02:00) Mid-Atlantic - Old","Mid-Atlantic Standard Time","Mid-Atlantic Daylight Time",true,-120],"Magallanes Standard Time":[null,"(UTC-03:00) Punta Arenas","Magallanes Standard Time","Magallanes Daylight Time",true,-180],"Kamchatka Standard Time":[null,"(UTC+12:00) Petropavlovsk-Kamchatsky - Old","Kamchatka Standard Time","Kamchatka Daylight Time",true,720],"America/Guatemala":"Central America Standard Time","Asia/Singapore":"Singapore Standard Time","Indian/Mayotte":"E. Africa Standard Time","Nepal Standard Time":[["Asia/Katmandu"],"(UTC+05:45) Kathmandu","Nepal Standard Time","Nepal Daylight Time",false,345],"UTC-11":[["Etc/GMT+11","Pacific/Pago_Pago","Pacific/Niue","Pacific/Midway"],"(UTC-11:00) Coordinated Universal Time-11","UTC-11","UTC-11",false,-660],"Asia/Qatar":"Arab Standard Time","Georgian Standard Time":[["Asia/Tbilisi"],"(UTC+04:00) Tbilisi","Georgian Standard Time","Georgian Daylight Time",false,240],"Europe/Simferopol":"Russian Standard Time","Etc/GMT+10":"Hawaiian Standard Time","Australia/Adelaide":"Cen. Australia Standard Time","America/Fort_Nelson":"US Mountain Standard Time","Transbaikal Standard Time":[["Asia/Chita"],"(UTC+09:00) Chita","Transbaikal Standard Time","Transbaikal Daylight Time",true,540],"Aleutian Standard Time":[["America/Adak"],"(UTC-10:00) Aleutian Islands","Aleutian Standard Time","Aleutian Daylight Time",true,-600],"America/Cayman":"SA Pacific Standard Time","Pacific Standard Time (Mexico)":[["America/Tijuana","America/Santa_Isabel"],"(UTC-08:00) Baja California","Pacific Standard Time (Mexico)","Pacific Daylight Time (Mexico)",true,-480],"America/Thule":"Atlantic Standard Time","America/Puerto_Rico":"SA Western Standard Time","Asia/Dili":"Tokyo Standard Time","Pacific/Kiritimati":"Line Islands Standard Time","Europe/Ljubljana":"Central Europe Standard Time","Europe/Tirane":"Central Europe Standard Time","Etc/GMT-5":"West Asia Standard Time","Etc/GMT+9":"UTC-09","Europe/Gibraltar":"W. Europe Standard Time","America/Manaus":"SA Western Standard Time","America/Argentina/San_Luis":"Argentina Standard Time","Venezuela Standard Time":[["America/Caracas"],"(UTC-04:00) Caracas","Venezuela Standard Time","Venezuela Daylight Time",true,-240],"Cen. Australia Standard Time":[["Australia/Adelaide","Australia/Broken_Hill"],"(UTC+09:30) Adelaide","Cen. Australia Standard Time","Cen. Australia Daylight Time",true,570],"America/Guayaquil":"SA Pacific Standard Time","Afghanistan Standard Time":[["Asia/Kabul"],"(UTC+04:30) Kabul","Afghanistan Standard Time","Afghanistan Daylight Time",false,270],"Mauritius Standard Time":[["Indian/Mauritius","Indian/Reunion","Indian/Mahe"],"(UTC+04:00) Port Louis","Mauritius Standard Time","Mauritius Daylight Time",true,240],"New Zealand Standard Time":[["Pacific/Auckland","Antarctica/McMurdo"],"(UTC+12:00) Auckland, Wellington","New Zealand Standard Time","New Zealand Daylight Time",true,720],"US Mountain Standard Time":[["America/Phoenix","America/Dawson_Creek","America/Creston","America/Fort_Nelson","America/Hermosillo","Etc/GMT+7"],"(UTC-07:00) Arizona","US Mountain Standard Time","US Mountain Daylight Time",false,-420],"Tokyo Standard Time":[["Asia/Tokyo","Asia/Jayapura","Pacific/Palau","Asia/Dili","Etc/GMT-9"],"(UTC+09:00) Osaka, Sapporo, Tokyo","Tokyo Standard Time","Tokyo Daylight Time",false,540],"Asia/Sakhalin":"Sakhalin Standard Time","Europe/Astrakhan":"Astrakhan Standard Time","America/Catamarca":"Argentina Standard Time","Africa/Lubumbashi":"South Africa Standard Time","America/Boise":"Mountain Standard Time","America/Glace_Bay":"Atlantic Standard Time","America/Tegucigalpa":"Central America Standard Time","America/Chicago":"Central Standard Time","Etc/GMT+6":"Central America Standard Time","Antarctica/Macquarie":"Central Pacific Standard Time","Europe/Kirov":"Russian Standard Time","America/Campo_Grande":"Central Brazilian Standard Time","Indian/Mauritius":"Mauritius Standard Time","America/La_Paz":"SA Western Standard Time","Russian Standard Time":[["Europe/Moscow","Europe/Kirov","Europe/Volgograd","Europe/Simferopol"],"(UTC+03:00) Moscow, St. Petersburg, Volgograd","Russia TZ 2 Standard Time","Russia TZ 2 Daylight Time",true,180],"America/Miquelon":"Saint Pierre Standard Time","Asia/Tbilisi":"Georgian Standard Time","Asia/Aden":"Arab Standard Time","Asia/Tehran":"Iran Standard Time","Asia/Colombo":"Sri Lanka Standard Time","America/Lower_Princes":"SA Western Standard Time","Azores Standard Time":[["Atlantic/Azores","America/Scoresbysund"],"(UTC-01:00) Azores","Azores Standard Time","Azores Daylight Time",true,-60],"America/Santo_Domingo":"SA Western Standard Time","Iran Standard Time":[["Asia/Tehran"],"(UTC+03:30) Tehran","Iran Standard Time","Iran Daylight Time",true,210],"Mountain Standard Time (Mexico)":[["America/Chihuahua","America/Mazatlan"],"(UTC-07:00) Chihuahua, La Paz, Mazatlan","Mountain Standard Time (Mexico)","Mountain Daylight Time (Mexico)",true,-420],"Central Europe Standard Time":[["Europe/Budapest","Europe/Tirane","Europe/Prague","Europe/Podgorica","Europe/Belgrade","Europe/Ljubljana","Europe/Bratislava"],"(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague","Central Europe Standard Time","Central Europe Daylight Time",true,60],"Asia/Beirut":"Middle East Standard Time","America/Denver":"Mountain Standard Time","America/Halifax":"Atlantic Standard Time","America/Barbados":"SA Western Standard Time","Pacific/Noumea":"Central Pacific Standard Time","Jordan Standard Time":[["Asia/Amman"],"(UTC+02:00) Amman","Jordan Standard Time","Jordan Daylight Time",true,120],"Singapore Standard Time":[["Asia/Singapore","Asia/Brunei","Asia/Makassar","Asia/Kuala_Lumpur","Asia/Kuching","Asia/Manila","Etc/GMT-8"],"(UTC+08:00) Kuala Lumpur, Singapore","Malay Peninsula Standard Time","Malay Peninsula Daylight Time",false,480],"Pacific/Rarotonga":"Hawaiian Standard Time","Asia/Saigon":"SE Asia Standard Time","Europe/Lisbon":"GMT Standard Time","America/Jamaica":"SA Pacific Standard Time","Atlantic/Stanley":"SA Eastern Standard Time","Europe/Sarajevo":"Central European Standard Time","Africa/Abidjan":"Greenwich Standard Time","Europe/London":"GMT Standard Time","Australia/Lord_Howe":"Lord Howe Standard Time","Africa/Kinshasa":"W. Central Africa Standard Time","Africa/Accra":"Greenwich Standard Time","India Standard Time":[["Asia/Calcutta"],"(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi","India Standard Time","India Daylight Time",false,330],"Europe/Kiev":"FLE Standard Time","America/Caracas":"Venezuela Standard Time","Europe/Guernsey":"GMT Standard Time","Africa/Nairobi":"E. Africa Standard Time","Asia/Gaza":"West Bank Standard Time","America/Kentucky/Monticello":"Eastern Standard Time","Europe/Sofia":"FLE Standard Time","America/Edmonton":"Mountain Standard Time","Asia/Almaty":"Central Asia Standard Time","Asia/Anadyr":"Russia Time Zone 11","Asia/Pontianak":"SE Asia Standard Time","Europe/Madrid":"Romance Standard Time","Asia/Kamchatka":"Russia Time Zone 11","Atlantic/Bermuda":"Atlantic Standard Time","Namibia Standard Time":[["Africa/Windhoek"],"(UTC+01:00) Windhoek","Namibia Standard Time","Namibia Daylight Time",true,60],"Pacific/Tarawa":"UTC+12","Montevideo Standard Time":[["America/Montevideo"],"(UTC-03:00) Montevideo","Montevideo Standard Time","Montevideo Daylight Time",true,-180],"America/Costa_Rica":"Central America Standard Time","Hawaiian Standard Time":[["Pacific/Honolulu","Pacific/Rarotonga","Pacific/Tahiti","Pacific/Johnston","Etc/GMT+10"],"(UTC-10:00) Hawaii","Hawaiian Standard Time","Hawaiian Daylight Time",false,-600],"Asia/Calcutta":"India Standard Time","Asia/Pyongyang":"North Korea Standard Time","Pacific/Palau":"Tokyo Standard Time","America/Asuncion":"Paraguay Standard Time","Sri Lanka Standard Time":[["Asia/Colombo"],"(UTC+05:30) Sri Jayawardenepura","Sri Lanka Standard Time","Sri Lanka Daylight Time",false,330],"Asia/Dubai":"Arabian Standard Time","Mountain Standard Time":[["America/Denver","America/Edmonton","America/Cambridge_Bay","America/Inuvik","America/Yellowknife","America/Ojinaga","America/Boise","MST7MDT"],"(UTC-07:00) Mountain Time (US \u0026amp; Canada)","Mountain Standard Time","Mountain Daylight Time",true,-420],"America/Havana":"Cuba Standard Time","Asia/Jerusalem":"Israel Standard Time","Pacific/Gambier":"UTC-09","America/Araguaina":"Tocantins Standard Time","Pacific/Midway":"UTC-11","Asia/Manila":"Singapore Standard Time","MST7MDT":"Mountain Standard Time","Europe/Bucharest":"GTB Standard Time","Asia/Baghdad":"Arabic Standard Time","Asia/Novokuznetsk":"North Asia Standard Time","Antarctica/DumontDUrville":"West Pacific Standard Time","Africa/Blantyre":"South Africa Standard Time","Libya Standard Time":[["Africa/Tripoli"],"(UTC+02:00) Tripoli","Libya Standard Time","Libya Daylight Time",true,120],"Samoa Standard Time":[["Pacific/Apia"],"(UTC+13:00) Samoa","Samoa Standard Time","Samoa Daylight Time",true,780],"Pacific/Efate":"Central Pacific Standard Time","Europe/Volgograd":"Russian Standard Time","America/Argentina/Tucuman":"Argentina Standard Time","America/St_Lucia":"SA Western Standard Time","Europe/Budapest":"Central Europe Standard Time","Etc/GMT+1":"Cape Verde Standard Time","Asia/Nicosia":"GTB Standard Time","Asia/Kuching":"Singapore Standard Time","America/Chihuahua":"Mountain Standard Time (Mexico)","Asia/Choibalsan":"Ulaanbaatar Standard Time","Europe/Zagreb":"Central European Standard Time","America/Martinique":"SA Western Standard Time","FLE Standard Time":[["Europe/Kiev","Europe/Mariehamn","Europe/Sofia","Europe/Tallinn","Europe/Helsinki","Europe/Vilnius","Europe/Riga","Europe/Uzhgorod","Europe/Zaporozhye"],"(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius","FLE Standard Time","FLE Daylight Time",true,120],"America/Swift_Current":"Canada Central Standard Time","America/Hermosillo":"US Mountain Standard Time","Etc/GMT-9":"Tokyo Standard Time","America/Santarem":"SA Eastern Standard Time","Pacific/Fakaofo":"Tonga Standard Time","Greenwich Standard Time":[["Atlantic/Reykjavik","Africa/Ouagadougou","Africa/Abidjan","Africa/Accra","Africa/Banjul","Africa/Conakry","Africa/Bissau","Africa/Monrovia","Africa/Bamako","Africa/Nouakchott","Atlantic/St_Helena","Africa/Freetown","Africa/Dakar","Africa/Sao_Tome","Africa/Lome"],"(UTC+00:00) Monrovia, Reykjavik","Greenwich Standard Time","Greenwich Daylight Time",false,0],"W. Australia Standard Time":[["Australia/Perth"],"(UTC+08:00) Perth","W. Australia Standard Time","W. Australia Daylight Time",true,480],"Pacific/Wake":"UTC+12","America/Merida":"Central Standard Time (Mexico)","America/Scoresbysund":"Azores Standard Time","Asia/Barnaul":"Altai Standard Time","Asia/Seoul":"Korea Standard Time","America/Inuvik":"Mountain Standard Time","America/Rainy_River":"Central Standard Time","Pacific/Tahiti":"Hawaiian Standard Time","America/Iqaluit":"Eastern Standard Time","Europe/Moscow":"Russian Standard Time","Korea Standard Time":[["Asia/Seoul"],"(UTC+09:00) Seoul","Korea Standard Time","Korea Daylight Time",false,540],"Paraguay Standard Time":[["America/Asuncion"],"(UTC-04:00) Asuncion","Paraguay Standard Time","Paraguay Daylight Time",true,-240],"Asia/Riyadh":"Arab Standard Time","Central European Standard Time":[["Europe/Warsaw","Europe/Sarajevo","Europe/Zagreb","Europe/Skopje"],"(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb","Central European Standard Time","Central European Daylight Time",true,60],"Europe/Samara":"Russia Time Zone 3","Central Standard Time (Mexico)":[["America/Mexico_City","America/Bahia_Banderas","America/Merida","America/Monterrey"],"(UTC-06:00) Guadalajara, Mexico City, Monterrey","Central Standard Time (Mexico)","Central Daylight Time (Mexico)",true,-360],"America/Indiana/Winamac":"Eastern Standard Time","North Asia East Standard Time":[["Asia/Irkutsk"],"(UTC+08:00) Irkutsk","Russia TZ 7 Standard Time","Russia TZ 7 Daylight Time",true,480],"Asia/Yekaterinburg":"Ekaterinburg Standard Time","Africa/Addis_Ababa":"E. Africa Standard Time","Haiti Standard Time":[["America/Port-au-Prince"],"(UTC-05:00) Haiti","Haiti Standard Time","Haiti Daylight Time",true,-300],"Asia/Jayapura":"Tokyo Standard Time","Etc/GMT-1":"W. Central Africa Standard Time","Europe/Skopje":"Central European Standard Time","America/Dominica":"SA Western Standard Time","Turks And Caicos Standard Time":[["America/Grand_Turk"],"(UTC-04:00) Turks and Caicos","Turks and Caicos Standard Time","Turks and Caicos Daylight Time",true,-240],"Pacific/Kwajalein":"UTC+12","Etc/GMT":"UTC","AUS Eastern Standard Time":[["Australia/Sydney","Australia/Melbourne"],"(UTC+10:00) Canberra, Melbourne, Sydney","AUS Eastern Standard Time","AUS Eastern Daylight Time",true,600],"Antarctica/Vostok":"Central Asia Standard Time","E. Europe Standard Time":[["Europe/Chisinau"],"(UTC+02:00) Chisinau","E. Europe Standard Time","E. Europe Daylight Time",true,120],"Pacific/Majuro":"UTC+12","CST6CDT":"Central Standard Time","Indian/Mahe":"Mauritius Standard Time","America/Yellowknife":"Mountain Standard Time","Etc/GMT+5":"SA Pacific Standard Time","Marquesas Standard Time":[["Pacific/Marquesas"],"(UTC-09:30) Marquesas Islands","Marquesas Standard Time","Marquesas Daylight Time",false,-570],"Atlantic/Madeira":"GMT Standard Time","Pacific/Tongatapu":"Tonga Standard Time","Europe/Andorra":"W. Europe Standard Time","America/Boa_Vista":"SA Western Standard Time","Europe/Vienna":"W. Europe Standard Time","Asia/Muscat":"Arabian Standard Time","America/Winnipeg":"Central Standard Time","America/Nassau":"Eastern Standard Time","Asia/Aqtobe":"West Asia Standard Time","Antarctica/McMurdo":"New Zealand Standard Time","Eastern Standard Time":[["America/New_York","America/Nassau","America/Toronto","America/Iqaluit","America/Montreal","America/Nipigon","America/Pangnirtung","America/Thunder_Bay","America/Detroit","America/Indiana/Petersburg","America/Indiana/Vincennes","America/Indiana/Winamac","America/Kentucky/Monticello","America/Louisville","EST5EDT"],"(UTC-05:00) Eastern Time (US \u0026amp; Canada)","Eastern Standard Time","Eastern Daylight Time",true,-300],"America/Anguilla":"SA Western Standard Time","Africa/Ouagadougou":"Greenwich Standard Time","Etc/GMT-4":"Arabian Standard Time","Atlantic/Azores":"Azores Standard Time","Europe/Mariehamn":"FLE Standard Time","Pacific/Saipan":"West Pacific Standard Time","Etc/UTC":"UTC","Australia/Currie":"Tasmania Standard Time","America/Louisville":"Eastern Standard Time","E. Africa Standard Time":[["Africa/Nairobi","Antarctica/Syowa","Africa/Djibouti","Africa/Asmera","Africa/Addis_Ababa","Indian/Comoro","Indian/Antananarivo","Africa/Khartoum","Africa/Mogadishu","Africa/Juba","Africa/Dar_es_Salaam","Africa/Kampala","Indian/Mayotte","Etc/GMT-3"],"(UTC+03:00) Nairobi","E. Africa Standard Time","E. Africa Daylight Time",false,180],"E. South America Standard Time":[["America/Sao_Paulo"],"(UTC-03:00) Brasilia","E. South America Standard Time","E. South America Daylight Time",true,-180],"Europe/Uzhgorod":"FLE Standard Time","America/El_Salvador":"Central America Standard Time","Pacific/Johnston":"Hawaiian Standard Time","Syria Standard Time":[["Asia/Damascus"],"(UTC+02:00) Damascus","Syria Standard Time","Syria Daylight Time",true,120],"America/Toronto":"Eastern Standard Time","Asia/Bishkek":"Central Asia Standard Time","Atlantic/Canary":"GMT Standard Time","America/Dawson":"Pacific Standard Time","Bougainville Standard Time":[["Pacific/Bougainville"],"(UTC+11:00) Bougainville Island","Bougainville Standard Time","Bougainville Daylight Time",true,660],"Alaskan Standard Time":[["America/Anchorage","America/Juneau","America/Metlakatla","America/Nome","America/Sitka","America/Yakutat"],"(UTC-09:00) Alaska","Alaskan Standard Time","Alaskan Daylight Time",true,-540],"America/Curacao":"SA Western Standard Time","America/Eirunepe":"SA Pacific Standard Time","Asia/Ust-Nera":"Vladivostok Standard Time","SA Pacific Standard Time":[["America/Bogota","America/Rio_Branco","America/Eirunepe","America/Coral_Harbour","America/Guayaquil","America/Jamaica","America/Cayman","America/Panama","America/Lima","Etc/GMT+5"],"(UTC-05:00) Bogota, Lima, Quito, Rio Branco","SA Pacific Standard Time","SA Pacific Daylight Time",false,-300],"Africa/Lome":"Greenwich Standard Time","Pacific/Pago_Pago":"UTC-11","America/Cambridge_Bay":"Mountain Standard Time","America/Indianapolis":"US Eastern Standard Time","America/Indiana/Vevay":"US Eastern Standard Time","Antarctica/Davis":"SE Asia Standard Time","Asia/Srednekolymsk":"Russia Time Zone 10","America/Bogota":"SA Pacific Standard Time","Europe/Saratov":"Astrakhan Standard Time","UTC+13":[null,"(UTC+13:00) Coordinated Universal Time+13","UTC+13","UTC+13",false,780],"Europe/Vatican":"W. Europe Standard Time","Belarus Standard Time":[["Europe/Minsk"],"(UTC+03:00) Minsk","Belarus Standard Time","Belarus Daylight Time",true,180],"Europe/Riga":"FLE Standard Time","Arctic/Longyearbyen":"W. Europe Standard Time","Asia/Tashkent":"West Asia Standard Time","America/Guadeloupe":"SA Western Standard Time","Africa/Conakry":"Greenwich Standard Time","America/Port-au-Prince":"Haiti Standard Time","America/Belize":"Central America Standard Time","South Africa Standard Time":[["Africa/Johannesburg","Africa/Bujumbura","Africa/Gaborone","Africa/Lubumbashi","Africa/Maseru","Africa/Blantyre","Africa/Maputo","Africa/Kigali","Africa/Mbabane","Africa/Lusaka","Africa/Harare","Etc/GMT-2"],"(UTC+02:00) Harare, Pretoria","South Africa Standard Time","South Africa Daylight Time",false,120],"Europe/Warsaw":"Central European Standard Time","Africa/Dakar":"Greenwich Standard Time","UTC-08":[["Etc/GMT+8","Pacific/Pitcairn"],"(UTC-08:00) Coordinated Universal Time-08","UTC-08","UTC-08",false,-480],"America/Vancouver":"Pacific Standard Time","Europe/Ulyanovsk":"Astrakhan Standard Time","Europe/Amsterdam":"W. Europe Standard Time","Cuba Standard Time":[["America/Havana"],"(UTC-05:00) Havana","Cuba Standard Time","Cuba Daylight Time",true,-300],"Asia/Baku":"Azerbaijan Standard Time","Asia/Ulaanbaatar":"Ulaanbaatar Standard Time","America/Argentina/Rio_Gallegos":"Argentina Standard Time","North Korea Standard Time":[["Asia/Pyongyang"],"(UTC+08:30) Pyongyang","North Korea Standard Time","North Korea Daylight Time",true,510],"Indian/Maldives":"West Asia Standard Time","SA Western Standard Time":[["America/La_Paz","America/Antigua","America/Anguilla","America/Aruba","America/Barbados","America/St_Barthelemy","America/Kralendijk","America/Manaus","America/Boa_Vista","America/Porto_Velho","America/Blanc-Sablon","America/Curacao","America/Dominica","America/Santo_Domingo","America/Grenada","America/Guadeloupe","America/Guyana","America/St_Kitts","America/St_Lucia","America/Marigot","America/Martinique","America/Montserrat","America/Puerto_Rico","America/Lower_Princes","America/Port_of_Spain","America/St_Vincent","America/Tortola","America/St_Thomas","Etc/GMT+4"],"(UTC-04:00) Georgetown, La Paz, Manaus, San Juan","SA Western Standard Time","SA Western Daylight Time",false,-240],"Central Pacific Standard Time":[["Pacific/Guadalcanal","Antarctica/Casey","Antarctica/Macquarie","Pacific/Ponape","Pacific/Kosrae","Pacific/Noumea","Pacific/Efate","Etc/GMT-11"],"(UTC+11:00) Solomon Is., New Caledonia","Central Pacific Standard Time","Central Pacific Daylight Time",false,660],"America/Dawson_Creek":"US Mountain Standard Time","Africa/Dar_es_Salaam":"E. Africa Standard Time","America/Rankin_Inlet":"Central Standard Time","America/Antigua":"SA Western Standard Time","Asia/Thimphu":"Bangladesh Standard Time","Chatham Islands Standard Time":[["Pacific/Chatham"],"(UTC+12:45) Chatham Islands","Chatham Islands Standard Time","Chatham Islands Daylight Time",true,765],"America/North_Dakota/New_Salem":"Central Standard Time","America/Ojinaga":"Mountain Standard Time","Africa/Asmera":"E. Africa Standard Time","Europe/San_Marino":"W. Europe Standard Time","Pacific/Pitcairn":"UTC-08","Europe/Isle_of_Man":"GMT Standard Time","North Asia Standard Time":[["Asia/Krasnoyarsk","Asia/Novokuznetsk"],"(UTC+07:00) Krasnoyarsk","Russia TZ 6 Standard Time","Russia TZ 6 Daylight Time",true,420],"America/Danmarkshavn":"UTC","America/Mexico_City":"Central Standard Time (Mexico)","Africa/Banjul":"Greenwich Standard Time","Europe/Zurich":"W. Europe Standard Time","America/St_Johns":"Newfoundland Standard Time","Pacific/Apia":"Samoa Standard Time","Pacific/Niue":"UTC-11","Etc/GMT-3":"E. Africa Standard Time","America/Fortaleza":"SA Eastern Standard Time","China Standard Time":[["Asia/Shanghai","Asia/Hong_Kong","Asia/Macau"],"(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi","China Standard Time","China Daylight Time",false,480],"America/Mazatlan":"Mountain Standard Time (Mexico)","Asia/Samarkand":"West Asia Standard Time","America/Adak":"Aleutian Standard Time","Russia Time Zone 3":[["Europe/Samara"],"(UTC+04:00) Izhevsk, Samara","Russia TZ 3 Standard Time","Russia TZ 3 Daylight Time",true,240],"Taipei Standard Time":[["Asia/Taipei"],"(UTC+08:00) Taipei","Taipei Standard Time","Taipei Daylight Time",false,480],"America/Montreal":"Eastern Standard Time","Russia Time Zone 11":[["Asia/Kamchatka","Asia/Anadyr"],"(UTC+12:00) Anadyr, Petropavlovsk-Kamchatsky","Russia TZ 11 Standard Time","Russia TZ 11 Daylight Time",true,720],"Arabian Standard Time":[["Asia/Dubai","Asia/Muscat","Etc/GMT-4"],"(UTC+04:00) Abu Dhabi, Muscat","Arabian Standard Time","Arabian Daylight Time",false,240],"Asia/Oral":"West Asia Standard Time","Asia/Brunei":"Singapore Standard Time","Bangladesh Standard Time":[["Asia/Dhaka","Asia/Thimphu"],"(UTC+06:00) Dhaka","Bangladesh Standard Time","Bangladesh Daylight Time",true,360],"America/Bahia_Banderas":"Central Standard Time (Mexico)","Africa/Khartoum":"E. Africa Standard Time","Asia/Hovd":"W. Mongolia Standard Time","Antarctica/Mawson":"West Asia Standard Time","Africa/Maseru":"South Africa Standard Time","Asia/Aqtau":"West Asia Standard Time","Europe/Chisinau":"E. Europe Standard Time","Africa/Douala":"W. Central Africa Standard Time","Asia/Hong_Kong":"China Standard Time","Africa/Ndjamena":"W. Central Africa Standard Time","Indian/Reunion":"Mauritius Standard Time","Asia/Krasnoyarsk":"North Asia Standard Time","America/Buenos_Aires":"Argentina Standard Time","America/Grand_Turk":"Turks And Caicos Standard Time","US Eastern Standard Time":[["America/Indianapolis","America/Indiana/Marengo","America/Indiana/Vevay"],"(UTC-05:00) Indiana (East)","US Eastern Standard Time","US Eastern Daylight Time",true,-300],"Etc/GMT-6":"Central Asia Standard Time","Europe/Monaco":"W. Europe Standard Time","W. Europe Standard Time":[["Europe/Berlin","Europe/Andorra","Europe/Vienna","Europe/Zurich","Europe/Busingen","Europe/Gibraltar","Europe/Rome","Europe/Vaduz","Europe/Luxembourg","Europe/Monaco","Europe/Malta","Europe/Amsterdam","Europe/Oslo","Europe/Stockholm","Arctic/Longyearbyen","Europe/San_Marino","Europe/Vatican"],"(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna","W. Europe Standard Time","W. Europe Daylight Time",true,60],"America/Montevideo":"Montevideo Standard Time","America/St_Thomas":"SA Western Standard Time","Africa/Monrovia":"Greenwich Standard Time","Etc/GMT-8":"Singapore Standard Time","Saint Pierre Standard Time":[["America/Miquelon"],"(UTC-03:00) Saint Pierre and Miquelon","Saint Pierre Standard Time","Saint Pierre Daylight Time",true,-180],"America/Coral_Harbour":"SA Pacific Standard Time","Africa/Djibouti":"E. Africa Standard Time","Asia/Kabul":"Afghanistan Standard Time","America/Port_of_Spain":"SA Western Standard Time","Atlantic/Reykjavik":"Greenwich Standard Time","Central Standard Time":[["America/Chicago","America/Winnipeg","America/Rainy_River","America/Rankin_Inlet","America/Resolute","America/Matamoros","America/Indiana/Knox","America/Indiana/Tell_City","America/Menominee","America/North_Dakota/Beulah","America/North_Dakota/Center","America/North_Dakota/New_Salem","CST6CDT"],"(UTC-06:00) Central Time (US \u0026amp; Canada)","Central Standard Time","Central Daylight Time",true,-360],"Australia/Melbourne":"AUS Eastern Standard Time","Africa/Freetown":"Greenwich Standard Time","Asia/Atyrau":"West Asia Standard Time","Africa/Lagos":"W. Central Africa Standard Time","Europe/Helsinki":"FLE Standard Time","Asia/Karachi":"Pakistan Standard Time","America/Regina":"Canada Central Standard Time","Tocantins Standard Time":[["America/Araguaina"],"(UTC-03:00) Araguaina","Tocantins Standard Time","Tocantins Daylight Time",true,-180],"Antarctica/Rothera":"SA Eastern Standard Time","Etc/GMT+3":"SA Eastern Standard Time","Dateline Standard Time":[["Etc/GMT+12"],"(UTC-12:00) International Date Line West","Dateline Standard Time","Dateline Daylight Time",false,-720],"Australia/Sydney":"AUS Eastern Standard Time","Etc/GMT+12":"Dateline Standard Time","PST8PDT":"Pacific Standard Time","Canada Central Standard Time":[["America/Regina","America/Swift_Current"],"(UTC-06:00) Saskatchewan","Canada Central Standard Time","Canada Central Daylight Time",false,-360],"Lord Howe Standard Time":[["Australia/Lord_Howe"],"(UTC+10:30) Lord Howe Island","Lord Howe Standard Time","Lord Howe Daylight Time",true,630],"Europe/Busingen":"W. Europe Standard Time","Turkey Standard Time":[["Europe/Istanbul","Asia/Famagusta"],"(UTC+03:00) Istanbul","Turkey Standard Time","Turkey Daylight Time",true,180],"Africa/Bamako":"Greenwich Standard Time","America/Grenada":"SA Western Standard Time","America/Kralendijk":"SA Western Standard Time","America/Indiana/Petersburg":"Eastern Standard Time","Etc/GMT+4":"SA Western Standard Time","GTB Standard Time":[["Europe/Bucharest","Asia/Nicosia","Europe/Athens"],"(UTC+02:00) Athens, Bucharest","GTB Standard Time","GTB Daylight Time",true,120],"Asia/Vientiane":"SE Asia Standard Time","Africa/Lusaka":"South Africa Standard Time","Europe/Oslo":"W. Europe Standard Time","Australia/Hobart":"Tasmania Standard Time","Central Asia Standard Time":[["Asia/Almaty","Antarctica/Vostok","Asia/Urumqi","Indian/Chagos","Asia/Bishkek","Asia/Qyzylorda","Etc/GMT-6"],"(UTC+06:00) Astana","Central Asia Standard Time","Central Asia Daylight Time",false,360],"Etc/GMT+7":"US Mountain Standard Time","Kaliningrad Standard Time":[["Europe/Kaliningrad"],"(UTC+02:00) Kaliningrad","Russia TZ 1 Standard Time","Russia TZ 1 Daylight Time",true,120],"Yakutsk Standard Time":[["Asia/Yakutsk","Asia/Khandyga"],"(UTC+09:00) Yakutsk","Russia TZ 8 Standard Time","Russia TZ 8 Daylight Time",true,540],"Caucasus Standard Time":[["Asia/Yerevan"],"(UTC+04:00) Yerevan","Caucasus Standard Time","Caucasus Daylight Time",true,240],"EST5EDT":"Eastern Standard Time","Egypt Standard Time":[["Africa/Cairo"],"(UTC+02:00) Cairo","Egypt Standard Time","Egypt Daylight Time",true,120],"Europe/Dublin":"GMT Standard Time","Pacific/Norfolk":"Norfolk Standard Time","Arabic Standard Time":[["Asia/Baghdad"],"(UTC+03:00) Baghdad","Arabic Standard Time","Arabic Daylight Time",true,180],"Antarctica/Casey":"Central Pacific Standard Time","America/Porto_Velho":"SA Western Standard Time","Pakistan Standard Time":[["Asia/Karachi"],"(UTC+05:00) Islamabad, Karachi","Pakistan Standard Time","Pakistan Daylight Time",true,300],"SE Asia Standard Time":[["Asia/Bangkok","Antarctica/Davis","Indian/Christmas","Asia/Jakarta","Asia/Pontianak","Asia/Phnom_Penh","Asia/Vientiane","Asia/Saigon","Etc/GMT-7"],"(UTC+07:00) Bangkok, Hanoi, Jakarta","SE Asia Standard Time","SE Asia Daylight Time",false,420],"Asia/Hebron":"West Bank Standard Time","Africa/Windhoek":"Namibia Standard Time","SA Eastern Standard Time":[["America/Cayenne","Antarctica/Rothera","Antarctica/Palmer","America/Fortaleza","America/Belem","America/Maceio","America/Recife","America/Santarem","America/Punta_Arenas","Atlantic/Stanley","America/Paramaribo","Etc/GMT+3"],"(UTC-03:00) Cayenne, Fortaleza","SA Eastern Standard Time","SA Eastern Daylight Time",false,-180],"Asia/Tokyo":"Tokyo Standard Time","Pacific/Honolulu":"Hawaiian Standard Time","Asia/Magadan":"Magadan Standard Time","Omsk Standard Time":[["Asia/Omsk"],"(UTC+06:00) Omsk","Omsk Standard Time","Omsk Daylight Time",true,360],"America/New_York":"Eastern Standard Time","Europe/Berlin":"W. Europe Standard Time","Easter Island Standard Time":[["Pacific/Easter"],"(UTC-06:00) Easter Island","Easter Island Standard Time","Easter Island Daylight Time",true,-360],"Central America Standard Time":[["America/Guatemala","America/Belize","America/Costa_Rica","Pacific/Galapagos","America/Tegucigalpa","America/Managua","America/El_Salvador","Etc/GMT+6"],"(UTC-06:00) Central America","Central America Standard Time","Central America Daylight Time",false,-360],"N. Central Asia Standard Time":[["Asia/Novosibirsk"],"(UTC+07:00) Novosibirsk","Novosibirsk Standard Time","Novosibirsk Daylight Time",true,420],"Asia/Rangoon":"Myanmar Standard Time","America/Argentina/La_Rioja":"Argentina Standard Time","Myanmar Standard Time":[["Asia/Rangoon","Indian/Cocos"],"(UTC+06:30) Yangon (Rangoon)","Myanmar Standard Time","Myanmar Daylight Time",false,390],"Etc/GMT-12":"UTC+12","Africa/Juba":"E. Africa Standard Time","Etc/GMT-11":"Central Pacific Standard Time","America/Yakutat":"Alaskan Standard Time","Pacific/Port_Moresby":"West Pacific Standard Time","Atlantic/South_Georgia":"UTC-02","Australia/Darwin":"AUS Central Standard Time","America/Nipigon":"Eastern Standard Time","America/Panama":"SA Pacific Standard Time","America/Cordoba":"Argentina Standard Time","Europe/Stockholm":"W. Europe Standard Time","America/Rio_Branco":"SA Pacific Standard Time","Europe/Prague":"Central Europe Standard Time","Antarctica/Palmer":"SA Eastern Standard Time","America/Whitehorse":"Pacific Standard Time","Pacific/Enderbury":"Tonga Standard Time","UTC+12":[["Etc/GMT-12","Pacific/Tarawa","Pacific/Majuro","Pacific/Kwajalein","Pacific/Nauru","Pacific/Funafuti","Pacific/Wake","Pacific/Wallis"],"(UTC+12:00) Coordinated Universal Time+12","UTC+12","UTC+12",false,720],"UTC-09":[["Etc/GMT+9","Pacific/Gambier"],"(UTC-09:00) Coordinated Universal Time-09","UTC-09","UTC-09",false,-540],"AUS Central Standard Time":[["Australia/Darwin"],"(UTC+09:30) Darwin","AUS Central Standard Time","AUS Central Daylight Time",false,570],"Line Islands Standard Time":[["Pacific/Kiritimati","Etc/GMT-14"],"(UTC+14:00) Kiritimati Island","Line Islands Standard Time","Line Islands Daylight Time",false,840],"Africa/Mbabane":"South Africa Standard Time","Asia/Dushanbe":"West Asia Standard Time","America/Indiana/Marengo":"US Eastern Standard Time","America/Punta_Arenas":"SA Eastern Standard Time","America/Maceio":"SA Eastern Standard Time","America/Menominee":"Central Standard Time","America/Anchorage":"Alaskan Standard Time","Norfolk Standard Time":[["Pacific/Norfolk"],"(UTC+11:00) Norfolk Island","Norfolk Standard Time","Norfolk Daylight Time",true,660],"America/Monterrey":"Central Standard Time (Mexico)","America/Paramaribo":"SA Eastern Standard Time","Africa/Gaborone":"South Africa Standard Time","Morocco Standard Time":[["Africa/Casablanca","Africa/El_Aaiun"],"(UTC+00:00) Casablanca","Morocco Standard Time","Morocco Daylight Time",true,0],"Australia/Brisbane":"E. Australia Standard Time","West Bank Standard Time":[["Asia/Hebron","Asia/Gaza"],"(UTC+02:00) Gaza, Hebron","West Bank Gaza Standard Time","West Bank Gaza Daylight Time",true,120],"America/St_Barthelemy":"SA Western Standard Time","America/Montserrat":"SA Western Standard Time","America/St_Vincent":"SA Western Standard Time","America/Goose_Bay":"Atlantic Standard Time","America/Argentina/Salta":"Argentina Standard Time","Europe/Malta":"W. Europe Standard Time","Australia/Perth":"W. Australia Standard Time","Azerbaijan Standard Time":[["Asia/Baku"],"(UTC+04:00) Baku","Azerbaijan Standard Time","Azerbaijan Daylight Time",true,240],"Asia/Katmandu":"Nepal Standard Time","Pacific/Bougainville":"Bougainville Standard Time","Asia/Phnom_Penh":"SE Asia Standard Time","Africa/Porto-Novo":"W. Central Africa Standard Time","America/Tortola":"SA Western Standard Time","Tomsk Standard Time":[["Asia/Tomsk"],"(UTC+07:00) Tomsk","Tomsk Standard Time","Tomsk Daylight Time",true,420],"Romance Standard Time":[["Europe/Paris","Europe/Brussels","Europe/Copenhagen","Europe/Madrid","Africa/Ceuta"],"(UTC+01:00) Brussels, Copenhagen, Madrid, Paris","Romance Standard Time","Romance Daylight Time",true,60],"America/Matamoros":"Central Standard Time","America/Bahia":"Bahia Standard Time","Indian/Chagos":"Central Asia Standard Time","America/Godthab":"Greenland Standard Time","Africa/Luanda":"W. Central Africa Standard Time","America/Resolute":"Central Standard Time","Asia/Omsk":"Omsk Standard Time","Indian/Christmas":"SE Asia Standard Time","Africa/El_Aaiun":"Morocco Standard Time","America/Metlakatla":"Alaskan Standard Time","Europe/Athens":"GTB Standard Time","Asia/Kuala_Lumpur":"Singapore Standard Time","Europe/Zaporozhye":"FLE Standard Time","Asia/Khandyga":"Yakutsk Standard Time","Arab Standard Time":[["Asia/Riyadh","Asia/Bahrain","Asia/Kuwait","Asia/Qatar","Asia/Aden"],"(UTC+03:00) Kuwait, Riyadh","Arab Standard Time","Arab Daylight Time",false,180],"America/Moncton":"Atlantic Standard Time","Europe/Bratislava":"Central Europe Standard Time","Etc/GMT-2":"South Africa Standard Time","Antarctica/Syowa":"E. Africa Standard Time","Etc/GMT+11":"UTC-11","America/Argentina/San_Juan":"Argentina Standard Time","Asia/Ashgabat":"West Asia Standard Time","Indian/Comoro":"E. Africa Standard Time","Asia/Shanghai":"China Standard Time","Asia/Yakutsk":"Yakutsk Standard Time","Aus Central W. Standard Time":[["Australia/Eucla"],"(UTC+08:45) Eucla","Aus Central W. Standard Time","Aus Central W. Daylight Time",false,525],"America/Managua":"Central America Standard Time","Africa/Nouakchott":"Greenwich Standard Time","America/North_Dakota/Center":"Central Standard Time","Africa/Algiers":"W. Central Africa Standard Time","Europe/Rome":"W. Europe Standard Time","Pacific/Wallis":"UTC+12","Europe/Tallinn":"FLE Standard Time","Australia/Broken_Hill":"Cen. Australia Standard Time","Etc/GMT-14":"Line Islands Standard Time","Africa/Casablanca":"Morocco Standard Time","Pacific Standard Time":[["America/Los_Angeles","America/Vancouver","America/Dawson","America/Whitehorse","PST8PDT"],"(UTC-08:00) Pacific Time (US \u0026amp; Canada)","Pacific Standard Time","Pacific Daylight Time",true,-480],"Pacific/Galapagos":"Central America Standard Time","Africa/Bissau":"Greenwich Standard Time","Pacific/Fiji":"Fiji Standard Time","Asia/Kuwait":"Arab Standard Time","America/Cuiaba":"Central Brazilian Standard Time","Pacific/Funafuti":"UTC+12","Etc/GMT-7":"SE Asia Standard Time","Africa/Kampala":"E. Africa Standard Time","Europe/Istanbul":"Turkey Standard Time","America/Thunder_Bay":"Eastern Standard Time","America/Creston":"US Mountain Standard Time","Pacific/Easter":"Easter Island Standard Time","Middle East Standard Time":[["Asia/Beirut"],"(UTC+02:00) Beirut","Middle East Standard Time","Middle East Daylight Time",true,120],"America/Detroit":"Eastern Standard Time","America/Cancun":"Eastern Standard Time (Mexico)","Asia/Macau":"China Standard Time","Eastern Standard Time (Mexico)":[["America/Cancun"],"(UTC-05:00) Chetumal","Eastern Standard Time (Mexico)","Eastern Daylight Time (Mexico)",true,-300],"America/Indiana/Vincennes":"Eastern Standard Time","Asia/Bahrain":"Arab Standard Time","Argentina Standard Time":[["America/Buenos_Aires","America/Argentina/La_Rioja","America/Argentina/Rio_Gallegos","America/Argentina/Salta","America/Argentina/San_Juan","America/Argentina/San_Luis","America/Argentina/Tucuman","America/Argentina/Ushuaia","America/Catamarca","America/Cordoba","America/Jujuy","America/Mendoza"],"(UTC-03:00) City of Buenos Aires","Argentina Standard Time","Argentina Daylight Time",true,-180],"Asia/Irkutsk":"North Asia East Standard Time","Asia/Novosibirsk":"N. Central Asia Standard Time","America/Noronha":"UTC-02","Africa/Maputo":"South Africa Standard Time","America/Sao_Paulo":"E. South America Standard Time","Europe/Podgorica":"Central Europe Standard Time","Etc/GMT+2":"UTC-02","Pacific/Marquesas":"Marquesas Standard Time","America/Blanc-Sablon":"SA Western Standard Time","Asia/Yerevan":"Caucasus Standard Time","Atlantic/Cape_Verde":"Cape Verde Standard Time","Pacific/Auckland":"New Zealand Standard Time","America/Phoenix":"US Mountain Standard Time","Pacific/Truk":"West Pacific Standard Time","Greenland Standard Time":[["America/Godthab"],"(UTC-03:00) Greenland","Greenland Standard Time","Greenland Daylight Time",true,-180],"Africa/Mogadishu":"E. Africa Standard Time","Pacific SA Standard Time":[["America/Santiago"],"(UTC-04:00) Santiago","Pacific SA Standard Time","Pacific SA Daylight Time",true,-240],"Asia/Urumqi":"Central Asia Standard Time","Asia/Chita":"Transbaikal Standard Time","America/Lima":"SA Pacific Standard Time","Australia/Eucla":"Aus Central W. Standard Time","Asia/Damascus":"Syria Standard Time","Europe/Minsk":"Belarus Standard Time","Africa/Bujumbura":"South Africa Standard Time","Asia/Makassar":"Singapore Standard Time","Saratov Standard Time":[null,"(UTC+04:00) Saratov","Saratov Standard Time","Saratov Daylight Time",true,240],"Ulaanbaatar Standard Time":[["Asia/Ulaanbaatar","Asia/Choibalsan"],"(UTC+08:00) Ulaanbaatar","Ulaanbaatar Standard Time","Ulaanbaatar Daylight Time",true,480],"Asia/Amman":"Jordan Standard Time","Tonga Standard Time":[["Pacific/Tongatapu","Pacific/Enderbury","Pacific/Fakaofo","Etc/GMT-13"],"(UTC+13:00) Nuku\u0027alofa","Tonga Standard Time","Tonga Daylight Time",true,780],"Atlantic/St_Helena":"Greenwich Standard Time","America/Santiago":"Pacific SA Standard Time","UTC-02":[["Etc/GMT+2","America/Noronha","Atlantic/South_Georgia"],"(UTC-02:00) Coordinated Universal Time-02","UTC-02","UTC-02",false,-120],"Europe/Luxembourg":"W. Europe Standard Time","Africa/Cairo":"Egypt Standard Time","America/Recife":"SA Eastern Standard Time","America/Indiana/Tell_City":"Central Standard Time","Africa/Niamey":"W. Central Africa Standard Time","America/Juneau":"Alaskan Standard Time","Asia/Qyzylorda":"Central Asia Standard Time","Asia/Bangkok":"SE Asia Standard Time","Magadan Standard Time":[["Asia/Magadan"],"(UTC+11:00) Magadan","Magadan Standard Time","Magadan Daylight Time",true,660],"Africa/Johannesburg":"South Africa Standard Time","America/Santa_Isabel":"Pacific Standard Time (Mexico)","Astrakhan Standard Time":[["Europe/Astrakhan","Europe/Saratov","Europe/Ulyanovsk"],"(UTC+04:00) Astrakhan, Ulyanovsk","Astrakhan Standard Time","Astrakhan Daylight Time",true,240],"America/Cayenne":"SA Eastern Standard Time","Africa/Tripoli":"Libya Standard Time","Africa/Bangui":"W. Central Africa Standard Time","Asia/Tomsk":"Tomsk Standard Time","Central Brazilian Standard Time":[["America/Cuiaba","America/Campo_Grande"],"(UTC-04:00) Cuiaba","Central Brazilian Standard Time","Central Brazilian Daylight Time",true,-240],"Africa/Harare":"South Africa Standard Time","Europe/Kaliningrad":"Kaliningrad Standard Time","Israel Standard Time":[["Asia/Jerusalem"],"(UTC+02:00) Jerusalem","Jerusalem Standard Time","Jerusalem Daylight Time",true,120],"E. Australia Standard Time":[["Australia/Brisbane","Australia/Lindeman"],"(UTC+10:00) Brisbane","E. Australia Standard Time","E. Australia Daylight Time",false,600],"America/Marigot":"SA Western Standard Time","Asia/Dhaka":"Bangladesh Standard Time","Etc/GMT-10":"West Pacific Standard Time","Europe/Paris":"Romance Standard Time","America/Nome":"Alaskan Standard Time","America/Belem":"SA Eastern Standard Time","Africa/Sao_Tome":"Greenwich Standard Time","Asia/Taipei":"Taipei Standard Time","Pacific/Chatham":"Chatham Islands Standard Time","Asia/Vladivostok":"Vladivostok Standard Time","Vladivostok Standard Time":[["Asia/Vladivostok","Asia/Ust-Nera"],"(UTC+10:00) Vladivostok","Russia TZ 9 Standard Time","Russia TZ 9 Daylight Time",true,600],"America/Tijuana":"Pacific Standard Time (Mexico)","Etc/GMT-13":"Tonga Standard Time","Pacific/Guadalcanal":"Central Pacific Standard Time","Indian/Antananarivo":"E. Africa Standard Time","Africa/Ceuta":"Romance Standard Time","America/Jujuy":"Argentina Standard Time","Cape Verde Standard Time":[["Atlantic/Cape_Verde","Etc/GMT+1"],"(UTC-01:00) Cabo Verde Is.","Cabo Verde Standard Time","Cabo Verde Daylight Time",false,-60],"GMT Standard Time":[["Europe/London","Atlantic/Canary","Atlantic/Faeroe","Europe/Guernsey","Europe/Dublin","Europe/Isle_of_Man","Europe/Jersey","Europe/Lisbon","Atlantic/Madeira"],"(UTC+00:00) Dublin, Edinburgh, Lisbon, London","GMT Standard Time","GMT Daylight Time",true,0],"Bahia Standard Time":[["America/Bahia"],"(UTC-03:00) Salvador","Bahia Standard Time","Bahia Daylight Time",true,-180]}
export let CustomTimeZoneMappingData = {
    'tzone://Microsoft/Utc':'UTC'
}


/**
* TimeZoneInfo
*/
export class TimeZoneInfo {

    // static get Utc(): TimeZoneInfo { return this.utc; }
    // private static utc: TimeZoneInfo = new TimeZoneInfo(0);

    // static get Local(): TimeZoneInfo { return this.local; }
    // private static local: TimeZoneInfo = new TimeZoneInfo(moment().local().utcOffset());

    // private offset: number;

    // constructor(offset: number) {
    //     this.offset = offset;
    // }

    // static IsLocalTimeZone(timeZone: TimeZoneInfo) {
    //     return timeZone.offset === this.local.offset;
    // }
    // get DisplayName(): string { return this.offset.toString(); }

    // static ConvertTime(dateTime: DateTime, sourceTZ: TimeZoneInfo, destinationTZ: TimeZoneInfo): DateTime {
    //     var returnDate = new DateTime(dateTime);
    //     //var offset = returnDate.currentUtcOffset + destinationTZ.offset - sourceTZ.offset 
    //     returnDate.utcOffset(destinationTZ.offset);
    //     return returnDate;
    // }


    private static _localTimeZone: TimeZoneInfo = null;
    private readonly _id: string;
    private _ianaId: string = null;
    private readonly _displayName: string = null;
    private readonly _standardDisplayName: string = null;
    private readonly _daylightDisplayName: string = null;
    private readonly _baseUtcOffset: TimeSpan;
    private readonly _supportsDaylightSavingTime: boolean = false;
    private readonly _adjustmentRules: TimeZoneInfo.AdjustmentRule[] = [];

    // constants for TimeZoneInfo.Local and TimeZoneInfo.Utc
    private static readonly UtcId: string = "UTC";
    private static readonly LocalId: string = "Local";

    private static readonly s_utcTimeZone: TimeZoneInfo = TimeZoneInfo.CreateCustomTimeZone(TimeZoneInfo.UtcId, TimeSpan.Zero, TimeZoneInfo.UtcId, TimeZoneInfo.UtcId);

    // used by GetUtcOffsetFromUtc (DateTime.Now, DateTime.ToLocalTime) for max/min whole-day range checks
    private static readonly s_maxDateOnly: DateTime = new DateTime(9999, 12, 31);
    private static readonly s_minDateOnly: DateTime = new DateTime(1, 1, 2);

    public get Id(): string {
        return this._id;
    }

    public get IanaId(): string {
        return this._ianaId;
    }

    public get DisplayName(): string {
        return this._displayName || StringHelper.Empty;
    }
    public get StandardName(): string {
        return this._standardDisplayName || StringHelper.Empty;
    }
    public get DaylightName(): string {
        return this._daylightDisplayName || StringHelper.Empty;
    }
    public get BaseUtcOffset(): TimeSpan {
        return this._baseUtcOffset;
    }
    public get SupportsDaylightSavingTime(): boolean {
        return this._supportsDaylightSavingTime;
    }

    public static get Local(): TimeZoneInfo {
        if (this._localTimeZone) {
            return this._localTimeZone;
        }
        return this.CreateLocal();
    }

    public static get Utc(): TimeZoneInfo {
        return this.s_utcTimeZone;
    }

    private constructor(
        id: string,
        baseUtcOffset: TimeSpan,
        displayName: string,
        standardDisplayName: string,
        daylightDisplayName: string,
        adjustmentRules: TimeZoneInfo.AdjustmentRule[],
        disableDaylightSavingTime: boolean) {

        let adjustmentRulesSupportDst: boolean;
        //TimeZoneInfo.ValidateTimeZoneInfo(id, baseUtcOffset, adjustmentRules, adjustmentRulesSupportDst);

        this._id = id;
        this._baseUtcOffset = baseUtcOffset;
        this._displayName = displayName;
        this._standardDisplayName = standardDisplayName;
        this._daylightDisplayName = disableDaylightSavingTime ? null : daylightDisplayName;
        //this._supportsDaylightSavingTime = adjustmentRulesSupportDst && !disableDaylightSavingTime;
        this._adjustmentRules = adjustmentRules;

        let tzArray = TimeZoneMappingData[id];
        if (ArrayHelper.isArray(tzArray)) {
            this._supportsDaylightSavingTime = tzArray[4] && !disableDaylightSavingTime;
        }
    }

    public static ConvertTime(dateTime: DateTime, sourceTimeZone: TimeZoneInfo, destinationTimeZone: TimeZoneInfo): DateTime {
        if (sourceTimeZone == null) {
            throw new ArgumentNullException("sourceTimeZone");
        }

        if (destinationTimeZone == null) {
            throw new ArgumentNullException("destinationTimeZone");
        }
        let sourceKind: DateTimeKind = this.GetCorrespondingKind(sourceTimeZone);
        if (dateTime.Kind != DateTimeKind.Unspecified && dateTime.Kind != sourceKind) {
            throw new ArgumentException("DateTime Kind mismatch with source time", "sourceTimeZone");
        }

        let targetKind: DateTimeKind = this.GetCorrespondingKind(destinationTimeZone);

        // handle the special case of Loss-less Local->Local and UTC->UTC)
        if (dateTime.Kind != DateTimeKind.Unspecified && sourceKind != DateTimeKind.Unspecified && sourceKind == targetKind) {
            return dateTime;
        }

        let targetIanaId = destinationTimeZone._ianaId;
        if (StringHelper.IsNullOrEmpty(targetIanaId)) {
            if (StringHelper.IsNullOrEmpty(destinationTimeZone._id)) {
                throw new ArgumentException("Destination Timezone does not have valid identifier")
            }
            let targetTzData = TimeZoneMappingData[destinationTimeZone._id] as string[];
            if (!ArrayHelper.isArray(targetTzData) || !ArrayHelper.isArray(targetTzData[0])) {
                throw new ArgumentException("Destination Timezone does not have valid identifier")
            }
            targetIanaId = targetTzData[0][0];
        }
        return new DateTime(dateTime.MomentDate.clone().tz(targetIanaId));
    }


    private static CreateLocal(): TimeZoneInfo {
        let tzGuess: string = moment.tz.guess();
        let offset: number = moment().utcOffset();
        if (StringHelper.IsNullOrEmpty(tzGuess) || StringHelper.IsNullOrEmpty(TimeZoneMappingData[tzGuess])) {
            console.log("Unable to guess timezone, switching to Utc");
            tzGuess = "Etc/UTC";
        }
        let tzArray: any[] = TimeZoneMappingData[TimeZoneMappingData[tzGuess]];


        if (ArrayHelper.isArray<any>(tzArray)) {
            this._localTimeZone = new TimeZoneInfo(TimeZoneMappingData[tzGuess], TimeSpan.FromMinutes(offset), tzArray[1], <string>tzArray[2], <string>tzArray[3], [], false);
        }
        else {
            this._localTimeZone = this.CreateCustomTimeZone(TimeZoneMappingData[tzGuess], TimeSpan.FromMinutes(offset), TimeZoneMappingData[tzGuess], TimeZoneMappingData[tzGuess]);
        }
        this._localTimeZone._ianaId = tzGuess;
        return this._localTimeZone;

    }

    public static CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string): TimeZoneInfo;
    public static CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: TimeZoneInfo.AdjustmentRule[]): TimeZoneInfo;
    public static CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: TimeZoneInfo.AdjustmentRule[], disableDaylightSavingTime: boolean): TimeZoneInfo;
    public static CreateCustomTimeZone(
        id: string,
        baseUtcOffset: TimeSpan,
        displayName: string,
        standardDisplayName: string,
        daylightDisplayName: string = null,
        adjustmentRules: TimeZoneInfo.AdjustmentRule[] = null,
        disableDaylightSavingTime: boolean = false): TimeZoneInfo {
        if (!disableDaylightSavingTime && adjustmentRules && adjustmentRules.length > 0) {
            adjustmentRules = adjustmentRules.slice(0);
        }

        let tz = new TimeZoneInfo(
            id,
            baseUtcOffset,
            displayName,
            standardDisplayName,
            daylightDisplayName || standardDisplayName,
            adjustmentRules,
            disableDaylightSavingTime);
        if (id === this.UtcId) {
            tz._ianaId = id;
        }
        return tz;
    }

    public static AddTimeZoneMapping(source: string, mappedTz: string) {
        CustomTimeZoneMappingData[source] = mappedTz;
    }

    public static FindSystemTimeZoneById(zoneName: string): TimeZoneInfo {
        let ianaId = StringHelper.Empty;
        let winId = StringHelper.Empty;

        let mappedTz: string | any[] = TimeZoneMappingData[zoneName];
        if (typeof mappedTz === 'undefined') {
            let zoneNameMapped = CustomTimeZoneMappingData[zoneName];
            if (zoneNameMapped) {
                mappedTz = TimeZoneMappingData[zoneNameMapped];
            }
            if (typeof mappedTz === 'undefined') {
                throw new Error("TimeZoneInfo->FromZoneName : Can not find zone name in mapped timezone data, try adding custom Map by calling TimeZoneInfo.AddTimeZoneMapping(sourceName, destinationName)");
            }
        }
        let tzArray = mappedTz;

        if (ArrayHelper.isArray<any>(mappedTz)) {
            ianaId = mappedTz[0][0];
            winId = zoneName;
        } else {
            ianaId = zoneName;
            winId = mappedTz;
            tzArray = TimeZoneMappingData[winId];
            if (!ArrayHelper.isArray(tzArray)) {
                throw new Error("TimeZoneInfo->FromZoneName : Invalid mapping data")
            }
        }

        let tzinfo = new TimeZoneInfo(winId, TimeSpan.FromMinutes(tzArray[5]), tzArray[1], tzArray[2], tzArray[3], [], !tzArray[4])
        tzinfo._ianaId = ianaId;
        return tzinfo;
    }

    public static get ListWindowsTimeZones(): () => string[] {
        return () => Object.keys(TimeZoneMappingData).filter(x => x.indexOf("/") < 0);
    }
    private static GetCorrespondingKind(timeZone: TimeZoneInfo): DateTimeKind {
        if (timeZone === TimeZoneInfo.Utc) return DateTimeKind.Utc;
        if (timeZone === TimeZoneInfo.Local) return DateTimeKind.Local;
        return DateTimeKind.Unspecified;

    }

    public static GuessLocalTimeZone(): string {
        return moment.tz.guess();
    }

    public HasSameRules(other: TimeZoneInfo): boolean {
        if (other == null) {
            throw new ArgumentNullException("other");
        }

        // check the utcOffset and supportsDaylightSavingTime members
        return this._baseUtcOffset === other._baseUtcOffset && this._supportsDaylightSavingTime === other._supportsDaylightSavingTime;
    }

}

export module TimeZoneInfo {

    export enum TimeZoneInfoOptions {
        None = 1,
        NoThrowOnInvalidTime = 2
    }

    enum TimeZoneInfoResult {
        Success = 0,
        TimeZoneNotFoundException = 1,
        InvalidTimeZoneException = 2,
        SecurityException = 3
    };

    export class AdjustmentRule {
        // ---- SECTION:  members supporting exposed properties -------------*
        private readonly _dateStart: DateTime;
        private readonly _dateEnd: DateTime;
        private readonly _daylightDelta: TimeSpan;
        private readonly _daylightTransitionStart: TransitionTime;
        private readonly _daylightTransitionEnd: TransitionTime;
        private readonly _baseUtcOffsetDelta: TimeSpan;   // delta from the default Utc offset (utcOffset = defaultUtcOffset + m_baseUtcOffsetDelta)
        private readonly _noDaylightTransitions: boolean;

        public get DateStart(): DateTime {
            return this._dateStart;
        }

        public get DateEnd(): DateTime {
            return this._dateEnd;
        }

        public get DaylightDelta(): TimeSpan {
            return this._daylightDelta;
        }

        public get DaylightTransitionStart(): TransitionTime {
            return this._daylightTransitionStart;
        }

        public get DaylightTransitionEnd(): TransitionTime {
            return this._daylightTransitionEnd;
        }

        /** @internal */
        get BaseUtcOffsetDelta(): TimeSpan {
            return this._baseUtcOffsetDelta;
        }

        /** @internal */
        get NoDaylightTransitions(): boolean {
            return this._noDaylightTransitions;
        }

        /** @internal */
        get HasDaylightSaving(): boolean {
            return ((this.DaylightDelta.TotalMilliseconds != TimeSpan.Zero.TotalMilliseconds)
                || ((this.DaylightTransitionStart.TimeOfDay.TotalMilliSeconds != DateTime.MinValue.TotalMilliSeconds)
                    || (this.DaylightTransitionEnd.TimeOfDay.TotalMilliSeconds != DateTime.MinValue.AddMilliseconds(1).TotalMilliSeconds)));
        }

        private constructor(
            dateStart: DateTime,
            dateEnd: DateTime,
            daylightDelta: TimeSpan,
            daylightTransitionStart: TransitionTime,
            daylightTransitionEnd: TransitionTime,
            baseUtcOffsetDelta: TimeSpan,
            noDaylightTransitions: boolean) {
            AdjustmentRule.ValidateAdjustmentRule(dateStart, dateEnd, daylightDelta,
                daylightTransitionStart, daylightTransitionEnd, noDaylightTransitions);

            this._dateStart = dateStart;
            this._dateEnd = dateEnd;
            this._daylightDelta = daylightDelta;
            this._daylightTransitionStart = daylightTransitionStart;
            this._daylightTransitionEnd = daylightTransitionEnd;
            this._baseUtcOffsetDelta = baseUtcOffsetDelta;
            this._noDaylightTransitions = noDaylightTransitions;
        }


        // IEquatable<AdjustmentRule>
        public Equals(other: AdjustmentRule): boolean {
            let equals: boolean = ((other != null)
                && ((this._dateStart == other._dateStart)
                    && ((this._dateEnd == other._dateEnd)
                        && ((this._daylightDelta == other._daylightDelta)
                            && (this._baseUtcOffsetDelta == other._baseUtcOffsetDelta)))));
            equals = (equals
                && (this._daylightTransitionEnd.Equals(other._daylightTransitionEnd) && this._daylightTransitionStart.Equals(other._daylightTransitionStart)));
            return equals;
        }



        // public /* override */ GetHashCode(): number {
        //     return this._dateStart.GetHashCode();
        // }


        static CreateAdjustmentRule(
            dateStart: DateTime,
            dateEnd: DateTime,
            daylightDelta: TimeSpan,
            daylightTransitionStart: TransitionTime,
            daylightTransitionEnd: TransitionTime): AdjustmentRule;
        /** @internal */
        static CreateAdjustmentRule(
            dateStart: DateTime,
            dateEnd: DateTime,
            daylightDelta: TimeSpan,
            daylightTransitionStart: TransitionTime,
            daylightTransitionEnd: TransitionTime,
            baseUtcOffsetDelta: TimeSpan,
            noDaylightTransitions: boolean): AdjustmentRule;
        static CreateAdjustmentRule(
            dateStart: DateTime,
            dateEnd: DateTime,
            daylightDelta: TimeSpan,
            daylightTransitionStart: TransitionTime,
            daylightTransitionEnd: TransitionTime,
            baseUtcOffsetDelta: TimeSpan = TimeSpan.Zero,
            noDaylightTransitions: boolean = false): AdjustmentRule {
            return new AdjustmentRule(
                dateStart,
                dateEnd,
                daylightDelta,
                daylightTransitionStart,
                daylightTransitionEnd,
                baseUtcOffsetDelta,
                noDaylightTransitions);
        }


        // ----- SECTION: internal utility methods ----------------*

        //
        // When Windows sets the daylight transition start Jan 1st at 12:00 AM, it means the year starts with the daylight saving on. 
        // We have to special case this value and not adjust it when checking if any date is in the daylight saving period. 
        //
        /** @internal */
        IsStartDateMarkerForBeginningOfYear(): boolean {
            return !this.NoDaylightTransitions &&
                this.DaylightTransitionStart.Month == 1 && this.DaylightTransitionStart.Day == 1 && this.DaylightTransitionStart.TimeOfDay.Hour == 0 &&
                this.DaylightTransitionStart.TimeOfDay.Minute == 0 && this.DaylightTransitionStart.TimeOfDay.Second == 0 &&
                this._dateStart.Year == this._dateEnd.Year;
        }

        //
        // When Windows sets the daylight transition end Jan 1st at 12:00 AM, it means the year ends with the daylight saving on. 
        // We have to special case this value and not adjust it when checking if any date is in the daylight saving period. 
        //
        /** @internal */
        IsEndDateMarkerForEndOfYear(): boolean {
            return !this.NoDaylightTransitions &&
                this.DaylightTransitionEnd.Month == 1 && this.DaylightTransitionEnd.Day == 1 && this.DaylightTransitionEnd.TimeOfDay.Hour == 0 &&
                this.DaylightTransitionEnd.TimeOfDay.Minute == 0 && this.DaylightTransitionEnd.TimeOfDay.Second == 0 &&
                this._dateStart.Year == this._dateEnd.Year;
        }

        //
        // ValidateAdjustmentRule -
        //
        // Helper function that performs all of the validation checks for the 
        // factory methods and deserialization callback
        //
        private static ValidateAdjustmentRule(
            dateStart: DateTime,
            dateEnd: DateTime,
            daylightDelta: TimeSpan,
            daylightTransitionStart: TransitionTime,
            daylightTransitionEnd: TransitionTime,
            noDaylightTransitions: boolean): void {

            if (dateStart.Kind != DateTimeKind.Unspecified && dateStart.Kind != DateTimeKind.Utc) {
                throw new ArgumentException("Argument_DateTimeKindMustBeUnspecifiedOrUtc", "dateStart");
            }

            if (dateEnd.Kind != DateTimeKind.Unspecified && dateEnd.Kind != DateTimeKind.Utc) {
                throw new ArgumentException("Argument_DateTimeKindMustBeUnspecifiedOrUtc", "dateEnd");
            }

            if (daylightTransitionStart.Equals(daylightTransitionEnd) && !noDaylightTransitions) {
                throw new ArgumentException("Argument_TransitionTimesAreIdentical", "daylightTransitionEnd");
            }

            if (dateStart > dateEnd) {
                throw new ArgumentException("Argument_OutOfOrderDateTimes", "dateStart");
            }

            // This cannot use UtcOffsetOutOfRange to account for the scenario where Samoa moved across the International Date Line,
            // which caused their current BaseUtcOffset to be +13. But on the other side of the line it was UTC-11 (+1 for daylight).
            // So when trying to describe DaylightDeltas for those times, the DaylightDelta needs
            // to be -23 (what it takes to go from UTC+13 to UTC-10)
            if (daylightDelta.TotalHours < -23.0 || daylightDelta.TotalHours > 14.0) {
                throw new ArgumentOutOfRangeException("daylightDelta", daylightDelta, "ArgumentOutOfRange_UtcOffset");
            }

            if (daylightDelta.TotalMilliseconds % TimeSpan.MillisPerMinute != 0) {
                throw new ArgumentException("Argument_TimeSpanHasSeconds", "daylightDelta");
            }

            if (dateStart.TotalMilliSeconds != DateTime.MinValue.TotalMilliSeconds && dateStart.Kind == DateTimeKind.Unspecified && dateStart.TimeOfDay.TotalMilliseconds != TimeSpan.Zero.TotalMilliseconds) {
                throw new ArgumentException("Argument_DateTimeHasTimeOfDay", "dateStart");
            }

            if (dateEnd.TotalMilliSeconds != DateTime.MaxValue.TotalMilliSeconds && dateEnd.Kind == DateTimeKind.Unspecified && dateEnd.TimeOfDay.TotalMilliseconds != TimeSpan.Zero.TotalMilliseconds) {
                throw new ArgumentException("Argument_DateTimeHasTimeOfDay", "dateEnd");
            }
        }
    }


    export class TransitionTime {

        private readonly _timeOfDay: DateTime;
        private readonly _month: number; //byte
        private readonly _week: number; //byte
        private readonly _day: number; //byte
        private readonly _dayOfWeek: DayOfWeek;
        private readonly _isFixedDateRule: boolean;

        public get TimeOfDay(): DateTime {
            return this._timeOfDay;
        }

        public get Month(): number {
            return this._month;
        }

        public get Week(): number {
            return this._week;
        }

        public get Day(): number {
            return this._day;
        }

        public get DayOfWeek(): DayOfWeek {
            return this._dayOfWeek;
        }

        public get IsFixedDateRule(): boolean {
            return this._isFixedDateRule;
        }

        // [Pure]

        // public override bool Equals(object obj) =>
        // obj is TransitionTime && Equals((TransitionTime)obj);

        // public static bool operator == (TransitionTime t1, TransitionTime t2) => t1.Equals(t2);

        // public static bool operator != (TransitionTime t1, TransitionTime t2) => !t1.Equals(t2);

        public Equals(other: TransitionTime): boolean {
            return
            this._isFixedDateRule == other._isFixedDateRule &&
                this._timeOfDay == other._timeOfDay &&
                this._month == other._month &&
                (other._isFixedDateRule ?
                    this._day == other._day :
                    this._week == other._week &&
                    this._dayOfWeek == other._dayOfWeek);
        }

        public GetHashCode(): number {
            return (this._month ^ this._week << 8)
        };

        private constructor(timeOfDay: DateTime, month: number, week: number, day: number, dayOfWeek: DayOfWeek, isFixedDateRule: boolean) {
            TransitionTime.ValidateTransitionTime(timeOfDay, month, week, day, dayOfWeek);

            this._timeOfDay = timeOfDay;
            this._month = month;
            this._week = week;
            this._day = day;
            this._dayOfWeek = dayOfWeek;
            this._isFixedDateRule = isFixedDateRule;
        }

        public static CreateFixedDateRule(timeOfDay: DateTime, month: number, day: number): TransitionTime {

            return new TransitionTime(timeOfDay, month, 1, day, DayOfWeek.Sunday, true);
        }

        public static CreateFloatingDateRule(timeOfDay: DateTime, month: number, week: number, dayOfWeek: DayOfWeek): TransitionTime {

            return new TransitionTime(timeOfDay, month, week, 1, dayOfWeek, false);
        }

        /// <summary>
        /// Helper function that validates a TransitionTime instance.
        /// </summary>
        private static ValidateTransitionTime(timeOfDay: DateTime, month: number, week: number, day: number, dayOfWeek: DayOfWeek): void {
            if (timeOfDay.Kind != DateTimeKind.Unspecified) {
                throw new ArgumentException("Argument_DateTimeKindMustBeUnspecified", "timeOfDay");
            }

            // Month range 1-12
            if (month < 1 || month > 12) {
                throw new ArgumentOutOfRangeException("month", "ArgumentOutOfRange_MonthParam");
            }

            // Day range 1-31
            if (day < 1 || day > 31) {
                throw new ArgumentOutOfRangeException("day", "ArgumentOutOfRange_DayParam");
            }

            // Week range 1-5
            if (week < 1 || week > 5) {
                throw new ArgumentOutOfRangeException("week", "ArgumentOutOfRange_Week");
            }

            // DayOfWeek range 0-6
            if (dayOfWeek < 0 || dayOfWeek > 6) {
                throw new ArgumentOutOfRangeException("dayOfWeek", "ArgumentOutOfRange_DayOfWeek");
            }

            if (timeOfDay.Year != 1 || timeOfDay.Month != 1 || timeOfDay.Day != 1 || (timeOfDay.TotalMilliSeconds % 1 != 0)) {
                throw new ArgumentException("Argument_DateTimeHasTicks", "timeOfDay");
            }
        }
    }

}
			
export interface ICalendarActionProvider {
	Accept(sendResponse: boolean): Promise<CalendarActionResults>;
	AcceptTentatively(sendResponse: boolean): Promise<CalendarActionResults>;
	CreateAcceptMessage(tentative: boolean): AcceptMeetingInvitationMessage;
	CreateDeclineMessage(): DeclineMeetingInvitationMessage;
	Decline(sendResponse: boolean): Promise<CalendarActionResults>;
}
export interface ICustomUpdateSerializer {
    //WriteDeleteUpdateToJson(service: ExchangeService, ewsObject: ServiceObject, updates: /*System.Collections.Generic.List<T>*/any): boolean;
    /** @internal */
    WriteDeleteUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject): boolean;
    //WriteSetUpdateToJson(service: ExchangeService, ewsObject: ServiceObject, propertyDefinition: PropertyDefinition, updates: /*System.Collections.Generic.List<T>*/any): boolean;
    /** @internal */
    WriteSetUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject, propertyDefinition: PropertyDefinition): boolean;
}
export interface IEnumerable<T> {
	GetEnumerator(): Array<T>
}
			
 export interface IEwsHttpWebRequest {
	Accept: string;
	AllowAutoRedirect: boolean;
	ClientCertificates: any /*System.Security.Cryptography.X509Certificates.X509CertificateCollection*/;
	ContentType: string;
	CookieContainer: any /*System.Net.CookieContainer*/;
	Credentials: any /*System.Net.ICredentials*/;
	Headers: any /*System.Net.WebHeaderCollection*/;
	Method: string;
	PreAuthenticate: boolean;
	Proxy: any /*System.Net.IWebProxy*/;
	RequestUri: string /*Uri*/;
	Timeout: number;
	UseDefaultCredentials: boolean;
	UserAgent: string;
	KeepAlive: boolean;
	ConnectionGroupName: string;
	Abort(): void;
	BeginGetRequestStream(callback: any /*System.AsyncCallback*/, state: any): any /*System.IAsyncResult*/;
	BeginGetResponse(callback: any /*System.AsyncCallback*/, state: any): any /*System.IAsyncResult*/;
	EndGetRequestStream(asyncResult: any /*System.IAsyncResult*/): any /*System.IO.Stream*/;
	EndGetResponse(asyncResult: any /*System.IAsyncResult*/): IEwsHttpWebResponse;
	GetRequestStream(): any /*System.IO.Stream*/;
	GetResponse(): IEwsHttpWebResponse;
}






			


export interface IEwsHttpWebRequestFactory {
    CreateExceptionResponse(exception: any /*System.Net.WebException*/): IEwsHttpWebResponse;
    CreateRequest(uri: string /*Uri*/): IEwsHttpWebRequest;
}






			

			
 export interface IEwsHttpWebResponse {
	ContentEncoding: string;
	ContentType: string;
	Headers: any /*System.Net.WebHeaderCollection*/;
	ResponseUri: string /*Uri*/;
	StatusCode: any /*System.Net.HttpStatusCode*/;
	StatusDescription: string;
	ProtocolVersion: any /*System.Version*/;
	Close(): void;
	GetResponseStream(): any /*System.IO.Stream*/;
}






			
			
 export interface IFileAttachmentContentHandler {
	GetOutputStream(attachmentId: string): any /*System.IO.Stream*/;
}






			
			
 export interface IJsonCollectionDeserializer {
	CreateFromJsonCollection(jsonCollection: any[], service: ExchangeService): void;
	UpdateFromJsonCollection(jsonCollection: any[], service: ExchangeService): void;
}






			


export interface IJsonSerializable {
    ToJson(service: ExchangeService): any;
}








export interface IOutParam<T> {
    outValue: T;
    exception?: any;
    success?: boolean;
}
export interface IOwnedProperty {
    Owner: ServiceObject;
}







export interface IRefParam<T> {
    getValue: () => T;
    //refGet:()=>T;
    setValue?: (value: T) => void;
}

			
 export interface ISearchStringProvider {
	GetSearchString(): string;
}






			
export interface ISelfValidate {
    Validate(): any;
}
			
 export interface ITraceListener {
	Trace(traceType: string, traceMessage: string): void;
}






			

export interface HasEwsEnumAttribute {
    FromEwsEnumString(value: string): any
    ToEwsEnumString(value: any): string;
}

export interface HasRequiredServerVersionAttribute {
    RequiredServerVersion(value: WellKnownFolderName): ExchangeVersion
}

/** @internal */
export module TypeGuards {

    /**
     * check if the object implements EwsEnumInterface interface
     */
    export function hasEwsEnumAttribute(arg: any): arg is HasEwsEnumAttribute {
        return arg && typeof arg.FromEwsEnumString === 'function' && typeof arg.ToEwsEnumString === 'function';
    }

    /**
     * check if the object implements EwsEnumInterface interface
     */
    export function hasRequiredServerVersionAttribute(arg: any): arg is HasRequiredServerVersionAttribute {
        return arg && typeof arg.RequiredServerVersion === 'function';
    }

    /**
     * check if the object implements ICalendarActionProvider interface
     */
    export function isICalendarActionProvider(arg: any): arg is ICalendarActionProvider {
        return arg && typeof arg.Accept === 'function' && typeof arg.CreateDeclineMessage === 'function';
    }

    /**
     * check if the object implements ICustomUpdateSerializer interface
     */
    export function isICustomUpdateSerializer(arg: any): arg is ICustomUpdateSerializer {
        return arg && typeof arg.WriteSetUpdateToXml === 'function' && typeof arg.WriteDeleteUpdateToXml === 'function';
    }

    /**
     * check if the object implements IFileAttachmentContentHandler interface
     */
    export function isIFileAttachmentContentHandler(arg: any): arg is IFileAttachmentContentHandler {
        return arg && typeof arg.GetOutputStream === 'function';
    }

    /**
     * check if the object implements IOwnedProperty interface
     */
    export function isIOwnedProperty(arg: any): arg is IOwnedProperty {
        return arg && typeof arg.Owner === 'object';
    }

    /**
     * check if the object implements ISearchStringProvider interface
     */
    export function isISearchStringProvider(arg: any): arg is ISearchStringProvider {
        return arg && typeof arg.GetSearchString === 'function';
    }

    /**
     * check if the object implements ISelfValidate interface
     */
    export function isISelfValidate(arg: any): arg is ISelfValidate {
        return arg && typeof arg.Validate === 'function';
    }

    /**
     * check if the object implements ITraceListener interface
     */
    export function isITraceListener(arg: any): arg is ITraceListener {
        return arg && typeof arg.Trace === 'function';
    }

    /** Not yet Used */
    // export function isIEwsHttpWebRequest(arg: IEwsHttpWebRequest): arg is IEwsHttpWebRequest {
    //     return arg && typeof arg === 'function';
    // }

    // export function isIEwsHttpWebRequestFactory(arg: IEwsHttpWebRequestFactory): arg is IEwsHttpWebRequestFactory {
    //     return arg && typeof arg === 'function';
    // }

    // export function isIEwsHttpWebResponse(arg: IEwsHttpWebResponse): arg is IEwsHttpWebResponse {
    //     return arg && typeof arg === 'function';
    // }

    // export function isIJsonCollectionDeserializer(arg: IJsonCollectionDeserializer): arg is IJsonCollectionDeserializer {
    //     return arg && typeof arg.CreateFromJsonCollection === 'function' && typeof arg.UpdateFromJsonCollection === 'function';
    // }

    // export function isIJsonSerializable(arg: IJsonSerializable): arg is IJsonSerializable {
    //     return arg && typeof arg.ToJson === 'function';
    // }
}
// import 'reflect-metadata';
// export var AttachableAttributeMetadata = "AttachableAttribute";
// export function AttachableAttribute(value: boolean = false) {
//     return function(target: Function) {
//         Reflect.defineMetadata("AttachableAttribute", value, target.prototype);
//     }
// }
// import 'reflect-metadata';
// export function EwsEnumAttribute(schemaName: string) {
//     return function(target: Function) {
//         Reflect.defineMetadata("EwsEnumAttribute", schemaName, target);
//     }
// }
// import 'reflect-metadata';
// export function RequiredServerVersionAttribute(version: ExchangeVersion) {
//     return function(target: Function) {
//         Reflect.defineMetadata("AttachableAttribute", version, target);
//     }
// }
//			
// class SchemaAttribute extends System.Attribute {
//}
//export = SchemaAttribute;


//------------modulename->Microsoft.Exchange.WebServices.Data------------


			
//			
// class ServiceObjectDefinitionAttribute extends System.Attribute {
//	XmlElementName: string;
//	ReturnedByServer: boolean;
//	private xmlElementName: string;
//	private returnedByServer: boolean;
//}
//export = ServiceObjectDefinitionAttribute;


//------------modulename->Microsoft.Exchange.WebServices.Data------------


			

/** 
 * Indicates which occurrence of a recurring task should be deleted
 */
export enum AffectedTaskOccurrence {
    
    /** 
     * All occurrences of the recurring task will be deleted.
     */
    AllOccurrences = 0,
    
    /** 
     * Only the current occurrence of the recurring task will be deleted. 
     */
    SpecifiedOccurrenceOnly = 1
}

/** 
 * Defines the type of aggregation to perform.
 */
export enum AggregateType {
    
    /** 
     * The maximum value is calculated. 
     */
    Minimum = 0,
    
    /** 
     * The minimum value is calculated. 
     */
    Maximum = 1
}

/**
 * Defines the type of an appointment.
 */
export enum AppointmentType {
    
    /**
     * The appointment is non-recurring.
     */
    Single = 0,
    
    /**
     * The appointment is an occurrence of a recurring appointment.
     */
    Occurrence = 1,
    
    /**
     * The appointment is an exception of a recurring appointment.
     */
    Exception = 2,
    
    /**
     * The appointment is the recurring master of a series.
     */
    RecurringMaster = 3
}

/**
 * @internal Defines the types of Autodiscover endpoints that are available.
 * 
 * [Flags]
 */
export enum AutodiscoverEndpoints {

    /**
     * No endpoints available.
     */
    None = 0,
    
    /**
     * The "legacy" Autodiscover endpoint.
     */
    Legacy = 1,
    
    /**
     * The SOAP endpoint.
     */
    Soap = 2,
    
    /**
     * The WS-Security endpoint.
     */
    WsSecurity = 4,
    
    /**
     * The WS-Security/SymmetricKey endpoint.
     */
    WSSecuritySymmetricKey = 8,
    
    /**
     * The WS-Security/X509Cert endpoint.
     */
    WSSecurityX509Cert = 16,
    
    /**
     * The OAuth endpoint
     */
    OAuth = 32
}

/**
 * Defines the error codes that can be returned by the Autodiscover service.
 */
export enum AutodiscoverErrorCode {
  
  /**
   * There was no Error.
   */
  NoError = 0,
  
  /**
   * The caller must follow the e-mail address redirection that was returned by Autodiscover.
   */
  RedirectAddress = 1,
  
  /**
   * The caller must follow the URL redirection that was returned by Autodiscover.
   */
  RedirectUrl = 2,
  
  /**
   * The user that was passed in the request is invalid.
   */
  InvalidUser = 3,
  
  /**
   * The request is invalid.
   */
  InvalidRequest = 4,
  
  /**
   * A specified setting is invalid.
   */
  InvalidSetting = 5,
  
  /**
   * A specified setting is not available.
   */
  SettingIsNotAvailable = 6,
  
  /**
   * The server is too busy to process the request.
   */
  ServerBusy = 7,
  
  /**
   * The requested domain is not valid.
   */
  InvalidDomain = 8,
  
  /**
   * The organization is not federated.
   */
  NotFederated = 9,
  
  /**
   * Internal server error.
   */
  InternalServerError = 10
}

/**
 * @internal Defines the types of response the Autodiscover service can return.
 */
export enum AutodiscoverResponseType {
  
  /**
   * The request returned an error.
   */
  Error = 0,
  
  /**
   * A URL redirection is necessary.
   */
  RedirectUrl = 1,
  
  /**
   * An address redirection is necessary.
   */
  RedirectAddress = 2,
  
  /**
   * The request succeeded.
   */
  Success = 3
}

/**
 * Defines the type of data that can be requested via GetUserAvailability.
 */
export enum AvailabilityData {
    
    /**
     * Only return free/busy data.
     */
    FreeBusy = 0,
    
    /**
     * Only return suggestions.
     */
    Suggestions = 1,
    
    /**
     * Return both free/busy data and suggestions.
     */
    FreeBusyAndSuggestions = 2
}

/**
 * Defines base property sets that are used as the base for custom property sets.
 */
export enum BasePropertySet {
  
  /**
   * Only includes the Id of items and folders.
   */
  IdOnly = 0,
  
  /**
   * Includes all the first class properties of items and folders.
   */
  FirstClassProperties = 1
}

/**
 * Defines the type of body of an item.
 */
export enum BodyType {
  
  /**
   * The body is formatted in HTML.
   */
  HTML = 0,
  
  /**
   * The body is in plain text.
   */
  Text = 1
}

/**
 * Defines the type of change of a synchronization event.
 */
export enum ChangeType {
    
    /**
     * An item or folder was created.
     */
    Create = 0,
    
    /**
     * An item or folder was modified.
     */
    Update = 1,
    
    /**
     * An item or folder was deleted.
     */
    Delete = 2,
    
    /**
     * An item's IsRead flag was changed.
     */
    ReadFlagChange = 3
}

/**
 * Defines the type of ClientAccessTokenType
 */
export enum ClientAccessTokenType {

    /**
     * CallerIdentity
     */
    CallerIdentity = 0,

    /**
     * ExtensionCallback.
     */
    ExtensionCallback = 1,

    /**
     * ScopedToken
     */
    ScopedToken = 2
}

/**
 * Defines the type of ClientExtensionProvidedTo.
 */
export enum ClientExtensionProvidedTo {

    /**
     * Everyone
     */
    Everyone = 0,

    /**
     * SpecificUsers
     */
    SpecificUsers = 1
}

/**
 * Defines the way values are compared in search filters.
 */
export enum ComparisonMode {

    /**
     * The comparison is exact.
     */
    Exact = 0,

    /**
     * The comparison ignores casing.
     */
    IgnoreCase = 1,

    /**
     * The comparison ignores spacing characters.
     */
    IgnoreNonSpacingCharacters = 2,

    /**
     * The comparison ignores casing and spacing characters.
     */
    IgnoreCaseAndNonSpacingCharacters = 3

    // Although the following four values are defined in the EWS schema, they are useless
    // as they are all technically equivalent to Loose. We are not exposing those values
    // in this API. When we encounter one of these values on an existing search folder
    // restriction, we map it to IgnoreCaseAndNonSpacingCharacters.
    //
    // Loose,
    // LooseAndIgnoreCase,
    // LooseAndIgnoreNonSpace,
    // LooseAndIgnoreCaseAndIgnoreNonSpace
}

/**
 * Defines how conflict resolutions are handled in update operations.
 */
export enum ConflictResolutionMode {
    
    /**
     * Local property changes are discarded.
     */
    NeverOverwrite = 0,
    
    /**
     * Local property changes are applied to the server unless the server-side copy is more recent than the local copy.
     */
    AutoResolve = 1,
    
    /**
     * Local property changes overwrite server-side changes. 
     */
    AlwaysOverwrite = 2
}

/**
 * Defines the conflict types that can be returned in meeting time suggestions.
 */
export enum ConflictType {
    
    /**
     * There is a conflict with an indicidual attendee.
     */
    IndividualAttendeeConflict = 0,
    
    /**
     * There is a conflict with at least one member of a group.
     */
    GroupConflict = 1,
    
    /**
     * There is a conflict with at least one member of a group, but the group was too big for detailed information to be returned.
     */
    GroupTooBigConflict = 2,
    
    /**
     * There is a conflict with an unresolvable attendee or an attendee that is not a user, group, or contact.
     */
    UnknownAttendeeConflict = 3
}

/**
 * Defines the type of Id of a ConnectingId object.
 */
export enum ConnectingIdType {

    /**
     * The connecting Id is a principal name.
     */
    PrincipalName = 0,

    /**
     * The Id is an SID.
     */
    SID = 1,

    /**
     * The Id is an SMTP address.
     */
    SmtpAddress = 2
}

/**
 * The ConnectionFailureCause enumeration
 */
export enum ConnectionFailureCause {

    /**
     * None
     */
    None = 0,

    /**
     * UserBusy
     */
    UserBusy = 1,

    /**
     * NoAnswer
     */
    NoAnswer = 2,

    /**
     * Unavailable
     */
    Unavailable = 3,

    /**
     * Other
     */
    Other = 4
}
//D:\dr\gh\ews-javascript-api_ForNewFeatures\build\temp\src\js\Enumerations\ConnectionStatus.ts

/**
 * The consent states enumeration
 */
export enum ConsentState {

    /**
     * User has closed the consent page or has not responded yet.
     */
    NotResponded = 0,


    /**
     * User has requested to disable the extension.
     */
    NotConsented = 1,


    /**
     * User has requested to enable the extension.
     */
    Consented = 2
}

/**
 * Defines the source of a contact or group.
 */
export enum ContactSource {

    /**
     * The contact or group is stored in the Global Address List
     */
    ActiveDirectory = 0,

    /**
     * The contact or group is stored in Exchange.
     */
    Store = 1
}

/**
 * Defines the containment mode for Contains search filters.
 */
export enum ContainmentMode {
    
    /**
     * The comparison is between the full string and the constant. The property value and the supplied constant are precisely the same.
     */
    FullString = 0,
    
    /**
     * The comparison is between the string prefix and the constant.
     */
    Prefixed = 1,
    
    /**
     * The comparison is between a substring of the string and the constant.
     */
    Substring = 2,
    
    /**
     * The comparison is between a prefix on individual words in the string and the constant.
     */
    PrefixOnWords = 3,
    
    /**
     * The comparison is between an exact phrase in the string and the constant.
     */
    ExactPhrase = 4
}


/**
 * @internal Defines actions applicable to Conversation.
 */
export enum ConversationActionType {
    
    /**
     * Categorizes every current and future message in the conversation
     */
    AlwaysCategorize = 0,
    
    /**
     * Deletes every current and future message in the conversation
     */
    AlwaysDelete = 1,
    
    /**
     * Moves every current and future message in the conversation
     */
    AlwaysMove = 2,
    
    /**
     * Deletes current item in context folder in the conversation
     */
    Delete = 3,
    
    /**
     * Moves current item in context folder in the conversation
     */
    Move = 4,
    
    /**
     * Copies current item in context folder in the conversation
     */
    Copy = 5,
    
    /**
     * Marks current item in context folder in the conversation with provided read state
     */
    SetReadState = 6,
    
    /**
     * Set retention policy.
     */
    SetRetentionPolicy = 7,
    
    /**
     * Flag current items in context folder in the conversation with provided flag state.
     */
    Flag = 8
}

/**
 * Defines the flag status of a Conversation.
 */
export enum ConversationFlagStatus {
    
    /**
     * Not Flagged
     */
    NotFlagged = 0,
    
    /**
     * Flagged
     */
    Flagged = 1,
    
    /**
     * Complete
     */
    Complete = 2
}

/**
 * Defines the folder traversal depth in queries.
 */
export enum ConversationQueryTraversal {

    /**
     * Shallow traversal
     */
    Shallow = 0,

    /**
     * Deep traversal
     */
    Deep = 1
}

export module ConversationQueryTraversal {
    
    /**RequiredServerVersionAttribute */
    export function RequiredServerVersion(value: ConversationQueryTraversal): ExchangeVersion {
        if (value <= 1) //<= ConversationQueryTraversal.Deep
            return ExchangeVersion.Exchange2013;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
}

/**
 * Defines the order in which conversation nodes should be returned by GetConversationItems.
 */
export enum ConversationSortOrder {
    
    /**
     * Tree order, ascending
     */
    TreeOrderAscending = 0,
    
    /**
     * Tree order, descending.
     */
    TreeOrderDescending = 1,
    
    /**
     * Chronological order, ascending.
     */
    DateOrderAscending = 2,
    
    /**
     * Chronological order, descending.
     */
    DateOrderDescending = 3
}

/**
 * Defines the precision for returned DateTime values
 */
export enum DateTimePrecision {
    
    /**
     * Default value.  No SOAP header emitted.
     */
    Default = 0,
    
    /**
     * Seconds
     */
    Seconds = 1,
    
    /**
     * Milliseconds
     */
    Milliseconds = 2
}

/**
 * Specifies the day of the week.
 * 
 * /remarks/    For the standard days of the week (Sunday, Monday...) the DayOfTheWeek enum value is the same as the System.DayOfWeek enum type. 
 * These values can be safely cast between the two enum types. The special days of the week (Day, Weekday and WeekendDay) are used for monthly and yearly recurrences and cannot be cast to System.DayOfWeek values.
 */
export enum DayOfTheWeek {
    
    /**
     * Sunday
     */
    Sunday = 0,
    
    /**
     * Monday
     */
    Monday = 1,
    
    /**
     * Tuesday
     */
    Tuesday = 2,
    
    /**
     * Wednesday
     */
    Wednesday = 3,
    
    /**
     * Thursday
     */
    Thursday = 4,
    
    /**
     * Friday
     */
    Friday = 5,
    
    /**
     * Saturday
     */
    Saturday = 6,
    
    /**
     * Any day of the week
     */
    Day = 7,
    
    /**
     * Any day of the usual business week (Monday-Friday)
     */
    Weekday = 8,
    
    /**
     * Any weekend day (Saturday or Sunday)
     */
    WeekendDay = 9
}

/**
 * Defines the index of a week day within a month.
 */
export enum DayOfTheWeekIndex {
    
    /**
     * The first specific day of the week in the month. For example, the first Tuesday of the month. 
     */
    First = 0,
    
    /**
     * The second specific day of the week in the month. For example, the second Tuesday of the month.
     */
    Second = 1,
    
    /**
     * The third specific day of the week in the month. For example, the third Tuesday of the month.
     */
    Third = 2,
    
    /**
     * The fourth specific day of the week in the month. For example, the fourth Tuesday of the month.
     */
    Fourth = 3,
    
    /**
     * The last specific day of the week in the month. For example, the last Tuesday of the month.
     */
    Last = 4
}
/**
 * Enum for the day of the week. 
 * System.DayOfWeek
 */
export enum DayOfWeek {
    
    /**
     * Sunday
     */
    Sunday = 0,
    
    /**
     * Monday
     */
    Monday = 1,
    
    /**
     * Tuesday
     */
    Tuesday = 2,
    
    /**
     * Wednesday
     */
    Wednesday = 3,
    
    /**
     * Thursday
     */
    Thursday = 4,
    
    /**
     * Friday
     */
    Friday = 5,
    
    /**
     * Saturday
     */
    Saturday = 6,
}

/**
 * Defines the default sets of extended properties.
 */
export enum DefaultExtendedPropertySet {
    
    /**
     * The Meeting extended property set.
     */
    Meeting = 0,
    
    /**
     * The Appointment extended property set.
     */
    Appointment = 1,
    
    /**
     * The Common extended property set.
     */
    Common = 2,
    
    /**
     * The PublicStrings extended property set.
     */
    PublicStrings = 3,
    
    /**
     * The Address extended property set.
     */
    Address = 4,
    
    /**
     * The InternetHeaders extended property set.
     */
    InternetHeaders = 5,
    
    /**
     * The CalendarAssistant extended property set.
     */
    CalendarAssistant = 6,
    
    /**
     * The UnifiedMessaging extended property set.
     */
    UnifiedMessaging = 7,
    
    /**
     * The Task extended property set.
     */
    Task = 8
}

/**
 * 
 */
export enum DelegateFolderPermissionLevel {

    /**
     * The delegate has no permissions.
     */
    None = 0,

    /**
     * The delegate has Editor permissions.
     */
    Editor = 1,

    /**
     * The delegate has Reviewer permissions.
     */
    Reviewer = 2,

    /**
     * The delegate has Author permissions.
     */
    Author = 3,

    /**
     * The delegate has Custom permissions.
     */
    Custom = 4
}

/**
 * Represents deletion modes.
 */
export enum DeleteMode {
    
    /**
     * The item or folder will be permanently deleted.
     */
    HardDelete = 0,
    
    /**
     * The item or folder will be moved to the dumpster. Items and folders in the dumpster can be recovered.
     */
    SoftDelete = 1,
    
    /**
     * The item or folder will be moved to the mailbox' Deleted Items folder.
     */
    MoveToDeletedItems = 2
}
export enum DictionaryKeyType{
	EmailAddressKey,
	ImAddressKey,
	PhoneNumberKey,
	PhysicalAddressKey
}

/**
 * Disable reason type
 */
export enum DisableReasonType {
    /**
     * Extension is being disabled with no reason
     */
    NoReason = 0,
    /**
     * Extension is being disabled from Outlook due to performance reasons
     */
    OutlookClientPerformance = 1,
    /**
     * Extension is being disabled from OWA due to performance reasons
     */
    OWAClientPerformance = 2,
    /**
     * Extension is being disabled from MOWA due to performance reasons
     */
    MobileClientPerformance = 3
}
// //todo - move to file where class Microsoft.Exchange.WebServices.Dns.DnsNativeMethods is located
// module Microsoft.Exchange.WebServices.Dns.DnsNativeMethods {
//     export enum DnsQueryOptions {
//         DNS_QUERY_STANDARD = 0
//     }
// }


/**
 * @internal DNS record types.
 */
export enum DnsRecordType {
    
    /**
     * RFC 1034/1035 Address Record
     */
    A = 0x0001,//1
    
    /**
     * Canonical Name Record
     */
    CNAME = 0x0005,//5
    
    /**
     * Start of Authority Record
     */
    SOA = 0x0006,//6
    
    /**
     * Pointer Record
     */
    PTR = 0x000c,//12
    
    /**
     * Mail Exchange Record
     */
    MX = 0x000f,//15
    
    /**
     * Text Record
     */
    TXT = 0x0010,//16,
    
    /**
     * RFC 1886 (IPv6 Address)
     */
    AAAA = 0x001c,//28,
    
    /**
     * Service location - RFC 2052
     */
    SRV = 0x0021,//33
}

/**
 * Domain setting names.
 */
export enum DomainSettingName {
    
    /**
     * The external URL of the Exchange Web Services.
     */
    ExternalEwsUrl = 0,
    
    /**
     * The version of the Exchange server hosting the URL of the Exchange Web Services.
     */
    ExternalEwsVersion = 1
}

/**
 * Defines the effective user rights associated with an item or folder.
 * 
 * [Flags]
 */
export enum EffectiveRights {
    
    /**
     * The user has no acces right on the item or folder.
     */
    None = 0,
    
    /**
     * The user can create associated items (FAI)
     */
    CreateAssociated = 1,
    
    /**
     * The user can create items.
     */
    CreateContents = 2,
    
    /**
     * The user can create sub-folders.
     */
    CreateHierarchy = 4,
    
    /**
     * The user can delete items and/or folders.
     */
    Delete = 8,
    
    /**
     * The user can modify the properties of items and/or folders.
     */
    Modify = 16,
    
    /**
     * The user can read the contents of items.
     */
    Read = 32,
    
    /**
     * The user can view private items.
     */
    ViewPrivateItems = 64
}

/**
 * Defines the folder type of a retention policy tag.
 */
export enum ElcFolderType {

    /**
     * Calendar folder.
     */
    Calendar = 1,

    /**
     * Contacts folder.
     */
    Contacts = 2,

    /**
     * Deleted Items.
     */
    DeletedItems = 3,

    /**
     * Drafts folder.
     */
    Drafts = 4,

    /**
     * Inbox.
     */
    Inbox = 5,

    /**
     * Junk mail
     */
    JunkEmail = 6,

    /**
     * Journal.
     */
    Journal = 7,

    /**
     * Notes.
     */
    Notes = 8,

    /**
     * Outbox.
     */
    Outbox = 9,

    /**
     * Sent Items.
     */
    SentItems = 10,

    /**
     * Tasks folder.
     */
    Tasks = 11,

    /**
     * Policy applies to all folders that do not have a policy.
     */
    All = 12,

    /**
     * Policy is for an organizational policy.
     */
    ManagedCustomFolder = 13,

    /**
     * Policy is for the RSS Subscription (default) folder.
     */
    RssSubscriptions = 14,

    /**
     * Policy is for the Sync Issues (default) folder.
     */
    SyncIssues = 15,

    /**
     * Policy is for the Conversation History (default) folder.
     * This folder is used by the Office Communicator to archive IM conversations.
     */
    ConversationHistory = 16,

    /**
     * Policy is for the personal folders.
     */
    Personal = 17,

    /**
     * Policy is for Dumpster 2.0.
     */
    RecoverableItems = 18,

    /**
     * Non IPM Subtree root.
     */
    NonIpmRoot = 19
}

/**
 * Defines e-mail address entries for a contact.
 */
export enum EmailAddressKey {
    
    /**
     * The first e-mail address.
     */
    EmailAddress1 = 0,
    
    /**
     * The second e-mail address.
     */
    EmailAddress2 = 1,
    
    /**
     * The third e-mail address.
     */
    EmailAddress3 = 2
}

/**
 * Defines the email position of an extracted entity.
 */
export enum EmailPosition {
    
    /**
     * The position is in the latest reply.
     */
    LatestReply = 0,
    
    /**
     * The position is not in the latest reply.
     */
    Other = 1,
    
    /**
     * The position is in the subject.
     */
    Subject = 2,
    
    /**
     * The position is in the signature.
     */
    Signature = 3
}
//D:\dr\gh\ews-javascript-api_ForNewFeatures\build\temp\src\js\Enumerations\EnumToExchangeVersionMappingHelper.ts
/**custom created to simplify creation of above Enum(s) to ExchangeVersion mapping in EwsUtil, There is no c# like Attribute typesystem and reflection available */
export enum EnumToSchemaMappingHelper {
    WellKnownFolderName,
    /**Item Traversal */
    ItemTraversal,
    ConversationQueryTraversal,
    FileAsMapping,
    EventType,
    MeetingRequestsDeliveryScope,
    ViewFilter,
    MailboxType,
}

/**
 * Defines the types of event that can occur in a folder.
 */
export enum EventType {

    /**
     * This event is sent to a client application by push notifications to indicate that the subscription is still alive.
     */
    Status = 0,

    /**
     * This event indicates that a new e-mail message was received.
     */
    NewMail = 1,

    /**
     * This event indicates that an item or folder has been deleted.
     */
    Deleted = 2,

    /**
     * This event indicates that an item or folder has been modified.
     */
    Modified = 3,

    /**
     * This event indicates that an item or folder has been moved to another folder.
     */
    Moved = 4,

    /**
     * This event indicates that an item or folder has been copied to another folder.
     */
    Copied = 5,

    /**
     * This event indicates that a new item or folder has been created.
     */
    Created = 6,

    /**
     * This event indicates that free/busy has changed. This is only supported in 2010 SP1 or later
     */
    FreeBusyChanged = 7
}

export module EventType {

    /**RequiredServerVersionAttribute */
    export function RequiredServerVersion(value: EventType): ExchangeVersion {
        if (value <= 6) //<= EventType.Created
            return ExchangeVersion.Exchange2007_SP1;
        if (value == 7) // == FreeBusyChanged
            return ExchangeVersion.Exchange2010_SP1;

        return ExchangeVersion.Exchange_Version_Not_Updated;
    }

    /**EwsEnumAttribute */
    export function FromEwsEnumString(value: string): EventType {
        return EventType[value.replace("Event", "")];
    }

    /**EwsEnumAttribute */
    export function ToEwsEnumString(value: EventType): string {
        return EventType[value] + "Event";
    }
}

/**
 * Defines the each available Exchange release version
 */
export enum ExchangeVersion {
    /**
     * Microsoft Exchange 2007, Service Pack 1
     */
    Exchange2007_SP1 = 0,
    /**
     * Microsoft Exchange 2010
     */
    Exchange2010 = 1,
    /**
     * Microsoft Exchange 2010, Service Pack 1
     */
    Exchange2010_SP1 = 2,
    /**
     * Microsoft Exchange 2010, Service Pack 2
     */
    Exchange2010_SP2 = 3,
    /**
     * Microsoft Exchange 2013
     */
    Exchange2013 = 4,
    /**
     * Microsoft Exchange 2013 SP1
     */
    Exchange2013_SP1 = 5,
    /**
     * Microsoft Exchange 2015 (aka Exchange 2016)
     */
    Exchange2015 = 6,
    /**
     * Microsoft Exchange 2016
     */
    Exchange2016 = 7,
    /**
     * Functionality starting 10/05/2015
     */
    V2015_10_05 = 8,
    
    /** internal tracking of any version not updated in **ews-javascript-api** */
    Exchange_Version_Not_Updated = 15000,
}

/**
 * Defines the type of ExtensionInstallScope.
 */
export enum ExtensionInstallScope {
    
    /**
     * None
     */
    None = 0,
    
    /**
     * User
     */
    User = 1,
    
    /**
     * Organization
     */
    Organization = 2,
    
    /**
     * Exchange Default
     */
    Default = 3
}

/**
 * Defines the type of ExtensionType.
 */
export enum ExtensionType {
    
    /**
     * Default
     */
    Default = 0,
    
    /**
     * Private
     */
    Private = 1,
    
    /**
     * MarketPlace
     */
    MarketPlace = 2
}

/**
 * Defines the way the FileAs property of a contact is automatically formatted.
 */
export enum FileAsMapping {

    /**
     * No automatic formatting is used.
     */
    None = 0,

    /**
     * Surname, GivenName
     */
    SurnameCommaGivenName = 1,

    /**
     * GivenName Surname
     */
    GivenNameSpaceSurname = 2,

    /**
     * Company
     */
    Company = 3,

    /**
     * Surname, GivenName (Company)
     */
    SurnameCommaGivenNameCompany = 4,

    /**
     * Company (SurnameGivenName)
     */
    CompanySurnameGivenName = 5,

    /**
     * SurnameGivenName
     */
    SurnameGivenName = 6,

    /**
     * SurnameGivenName (Company)
     */
    SurnameGivenNameCompany = 7,

    /**
     * Company (Surname, GivenName)
     */
    CompanySurnameCommaGivenName = 8,

    /**
     * SurnameGivenName Suffix
     */
    SurnameGivenNameSuffix = 9,

    /**
     * Surname GivenName (Company)
     */
    SurnameSpaceGivenNameCompany = 10,

    /**
     * Company (Surname GivenName)
     */
    CompanySurnameSpaceGivenName = 11,

    /**
     * Surname GivenName
     */
    SurnameSpaceGivenName = 12,

    /**
     * Display Name (Exchange 2010 or later).
     */
    DisplayName = 13,

    /**
     * GivenName (Exchange 2010 or later).
     */
    GivenName = 14,

    /**
     * Surname GivenName Middle Suffix (Exchange 2010 or later).
     */
    SurnameGivenNameMiddleSuffix = 15,

    /**
     * Surname (Exchange 2010 or later).
     */
    Surname = 16,

    /**
     * Empty (Exchange 2010 or later).
     */
    Empty = 17
}

export module FileAsMapping {

    /**RequiredServerVersionAttribute */
    export function RequiredServerVersion(value: FileAsMapping): ExchangeVersion {
        if (value <= 12) //<= FileAsMapping.SurnameSpaceGivenName
            return ExchangeVersion.Exchange2007_SP1;
        if (value <= 17) // >= DisplayName && <=Empty
            return ExchangeVersion.Exchange2010;

        return ExchangeVersion.Exchange_Version_Not_Updated;
    }

    // create map for EwsEnumAttribute, this can be parsed without issue
    let EwsEnumStringMap = {}
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameCommaGivenName] = "LastCommaFirst"] = FileAsMapping.SurnameCommaGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.GivenNameSpaceSurname] = "FirstSpaceLast"] = FileAsMapping.GivenNameSpaceSurname;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameCommaGivenNameCompany] = "LastCommaFirstCompany"] = FileAsMapping.SurnameCommaGivenNameCompany;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.CompanySurnameGivenName] = "CompanyLastFirst"] = FileAsMapping.CompanySurnameGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameGivenName] = "LastFirst"] = FileAsMapping.SurnameGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameGivenNameCompany] = "LastFirstCompany"] = FileAsMapping.SurnameGivenNameCompany;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.CompanySurnameCommaGivenName] = "CompanyLastCommaFirst"] = FileAsMapping.CompanySurnameCommaGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameGivenNameSuffix] = "LastFirstSuffix"] = FileAsMapping.SurnameGivenNameSuffix;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameSpaceGivenNameCompany] = "LastSpaceFirstCompany"] = FileAsMapping.SurnameSpaceGivenNameCompany;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.CompanySurnameSpaceGivenName] = "CompanyLastSpaceFirst"] = FileAsMapping.CompanySurnameSpaceGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameSpaceGivenName] = "LastSpaceFirst"] = FileAsMapping.SurnameSpaceGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.GivenName] = "FirstName"] = FileAsMapping.GivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameGivenNameMiddleSuffix] = "LastFirstMiddleSuffix"] = FileAsMapping.SurnameGivenNameMiddleSuffix;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.Surname] = "LastName"] = FileAsMapping.Surname;

    /**EwsEnumAttribute */
    export function FromEwsEnumString(value: string): FileAsMapping {
        return EwsEnumStringMap[value] || FileAsMapping[value];
    }

    /**EwsEnumAttribute */
    export function ToEwsEnumString(value: FileAsMapping): string {
        return EwsEnumStringMap[value] || FileAsMapping[value];
    }
}

/**
 * Defines the follow-up actions that may be stamped on a message.
 */
export enum FlaggedForAction {
    
    /**
     * The message is flagged with any action.
     */
    Any = 0,
    
    /**
     * The recipient is requested to call the sender.
     */
    Call = 1,
    
    /**
     * The recipient is requested not to forward the message.
     */
    DoNotForward = 2,
    
    /**
     * The recipient is requested to follow up on the message.
     */
    FollowUp = 3,
    
    /**
     * The recipient received the message for information.
     */
    FYI = 4,
    
    /**
     * The recipient is requested to forward the message.
     */
    Forward = 5,
    
    /**
     * The recipient is informed that a response to the message is not required.
     */
    NoResponseNecessary = 6,
    
    /**
     * The recipient is requested to read the message.
     */
    Read = 7,
    
    /**
     * The recipient is requested to reply to the sender of the message.
     */
    Reply = 8,
    
    /**
     * The recipient is requested to reply to everyone the message was sent to.
     */
    ReplyToAll = 9,
    
    /**
     * The recipient is requested to review the message.
     */
    Review = 10
}

/**
 * Defines permission levels for calendar folders.
 */
export enum FolderPermissionLevel {
    
    /**
     * No permission is granted.
     */
    None = 0,
    
    /**
     * The Owner level.
     */
    Owner = 1,
    
    /**
     * The Publishing Editor level.
     */
    PublishingEditor = 2,
    
    /**
     * The Editor level.
     */
    Editor = 3,
    
    /**
     * The Publishing Author level.
     */
    PublishingAuthor = 4,
    
    /**
     * The Author level.
     */
    Author = 5,
    
    /**
     * The Nonediting Author level.
     */
    NoneditingAuthor = 6,
    
    /**
     * The Reviewer level.
     */
    Reviewer = 7,
    
    /**
     * The Contributor level.
     */
    Contributor = 8,
    
    /**
     * The Free/busy Time Only level. (Can only be applied to Calendar folders).
     */
    FreeBusyTimeOnly = 9,
    
    /**
     * The Free/busy Time, Subject and Location level. (Can only be applied to Calendar folders).
     */
    FreeBusyTimeAndSubjectAndLocation = 10,
    
    /**
     * The Custom level.
     */
    Custom = 11
}

/**
 * Defines a user's read access permission on items in a non-calendar folder.
 */
export enum FolderPermissionReadAccess {
    
    /**
     * The user has no read access on the items in the folder.
     */
    None = 0,
    
    /**
     * The user can read the start and end date and time of appointments. (Can only be applied to Calendar folders).
     */
    TimeOnly = 1,
    
    /**
     * The user can read the start and end date and time, subject and location of appointments. (Can only be applied to Calendar folders).
     */
    TimeAndSubjectAndLocation = 2,
    
    /**
     * The user has access to the full details of items.
     */
    FullDetails = 3
}

/**
 * Defines the scope of FindFolders operations.
 */
export enum FolderTraversal {
    
    /**
     * Only direct sub-folders are retrieved.
     */
    Shallow = 0,
    
    /**
     * The entire hierarchy of sub-folders is retrieved.
     */
    Deep = 1,
    
    /**
     * Only soft deleted folders are retrieved.
     */
    SoftDeleted = 2
}

/**
 * Defines the type of free/busy information returned by a GetUserAvailability operation.
 */
export enum FreeBusyViewType {
    
    /**
     * No view could be returned. This value cannot be specified in a call to GetUserAvailability.
     */
    None = 0,
    
    /**
     * Represents an aggregated free/busy stream. In cross-forest scenarios in which the target user in one forest does not have an Availability service configured, the Availability service of the requestor retrieves the target user's free/busy information from the free/busy public folder. 
     * Because public folders only store free/busy information in merged form, MergedOnly is the only available information.
     */
    MergedOnly = 1,
    
    /**
     * Represents the legacy status information: free, busy, tentative, and OOF. This also includes the start/end times of the appointments. This view is richer than the legacy free/busy view because individual meeting start and end times are provided instead of an aggregated free/busy stream.
     */
    FreeBusy = 2,
    
    /**
     * Represents all the properties in FreeBusy with a stream of merged free/busy availability information.
     */
    FreeBusyMerged = 3,
    
    /**
     * Represents the legacy status information: free, busy, tentative, and OOF; the start/end times of the appointments; and various properties of the appointment such as subject, location, and importance.
     * This requested view will return the maximum amount of information for which the requesting user is privileged.
     * If merged free/busy information only is available, as with requesting information for users in a Microsoft Exchange Server 2003 forest, MergedOnly will be returned. 
     * Otherwise, FreeBusy or Detailed will be returned.
     */
    Detailed = 4,
    
    /**
     * Represents all the properties in Detailed with a stream of merged free/busy availability information. 
     * If only merged free/busy information is available, for example if the mailbox exists on a computer running Exchange 2003, MergedOnly will be returned.
     * Otherwise, FreeBusyMerged or DetailedMerged will be returned.
     */
    DetailedMerged = 5
}
//todo - move to file where class Microsoft.Exchange.WebServices.Dns.DnsNativeMethods is located
// module Microsoft.Exchange.WebServices.Dns.DnsNativeMethods {
//     export enum FreeType {
//         RecordList = 1
//     }
// }

// import _export = Microsoft.Exchange.WebServices.Dns.DnsNativeMethods.FreeType;
// export = _export;

/**
 * Defines the response types from a GetUserPhoto request
 */
export enum GetUserPhotoStatus {
    /**
     * The photo was successfully returned
     */
    PhotoReturned = 0,

    /**
     * The photo has not changed since it was last obtained
     */
    PhotoUnchanged = 1,

    /**
     * The photo or user was not found on the server
     */
    PhotoOrUserNotFound = 2,
}
//todo - move to file where class Microsoft.Exchange.WebServices.Data.HangingServiceRequestBase is located
// - cant move - this is needed by shared eventargs type member

/**
 * @internal Enumeration of reasons that a hanging request may disconnect.
 */
export enum HangingRequestDisconnectReason {
    
    /**
     * The server cleanly closed the connection.
     */
    Clean = 0,
    
    /**
     * The client closed the connection.
     */
    UserInitiated = 1,
    
    /**
     * The connection timed out do to a lack of a heartbeat received.
     */
    Timeout = 2,
    
    /**
     * An exception occurred on the connection.
     */
    Exception = 3
}

/**
 * Defines the hold action.
 */
export enum HoldAction {
    
    /**
     * Create new hold
     */
    Create = 0,
    
    /**
     * Update query associated with a hold
     */
    Update = 1,
    
    /**
     * Release the hold
     */
    Remove = 2
}

/**
 * Defines the hold status.
 */
export enum HoldStatus {
    
    /**
     * Not on hold
     */
    NotOnHold = 0,
    
    /**
     * Placing/removing hold is in-progress
     */
    Pending = 1,
    
    /**
     * On hold
     */
    OnHold = 2,
    
    /**
     * Some mailboxes are on hold and some are not
     */
    PartialHold = 3,
    
    /**
     * The hold operation failed
     */
    Failed = 4
}

/**
 * The values indicate the types of item icons to display.
 */
export enum IconIndex {

    /**
     * A default icon.
     */
    Default = 0,

    /**
     * Post Item
     */
    PostItem = 1,

    /**
     * Icon read
     */
    MailRead = 2,

    /**
     * Icon unread
     */
    MailUnread = 3,

    /**
     * Icon replied
     */
    MailReplied = 4,

    /**
     * Icon forwarded
     */
    MailForwarded = 5,

    /**
     * Icon encrypted
     */
    MailEncrypted = 6,

    /**
     * Icon S/MIME signed
     */
    MailSmimeSigned = 7,

    /**
     * Icon encrypted replied
     */
    MailEncryptedReplied = 8,

    /**
     * Icon S/MIME signed replied
     */
    MailSmimeSignedReplied = 9,

    /**
     * Icon encrypted forwarded
     */
    MailEncryptedForwarded = 10,

    /**
     * Icon S/MIME signed forwarded
     */
    MailSmimeSignedForwarded = 11,

    /**
     * Icon encrypted read
     */
    MailEncryptedRead = 12,

    /**
     * Icon S/MIME signed read
     */
    MailSmimeSignedRead = 13,

    /**
     * IRM-protected mail
     */
    MailIrm = 14,

    /**
     * IRM-protected mail forwarded
     */
    MailIrmForwarded = 15,

    /**
     * IRM-protected mail replied
     */
    MailIrmReplied = 16,

    /**
     * Icon sms routed to external messaging system
     */
    SmsSubmitted = 17,

    /**
     * Icon sms routed to external messaging system
     */
    SmsRoutedToDeliveryPoint = 18,

    /**
     * Icon sms routed to external messaging system
     */
    SmsRoutedToExternalMessagingSystem = 19,

    /**
     * Icon sms routed to external messaging system
     */
    SmsDelivered = 20,

    /**
     * Outlook Default for Contacts
     */
    OutlookDefaultForContacts = 21,

    /**
     * Icon appointment item
     */
    AppointmentItem = 22,

    /**
     * Icon appointment recur
     */
    AppointmentRecur = 23,

    /**
     * Icon appointment meet
     */
    AppointmentMeet = 24,

    /**
     * Icon appointment meet recur
     */
    AppointmentMeetRecur = 25,

    /**
     * Icon appointment meet NY
     */
    AppointmentMeetNY = 26,

    /**
     * Icon appointment meet yes
     */
    AppointmentMeetYes = 27,

    /**
     * Icon appointment meet no
     */
    AppointmentMeetNo = 28,

    /**
     * Icon appointment meet maybe
     */
    AppointmentMeetMaybe = 29,

    /**
     * Icon appointment meet cancel
     */
    AppointmentMeetCancel = 30,

    /**
     * Icon appointment meet info
     */
    AppointmentMeetInfo = 31,

    /**
     * Icon task item
     */
    TaskItem = 32,

    /**
     * Icon task recur
     */
    TaskRecur = 33,

    /**
     * Icon task owned
     */
    TaskOwned = 34,

    /**
     * Icon task delegated
     */
    TaskDelegated = 35
}

/**
 * Defines supported Id formats in ConvertId operations.
 */
export enum IdFormat {
    
    /**
     * The EWS Id format used in Exchange 2007 RTM.
     */
    EwsLegacyId = 0,
    
    /**
     * The EWS Id format used in Exchange 2007 SP1 and above.
     */
    EwsId = 1,
    
    /**
     * The base64-encoded PR_ENTRYID property.
     */
    EntryId = 2,
    
    /**
     * The hexadecimal representation  of the PR_ENTRYID property.
     */
    HexEntryId = 3,
    
    /**
     * The Store Id format.
     */
    StoreId = 4,
    
    /**
     * The Outlook Web Access Id format.
     */
    OwaId = 5
}
// //todo - move to file where class Microsoft.Exchange.WebServices.Strings is located

// module Microsoft.Exchange.WebServices.Strings {
//     export enum IDs {
//         CannotRemoveSubscriptionFromLiveConnection = 1631423810,
//         ReadAccessInvalidForNonCalendarFolder = 3355844483,
//         PropertyDefinitionPropertyMustBeSet = 1413133863,
//         ArgumentIsBlankString = 2808916828,
//         InvalidAutodiscoverDomainsCount = 2110564001,
//         MinutesMustBeBetween0And1439 = 3846446647,
//         DeleteInvalidForUnsavedUserConfiguration = 3725066606,
//         PeriodNotFound = 732877372,
//         InvalidAutodiscoverSmtpAddress = 742945049,
//         InvalidOAuthToken = 2371807741,
//         MaxScpHopsExceeded = 540781291,
//         ContactGroupMemberCannotBeUpdatedWithoutBeingLoadedFirst = 412932664,
//         CurrentPositionNotElementStart = 3932722495,
//         CannotConvertBetweenTimeZones = 1762296216,
//         FrequencyMustBeBetween1And1440 = 2947629837,
//         CannotSetDelegateFolderPermissionLevelToCustom = 4255072555,
//         PartnerTokenIncompatibleWithRequestVersion = 231532733,
//         InvalidAutodiscoverRequest = 216906786,
//         InvalidAsyncResult = 2795977038,
//         InvalidMailboxType = 1875536889,
//         AttachmentCollectionNotLoaded = 368467777,
//         ParameterIncompatibleWithRequestVersion = 1937216341,
//         DayOfWeekIndexMustBeSpecifiedForRecurrencePattern = 814325722,
//         WLIDCredentialsCannotBeUsedWithLegacyAutodiscover = 365885070,
//         PropertyCannotBeUpdated = 2534953608,
//         IncompatibleTypeForArray = 3820761979,
//         PercentCompleteMustBeBetween0And100 = 3936886128,
//         AutodiscoverServiceIncompatibleWithRequestVersion = 460414997,
//         InvalidAutodiscoverSmtpAddressesCount = 1774410042,
//         ServiceUrlMustBeSet = 1922401890,
//         ItemTypeNotCompatible = 4181025268,
//         AttachmentItemTypeMismatch = 1516841384,
//         UnsupportedWebProtocol = 3620572079,
//         EnumValueIncompatibleWithRequestVersion = 777131942,
//         UnexpectedElement = 2080190431,
//         InvalidOrderBy = 162617974,
//         NoAppropriateConstructorForItemClass = 3730786468,
//         SearchFilterAtIndexIsInvalid = 1334400254,
//         DeletingThisObjectTypeNotAuthorized = 3957228737,
//         PropertyCannotBeDeleted = 2011990502,
//         ValuePropertyMustBeSet = 49538054,
//         TagValueIsOutOfRange = 4177209255,
//         ItemToUpdateCannotBeNullOrNew = 893972063,
//         SearchParametersRootFolderIdsEmpty = 2492696699,
//         MailboxQueriesParameterIsNotSpecified = 2182404464,
//         FolderPermissionHasInvalidUserId = 3079787672,
//         InvalidAutodiscoverDomain = 95137117,
//         MailboxesParameterIsNotSpecified = 1274908260,
//         ParentFolderDoesNotHaveId = 3207115397,
//         DayOfMonthMustBeSpecifiedForRecurrencePattern = 190140884,
//         ClassIncompatibleWithRequestVersion = 886236812,
//         CertificateHasNoPrivateKey = 956539910,
//         InvalidOrUnsupportedTimeZoneDefinition = 2660350763,
//         HourMustBeBetween0And23 = 980862610,
//         TimeoutMustBeBetween1And1440 = 1864811546,
//         CredentialsRequired = 107509017,
//         MustLoadOrAssignPropertyBeforeAccess = 1301287431,
//         InvalidAutodiscoverServiceResponse = 2421645987,
//         CannotCallConnectDuringLiveConnection = 3637880390,
//         ObjectDoesNotHaveId = 1990317298,
//         CannotAddSubscriptionToLiveConnection = 2374077290,
//         MaxChangesMustBeBetween1And512 = 3989266019,
//         AttributeValueCannotBeSerialized = 3745271395,
//         SearchFilterMustBeSet = 2182989540,
//         EndDateMustBeGreaterThanStartDate = 2696927076,
//         InvalidDateTime = 3410810540,
//         UpdateItemsDoesNotAllowAttachments = 2505974152,
//         TimeoutMustBeGreaterThanZero = 3210574608,
//         AutodiscoverInvalidSettingForOutlookProvider = 81925120,
//         InvalidRedirectionResponseReturned = 706868687,
//         ExpectedStartElement = 3728006586,
//         DaysOfTheWeekNotSpecified = 2925351706,
//         FolderToUpdateCannotBeNullOrNew = 2887145506,
//         PartnerTokenRequestRequiresUrl = 1709653493,
//         NumberOfOccurrencesMustBeGreaterThanZero = 4020293177,
//         JsonSerializationNotImplemented = 537341821,
//         StartTimeZoneRequired = 263088904,
//         PropertyAlreadyExistsInOrderByCollection = 2291792901,
//         ItemAttachmentMustBeNamed = 2209938519,
//         InvalidAutodiscoverSettingsCount = 2688936715,
//         LoadingThisObjectTypeNotSupported = 1313605428,
//         UserIdForDelegateUserNotSpecified = 3460610998,
//         PhoneCallAlreadyDisconnected = 2720737469,
//         OperationDoesNotSupportAttachments = 1464025756,
//         UnsupportedTimeZonePeriodTransitionTarget = 98512741,
//         IEnumerableDoesNotContainThatManyObject = 474853648,
//         UpdateItemsDoesNotSupportNewOrUnchangedItems = 953072612,
//         ValidationFailed = 1341796948,
//         InvalidRecurrencePattern = 3636462697,
//         TimeWindowStartTimeMustBeGreaterThanEndTime = 4170253059,
//         InvalidAttributeValue = 369811396,
//         FileAttachmentContentIsNotSet = 2449142619,
//         AutodiscoverDidNotReturnEwsUrl = 628121484,
//         RecurrencePatternMustHaveStartDate = 423461609,
//         OccurrenceIndexMustBeGreaterThanZero = 1396112272,
//         ServiceResponseDoesNotContainXml = 1981959699,
//         ItemIsOutOfDate = 2560682386,
//         MinuteMustBeBetween0And59 = 3637133283,
//         NoSoapOrWsSecurityEndpointAvailable = 3954825173,
//         ElementNotFound = 3189440097,
//         IndexIsOutOfRange = 4223767916,
//         PropertyIsReadOnly = 869119007,
//         AttachmentCreationFailed = 2817837707,
//         DayOfMonthMustBeBetween1And31 = 3133762315,
//         ServiceRequestFailed = 2091738407,
//         DelegateUserHasInvalidUserId = 129422921,
//         SearchFilterComparisonValueTypeIsNotSupported = 1069581653,
//         ElementValueCannotBeSerialized = 4258284629,
//         PropertyValueMustBeSpecifiedForRecurrencePattern = 2924950297,
//         NonSummaryPropertyCannotBeUsed = 2436895661,
//         HoldIdParameterIsNotSpecified = 134310332,
//         TransitionGroupNotFound = 21384399,
//         ObjectTypeNotSupported = 4144876524,
//         InvalidTimeoutValue = 3454211069,
//         AutodiscoverRedirectBlocked = 3339063014,
//         PropertySetCannotBeModified = 3717641032,
//         DayOfTheWeekMustBeSpecifiedForRecurrencePattern = 3877446129,
//         ServiceObjectAlreadyHasId = 3918321785,
//         MethodIncompatibleWithRequestVersion = 4274338115,
//         OperationNotSupportedForPropertyDefinitionType = 2727810523,
//         InvalidElementStringValue = 3934659801,
//         CollectionIsEmpty = 500353177,
//         InvalidFrequencyValue = 885177846,
//         UnexpectedEndOfXmlDocument = 546825189,
//         FolderTypeNotCompatible = 3578997681,
//         RequestIncompatibleWithRequestVersion = 3451337077,
//         PropertyTypeIncompatibleWhenUpdatingCollection = 4148083232,
//         ServerVersionNotSupported = 603284986,
//         DurationMustBeSpecifiedWhenScheduled = 666454105,
//         NoError = 1005127777,
//         CannotUpdateNewUserConfiguration = 3972010693,
//         ObjectTypeIncompatibleWithRequestVersion = 2438108153,
//         NullStringArrayElementInvalid = 3604837092,
//         HttpsIsRequired = 333950754,
//         MergedFreeBusyIntervalMustBeSmallerThanTimeWindow = 2480357954,
//         SecondMustBeBetween0And59 = 328519365,
//         AtLeastOneAttachmentCouldNotBeDeleted = 3596957401,
//         IdAlreadyInList = 1233804470,
//         BothSearchFilterAndQueryStringCannotBeSpecified = 3295662635,
//         AdditionalPropertyIsNull = 3383788511,
//         InvalidEmailAddress = 2316486059,
//         MaximumRedirectionHopsExceeded = 1588497945,
//         AutodiscoverCouldNotBeLocated = 3097538091,
//         NoSubscriptionsOnConnection = 2715578908,
//         PermissionLevelInvalidForNonCalendarFolder = 1063351272,
//         InvalidAuthScheme = 2845550636,
//         JsonDeserializationNotImplemented = 311071154,
//         ValuePropertyNotLoaded = 2743202310,
//         PropertyIncompatibleWithRequestVersion = 843308875,
//         OffsetMustBeGreaterThanZero = 2437116628,
//         CreateItemsDoesNotAllowAttachments = 690508625,
//         PropertyDefinitionTypeMismatch = 2445370550,
//         IntervalMustBeGreaterOrEqualToOne = 2129318611,
//         CannotSetPermissionLevelToCustom = 961741172,
//         CannotAddRequestHeader = 2921139860,
//         ArrayMustHaveAtLeastOneElement = 4264880578,
//         MonthMustBeSpecifiedForRecurrencePattern = 567828041,
//         ValueOfTypeCannotBeConverted = 3869807514,
//         ValueCannotBeConverted = 788051255,
//         ServerErrorAndStackTraceDetails = 1481761255,
//         FolderPermissionLevelMustBeSet = 2586079185,
//         AutodiscoverError = 4003396996,
//         ArrayMustHaveSingleDimension = 3066801652,
//         InvalidPropertyValueNotInRange = 2233059550,
//         RegenerationPatternsOnlyValidForTasks = 1453973661,
//         ItemAttachmentCannotBeUpdated = 914733855,
//         EqualityComparisonFilterIsInvalid = 1467147488,
//         AutodiscoverServiceRequestRequiresDomainOrUrl = 2950491364,
//         InvalidUser = 3929050450,
//         AccountIsLocked = 2901788841,
//         InvalidDomainName = 2762661174,
//         TooFewServiceReponsesReturned = 710118117,
//         CannotSubscribeToStatusEvents = 463464377,
//         InvalidSortByPropertyForMailboxSearch = 1066736932,
//         UnexpectedElementType = 2100812591,
//         ValueMustBeGreaterThanZero = 691200302,
//         AttachmentCannotBeUpdated = 2292458752,
//         CreateItemsDoesNotHandleExistingItems = 3912371609,
//         MultipleContactPhotosInAttachment = 2967125165,
//         InvalidRecurrenceRange = 3387532664,
//         CannotSetBothImpersonatedAndPrivilegedUser = 4210899574,
//         NewMessagesWithAttachmentsCannotBeSentDirectly = 1565629292,
//         CannotCallDisconnectWithNoLiveConnection = 3633425214,
//         IdPropertyMustBeSet = 3940556486,
//         ValuePropertyNotAssigned = 1562822901,
//         ZeroLengthArrayInvalid = 4061174908,
//         HoldMailboxesParameterIsNotSpecified = 3345946933,
//         CannotSaveNotNewUserConfiguration = 2270311116,
//         ServiceObjectDoesNotHaveId = 2111195463,
//         PropertyCollectionSizeMismatch = 491519754,
//         XsDurationCouldNotBeParsed = 2861470707,
//         UnknownTimeZonePeriodTransitionType = 2279096081
//     }
// }

// import _export = Microsoft.Exchange.WebServices.Strings.IDs;
// export = _export;

/**
 * Defines Instant Messaging address entries for a contact.
 */
export enum ImAddressKey {
    
    /**
     * The first Instant Messaging address.
     */
    ImAddress1 = 0,
    
    /**
     * The second Instant Messaging address.
     */
    ImAddress2 = 1,
    
    /**
     * The third Instant Messaging address.
     */
    ImAddress3 = 2
}

/**
 * Defines the importance of an item.
 */
export enum Importance {
    
    /**
     * Low importance.
     */
    Low = 0,
    
    /**
     * Normal importance.
     */
    Normal = 1,
    
    /**
     * High importance.
     */
    High = 2
}

/**
 * Defines the flag status of an Item.
 */
export enum ItemFlagStatus {
    
    /**
     * Not Flagged.
     */
    NotFlagged = 0,
    
    /**
     * Flagged.
     */
    Flagged = 1,
    
    /**
     * Complete.
     */
    Complete = 2
}
//todo - move to file where class Microsoft.Exchange.WebServices.Data.NonIndexableItem is located

/**
 * Item index error
 */
export enum ItemIndexError {
    
    /**
     * None
     */
    None = 0,
    
    /**
     * Generic Error
     */
    GenericError = 1,
    
    /**
     * Timeout
     */
    Timeout = 2,
    
    /**
     * Stale Event
     */
    StaleEvent = 3,
    
    /**
     * Mailbox Offline
     */
    MailboxOffline = 4,
    
    /**
     * Too many attachments to index
     */
    AttachmentLimitReached = 5,
    
    /**
     * Data is truncated
     */
    MarsWriterTruncation = 6
}

/**
 * Defines the scope of FindItems operations.
 */
export enum ItemTraversal {

    /**
     * All non deleted items in the specified folder are retrieved.
     */
    Shallow = 0,

    /**
     * Only soft-deleted items are retrieved.
     */
    SoftDeleted = 1,

    /**
     * Only associated items are retrieved (Exchange 2010 or later).
     */
    Associated = 2
}

export module ItemTraversal {

    /**RequiredServerVersionAttribute */
    export function RequiredServerVersion(value: ItemTraversal): ExchangeVersion {
        if (value <= 1) //<= ItemTraversal.SoftDeleted
            return ExchangeVersion.Exchange2007_SP1;
        if (value == 2) // === Associated
            return ExchangeVersion.Exchange2010;

        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
}
//todo - move to file where class Microsoft.Exchange.WebServices.Data.JsonTokenizer is located

export enum JsonTokenType {
    String = 0,
    Number = 1,
    Boolean = 2,
    Null = 3,
    ObjectOpen = 4,
    ObjectClose = 5,
    ArrayOpen = 6,
    ArrayClose = 7,
    Colon = 8,
    Comma = 9,
    EndOfFile = 10
}




/**
 * Defines the legacy free/busy status associated with an appointment.
 */
export enum LegacyFreeBusyStatus {
    
    /**
     * The time slot associated with the appointment appears as free.
     */
    Free = 0,
    
    /**
     * The time slot associated with the appointment appears as tentative.
     */
    Tentative = 1,
    
    /**
     * The time slot associated with the appointment appears as busy.
     */
    Busy = 2,
    
    /**
     * The time slot associated with the appointment appears as Out of Office.
     */
    OOF = 3,
    
    /**
     * The time slot associated with the appointment appears as working else where.
     */
    WorkingElsewhere = 4,
    
    /**
     * No free/busy status is associated with the appointment.
     */
    NoData = 5
}
//todo - move to file where class Microsoft.Exchange.WebServices.Data.OnlineMeetingSettings is located

/**
 * Online Meeting Lobby Bypass options.
 */
export enum LobbyBypass {
    
    /**
     * Disabled.
     */
    Disabled = 0,
    
    /**
     * Enabled for gateway participants.
     */
    EnabledForGatewayParticipants = 1
}

/**
 * Source of resolution.
 */
export enum LocationSource {
    
    /**
     * Unresolved
     */
    None = 0,
    
    /**
     * Resolved by external location services (such as Bing, Google, etc)
     */
    LocationServices = 1,
    
    /**
     * Resolved by external phonebook services (such as Bing, Google, etc)
     */
    PhonebookServices = 2,
    
    /**
     * Revolved by a GPS enabled device (such as cellphone)
     */
    Device = 3,
    
    /**
     * Sourced from a contact card
     */
    Contact = 4,
    
    /**
     * Sourced from a resource (such as a conference room)
     */
    Resource = 5
}

/**
 * Defines a logical operator as used by search filter collections.
 */
export enum LogicalOperator {

    /**
     * The AND operator.
     */
    And = 0,

    /**
     * The OR operator.
     */
    Or = 1
}

/**
 * Defines the location for mailbox search.
 */
export enum MailboxSearchLocation {

    /**
     * Primary only (Exchange 2013 or later).
     */
    PrimaryOnly = 0,

    /**
     * Archive only (Exchange 2013 or later).
     */
    ArchiveOnly = 1,

    /**
     * Both Primary and Archive (Exchange 2013 or later).
     */
    All = 2
}

export module MailboxSearchLocation {

    /**RequiredServerVersionAttribute */
    export function RequiredServerVersion(value: MailboxSearchLocation): ExchangeVersion {
        if (value <= 2) //<= MailboxSearchLocation.All
            return ExchangeVersion.Exchange2013;
        
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
}

/**
 * @internal Enum MailboxSearchScopeType
 */
export enum MailboxSearchScopeType {
    
    /**
     * The legacy exchange DN
     */
    LegacyExchangeDN = 0,
    
    /**
     * The public folder
     */
    PublicFolder = 1,
    
    /**
     * The recipient
     */
    Recipient = 2,
    
    /**
     * The mailbox GUID
     */
    MailboxGuid = 3,
    
    /**
     * All public folders
     */
    AllPublicFolders = 4,
    
    /**
     * All mailboxes
     */
    AllMailboxes = 5,
    
    /**
     * The saved search id
     */
    SavedSearchId = 6,
    
    /**
     * The auto detect
     */
    AutoDetect = 7
}

/**
 * Defines the type of an EmailAddress object.
 */
export enum MailboxType {
    /**
     * Unknown mailbox type (Exchange 2010 or later).
     */
    Unknown,

    /**
     * The EmailAddress represents a one-off contact (Exchange 2010 or later).
     */
    OneOff,

    /**
     * The EmailAddress represents a mailbox.
     */
    Mailbox,

    /**
     * The EmailAddress represents a public folder.
     */
    PublicFolder,

    /**
     * The EmailAddress represents a Public Group.
     */
    PublicGroup,

    /**
     * The EmailAddress represents a Contact Group.
     */
    ContactGroup,

    /**
     * The EmailAddress represents a store contact or AD mail contact.
     */
    Contact,

    /**
     * The EmailAddress represents a GroupMailbox (Exchange 2015/2016 or later).
     */
    GroupMailbox,
}

export module MailboxType {

    /**RequiredServerVersionAttribute */
    export function RequiredServerVersion(value: MailboxType): ExchangeVersion {
        if (value <= 1) //<=MailboxType.OneOff
            return ExchangeVersion.Exchange2010;
        if (value <= 6) //<=MailboxType.Contact
            return ExchangeVersion.Exchange2007_SP1;
        if (value <= 7) //<=MailboxType.GroupMailbox
            return ExchangeVersion.Exchange2015;

        return ExchangeVersion.Exchange_Version_Not_Updated;
    }

    /**EwsEnumAttribute */
    export function FromEwsEnumString(value: string): MailboxType {
        switch (value) {
            case "PublicDL":
                return MailboxType.PublicGroup;
            case "PrivateDL":
                return MailboxType.ContactGroup;
            default:
                return MailboxType[value];
        }
    }

    /**EwsEnumAttribute */
    export function ToEwsEnumString(value: MailboxType): string {
        switch (value) {
            case MailboxType.PublicGroup:
                return "PublicDL";
            case MailboxType.ContactGroup:
                return "PrivateDL";
            default:
                return MailboxType[value];
        }
    }
}

/**
 * Defines the MAPI type of an extended property.
 */
export enum MapiPropertyType {
    
    /**
     * The property is of type ApplicationTime.
     */
    ApplicationTime = 0,
    
    /**
     * The property is of type ApplicationTimeArray.
     */
    ApplicationTimeArray = 1,
    
    /**
     * The property is of type Binary.
     */
    Binary = 2,
    
    /**
     * The property is of type BinaryArray.
     */
    BinaryArray = 3,
    
    /**
     * The property is of type Boolean.
     */
    Boolean = 4,
    
    /**
     * The property is of type CLSID.
     */
    CLSID = 5,
    
    /**
     * The property is of type CLSIDArray.
     */
    CLSIDArray = 6,
    
    /**
     * The property is of type Currency.
     */
    Currency = 7,
    
    /**
     * The property is of type CurrencyArray.
     */
    CurrencyArray = 8,
    
    /**
     * The property is of type Double.
     */
    Double = 9,
    
    /**
     * The property is of type DoubleArray.
     */
    DoubleArray = 10,
    
    /**
     * The property is of type Error.
     */
    Error = 11,
    
    /**
     * The property is of type Float.
     */
    Float = 12,
    
    /**
     * The property is of type FloatArray.
     */
    FloatArray = 13,
    
    /**
     * The property is of type Integer.
     */
    Integer = 14,
    
    /**
     * The property is of type IntegerArray.
     */
    IntegerArray = 15,
    
    /**
     * The property is of type Long.
     */
    Long = 16,
    
    /**
     * The property is of type LongArray.
     */
    LongArray = 17,
    
    /**
     * The property is of type Null.
     */
    Null = 18,
    
    /**
     * The property is of type Object.
     */
    Object = 19,
    
    /**
     * The property is of type ObjectArray.
     */
    ObjectArray = 20,
    
    /**
     * The property is of type Short.
     */
    Short = 21,
    
    /**
     * The property is of type ShortArray.
     */
    ShortArray = 22,
    
    /**
     * The property is of type SystemTime.
     */
    SystemTime = 23,
    
    /**
     * The property is of type SystemTimeArray.
     */
    SystemTimeArray = 24,
    
    /**
     * The property is of type String.
     */
    String = 25,
    
    /**
     * The property is of type StringArray.
     */
    StringArray = 26
}
/** shim to store type of data in MapiTypeConverterMapEntry */
export enum MapiTypeConverterTypeSystem {
    boolean,
    string,
    number,
    DateTime,
    guid,
    byteArray
}

/**
 * The attendee is the organizer of the meeting.
 */
export enum MeetingAttendeeType {
    
    /**
     * The attendee is the organizer of the meeting.
     */
    Organizer = 0,
    
    /**
     * The attendee is required.
     */
    Required = 1,
    
    /**
     * The attendee is optional.
     */
    Optional = 2,
    
    /**
     * The attendee is a room.
     */
    Room = 3,
    
    /**
     * The attendee is a resource.
     */
    Resource = 4
}

/**
 * Defines how meeting requests are sent to delegates.
 */
export enum MeetingRequestsDeliveryScope {

    /**
     * Meeting requests are sent to delegates only.
     */
    DelegatesOnly = 0,

    /**
     * Meeting requests are sent to delegates and to the owner of the mailbox.
     */
    DelegatesAndMe = 1,

    /**
     * Meeting requests are sent to delegates and informational messages are sent to the owner of the mailbox.
     */
    DelegatesAndSendInformationToMe = 2,

    /**
     * Meeting requests are not sent to delegates.  This value is supported only for Exchange 2010 SP1 or later server versions.
     */
    NoForward = 3
}

export module MeetingRequestsDeliveryScope {

    /**RequiredServerVersionAttribute */
    export function RequiredServerVersion(value: MeetingRequestsDeliveryScope): ExchangeVersion {
        if (value <= 2) //<= MeetingRequestsDeliveryScope.DelegatesAndSendInformationToMe
            return ExchangeVersion.Exchange2007_SP1;
        else if (value == 3) // == NoForward
            return ExchangeVersion.Exchange2010_SP1;

        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
}

/**
 * Defines the type of a meeting request.
 */
export enum MeetingRequestType {
    
    /**
     * Undefined meeting request type.
     */
    None = 0,
    
    /**
     * The meeting request is an update to the original meeting.
     */
    FullUpdate = 1,
    
    /**
     * The meeting request is an information update.
     */
    InformationalUpdate = 2,
    
    /**
     * The meeting request is for a new meeting.
     */
    NewMeetingRequest = 3,
    
    /**
     * The meeting request is outdated.
     */
    Outdated = 4,
    
    /**
     * The meeting update is a silent update to an existing meeting.
     */
    SilentUpdate = 5,
    
    /**
     * The meeting update was forwarded to a delegate, and this copy is informational.
     */
    PrincipalWantsCopy = 6
}

/**
 * Defines the types of response given to a meeting request.
 */
export enum MeetingResponseType {
    
    /**
     * The response type is unknown.
     */
    Unknown = 0,
    
    /**
     * There was no response. The authenticated is the organizer of the meeting.
     */
    Organizer = 1,
    
    /**
     * The meeting was tentatively accepted.
     */
    Tentative = 2,
    
    /**
     * The meeting was accepted.
     */
    Accept = 3,
    
    /**
     * The meeting was declined.
     */
    Decline = 4,
    
    /**
     * No response was received for the meeting.
     */
    NoResponseReceived = 5
}

/**
 * Defines the status of group members.
 */
export enum MemberStatus {
    
    /**
     * The member is unrecognized.
     */
    Unrecognized = 0,
    
    /**
     * The member is normal.
     */
    Normal = 1,
    
    /**
     * The member is demoted.
     */
    Demoted = 2
}

/**
 * Defines how messages are disposed of in CreateItem and UpdateItem operations.
 */
export enum MessageDisposition {
    
    /**
     * Messages are saved but not sent.
     */
    SaveOnly = 0,
    
    /**
     * Messages are sent and a copy is saved.
     */
    SendAndSaveCopy = 1,
    
    /**
     * Messages are sent but no copy is saved.
     */
    SendOnly = 2
}

/**
 * Defines months of the year.
 */
export enum Month {
    
    /**
     * January.
     */
    January = 1,
    
    /**
     * February.
     */
    February = 2,
    
    /**
     * March.
     */
    March = 3,
    
    /**
     * April.
     */
    April = 4,
    
    /**
     * May.
     */
    May = 5,
    
    /**
     * June.
     */
    June = 6,
    
    /**
     * July.
     */
    July = 7,
    
    /**
     * August.
     */
    August = 8,
    
    /**
     * September.
     */
    September = 9,
    
    /**
     * October.
     */
    October = 10,
    
    /**
     * November.
     */
    November = 11,
    
    /**
     * December.
     */
    December = 12
}

/**
 * Defines the offset's base point in a paged view.
 */
export enum OffsetBasePoint {

    /**
     * The offset is from the beginning of the view.
     */
    Beginning = 0,

    /**
     * The offset is from the end of the view.
     */
    End = 1
}
//todo - move to file where class Microsoft.Exchange.WebServices.Data.OnlineMeetingSettings is located

/**
 * Online Meeting Access Level options.
 */
export enum OnlineMeetingAccessLevel {
    
    /**
     * Locked.
     */
    Locked = 0,
    
    /**
     * Invited.
     */
    Invited = 1,
    
    /**
     * Internal.
     */
    Internal = 2,
    
    /**
     * Everyone.
     */
    Everyone = 3
}

/**
 * Defines the external audience of an Out of Office notification.
 */
export enum OofExternalAudience {
    
    /**
     * No external recipients should receive Out of Office notifications.
     */
    None = 0,
    
    /**
     * Only recipients that are in the user's Contacts frolder should receive Out of Office notifications.
     */
    Known = 1,
    
    /**
     * All recipients should receive Out of Office notifications.
     */
    All = 2
}

/**
 * Defines a user's Out of Office Assistant status.
 */
export enum OofState {
    
    /**
     * The assistant is diabled.
     */
    Disabled = 0,
    
    /**
     * The assistant is enabled.
     */
    Enabled = 1,
    
    /**
     * The assistant is scheduled.
     */
    Scheduled = 2
}

/**
 * @internal Defines supported Outlook protocls.
 */
export enum OutlookProtocolType {
    
    /**
     * The Remote Procedure Call (RPC) protocol.
     */
    Rpc = 0,
    
    /**
     * The Remote Procedure Call (RPC) over HTTP protocol.
     */
    RpcOverHttp = 1,
    
    /**
     * The Web protocol.
     */
    Web = 2,
    
    /**
     * The protocol is unknown.
     */
    Unknown = 3
}

/**
 * Defines the scope of a user's permission on a folders.
 */
export enum PermissionScope {

    /**
     * The user does not have the associated permission.
     */
    None = 0,

    /**
     * The user has the associated permission on items that it owns.
     */
    Owned = 1,

    /**
     * The user has the associated permission on all items.
     */
    All = 2
}

/**
 * The PhoneCallState enumeration
 */
export enum PhoneCallState {
    
    /**
     * Idle.
     */
    Idle = 0,
    
    /**
     * Connecting.
     */
    Connecting = 1,
    
    /**
     * Alerted.
     */
    Alerted = 2,
    
    /**
     * Connected.
     */
    Connected = 3,
    
    /**
     * Disconnected.
     */
    Disconnected = 4,
    
    /**
     * Incoming.
     */
    Incoming = 5,
    
    /**
     * Transferring.
     */
    Transferring = 6,
    
    /**
     * Forwarding.
     */
    Forwarding = 7
}

/**
 * Defines phone number entries for a contact.
 */
export enum PhoneNumberKey {
    
    /**
     * The assistant's phone number.
     */
    AssistantPhone = 0,
    
    /**
     * The business fax number.
     */
    BusinessFax = 1,
    
    /**
     * The business phone number.
     */
    BusinessPhone = 2,
    
    /**
     * The second business phone number.
     */
    BusinessPhone2 = 3,
    
    /**
     * The callback number.
     */
    Callback = 4,
    
    /**
     * The car phone number.
     */
    CarPhone = 5,
    
    /**
     * The company's main phone number.
     */
    CompanyMainPhone = 6,
    
    /**
     * The home fax number.
     */
    HomeFax = 7,
    
    /**
     * The home phone number.
     */
    HomePhone = 8,
    
    /**
     * The second home phone number.
     */
    HomePhone2 = 9,
    
    /**
     * The ISDN number.
     */
    Isdn = 10,
    
    /**
     * The mobile phone number.
     */
    MobilePhone = 11,
    
    /**
     * An alternate fax number.
     */
    OtherFax = 12,
    
    /**
     * An alternate phone number.
     */
    OtherTelephone = 13,
    
    /**
     * The pager number.
     */
    Pager = 14,
    
    /**
     * The primary phone number.
     */
    PrimaryPhone = 15,
    
    /**
     * The radio phone number.
     */
    RadioPhone = 16,
    
    /**
     * The Telex number
     */
    Telex = 17,
    
    /**
     * The TTY/TTD phone number.
     */
    TtyTddPhone = 18
}

/**
 * Defines a physical address index.
 */
export enum PhysicalAddressIndex {
    
    /**
     * None.
     */
    None = 0,
    
    /**
     * The business address.
     */
    Business = 1,
    
    /**
     * The home address.
     */
    Home = 2,
    
    /**
     * The alternate address.
     */
    Other = 3
}

/**
 * Defines physical address entries for a contact.
 */
export enum PhysicalAddressKey {
    
    /**
     * The business address.
     */
    Business = 0,
    
    /**
     * The home address.
     */
    Home = 1,
    
    /**
     * An alternate address.
     */
    Other = 2
}
//todo - move to file where class Microsoft.Exchange.WebServices.Data.OnlineMeetingSettings is located

/**
 * Online Meeting Presenters options.
 */
export enum Presenters {
    
    /**
     * Disabled.
     */
    Disabled = 0,
    
    /**
     * Internal.
     */
    Internal = 1,
    
    /**
     * Everyone.
     */
    Everyone = 2
}

/**
 * Preview item base shape
 */
export enum PreviewItemBaseShape {
    
    /**
     * Default (all properties required for showing preview by default)
     */
    Default = 0,
    
    /**
     * Compact (only a set of core properties)
     */
    Compact = 1
}

/**
 * @internal Defines the type of PrivilegedLogonType.
 */
export enum PrivilegedLogonType {
    
    /**
     * Logon as Admin
     */
    Admin = 0,
    
    /**
     * Logon as SystemService
     */
    SystemService = 1
}
//todo - move to file where class Microsoft.Exchange.WebServices.Dns.PrivilegedUserId is located

/**
 * @internal Interactive, charge against a copy of target mailbox budget.
 */
export enum PrivilegedUserIdBudgetType {
    
    /**
     * Interactive, charge against a copy of target mailbox budget.
     */
    Default = 0,

    /**
     * Running as background load
     */
    RunningAsBackgroundLoad = 1,

    /**
     * Unthrottled budget.
     */
    Unthrottled = 2
}

/**
 * @internal Defines how a complex property behaves.
 * 
 * [Flags]
 */
export enum PropertyDefinitionFlags {
  
  /**
   * No specific behavior.
   */
  None = 0,
  
  /**
   * The property is automatically instantiated when it is read.
   */
  AutoInstantiateOnRead = 1,
  
  /**
   * The existing instance of the property is reusable. 
   */
  ReuseInstance = 2,
  
  /**
   * The property can be set.
   */
  CanSet = 4,
  
  /**
   * The property can be updated.
   */
  CanUpdate = 8,
  
  /**
   * The property can be deleted.
   */
  CanDelete = 16,
  
  /**
   * The property can be searched.
   */
  CanFind = 32,
  
  /**
   * The property must be loaded explicitly
   */
  MustBeExplicitlyLoaded = 64,
  
  /**
   * Only meaningful for "collection" property. 
   * With this flag, the item in the collection gets updated, instead of creating and adding new items to the collection.
   * Should be used together with the ReuseInstance flag.
   */
  UpdateCollectionItems = 128
}

/**
 * The rendering method.
 */
export enum RenderingMode {

    /**
     * XML
     */
    Xml = 0,

    /**
     * Javascript Object Notation
     */
    JSON = 1
}

/**
 * Defines the location where a ResolveName operation searches for contacts.
 */
export enum ResolveNameSearchLocation {
    
    /**
     * The name is resolved against the Global Address List.
     */
    DirectoryOnly = 0,
    
    /**
     * The name is resolved against the Global Address List and then against the Contacts folder if no match was found.
     */
    DirectoryThenContacts = 1,
    
    /**
     * The name is resolved against the Contacts folder.
     */
    ContactsOnly = 2,
    
    /**
     * The name is resolved against the Contacts folder and then against the Global Address List if no match was found.
     */
    ContactsThenDirectory = 3
}

/**
 * Defines the response actions that can be taken on an item.
 * 
 * [Flags]
 */
export enum ResponseActions {
    
    /**
     * No action can be taken.
     */
    None = 0,
    
    /**
     * The item can be accepted.
     */
    Accept = 1,
    
    /**
     * The item can be tentatively accepted.
     */
    TentativelyAccept = 2,
    
    /**
     * The item can be declined.
     */
    Decline = 4,
    
    /**
     * The item can be replied to.
     */
    Reply = 8,
    
    /**
     * The item can be replied to all.
     */
    ReplyAll = 16,
    
    /**
     * The item can be forwarded.
     */
    Forward = 32,
    
    /**
     * The item can be cancelled.
     */
    Cancel = 64,
    
    /**
     * The item can be removed from the calendar.
     */
    RemoveFromCalendar = 128,
    
    /**
     * The item's read receipt can be suppressed.
     */
    SuppressReadReceipt = 256,
    
    /**
     * A reply to the item can be posted.
     */
    PostReply = 512
}

/**
 * Defines the type of a ResponseMessage object.
 */
export enum ResponseMessageType {
    
    /**
     * The ResponseMessage is a reply to the sender of a message.
     */
    Reply = 0,
    
    /**
     * The ResponseMessage is a reply to the sender and all the recipients of a message.
     */
    ReplyAll = 1,
    
    /**
     * The ResponseMessage is a forward.
     */
    Forward = 2
}

/**
 * Defines the action of a retention policy tag.
 */
export enum RetentionActionType {
    
    /**
     * Never tags (RetentionEnabled = false) do not have retention action in the FAI.
     */
    None = 0,
    
    /**
     * Expired items will be moved to the Deleted Items folder.
     */
    MoveToDeletedItems = 1,
    
    /**
     * Expired items will be moved to the organizational folder specified in the ExpirationDestination field.
     */
    MoveToFolder = 2,
    
    /**
     * Expired items will be soft deleted.
     */
    DeleteAndAllowRecovery = 3,
    
    /**
     * Expired items will be hard deleted.
     */
    PermanentlyDelete = 4,
    
    /**
     * Expired items will be tagged as expired.
     */
    MarkAsPastRetentionLimit = 5,
    
    /**
     * Expired items will be moved to the archive.
     */
    MoveToArchive = 6
}

/**
 * Defines the retention type.
 */
export enum RetentionType {
    
    /**
     * Delete retention.
     */
    Delete = 0,
    
    /**
     * Archive retention.
     */
    Archive = 1
}

/**
 * Defines the error codes identifying why a rule failed validation.
 */
export enum RuleErrorCode {
    
    /**
     * Active Directory operation failed.
     */
    ADOperationFailure = 0,
    
    /**
     * The e-mail account specified in the FromConnectedAccounts predicate was not found.
     */
    ConnectedAccountNotFound = 1,
    
    /**
     * The Rule object in a CreateInboxRuleOperation has an Id. 
     * The Ids of new  rules are generated server side and should not be provided by the client.
     */
    CreateWithRuleId = 2,
    
    /**
     * The value is empty. An empty value is not allowed for the property.
     */
    EmptyValueFound = 3,
    
    /**
     * There already is a rule with the same priority. 
     */
    DuplicatedPriority = 4,
    
    /**
     * There are multiple operations against the same rule. 
     * Only one operation per rule is allowed.
     */
    DuplicatedOperationOnTheSameRule = 5,
    
    /**
     * The folder does not exist in the user's mailbox.
     */
    FolderDoesNotExist = 6,
    
    /**
     * The e-mail address is invalid.
     */
    InvalidAddress = 7,
    
    /**
     * The date range is invalid.
     */
    InvalidDateRange = 8,
    
    /**
     * The folder Id is invalid.
     */
    InvalidFolderId = 9,
    
    /**
     * The size range is invalid.
     */
    InvalidSizeRange = 10,
    
    /**
     * The value is invalid.
     */
    InvalidValue = 11,
    
    /**
     * The message classification was not found.
     */
    MessageClassificationNotFound = 12,
    
    /**
     * No action was specified. At least one action must be specified.
     */
    MissingAction = 13,
    
    /**
     * The required parameter is missing.
     */
    MissingParameter = 14,
    
    /**
     * The range value is missing.
     */
    MissingRangeValue = 15,
    
    /**
     * The property cannot be modified.
     */
    NotSettable = 16,
    
    /**
     * The recipient does not exist.
     */
    RecipientDoesNotExist = 17,
    
    /**
     * The rule was not found.
     */
    RuleNotFound = 18,
    
    /**
     * The size is less than zero.
     */
    SizeLessThanZero = 19,
    
    /**
     * The string value is too big.
     */
    StringValueTooBig = 20,
    
    /**
     * The address is unsupported.
     */
    UnsupportedAddress = 21,
    
    /**
     * An unexpected error occured.
     */
    UnexpectedError = 22,
    
    /**
     * The rule is not supported.
     */
    UnsupportedRule = 23
}

/**
 * Defines the available properties of a rule. 
 */
export enum RuleProperty {

    /**
     * The RuleId property of a rule.
     */
    RuleId = 0,

    /**
     * The DisplayName property of a rule.
     */
    DisplayName = 1,

    /**
     * The Priority property of a rule.
     */
    Priority = 2,

    /**
     * The IsNotSupported property of a rule.
     */
    IsNotSupported = 3,

    /**
     * The Actions property of a rule.
     */
    Actions = 4,

    /**
     * The Categories property of a rule's set of conditions.
     */
    ConditionCategories = 5,

    /**
     * The ContainsBodyStrings property of a rule's set of conditions.
     */
    ConditionContainsBodyStrings = 6,

    /**
     * The ContainsHeaderStrings property of a rule's set of conditions.
     */
    ConditionContainsHeaderStrings = 7,

    /**
     * The ContainsRecipientStrings property of a rule's set of conditions.
     */
    ConditionContainsRecipientStrings = 8,

    /**
     * The ContainsSenderStrings property of a rule's set of conditions.
     */
    ConditionContainsSenderStrings = 9,

    /**
     * The ContainsSubjectOrBodyStrings property of a rule's set of conditions.
     */
    ConditionContainsSubjectOrBodyStrings = 10,

    /**
     * The ContainsSubjectStrings property of a rule's set of conditions.
     */
    ConditionContainsSubjectStrings = 11,

    /**
     * The FlaggedForAction property of a rule's set of conditions.
     */
    ConditionFlaggedForAction = 12,

    /**
     * The FromAddresses property of a rule's set of conditions.
     */
    ConditionFromAddresses = 13,

    /**
     * The FromConnectedAccounts property of a rule's set of conditions.
     */
    ConditionFromConnectedAccounts = 14,

    /**
     * The HasAttachments property of a rule's set of conditions.
     */
    ConditionHasAttachments = 15,

    /**
     * The Importance property of a rule's set of conditions.
     */
    ConditionImportance = 16,

    /**
     * The IsApprovalRequest property of a rule's set of conditions.
     */
    ConditionIsApprovalRequest = 17,

    /**
     * The IsAutomaticForward property of a rule's set of conditions.
     */
    ConditionIsAutomaticForward = 18,

    /**
     * The IsAutomaticReply property of a rule's set of conditions.
     */
    ConditionIsAutomaticReply = 19,

    /**
     * The IsEncrypted property of a rule's set of conditions.
     */
    ConditionIsEncrypted = 20,

    /**
     * The IsMeetingRequest property of a rule's set of conditions.
     */
    ConditionIsMeetingRequest = 21,

    /**
     * The IsMeetingResponse property of a rule's set of conditions.
     */
    ConditionIsMeetingResponse = 22,

    /**
     * The IsNonDeliveryReport property of a rule's set of conditions.
     */
    ConditionIsNonDeliveryReport = 23,

    /**
     * The IsPermissionControlled property of a rule's set of conditions.
     */
    ConditionIsPermissionControlled = 24,

    /**
     * The IsRead property of a rule's set of conditions.
     */
    ConditionIsRead = 25,

    /**
     * The IsSigned property of a rule's set of conditions.
     */
    ConditionIsSigned = 26,

    /**
     * The IsVoicemail property of a rule's set of conditions.
     */
    ConditionIsVoicemail = 27,

    /**
     * The IsReadReceipt property of a rule's set of conditions.
     */
    ConditionIsReadReceipt = 28,

    /**
     * The ItemClasses property of a rule's set of conditions.
     */
    ConditionItemClasses = 29,

    /**
     * The MessageClassifications property of a rule's set of conditions.
     */
    ConditionMessageClassifications = 30,

    /**
     * The NotSentToMe property of a rule's set of conditions.
     */
    ConditionNotSentToMe = 31,

    /**
     * The SentCcMe property of a rule's set of conditions.
     */
    ConditionSentCcMe = 32,

    /**
     * The SentOnlyToMe property of a rule's set of conditions.
     */
    ConditionSentOnlyToMe = 33,

    /**
     * The SentToAddresses property of a rule's set of conditions.
     */
    ConditionSentToAddresses = 34,

    /**
     * The SentToMe property of a rule's set of conditions.
     */
    ConditionSentToMe = 35,

    /**
     * The SentToOrCcMe property of a rule's set of conditions.
     */
    ConditionSentToOrCcMe = 36,

    /**
     * The Sensitivity property of a rule's set of conditions.
     */
    ConditionSensitivity = 37,

    /**
     * The WithinDateRange property of a rule's set of conditions.
     */
    ConditionWithinDateRange = 38,

    /**
     * The WithinSizeRange property of a rule's set of conditions.
     */
    ConditionWithinSizeRange = 39,

    /**
     * The Categories property of a rule's set of exceptions.
     */
    ExceptionCategories = 40,

    /**
     * The ContainsBodyStrings property of a rule's set of exceptions.
     */
    ExceptionContainsBodyStrings = 41,

    /**
     * The ContainsHeaderStrings property of a rule's set of exceptions.
     */
    ExceptionContainsHeaderStrings = 42,

    /**
     * The ContainsRecipientStrings property of a rule's set of exceptions.
     */
    ExceptionContainsRecipientStrings = 43,

    /**
     * The ContainsSenderStrings property of a rule's set of exceptions.
     */
    ExceptionContainsSenderStrings = 44,

    /**
     * The ContainsSubjectOrBodyStrings property of a rule's set of exceptions.
     */
    ExceptionContainsSubjectOrBodyStrings = 45,

    /**
     * The ContainsSubjectStrings property of a rule's set of exceptions.
     */
    ExceptionContainsSubjectStrings = 46,

    /**
     * The FlaggedForAction property of a rule's set of exceptions.
     */
    ExceptionFlaggedForAction = 47,

    /**
     * The FromAddresses property of a rule's set of exceptions.
     */
    ExceptionFromAddresses = 48,

    /**
     * The FromConnectedAccounts property of a rule's set of exceptions.
     */
    ExceptionFromConnectedAccounts = 49,

    /**
     * The HasAttachments property of a rule's set of exceptions.
     */
    ExceptionHasAttachments = 50,

    /**
     * The Importance property of a rule's set of exceptions.
     */
    ExceptionImportance = 51,

    /**
     * The IsApprovalRequest property of a rule's set of exceptions.
     */
    ExceptionIsApprovalRequest = 52,

    /**
     * The IsAutomaticForward property of a rule's set of exceptions.
     */
    ExceptionIsAutomaticForward = 53,

    /**
     * The IsAutomaticReply property of a rule's set of exceptions.
     */
    ExceptionIsAutomaticReply = 54,

    /**
     * The IsEncrypted property of a rule's set of exceptions.
     */
    ExceptionIsEncrypted = 55,

    /**
     * The IsMeetingRequest property of a rule's set of exceptions.
     */
    ExceptionIsMeetingRequest = 56,

    /**
     * The IsMeetingResponse property of a rule's set of exceptions.
     */
    ExceptionIsMeetingResponse = 57,

    /**
     * The IsNonDeliveryReport property of a rule's set of exceptions.
     */
    ExceptionIsNonDeliveryReport = 58,

    /**
     * The IsPermissionControlled property of a rule's set of exceptions.
     */
    ExceptionIsPermissionControlled = 59,

    /**
     * The IsRead property of a rule's set of exceptions.
     */
    ExceptionIsRead = 60,

    /**
     * The IsSigned property of a rule's set of exceptions.
     */
    ExceptionIsSigned = 61,

    /**
     * The IsVoicemail property of a rule's set of exceptions.
     */
    ExceptionIsVoicemail = 62,

    /**
     * The ItemClasses property of a rule's set of exceptions.
     */
    ExceptionItemClasses = 63,

    /**
     * The MessageClassifications property of a rule's set of exceptions.
     */
    ExceptionMessageClassifications = 64,

    /**
     * The NotSentToMe property of a rule's set of exceptions.
     */
    ExceptionNotSentToMe = 65,

    /**
     * The SentCcMe property of a rule's set of exceptions.
     */
    ExceptionSentCcMe = 66,

    /**
     * The SentOnlyToMe property of a rule's set of exceptions.
     */
    ExceptionSentOnlyToMe = 67,

    /**
     * The SentToAddresses property of a rule's set of exceptions.
     */
    ExceptionSentToAddresses = 68,

    /**
     * The SentToMe property of a rule's set of exceptions.
     */
    ExceptionSentToMe = 69,

    /**
     * The SentToOrCcMe property of a rule's set of exceptions.
     */
    ExceptionSentToOrCcMe = 70,

    /**
     * The Sensitivity property of a rule's set of exceptions.
     */
    ExceptionSensitivity = 71,

    /**
     * The WithinDateRange property of a rule's set of exceptions.
     */
    ExceptionWithinDateRange = 72,

    /**
     * The WithinSizeRange property of a rule's set of exceptions.
     */
    ExceptionWithinSizeRange = 73,

    /**
     * The Categories property in a rule's set of actions.
     */
    ActionCategories = 74,

    /**
     * The CopyToFolder property in a rule's set of actions.
     */
    ActionCopyToFolder = 75,

    /**
     * The Delete property in a rule's set of actions.
     */
    ActionDelete = 76,

    /**
     * The ForwardAsAttachmentToRecipients property in a rule's set of actions.
     */
    ActionForwardAsAttachmentToRecipients = 77,

    /**
     * The ForwardToRecipients property in a rule's set of actions.
     */
    ActionForwardToRecipients = 78,

    /**
     * The Importance property in a rule's set of actions.
     */
    ActionImportance = 79,

    /**
     * The MarkAsRead property in a rule's set of actions.
     */
    ActionMarkAsRead = 80,

    /**
     * The MoveToFolder property in a rule's set of actions.
     */
    ActionMoveToFolder = 81,

    /**
     * The PermanentDelete property in a rule's set of actions.
     */
    ActionPermanentDelete = 82,

    /**
     * The RedirectToRecipients property in a rule's set of actions.
     */
    ActionRedirectToRecipients = 83,

    /**
     * The SendSMSAlertToRecipients property in a rule's set of actions.
     */
    ActionSendSMSAlertToRecipients = 84,

    /**
     * The ServerReplyWithMessage property in a rule's set of actions.
     */
    ActionServerReplyWithMessage = 85,

    /**
     * The StopProcessingRules property in a rule's set of actions.
     */
    ActionStopProcessingRules = 86,

    /**
     * The IsEnabled property of a rule, indicating if the rule is enabled.
     */
    IsEnabled = 87,

    /**
     * The IsInError property of a rule, indicating if the rule is in error.
     */
    IsInError = 88,

    /**
     * The Conditions property of a rule, contains all conditions of the rule.
     */
    Conditions = 89,

    /**
     * The Exceptions property of a rule, contains all exceptions of the rule.
     */
    Exceptions = 90
}

export module RuleProperty {

    /**EwsEnumAttribute */
    export function FromEwsEnumString(value: string): RuleProperty {
        return RuleProperty[value.replace(":", "")];
    }

    /**EwsEnumAttribute */
    export function ToEwsEnumString(value: RuleProperty): string {
        let startsWith = ["Condition", "Exception", "Action"];
        let str2 = null;
        startsWith.map((str)=>{
            if(RuleProperty[value].indexOf(str) === 0){
                str2 = RuleProperty[value].replace(str, str + ":");
            }
        });
        
        return str2 || RuleProperty[value];
    }
}

/**
 * Defines the scope of a search folder.
 */
export enum SearchFolderTraversal {
    
    /**
     * Items belonging to the root folder are retrieved.
     */
    Shallow = 0,
    
    /**
     * Items belonging to the root folder and its sub-folders are retrieved.
     */
    Deep = 1
}

/**
 * Defines the page direction for mailbox search.
 */
export enum SearchPageDirection {
    
    /**
     * Navigate to next page.
     */
    Next = 0,
    
    /**
     * Navigate to previous page.
     */
    Previous = 1
}

/**
 * Defines the type of search result.
 */
export enum SearchResultType {
    
    /**
     * Keyword statistics only.
     */
    StatisticsOnly = 0,
    
    /**
     * Preview only.
     */
    PreviewOnly = 1
}

/**
 * Defines how meeting cancellations should be sent to attendees when an appointment is deleted.
 */
export enum SendCancellationsMode {
    
    /**
     * No meeting cancellation is sent.
     */
    SendToNone = 0,
    
    /**
     * Meeting cancellations are sent to all attendees.
     */
    SendOnlyToAll = 1,
    
    /**
     * Meeting cancellations are sent to all attendees and a copy of the cancellation message is saved in the organizer's Sent Items folder.
     */
    SendToAllAndSaveCopy = 2
}

/**
 * Defines if/how meeting invitations are sent.
 */
export enum SendInvitationsMode {
    
    /**
     * No meeting invitation is sent.
     */
    SendToNone = 0,
    
    /**
     * Meeting invitations are sent to all attendees.
     */
    SendOnlyToAll = 1,
    
    /**
     * Meeting invitations are sent to all attendees and a copy of the invitation message is saved.
     */
    SendToAllAndSaveCopy = 2
}

/**
 * Defines if/how meeting invitations or cancellations should be sent to attendees when an appointment is updated.
 */
export enum SendInvitationsOrCancellationsMode {
    
    /**
     * No meeting invitation/cancellation is sent.
     */
    SendToNone = 0,
    
    /**
     * Meeting invitations/cancellations are sent to all attendees.
     */
    SendOnlyToAll = 1,
    
    /**
     * Meeting invitations/cancellations are sent only to attendees that have been added or modified.
     */
    SendOnlyToChanged = 2,
    
    /**
     * Meeting invitations/cancellations are sent to all attendees and a copy is saved in the organizer's Sent Items folder.
     */
    SendToAllAndSaveCopy = 3,
    
    /**
     * Meeting invitations/cancellations are sent only to attendees that have been added or modified and a copy is saved in the organizer's Sent Items folder.
     */
    SendToChangedAndSaveCopy = 4
}

/**
 * The values indicate the types of item icons to display.
 */
export enum SendPrompt {
    
    /**
     * None
     */
    None = 0,
    
    /**
     * Send
     */
    Send = 1,
    
    /**
     * VotingOption
     */
    VotingOption = 2
}

/**
 * Defines the sensitivity of an item.
 */
export enum Sensitivity {
    
    /**
     * The item has a normal sensitivity.
     */
    Normal = 0,
    
    /**
     * The item is personal.
     */
    Personal = 1,
    
    /**
     * The item is private.
     */
    Private = 2,
    
    /**
     * The item is confidential.
     */
    Confidential = 3
}
/**
 * Defines the error codes that can be returned by the Exchange Web Services.
 */
export enum ServiceError {
    /**
     * NoError. Indicates that an error has not occurred.
     */
    NoError = 0,
    /**
     * Access is denied. Check credentials and try again.
     */
    ErrorAccessDenied,
    /**
     * The impersonation authentication header should not be included.
     */
    ErrorAccessModeSpecified,
    /**
     * Account is disabled. Contact the account administrator.
     */
    ErrorAccountDisabled,
    /**
     * Failed to add one or more delegates.
     */
    ErrorAddDelegatesFailed,
    /**
     * ErrorAddressSpaceNotFound
     */
    ErrorAddressSpaceNotFound,
    /**
     * Active Directory operation did not succeed. Try again later.
     */
    ErrorADOperation,
    /**
     * Invalid search criteria.
     */
    ErrorADSessionFilter,
    /**
     * Active Directory is unavailable. Try again later.
     */
    ErrorADUnavailable,
    /**
     * AffectedTaskOccurrences attribute is required for Task items.
     */
    ErrorAffectedTaskOccurrencesRequired,
    /**
     * The conversation action alwayscategorize or alwaysmove or alwaysdelete has failed.
     */
    ErrorApplyConversationActionFailed,
    /**
     * Archive mailbox not enabled
     */
    ErrorArchiveMailboxNotEnabled,
    /**
     * Unable to create the folder in archive mailbox to which the items will be archived
     */
    ErrorArchiveFolderPathCreation,
    /**
     * Unable to discover archive mailbox
     */
    ErrorArchiveMailboxServiceDiscoveryFailed,
    /**
     * The item has attachment at more than the maximum supported nest level.
     */
    ErrorAttachmentNestLevelLimitExceeded,
    /**
     * The file attachment exceeds the maximum supported size.
     */
    ErrorAttachmentSizeLimitExceeded,
    /**
     * ErrorAutoDiscoverFailed
     */
    ErrorAutoDiscoverFailed,
    /**
     * ErrorAvailabilityConfigNotFound
     */
    ErrorAvailabilityConfigNotFound,
    /**
     * Item was not processed as a result of a previous error.
     */
    ErrorBatchProcessingStopped,
    /**
     * Can not move or copy a calendar occurrence.
     */
    ErrorCalendarCannotMoveOrCopyOccurrence,
    /**
     * Cannot update calendar item that has already been deleted.
     */
    ErrorCalendarCannotUpdateDeletedItem,
    /**
     * The Id specified does not represent an occurrence.
     */
    ErrorCalendarCannotUseIdForOccurrenceId,
    /**
     * The specified Id does not represent a recurring master item.
     */
    ErrorCalendarCannotUseIdForRecurringMasterId,
    /**
     * Calendar item duration is too long.
     */
    ErrorCalendarDurationIsTooLong,
    /**
     * EndDate is earlier than StartDate
     */
    ErrorCalendarEndDateIsEarlierThanStartDate,
    /**
     * Cannot request CalendarView for the folder.
     */
    ErrorCalendarFolderIsInvalidForCalendarView,
    /**
     * Attribute has an invalid value.
     */
    ErrorCalendarInvalidAttributeValue,
    /**
     * The value of the DaysOfWeek property is not valid for time change pattern of time zone.
     */
    ErrorCalendarInvalidDayForTimeChangePattern,
    /**
     * The value of the DaysOfWeek property is invalid for a weekly recurrence.
     */
    ErrorCalendarInvalidDayForWeeklyRecurrence,
    /**
     * The property has invalid state.
     */
    ErrorCalendarInvalidPropertyState,
    /**
     * The property has an invalid value.
     */
    ErrorCalendarInvalidPropertyValue,
    /**
     * The recurrence is invalid.
     */
    ErrorCalendarInvalidRecurrence,
    /**
     * TimeZone is invalid.
     */
    ErrorCalendarInvalidTimeZone,
    /**
     * A meeting that's been canceled can't be accepted.
     */
    ErrorCalendarIsCancelledForAccept,
    /**
     * A canceled meeting can't be declined.
     */
    ErrorCalendarIsCancelledForDecline,
    /**
     * A canceled meeting can't be removed.
     */
    ErrorCalendarIsCancelledForRemove,
    /**
     * A canceled meeting can't be accepted tentatively.
     */
    ErrorCalendarIsCancelledForTentative,
    /**
     * AcceptItem action is invalid for a delegated meeting message.
     */
    ErrorCalendarIsDelegatedForAccept,
    /**
     * DeclineItem operation is invalid for a delegated meeting message.
     */
    ErrorCalendarIsDelegatedForDecline,
    /**
     * RemoveItem action is invalid for a delegated meeting message.
     */
    ErrorCalendarIsDelegatedForRemove,
    /**
     * The TentativelyAcceptItem action isn't valid for a delegated meeting message.
     */
    ErrorCalendarIsDelegatedForTentative,
    /**
     * User must be an organizer for CancelCalendarItem action.
     */
    ErrorCalendarIsNotOrganizer,
    /**
     * The user is the organizer of this meeting, and cannot, therefore, accept it.
     */
    ErrorCalendarIsOrganizerForAccept,
    /**
     * The user is the organizer of this meeting, and cannot, therefore, decline it.
     */
    ErrorCalendarIsOrganizerForDecline,
    /**
     * The user is the organizer of this meeting, and cannot, therefore, remove it.
     */
    ErrorCalendarIsOrganizerForRemove,
    /**
     * The user is the organizer of this meeting, and therefore can't tentatively accept it.
     */
    ErrorCalendarIsOrganizerForTentative,
    /**
     * The meeting request is out of date. The calendar couldn't be updated.
     */
    ErrorCalendarMeetingRequestIsOutOfDate,
    /**
     * Occurrence index is out of recurrence range.
     */
    ErrorCalendarOccurrenceIndexIsOutOfRecurrenceRange,
    /**
     * Occurrence with this index was previously deleted from the recurrence.
     */
    ErrorCalendarOccurrenceIsDeletedFromRecurrence,
    /**
     * The calendar property falls out of valid range.
     */
    ErrorCalendarOutOfRange,
    /**
     * The specified view range exceeds the maximum range of two years.
     */
    ErrorCalendarViewRangeTooBig,
    /**
     * Failed to get valid Active Directory information for the calling account. Confirm that it
     * is a valid Active Directory account.
     */
    ErrorCallerIsInvalidADAccount,
    /**
     * Cannot archive items in Calendar, contact to task folders
     */
    ErrorCannotArchiveCalendarContactTaskFolderException,
    /**
     * Cannot archive items in archive mailboxes
     */
    ErrorCannotArchiveItemsInArchiveMailbox,
    /**
     * Cannot archive items in public folders
     */
    ErrorCannotArchiveItemsInPublicFolders,
    /**
     * Cannot create a calendar item in a non-calendar folder.
     */
    ErrorCannotCreateCalendarItemInNonCalendarFolder,
    /**
     * Cannot create a contact in a non-contact folder.
     */
    ErrorCannotCreateContactInNonContactFolder,
    /**
     * Cannot create a post item in a folder that is not a mail folder.
     */
    ErrorCannotCreatePostItemInNonMailFolder,
    /**
     * Cannot create a task in a non-task Folder.
     */
    ErrorCannotCreateTaskInNonTaskFolder,
    /**
     * Object cannot be deleted.
     */
    ErrorCannotDeleteObject,
    /**
     * Deleting a task occurrence is not permitted on non-recurring tasks, on the last
     * occurrence of a recurring task or on a regenerating task.
     */
    ErrorCannotDeleteTaskOccurrence,
    /**
     * Mandatory extensions cannot be disabled by end users
     */
    ErrorCannotDisableMandatoryExtension,
    /**
     * Folder cannot be emptied.
     */
    ErrorCannotEmptyFolder,
    /**
     * Cannot get external ECP URL. This might happen if external ECP URL isn't configured
     */
    ErrorCannotGetExternalEcpUrl,
    /**
     * Unable to read the folder path for the source folder while archiving items
     */
    ErrorCannotGetSourceFolderPath,
    /**
     * The attachment could not be opened.
     */
    ErrorCannotOpenFileAttachment,
    /**
     * Expected a PermissionSet but received a CalendarPermissionSet.
     */
    ErrorCannotSetCalendarPermissionOnNonCalendarFolder,
    /**
     * Expected a CalendarPermissionSet but received a PermissionSet.
     */
    ErrorCannotSetNonCalendarPermissionOnCalendarFolder,
    /**
     * Cannot set UnknownEntries on a PermissionSet or CalendarPermissionSet.
     */
    ErrorCannotSetPermissionUnknownEntries,
    /**
     * Cannot specify search folders as source folders while archiving items
     */
    ErrorCannotSpecifySearchFolderAsSourceFolder,
    /**
     * Expected an item Id but received a folder Id.
     */
    ErrorCannotUseFolderIdForItemId,
    /**
     * Expected a folder Id but received an item Id.
     */
    ErrorCannotUseItemIdForFolderId,
    /**
     * ChangeKey is required if overriding automatic conflict resolution.
     */
    ErrorChangeKeyRequired,
    /**
     * ChangeKey is required for this operation.
     */
    ErrorChangeKeyRequiredForWriteOperations,
    /**
     * ErrorClientDisconnected
     */
    ErrorClientDisconnected,
    /**
     * Connection did not succeed. Try again later.
     */
    ErrorConnectionFailed,
    /**
     * The Contains filter can only be used for string properties.
     */
    ErrorContainsFilterWrongType,
    /**
     * Content conversion failed.
     */
    ErrorContentConversionFailed,
    /**
     * Data is corrupt.
     */
    ErrorCorruptData,
    /**
     * Unable to create item. The user account does not have the right to create items.
     */
    ErrorCreateItemAccessDenied,
    /**
     * Failed to create one or more of the specified managed folders.
     */
    ErrorCreateManagedFolderPartialCompletion,
    /**
     * Unable to create subfolder. The user account does not have the right to create
     * subfolders.
     */
    ErrorCreateSubfolderAccessDenied,
    /**
     * Move and Copy operations across mailbox boundaries are not permitted.
     */
    ErrorCrossMailboxMoveCopy,
    /**
     * This request isn't allowed because the Client Access server that's servicing the request
     * is in a different site than the requested resource. Use Autodiscover to find the correct
     * URL for accessing the specified resource.
     */
    ErrorCrossSiteRequest,
    /**
     * Property exceeds the maximum supported size.
     */
    ErrorDataSizeLimitExceeded,
    /**
     * Invalid data source operation.
     */
    ErrorDataSourceOperation,
    /**
     * The user is already a delegate for the mailbox.
     */
    ErrorDelegateAlreadyExists,
    /**
     * This is an invalid operation. Cannot add owner as delegate.
     */
    ErrorDelegateCannotAddOwner,
    /**
     * Delegate is not configured properly.
     */
    ErrorDelegateMissingConfiguration,
    /**
     * The delegate does not map to a user in the Active Directory.
     */
    ErrorDelegateNoUser,
    /**
     * Cannot add the delegate user. Failed to validate the changes.
     */
    ErrorDelegateValidationFailed,
    /**
     * Distinguished folders cannot be deleted.
     */
    ErrorDeleteDistinguishedFolder,
    /**
     * The deletion failed.
     */
    ErrorDeleteItemsFailed,
    /**
     * DistinguishedUser should not be specified for a Delegate User.
     */
    ErrorDistinguishedUserNotSupported,
    /**
     * The group member doesn't exist.
     */
    ErrorDistributionListMemberNotExist,
    /**
     * The specified list of managed folder names contains duplicate entries.
     */
    ErrorDuplicateInputFolderNames,
    /**
     * A duplicate exchange legacy DN.
     */
    ErrorDuplicateLegacyDistinguishedName,
    /**
     * A duplicate SOAP header was received.
     */
    ErrorDuplicateSOAPHeader,
    /**
     * The specified permission set contains duplicate UserIds.
     */
    ErrorDuplicateUserIdsSpecified,
    /**
     * The email address associated with a folder Id does not match the mailbox you are
     * operating on.
     */
    ErrorEmailAddressMismatch,
    /**
     * The watermark used for creating this subscription was not found.
     */
    ErrorEventNotFound,
    /**
     * You have exceeded the available concurrent connections for your account.  Try again once
     * your other requests have completed.
     */
    ErrorExceededConnectionCount,
    /**
     * You have exceeded the maximum number of objects that can be returned for the find
     * operation. Use paging to reduce the result size and try your request again.
     */
    ErrorExceededFindCountLimit,
    /**
     * You have exceeded the available subscriptions for your account.  Remove unnecessary
     * subscriptions and try your request again.
     */
    ErrorExceededSubscriptionCount,
    /**
     * Subscription information is not available. Subscription is expired.
     */
    ErrorExpiredSubscription,
    /**
     * Extension with id specified was not found
     */
    ErrorExtensionNotFound,
    /**
     * The folder is corrupt.
     */
    ErrorFolderCorrupt,
    /**
     * A folder with the specified name already exists.
     */
    ErrorFolderExists,
    /**
     * The specified folder could not be found in the store.
     */
    ErrorFolderNotFound,
    /**
     * ErrorFolderPropertRequestFailed
     */
    ErrorFolderPropertRequestFailed,
    /**
     * The folder save operation did not succeed.
     */
    ErrorFolderSave,
    /**
     * The save operation failed or partially succeeded.
     */
    ErrorFolderSaveFailed,
    /**
     * The folder save operation failed due to invalid property values.
     */
    ErrorFolderSavePropertyError,
    /**
     * ErrorFreeBusyDLLimitReached
     */
    ErrorFreeBusyDLLimitReached,
    /**
     * ErrorFreeBusyGenerationFailed
     */
    ErrorFreeBusyGenerationFailed,
    /**
     * ErrorGetServerSecurityDescriptorFailed
     */
    ErrorGetServerSecurityDescriptorFailed,
    /**
     * ErrorImContactLimitReached
     */
    ErrorImContactLimitReached,
    /**
     * ErrorImGroupDisplayNameAlreadyExists
     */
    ErrorImGroupDisplayNameAlreadyExists,
    /**
     * ErrorImGroupLimitReached
     */
    ErrorImGroupLimitReached,
    /**
     * The account does not have permission to impersonate the requested user.
     */
    ErrorImpersonateUserDenied,
    /**
     * ErrorImpersonationDenied
     */
    ErrorImpersonationDenied,
    /**
     * Impersonation failed.
     */
    ErrorImpersonationFailed,
    /**
     * ErrorInboxRulesValidationError
     */
    ErrorInboxRulesValidationError,
    /**
     * The request is valid but does not specify the correct server version in the
     * RequestServerVersion SOAP header.  Ensure that the RequestServerVersion SOAP header is
     * set with the correct RequestServerVersionValue.
     */
    ErrorIncorrectSchemaVersion,
    /**
     * An object within a change description must contain one and only one property to modify.
     */
    ErrorIncorrectUpdatePropertyCount,
    /**
     * ErrorIndividualMailboxLimitReached
     */
    ErrorIndividualMailboxLimitReached,
    /**
     * Resources are unavailable. Try again later.
     */
    ErrorInsufficientResources,
    /**
     * An internal server error occurred. The operation failed.
     */
    ErrorInternalServerError,
    /**
     * An internal server error occurred. Try again later.
     */
    ErrorInternalServerTransientError,
    /**
     * ErrorInvalidAccessLevel
     */
    ErrorInvalidAccessLevel,
    /**
     * ErrorInvalidArgument
     */
    ErrorInvalidArgument,
    /**
     * The specified attachment Id is invalid.
     */
    ErrorInvalidAttachmentId,
    /**
     * Attachment subfilters must have a single TextFilter therein.
     */
    ErrorInvalidAttachmentSubfilter,
    /**
     * Attachment subfilters must have a single TextFilter on the display name only.
     */
    ErrorInvalidAttachmentSubfilterTextFilter,
    /**
     * ErrorInvalidAuthorizationContext
     */
    ErrorInvalidAuthorizationContext,
    /**
     * The change key is invalid.
     */
    ErrorInvalidChangeKey,
    /**
     * ErrorInvalidClientSecurityContext
     */
    ErrorInvalidClientSecurityContext,
    /**
     * CompleteDate cannot be set to a date in the future.
     */
    ErrorInvalidCompleteDate,
    /**
     * The e-mail address that was supplied isn't valid.
     */
    ErrorInvalidContactEmailAddress,
    /**
     * The e-mail index supplied isn't valid.
     */
    ErrorInvalidContactEmailIndex,
    /**
     * ErrorInvalidCrossForestCredentials
     */
    ErrorInvalidCrossForestCredentials,
    /**
     * Invalid Delegate Folder Permission.
     */
    ErrorInvalidDelegatePermission,
    /**
     * One or more UserId parameters are invalid. Make sure that the PrimarySmtpAddress, Sid and
     * DisplayName properties refer to the same user when specified.
     */
    ErrorInvalidDelegateUserId,
    /**
     * An ExchangeImpersonation SOAP header must contain a user principal name, user SID, or
     * primary SMTP address.
     */
    ErrorInvalidExchangeImpersonationHeaderData,
    /**
     * Second operand in Excludes expression must be uint compatible.
     */
    ErrorInvalidExcludesRestriction,
    /**
     * FieldURI can only be used in Contains expressions.
     */
    ErrorInvalidExpressionTypeForSubFilter,
    /**
     * The extended property attribute combination is invalid.
     */
    ErrorInvalidExtendedProperty,
    /**
     * The extended property value is inconsistent with its type.
     */
    ErrorInvalidExtendedPropertyValue,
    /**
     * The original sender of the message (initiator field in the sharing metadata) is not
     * valid.
     */
    ErrorInvalidExternalSharingInitiator,
    /**
     * The sharing message is not intended for this caller.
     */
    ErrorInvalidExternalSharingSubscriber,
    /**
     * The organization is either not federated, or it's configured incorrectly.
     */
    ErrorInvalidFederatedOrganizationId,
    /**
     * Folder Id is invalid.
     */
    ErrorInvalidFolderId,
    /**
     * ErrorInvalidFolderTypeForOperation
     */
    ErrorInvalidFolderTypeForOperation,
    /**
     * Invalid fractional paging offset values.
     */
    ErrorInvalidFractionalPagingParameters,
    /**
     * ErrorInvalidFreeBusyViewType
     */
    ErrorInvalidFreeBusyViewType,
    /**
     * Either DataType or SharedFolderId must be specified, but not both.
     */
    ErrorInvalidGetSharingFolderRequest,
    /**
     * The Id is invalid.
     */
    ErrorInvalidId,
    /**
     * The Im Contact id was invalid.
     */
    ErrorInvalidImContactId,
    /**
     * The Im Distribution Group Smtp Address was invalid.
     */
    ErrorInvalidImDistributionGroupSmtpAddress,
    /**
     * The Im Contact id was invalid.
     */
    ErrorInvalidImGroupId,
    /**
     * Id must be non-empty.
     */
    ErrorInvalidIdEmpty,
    /**
     * Id is malformed.
     */
    ErrorInvalidIdMalformed,
    /**
     * The EWS Id is in EwsLegacyId format which is not supported by the Exchange version
     * specified by your request. Please use the ConvertId method to convert from EwsLegacyId 
     * to EwsId format.
     */
    ErrorInvalidIdMalformedEwsLegacyIdFormat,
    /**
     * Moniker exceeded allowable length.
     */
    ErrorInvalidIdMonikerTooLong,
    /**
     * The Id does not represent an item attachment.
     */
    ErrorInvalidIdNotAnItemAttachmentId,
    /**
     * ResolveNames returned an invalid Id.
     */
    ErrorInvalidIdReturnedByResolveNames,
    /**
     * Id exceeded allowable length.
     */
    ErrorInvalidIdStoreObjectIdTooLong,
    /**
     * Too many attachment levels.
     */
    ErrorInvalidIdTooManyAttachmentLevels,
    /**
     * The Id Xml is invalid.
     */
    ErrorInvalidIdXml,
    /**
     * The specified indexed paging values are invalid.
     */
    ErrorInvalidIndexedPagingParameters,
    /**
     * Only one child node is allowed when setting an Internet Message Header.
     */
    ErrorInvalidInternetHeaderChildNodes,
    /**
     * Item type is invalid for AcceptItem action.
     */
    ErrorInvalidItemForOperationAcceptItem,
    /**
     * Item type is invalid for ArchiveItem action.
     */
    ErrorInvalidItemForOperationArchiveItem,
    /**
     * Item type is invalid for CancelCalendarItem action.
     */
    ErrorInvalidItemForOperationCancelItem,
    /**
     * Item type is invalid for CreateItem operation.
     */
    ErrorInvalidItemForOperationCreateItem,
    /**
     * Item type is invalid for CreateItemAttachment operation.
     */
    ErrorInvalidItemForOperationCreateItemAttachment,
    /**
     * Item type is invalid for DeclineItem operation.
     */
    ErrorInvalidItemForOperationDeclineItem,
    /**
     * ExpandDL operation does not support this item type.
     */
    ErrorInvalidItemForOperationExpandDL,
    /**
     * Item type is invalid for RemoveItem operation.
     */
    ErrorInvalidItemForOperationRemoveItem,
    /**
     * Item type is invalid for SendItem operation.
     */
    ErrorInvalidItemForOperationSendItem,
    /**
     * The item of this type is invalid for TentativelyAcceptItem action.
     */
    ErrorInvalidItemForOperationTentative,
    /**
     * The logon type isn't valid.
     */
    ErrorInvalidLogonType,
    /**
     * Mailbox is invalid. Verify the specified Mailbox property.
     */
    ErrorInvalidMailbox,
    /**
     * The Managed Folder property is corrupt or otherwise invalid.
     */
    ErrorInvalidManagedFolderProperty,
    /**
     * The managed folder has an invalid quota.
     */
    ErrorInvalidManagedFolderQuota,
    /**
     * The managed folder has an invalid storage limit value.
     */
    ErrorInvalidManagedFolderSize,
    /**
     * ErrorInvalidMergedFreeBusyInterval
     */
    ErrorInvalidMergedFreeBusyInterval,
    /**
     * The specified value is not a valid name for name resolution.
     */
    ErrorInvalidNameForNameResolution,
    /**
     * ErrorInvalidNetworkServiceContext
     */
    ErrorInvalidNetworkServiceContext,
    /**
     * ErrorInvalidOofParameter
     */
    ErrorInvalidOofParameter,
    /**
     * ErrorInvalidOperation
     */
    ErrorInvalidOperation,
    /**
     * ErrorInvalidOrganizationRelationshipForFreeBusy
     */
    ErrorInvalidOrganizationRelationshipForFreeBusy,
    /**
     * MaxEntriesReturned must be greater than zero.
     */
    ErrorInvalidPagingMaxRows,
    /**
     * Cannot create a subfolder within a SearchFolder.
     */
    ErrorInvalidParentFolder,
    /**
     * PercentComplete must be an integer between 0 and 100.
     */
    ErrorInvalidPercentCompleteValue,
    /**
     * The permission settings were not valid.
     */
    ErrorInvalidPermissionSettings,
    /**
     * The phone call ID isn't valid.
     */
    ErrorInvalidPhoneCallId,
    /**
     * The phone number isn't valid.
     */
    ErrorInvalidPhoneNumber,
    /**
     * The append action is not supported for this property.
     */
    ErrorInvalidPropertyAppend,
    /**
     * The delete action is not supported for this property.
     */
    ErrorInvalidPropertyDelete,
    /**
     * Property cannot be used in Exists expression.  Use IsEqualTo instead.
     */
    ErrorInvalidPropertyForExists,
    /**
     * Property is not valid for this operation.
     */
    ErrorInvalidPropertyForOperation,
    /**
     * Property is not valid for this object type.
     */
    ErrorInvalidPropertyRequest,
    /**
     * Set action is invalid for property.
     */
    ErrorInvalidPropertySet,
    /**
     * Update operation is invalid for property of a sent message.
     */
    ErrorInvalidPropertyUpdateSentMessage,
    /**
     * The proxy security context is invalid.
     */
    ErrorInvalidProxySecurityContext,
    /**
     * SubscriptionId is invalid. Subscription is not a pull subscription.
     */
    ErrorInvalidPullSubscriptionId,
    /**
     * URL specified for push subscription is invalid.
     */
    ErrorInvalidPushSubscriptionUrl,
    /**
     * One or more recipients are invalid.
     */
    ErrorInvalidRecipients,
    /**
     * Recipient subfilters are only supported when there are two expressions within a single
     * AND filter.
     */
    ErrorInvalidRecipientSubfilter,
    /**
     * Recipient subfilter must have a comparison filter that tests equality to recipient type
     * or attendee type.
     */
    ErrorInvalidRecipientSubfilterComparison,
    /**
     * Recipient subfilters must have a text filter and a comparison filter in that order.
     */
    ErrorInvalidRecipientSubfilterOrder,
    /**
     * Recipient subfilter must have a TextFilter on the SMTP address only.
     */
    ErrorInvalidRecipientSubfilterTextFilter,
    /**
     * The reference item does not support the requested operation.
     */
    ErrorInvalidReferenceItem,
    /**
     * The request is invalid.
     */
    ErrorInvalidRequest,
    /**
     * The restriction is invalid.
     */
    ErrorInvalidRestriction,
    /**
     * ErrorInvalidRetentionIdTagTypeMismatch.
     */
    ErrorInvalidRetentionTagTypeMismatch,
    /**
     * ErrorInvalidRetentionTagInvisible.
     */
    ErrorInvalidRetentionTagInvisible,
    /**
     * ErrorInvalidRetentionTagInheritance.
     */
    ErrorInvalidRetentionTagInheritance,
    /**
     * ErrorInvalidRetentionTagIdGuid.
     */
    ErrorInvalidRetentionTagIdGuid,
    /**
     * The routing type format is invalid.
     */
    ErrorInvalidRoutingType,
    /**
     * ErrorInvalidScheduledOofDuration
     */
    ErrorInvalidScheduledOofDuration,
    /**
     * The mailbox that was requested doesn't support the specified RequestServerVersion.
     */
    ErrorInvalidSchemaVersionForMailboxVersion,
    /**
     * ErrorInvalidSecurityDescriptor
     */
    ErrorInvalidSecurityDescriptor,
    /**
     * Invalid combination of SaveItemToFolder attribute and SavedItemFolderId element.
     */
    ErrorInvalidSendItemSaveSettings,
    /**
     * Invalid serialized access token.
     */
    ErrorInvalidSerializedAccessToken,
    /**
     * The specified server version is invalid.
     */
    ErrorInvalidServerVersion,
    /**
     * The sharing message metadata is not valid.
     */
    ErrorInvalidSharingData,
    /**
     * The sharing message is not valid.
     */
    ErrorInvalidSharingMessage,
    /**
     * A SID with an invalid format was encountered.
     */
    ErrorInvalidSid,
    /**
     * The SIP address isn't valid.
     */
    ErrorInvalidSIPUri,
    /**
     * The SMTP address format is invalid.
     */
    ErrorInvalidSmtpAddress,
    /**
     * Invalid subFilterType.
     */
    ErrorInvalidSubfilterType,
    /**
     * SubFilterType is not attendee type.
     */
    ErrorInvalidSubfilterTypeNotAttendeeType,
    /**
     * SubFilterType is not recipient type.
     */
    ErrorInvalidSubfilterTypeNotRecipientType,
    /**
     * Subscription is invalid.
     */
    ErrorInvalidSubscription,
    /**
     * A subscription can only be established on a single public folder or on folders from a
     * single mailbox.
     */
    ErrorInvalidSubscriptionRequest,
    /**
     * Synchronization state data is corrupt or otherwise invalid.
     */
    ErrorInvalidSyncStateData,
    /**
     * ErrorInvalidTimeInterval
     */
    ErrorInvalidTimeInterval,
    /**
     * A UserId was not valid.
     */
    ErrorInvalidUserInfo,
    /**
     * ErrorInvalidUserOofSettings
     */
    ErrorInvalidUserOofSettings,
    /**
     * The impersonation principal name is invalid.
     */
    ErrorInvalidUserPrincipalName,
    /**
     * The user SID is invalid or does not map to a user in the Active Directory.
     */
    ErrorInvalidUserSid,
    /**
     * ErrorInvalidUserSidMissingUPN
     */
    ErrorInvalidUserSidMissingUPN,
    /**
     * The specified value is invalid for property.
     */
    ErrorInvalidValueForProperty,
    /**
     * The watermark is invalid.
     */
    ErrorInvalidWatermark,
    /**
     * A valid IP gateway couldn't be found.
     */
    ErrorIPGatewayNotFound,
    /**
     * The send or update operation could not be performed because the change key passed in the
     * request does not match the current change key for the item.
     */
    ErrorIrresolvableConflict,
    /**
     * The item is corrupt.
     */
    ErrorItemCorrupt,
    /**
     * The specified object was not found in the store.
     */
    ErrorItemNotFound,
    /**
     * One or more of the properties requested for this item could not be retrieved.
     */
    ErrorItemPropertyRequestFailed,
    /**
     * The item save operation did not succeed.
     */
    ErrorItemSave,
    /**
     * Item save operation did not succeed.
     */
    ErrorItemSavePropertyError,
    /**
     * ErrorLegacyMailboxFreeBusyViewTypeNotMerged
     */
    ErrorLegacyMailboxFreeBusyViewTypeNotMerged,
    /**
     * ErrorLocalServerObjectNotFound
     */
    ErrorLocalServerObjectNotFound,
    /**
     * ErrorLogonAsNetworkServiceFailed
     */
    ErrorLogonAsNetworkServiceFailed,
    /**
     * Unable to access an account or mailbox.
     */
    ErrorMailboxConfiguration,
    /**
     * ErrorMailboxDataArrayEmpty
     */
    ErrorMailboxDataArrayEmpty,
    /**
     * ErrorMailboxDataArrayTooBig
     */
    ErrorMailboxDataArrayTooBig,
    /**
     * ErrorMailboxFailover
     */
    ErrorMailboxFailover,
    /**
     * The specific mailbox hold is not found.
     */
    ErrorMailboxHoldNotFound,
    /**
     * ErrorMailboxLogonFailed
     */
    ErrorMailboxLogonFailed,
    /**
     * Mailbox move in progress. Try again later.
     */
    ErrorMailboxMoveInProgress,
    /**
     * The mailbox database is temporarily unavailable.
     */
    ErrorMailboxStoreUnavailable,
    /**
     * ErrorMailRecipientNotFound
     */
    ErrorMailRecipientNotFound,
    /**
     * MailTips aren't available for your organization.
     */
    ErrorMailTipsDisabled,
    /**
     * The specified Managed Folder already exists in the mailbox.
     */
    ErrorManagedFolderAlreadyExists,
    /**
     * Unable to find the specified managed folder in the Active Directory.
     */
    ErrorManagedFolderNotFound,
    /**
     * Failed to create or bind to the folder: Managed Folders
     */
    ErrorManagedFoldersRootFailure,
    /**
     * ErrorMeetingSuggestionGenerationFailed
     */
    ErrorMeetingSuggestionGenerationFailed,
    /**
     * MessageDisposition attribute is required.
     */
    ErrorMessageDispositionRequired,
    /**
     * The message exceeds the maximum supported size.
     */
    ErrorMessageSizeExceeded,
    /**
     * The domain specified in the tracking request doesn't exist.
     */
    ErrorMessageTrackingNoSuchDomain,
    /**
     * The log search service can't track this message.
     */
    ErrorMessageTrackingPermanentError,
    /**
     * The log search service isn't currently available. Please try again later.
     */
    ErrorMessageTrackingTransientError,
    /**
     * MIME content conversion failed.
     */
    ErrorMimeContentConversionFailed,
    /**
     * Invalid MIME content.
     */
    ErrorMimeContentInvalid,
    /**
     * Invalid base64 string for MIME content.
     */
    ErrorMimeContentInvalidBase64String,
    /**
     * The subscription has missed events, but will continue service on this connection.
     */
    ErrorMissedNotificationEvents,
    /**
     * ErrorMissingArgument
     */
    ErrorMissingArgument,
    /**
     * When making a request as an account that does not have a mailbox, you must specify the
     * mailbox primary SMTP address for any distinguished folder Ids.
     */
    ErrorMissingEmailAddress,
    /**
     * When making a request with an account that does not have a mailbox, you must specify the
     * primary SMTP address for an existing mailbox.
     */
    ErrorMissingEmailAddressForManagedFolder,
    /**
     * EmailAddress or ItemId must be included in the request.
     */
    ErrorMissingInformationEmailAddress,
    /**
     * ReferenceItemId must be included in the request.
     */
    ErrorMissingInformationReferenceItemId,
    /**
     * SharingFolderId must be included in the request.
     */
    ErrorMissingInformationSharingFolderId,
    /**
     * An item must be specified when creating an item attachment.
     */
    ErrorMissingItemForCreateItemAttachment,
    /**
     * The managed folder Id is missing.
     */
    ErrorMissingManagedFolderId,
    /**
     * A message needs to have at least one recipient.
     */
    ErrorMissingRecipients,
    /**
     * Missing information for delegate user. You must either specify a valid SMTP address or
     * SID.
     */
    ErrorMissingUserIdInformation,
    /**
     * Only one access mode header may be specified.
     */
    ErrorMoreThanOneAccessModeSpecified,
    /**
     * The move or copy operation failed.
     */
    ErrorMoveCopyFailed,
    /**
     * Cannot move distinguished folder.
     */
    ErrorMoveDistinguishedFolder,
    /**
     * ErrorMultiLegacyMailboxAccess
     */
    ErrorMultiLegacyMailboxAccess,
    /**
     * Multiple results were found.
     */
    ErrorNameResolutionMultipleResults,
    /**
     * User must have a mailbox for name resolution operations.
     */
    ErrorNameResolutionNoMailbox,
    /**
     * No results were found.
     */
    ErrorNameResolutionNoResults,
    /**
     * Another connection was opened against this subscription.
     */
    ErrorNewEventStreamConnectionOpened,
    /**
     * Exchange Web Services are not currently available for this request because there are no
     * available Client Access Services Servers in the target AD Site.
     */
    ErrorNoApplicableProxyCASServersAvailable,
    /**
     * ErrorNoCalendar
     */
    ErrorNoCalendar,
    /**
     * Exchange Web Services aren't available for this request because there is no Client Access
     * server with the necessary configuration in the Active Directory site where the mailbox is
     * stored. If the problem continues, click Help.
     */
    ErrorNoDestinationCASDueToKerberosRequirements,
    /**
     * Exchange Web Services aren't currently available for this request because an SSL
     * connection couldn't be established to the Client Access server that should be used for
     * mailbox access. If the problem continues, click Help.
     */
    ErrorNoDestinationCASDueToSSLRequirements,
    /**
     * Exchange Web Services aren't currently available for this request because the Client
     * Access server used for proxying has an older version of Exchange installed than the
     * Client Access server in the mailbox Active Directory site.
     */
    ErrorNoDestinationCASDueToVersionMismatch,
    /**
     * You cannot specify the FolderClass when creating a non-generic folder.
     */
    ErrorNoFolderClassOverride,
    /**
     * ErrorNoFreeBusyAccess
     */
    ErrorNoFreeBusyAccess,
    /**
     * Mailbox does not exist.
     */
    ErrorNonExistentMailbox,
    /**
     * The primary SMTP address must be specified when referencing a mailbox.
     */
    ErrorNonPrimarySmtpAddress,
    /**
     * Custom properties cannot be specified using property tags.  The GUID and Id/Name
     * combination must be used instead.
     */
    ErrorNoPropertyTagForCustomProperties,
    /**
     * ErrorNoPublicFolderReplicaAvailable
     */
    ErrorNoPublicFolderReplicaAvailable,
    /**
     * There are no public folder servers available.
     */
    ErrorNoPublicFolderServerAvailable,
    /**
     * Exchange Web Services are not currently available for this request because none of the
     * Client Access Servers in the destination site could process the request.
     */
    ErrorNoRespondingCASInDestinationSite,
    /**
     * Policy does not allow granting of permissions to external users.
     */
    ErrorNotAllowedExternalSharingByPolicy,
    /**
     * The user is not a delegate for the mailbox.
     */
    ErrorNotDelegate,
    /**
     * There was not enough memory to complete the request.
     */
    ErrorNotEnoughMemory,
    /**
     * The sharing message is not supported.
     */
    ErrorNotSupportedSharingMessage,
    /**
     * Operation would change object type, which is not permitted.
     */
    ErrorObjectTypeChanged,
    /**
     * Modified occurrence is crossing or overlapping adjacent occurrence.
     */
    ErrorOccurrenceCrossingBoundary,
    /**
     * One occurrence of the recurring calendar item overlaps with another occurrence of the
     * same calendar item.
     */
    ErrorOccurrenceTimeSpanTooBig,
    /**
     * Operation not allowed with public folder root.
     */
    ErrorOperationNotAllowedWithPublicFolderRoot,
    /**
     * Organization is not federated.
     */
    ErrorOrganizationNotFederated,
    /**
     * ErrorOutlookRuleBlobExists
     */
    ErrorOutlookRuleBlobExists,
    /**
     * You must specify the parent folder Id for this operation.
     */
    ErrorParentFolderIdRequired,
    /**
     * The specified parent folder could not be found.
     */
    ErrorParentFolderNotFound,
    /**
     * Password change is required.
     */
    ErrorPasswordChangeRequired,
    /**
     * Password has expired. Change password.
     */
    ErrorPasswordExpired,
    /**
     * Policy does not allow granting permission level to user.
     */
    ErrorPermissionNotAllowedByPolicy,
    /**
     * Dialing restrictions are preventing the phone number that was entered from being dialed.
     */
    ErrorPhoneNumberNotDialable,
    /**
     * Property update did not succeed.
     */
    ErrorPropertyUpdate,
    /**
     * At least one property failed validation.
     */
    ErrorPropertyValidationFailure,
    /**
     * Subscription related request failed because EWS could not contact the appropriate CAS
     * server for this request.  If this problem persists, recreate the subscription.
     */
    ErrorProxiedSubscriptionCallFailure,
    /**
     * Request failed because EWS could not contact the appropriate CAS server for this request.
     */
    ErrorProxyCallFailed,
    /**
     * Exchange Web Services (EWS) is not available for this mailbox because the user account
     * associated with the mailbox is a member of too many groups. EWS limits the group
     * membership it can proxy between Client Access Service Servers to 3000.
     */
    ErrorProxyGroupSidLimitExceeded,
    /**
     * ErrorProxyRequestNotAllowed
     */
    ErrorProxyRequestNotAllowed,
    /**
     * ErrorProxyRequestProcessingFailed
     */
    ErrorProxyRequestProcessingFailed,
    /**
     * Exchange Web Services are not currently available for this mailbox because it could not
     * determine the Client Access Services Server to use for the mailbox.
     */
    ErrorProxyServiceDiscoveryFailed,
    /**
     * Proxy token has expired.
     */
    ErrorProxyTokenExpired,
    /**
     * ErrorPublicFolderRequestProcessingFailed
     */
    ErrorPublicFolderRequestProcessingFailed,
    /**
     * ErrorPublicFolderServerNotFound
     */
    ErrorPublicFolderServerNotFound,
    /**
     * The search folder has a restriction that is too long to return.
     */
    ErrorQueryFilterTooLong,
    /**
     * Mailbox has exceeded maximum mailbox size.
     */
    ErrorQuotaExceeded,
    /**
     * Unable to retrieve events for this subscription.  The subscription must be recreated.
     */
    ErrorReadEventsFailed,
    /**
     * Unable to suppress read receipt. Read receipts are not pending.
     */
    ErrorReadReceiptNotPending,
    /**
     * Recurrence end date can not exceed Sep 1, 4500 00:00:00.
     */
    ErrorRecurrenceEndDateTooBig,
    /**
     * Recurrence has no occurrences in the specified range.
     */
    ErrorRecurrenceHasNoOccurrence,
    /**
     * Failed to remove one or more delegates.
     */
    ErrorRemoveDelegatesFailed,
    /**
     * ErrorRequestAborted
     */
    ErrorRequestAborted,
    /**
     * ErrorRequestStreamTooBig
     */
    ErrorRequestStreamTooBig,
    /**
     * Required property is missing.
     */
    ErrorRequiredPropertyMissing,
    /**
     * Cannot perform ResolveNames for non-contact folder.
     */
    ErrorResolveNamesInvalidFolderType,
    /**
     * Only one contacts folder can be specified in request.
     */
    ErrorResolveNamesOnlyOneContactsFolderAllowed,
    /**
     * The response failed schema validation.
     */
    ErrorResponseSchemaValidation,
    /**
     * The restriction or sort order is too complex for this operation.
     */
    ErrorRestrictionTooComplex,
    /**
     * Restriction contained too many elements.
     */
    ErrorRestrictionTooLong,
    /**
     * ErrorResultSetTooBig
     */
    ErrorResultSetTooBig,
    /**
     * ErrorRulesOverQuota
     */
    ErrorRulesOverQuota,
    /**
     * The folder in which items were to be saved could not be found.
     */
    ErrorSavedItemFolderNotFound,
    /**
     * The request failed schema validation.
     */
    ErrorSchemaValidation,
    /**
     * The search folder is not initialized.
     */
    ErrorSearchFolderNotInitialized,
    /**
     * The user account which was used to submit this request does not have the right to send
     * mail on behalf of the specified sending account.
     */
    ErrorSendAsDenied,
    /**
     * SendMeetingCancellations attribute is required for Calendar items.
     */
    ErrorSendMeetingCancellationsRequired,
    /**
     * The SendMeetingInvitationsOrCancellations attribute is required for calendar items.
     */
    ErrorSendMeetingInvitationsOrCancellationsRequired,
    /**
     * The SendMeetingInvitations attribute is required for calendar items.
     */
    ErrorSendMeetingInvitationsRequired,
    /**
     * The meeting request has already been sent and might not be updated.
     */
    ErrorSentMeetingRequestUpdate,
    /**
     * The task request has already been sent and may not be updated.
     */
    ErrorSentTaskRequestUpdate,
    /**
     * The server cannot service this request right now. Try again later.
     */
    ErrorServerBusy,
    /**
     * ErrorServiceDiscoveryFailed
     */
    ErrorServiceDiscoveryFailed,
    /**
     * No external Exchange Web Service URL available.
     */
    ErrorSharingNoExternalEwsAvailable,
    /**
     * Failed to synchronize the sharing folder.
     */
    ErrorSharingSynchronizationFailed,
    /**
     * The current ChangeKey is required for this operation.
     */
    ErrorStaleObject,
    /**
     * The message couldn't be sent because the sender's submission quota was exceeded. Please
     * try again later.
     */
    ErrorSubmissionQuotaExceeded,
    /**
     * Access is denied. Only the subscription owner may access the subscription.
     */
    ErrorSubscriptionAccessDenied,
    /**
     * Subscriptions are not supported for delegate user access.
     */
    ErrorSubscriptionDelegateAccessNotSupported,
    /**
     * The specified subscription was not found.
     */
    ErrorSubscriptionNotFound,
    /**
     * The StreamingSubscription was unsubscribed while the current connection was servicing it.
     */
    ErrorSubscriptionUnsubscribed,
    /**
     * The folder to be synchronized could not be found.
     */
    ErrorSyncFolderNotFound,
    /**
     * ErrorTeamMailboxNotFound
     */
    ErrorTeamMailboxNotFound,
    /**
     * ErrorTeamMailboxNotLinkedToSharePoint
     */
    ErrorTeamMailboxNotLinkedToSharePoint,
    /**
     * ErrorTeamMailboxUrlValidationFailed
     */
    ErrorTeamMailboxUrlValidationFailed,
    /**
     * ErrorTeamMailboxNotAuthorizedOwner
     */
    ErrorTeamMailboxNotAuthorizedOwner,
    /**
     * ErrorTeamMailboxActiveToPendingDelete
     */
    ErrorTeamMailboxActiveToPendingDelete,
    /**
     * ErrorTeamMailboxFailedSendingNotifications
     */
    ErrorTeamMailboxFailedSendingNotifications,
    /**
     * ErrorTeamMailboxErrorUnknown
     */
    ErrorTeamMailboxErrorUnknown,
    /**
     * ErrorTimeIntervalTooBig
     */
    ErrorTimeIntervalTooBig,
    /**
     * ErrorTimeoutExpired
     */
    ErrorTimeoutExpired,
    /**
     * The time zone isn't valid.
     */
    ErrorTimeZone,
    /**
     * The specified target folder could not be found.
     */
    ErrorToFolderNotFound,
    /**
     * The requesting account does not have permission to serialize tokens.
     */
    ErrorTokenSerializationDenied,
    /**
     * ErrorUnableToGetUserOofSettings
     */
    ErrorUnableToGetUserOofSettings,
    /**
     * ErrorUnableToRemoveImContactFromGroup
     */
    ErrorUnableToRemoveImContactFromGroup,
    /**
     * A dial plan could not be found.
     */
    ErrorUnifiedMessagingDialPlanNotFound,
    /**
     * The UnifiedMessaging request failed.
     */
    ErrorUnifiedMessagingRequestFailed,
    /**
     * A connection couldn't be made to the Unified Messaging server.
     */
    ErrorUnifiedMessagingServerNotFound,
    /**
     * The specified item culture is not supported on this server.
     */
    ErrorUnsupportedCulture,
    /**
     * The MAPI property type is not supported.
     */
    ErrorUnsupportedMapiPropertyType,
    /**
     * MIME conversion is not supported for this item type.
     */
    ErrorUnsupportedMimeConversion,
    /**
     * The property can not be used with this type of restriction.
     */
    ErrorUnsupportedPathForQuery,
    /**
     * The property can not be used for sorting or grouping results.
     */
    ErrorUnsupportedPathForSortGroup,
    /**
     * PropertyDefinition is not supported in searches.
     */
    ErrorUnsupportedPropertyDefinition,
    /**
     * QueryFilter type is not supported.
     */
    ErrorUnsupportedQueryFilter,
    /**
     * The specified recurrence is not supported.
     */
    ErrorUnsupportedRecurrence,
    /**
     * Unsupported subfilter type.
     */
    ErrorUnsupportedSubFilter,
    /**
     * Unsupported type for restriction conversion.
     */
    ErrorUnsupportedTypeForConversion,
    /**
     * Failed to update one or more delegates.
     */
    ErrorUpdateDelegatesFailed,
    /**
     * Property for update does not match property in object.
     */
    ErrorUpdatePropertyMismatch,
    /**
     * Policy does not allow granting permissions to user.
     */
    ErrorUserNotAllowedByPolicy,
    /**
     * The user isn't enabled for Unified Messaging
     */
    ErrorUserNotUnifiedMessagingEnabled,
    /**
     * The user doesn't have an SMTP proxy address from a federated domain.
     */
    ErrorUserWithoutFederatedProxyAddress,
    /**
     * The value is out of range.
     */
    ErrorValueOutOfRange,
    /**
     * Virus detected in the message.
     */
    ErrorVirusDetected,
    /**
     * The item has been deleted as a result of a virus scan.
     */
    ErrorVirusMessageDeleted,
    /**
     * The Voice Mail distinguished folder is not implemented.
     */
    ErrorVoiceMailNotImplemented,
    /**
     * ErrorWebRequestInInvalidState
     */
    ErrorWebRequestInInvalidState,
    /**
     * ErrorWin32InteropError
     */
    ErrorWin32InteropError,
    /**
     * ErrorWorkingHoursSaveFailed
     */
    ErrorWorkingHoursSaveFailed,
    /**
     * ErrorWorkingHoursXmlMalformed
     */
    ErrorWorkingHoursXmlMalformed,
    /**
     * The Client Access server version doesn't match the Mailbox server version of the resource
     * that was being accessed. To determine the correct URL to use to access the resource, use
     * Autodiscover with the address of the resource.
     */
    ErrorWrongServerVersion,
    /**
     * The mailbox of the authenticating user and the mailbox of the resource being accessed
     * must have the same Mailbox server version.
     */
    ErrorWrongServerVersionDelegate,
    /**
     * The client access token request is invalid.
     */
    ErrorInvalidClientAccessTokenRequest,
    /**
     * invalid managementrole header value or usage.
     */
    ErrorInvalidManagementRoleHeader,
    /**
     * SearchMailboxes query has too many keywords.
     */
    ErrorSearchQueryHasTooManyKeywords,
    /**
     * SearchMailboxes on too many mailboxes.
     */
    ErrorSearchTooManyMailboxes,
    /**
     * There are no retention tags.
     */
    ErrorInvalidRetentionTagNone,
    /**
     * Discovery Searches are disabled.
     */
    ErrorDiscoverySearchesDisabled,
    /**
     * SeekToConditionPageView not supported for calendar items.
     */
    ErrorCalendarSeekToConditionNotSupported,
    /**
     * Archive mailbox search operation failed.
     */
    ErrorArchiveMailboxSearchFailed,
    /**
     * Get remote archive mailbox folder failed.
     */
    ErrorGetRemoteArchiveFolderFailed,
    /**
     * Find remote archive mailbox folder failed.
     */
    ErrorFindRemoteArchiveFolderFailed,
    /**
     * Get remote archive mailbox item failed.
     */
    ErrorGetRemoteArchiveItemFailed,
    /**
     * Export remote archive mailbox items failed.
     */
    ErrorExportRemoteArchiveItemsFailed,
    /**
     * Invalid state definition.
     */
    ErrorClientIntentInvalidStateDefinition,
    /**
     * Client intent not found.
     */
    ErrorClientIntentNotFound,
    /**
     * The Content Indexing service is required to perform this search, but it's not enabled.
     */
    ErrorContentIndexingNotEnabled,
    /**
     * The custom prompt files you specified couldn't be removed.
     */
    ErrorDeleteUnifiedMessagingPromptFailed,
    /**
     * The location service is disabled.
     */
    ErrorLocationServicesDisabled,
    /**
     * Invalid location service request.
     */
    ErrorLocationServicesInvalidRequest,
    /**
     * The request for location information failed.
     */
    ErrorLocationServicesRequestFailed,
    /**
     * The request for location information timed out.
     */
    ErrorLocationServicesRequestTimedOut,
    /**
     * Weather service is disabled.
     */
    ErrorWeatherServiceDisabled,
    /**
     * Mailbox scope not allowed without a query string.
     */
    ErrorMailboxScopeNotAllowedWithoutQueryString,
    /**
     * No speech detected.
     */
    ErrorNoSpeechDetected,
    /**
     * An error occurred while accessing the custom prompt publishing point.
     */
    ErrorPromptPublishingOperationFailed,
    /**
     * Unable to discover the URL of the public folder mailbox.
     */
    ErrorPublicFolderMailboxDiscoveryFailed,
    /**
     * Public folder operation failed.
     */
    ErrorPublicFolderOperationFailed,
    /**
     * The operation succeeded on the primary public folder mailbox, but failed to sync to the secondary public folder mailbox.
     */
    ErrorPublicFolderSyncException,
    /**
     * Discovery Searches are disabled.
     */
    ErrorRecipientNotFound,
    /**
     * Recognizer not installed.
     */
    ErrorRecognizerNotInstalled,
    /**
     * Speech grammar error.
     */
    ErrorSpeechGrammarError,
    /**
     * Too many concurrent connections opened.
     */
    ErrorTooManyObjectsOpened,
    /**
     * Unified Messaging server unavailable.
     */
    ErrorUMServerUnavailable,
    /**
     * The Unified Messaging custom prompt file you specified couldn't be found.
     */
    ErrorUnifiedMessagingPromptNotFound,
    /**
     * Report data for the UM call summary couldn't be found.
     */
    ErrorUnifiedMessagingReportDataNotFound,
    /**
     * The requested size is invalid.
     */
    ErrorInvalidPhotoSize,
    /**
     * AcceptItem action is invalid for a meeting message in group mailbox.
     */
    ErrorCalendarIsGroupMailboxForAccept,
    /**
     * DeclineItem operation is invalid for a meeting message in group mailbox.
     */
    ErrorCalendarIsGroupMailboxForDecline,
    /**
     * TentativelyAcceptItem action isn't valid for a meeting message in group mailbox.
     */
    ErrorCalendarIsGroupMailboxForTentative,
    /**
     * SuppressReadReceipt action isn't valid for a meeting message in group mailbox.
     */
    ErrorCalendarIsGroupMailboxForSuppressReadReceipt,
    /**
     * The Organization is marked for removal.
     */
    ErrorOrganizationAccessBlocked,
    /**
     * User doesn't have a valid license.
     */
    ErrorInvalidLicense,
    /**
     * Receive quota message per folder is exceeded.
     */
    ErrorMessagePerFolderCountReceiveQuotaExceeded,
    /**
     * Unified group was not found.
     */
    ErrorUnifiedGroupMailboxNotFound,
    /**
     * Invalid channel id.
     */
    ErrorInvalidChannelId,
    /**
     * Another connection is opened on the same channel.
     */
    ErrorNewChannelConnectionOpened,
    /**
     * The channel subscription cannot be found.
     */
    ErrorChannelSubscriptionNotFound,
    /**
     * The channel contains too many subscriptions.
     */
    ErrorExceededChannelSubscriptionCount,
    /**
     * The channel subscription already exists.
     */
    ErrorChannelSubscriptionAlreadyExists,
    /**
     * The given channel subscription id is invalid.
     */
    ErrorInvalidChannelSubscriptionId,
    
    /* #region Error codes to map WASCL errors */
    
    /**
     * Error indicating that message submission blocked by WASCL for a consumer mailboxes
     */
    ErrorMessageSubmissionBlocked,
    /**
     * Error indicating that number of submitted messages exceeded the limit and message submission is blocked by WASCL
     */
    ErrorExceededMessageLimit,
    /**
     * Error indicating that recipients number for a consumer mailbox has exceeded the limit defined by WASCL
     */
    ErrorExceededMaxRecipientLimitBlock,
    /**
     * Error indicating that access to the consumer mailbox is suspended by WASCL
     */
    ErrorAccountSuspend,
    /**
     * Error indicating that recipients number for a consumer mailbox has exceeded the limit defined by WASCL
     */
    ErrorExceededMaxRecipientLimit,
    /**
     * Error indicating that particular message cannot be sent for a consumer mailbox as it is considered as SPAM by WASCL
     */
    ErrorMessageBlocked,
    /**
     * Error indicating that access to the consumer mailbox is suspended by WASCL
     */
    ErrorAccountSuspendShowTierUpgrade,
    /**
     * Error indicating that message sent from a consumer mailbox has exceeded the limit defined by WASCL
     */
    ErrorExceededMessageLimitShowTierUpgrade,
    /**
     * Error indicating that recipients number for a consumer mailbox has exceeded the limit defined by WASCL
     */
    ErrorExceededMaxRecipientLimitShowTierUpgrade,
 
    /* #endregion */
}

/**
 * @internal Defines the type of error handling used for service method calls. 
 */
export enum ServiceErrorHandling {
  
  /**
   * Service method should return the error(s).
   */
  ReturnErrors = 0,
  
  /**
   * Service method should throw exception when error occurs.
   */
  ThrowOnError = 1
}

/**
 * Defines the type of a service object.
 */
export enum ServiceObjectType {

    /**
     * The object is a folder.
     */
    Folder = 0,

    /**
     * The object is an item.
     */
    Item = 1,

    /**
     * Data represents a conversation
     */
    Conversation = 2,

    /**
     * Data represents a persona
     */
    Persona = 3
}

/**
 * Defines the result of a call to an EWS method. 
 * Values in this enumeration have to be ordered from lowest to highest severity.
 */
export enum ServiceResult {
    
    /**
     * The call was successful
     */
    Success = 0,
    
    /**
     * The call triggered at least one warning
     */
    Warning = 1,
    
    /**
     * The call triggered at least one error
     */
    Error = 2
}

/**
 * Defines the type of SetClientExtensionActionId.
 */
export enum SetClientExtensionActionId {
    
    /**
     * Install
     */
    Install = 0,
    
    /**
     * Uninstall
     */
    Uninstall = 1,
    
    /**
     * Configure
     */
    Configure = 2
}

/**
 * Defines a sort direction
 */
export enum SortDirection {
    
    /**
     * The sort is performed in ascending order.
     */
    Ascending = 0,
    
    /**
     * The sort is performed in descending order.
     */
    Descending = 1
}

/**
 * Defines a standard delegate user.
 */
export enum StandardUser {
    
    /**
     * The Default delegate user, used to define default delegation permissions.
     */
    Default = 0,
    
    /**
     * The Anonymous delegate user, used to define delegate permissions for unauthenticated users.
     */
    Anonymous = 1
}

/**
 * Defines the quality of an availability suggestion.
 */
export enum SuggestionQuality {
    
    /**
     * The suggestion is excellent.
     */
    Excellent = 0,
    
    /**
     * The suggestion is good.
     */
    Good = 1,
    
    /**
     * The suggestion is fair.
     */
    Fair = 2,
    
    /**
     * The suggestion is poor.
     */
    Poor = 3
}

/**
 * Determines items to be included in a SyncFolderItems response.
 */
export enum SyncFolderItemsScope {
    
    /**
     * Include only normal items in the response.
     */
    NormalItems = 0,
    
    /**
     * Include normal and associated items in the response.
     */
    NormalAndAssociatedItems = 1
}

/**
 * This maps to the bogus TaskDelegationState in the EWS schema.
 * The schema enum has 6 values, but EWS should never return anything but values between 0 and 3, so we should be safe without mappings for EWS's Declined and Max values
 */
export enum TaskDelegationState {

    /**
     * The task is not delegated
     */
    NoDelegation = 0, // Maps to NoMatch

    /**
     * The task's delegation state is unknown.
     */
    Unknown = 1,      // Maps to OwnNew

    /**
     * The task was delegated and the delegation was accepted.
     */
    Accepted = 2,     // Maps to Owned

    /**
     * The task was delegated but the delegation was declined.
     */
    Declined = 3      // Maps to Accepted

    // The original Declined value has no mapping
    // The original Max value has no mapping
}

/**
 * Defines the modes of a Task.
 */
export enum TaskMode {
    
    /**
     * The task is normal
     */
    Normal = 0,
    
    /**
     * The task is a task assignment request
     */
    Request = 1,
    
    /**
     * The task assignment request was accepted
     */
    RequestAccepted = 2,
    
    /**
     * The task assignment request was declined
     */
    RequestDeclined = 3,
    
    /**
     * The task has been updated
     */
    Update = 4,
    
    /**
     * The task is self delegated
     */
    SelfDelegated = 5
}

/**
 * Defines the execution status of a task.
 */
export enum TaskStatus {
    
    /**
     * The execution of the task is not started.
     */
    NotStarted = 0,
    
    /**
     * The execution of the task is in progress.
     */
    InProgress = 1,
    
    /**
     * The execution of the task is completed.
     */
    Completed = 2,
    
    /**
     * The execution of the task is waiting on others.
     */
    WaitingOnOthers = 3,
    
    /**
     * The execution of the task is deferred.
     */
    Deferred = 4
}

/**
 * TeamMailbox lifecycle state
 */
export enum TeamMailboxLifecycleState {

    /**
     * Active
     */
    Active = 0,

    /**
     * Closed
     */
    Closed = 1,

    /**
     * Unlinked
     */
    Unlinked = 2,

    /**
     * PendingDelete
     */
    PendingDelete = 3
}

export module TeamMailboxLifecycleState {

    /**EwsEnumAttribute */
    export function FromEwsEnumString(value: string): TeamMailboxLifecycleState {
        return TeamMailboxLifecycleState[value];
    }

    /**EwsEnumAttribute */
    export function ToEwsEnumString(value: TeamMailboxLifecycleState): string {
        return TeamMailboxLifecycleState[value];
    }
}

/**
 * Defines flags to control tracing details
 * 
 * [Flags]
 */
export enum TraceFlags {
  
  /**
   * No tracing.
   */
  None = 0,
  
  /**
   * Trace EWS request messages.
   */
  EwsRequest = 1,
  
  /**
   * Trace EWS response messages.
   */
  EwsResponse = 2,
  
  /**
   * Trace EWS response HTTP headers.
   */
  EwsResponseHttpHeaders = 4,
  
  /**
   * Trace Autodiscover request messages.
   */
  AutodiscoverRequest = 8,
  
  /**
   * Trace Autodiscover response messages.
   */
  AutodiscoverResponse = 16,
  
  /**
   * Trace Autodiscover response HTTP headers.
   */
  AutodiscoverResponseHttpHeaders = 32,
  
  /**
   * Trace Autodiscover configuration logic.
   */
  AutodiscoverConfiguration = 64,
  
  /**
   * Trace messages used in debugging the Exchange Web Services Managed API
   */
  DebugMessage = 128,
  
  /**
   * Trace EWS request HTTP headers.
   */
  EwsRequestHttpHeaders = 256,
  
  /**
   * Trace Autodiscover request HTTP headers.
   */
  AutodiscoverRequestHttpHeaders = 512,
  
  /**
   * Trace EWS timezone related logic.
   */
  EwsTimeZones = 1024,

  /**
   * All trace types enabled.
   */
  All = 9223372036854775807
}

/**
 * Identifies the user configuration dictionary key and value types.
 */
export enum UserConfigurationDictionaryObjectType {

    /**
     * DateTime type.
     */
    DateTime = 0,

    /**
     * Boolean type.
     */
    Boolean = 1,

    /**
     * Byte type.
     */
    Byte = 2,

    /**
     * String type.
     */
    String = 3,

    /**
     * 32-bit integer type.
     */
    Integer32 = 4,

    /**
     * 32-bit unsigned integer type.
     */
    UnsignedInteger32 = 5,

    /**
     * 64-bit integer type.
     */
    Integer64 = 6,

    /**
     * 64-bit unsigned integer type.
     */
    UnsignedInteger64 = 7,

    /**
     * String array type.
     */
    StringArray = 8,

    /**
     * Byte array type
     */
    ByteArray = 9
}

/**
 * Identifies the user configuration properties to retrieve.
 * 
 * [Flags]
 */
export enum UserConfigurationProperties {

    /**
     * Retrieve the Id property.
     */
    Id = 1,
    
    /**
     * Retrieve the Dictionary property.
     */
    Dictionary = 2,
    
    /**
     * Retrieve the XmlData property.
     */
    XmlData = 4,
    
    /**
     * Retrieve the BinaryData property.
     */
    BinaryData = 8,
    
    /**
     * Retrieve all properties.
     */
    All = UserConfigurationProperties.Id | UserConfigurationProperties.Dictionary | UserConfigurationProperties.XmlData | UserConfigurationProperties.BinaryData
}

/**
 * User settings that can be requested using GetUserSettings.
 * 
 * /remarks/  Add new values to the end and keep in sync with Microsoft.Exchange.Autodiscover.ConfigurationSettings.UserConfigurationSettingName.
 */
export enum UserSettingName {

  /**
   * The display name of the user.
   */
  UserDisplayName = 0,

  /**
   * The legacy distinguished name of the user.
   */
  UserDN = 1,

  /**
   * The deployment Id of the user.
   */
  UserDeploymentId = 2,

  /**
   * The fully qualified domain name of the mailbox server.
   */
  InternalMailboxServer = 3,

  /**
   * The fully qualified domain name of the RPC client server.
   */
  InternalRpcClientServer = 4,

  /**
   * The legacy distinguished name of the mailbox server.
   */
  InternalMailboxServerDN = 5,

  /**
   * The internal URL of the Exchange Control Panel.
   */
  InternalEcpUrl = 6,

  /**
   * The internal URL of the Exchange Control Panel for VoiceMail Customization.
   */
  InternalEcpVoicemailUrl = 7,

  /**
   * The internal URL of the Exchange Control Panel for Email Subscriptions.
   */
  InternalEcpEmailSubscriptionsUrl = 8,

  /**
   * The internal URL of the Exchange Control Panel for Text Messaging.
   */
  InternalEcpTextMessagingUrl = 9,

  /**
   * The internal URL of the Exchange Control Panel for Delivery Reports.
   */
  InternalEcpDeliveryReportUrl = 10,

  /**
   * The internal URL of the Exchange Control Panel for RetentionPolicy Tags.
   */
  InternalEcpRetentionPolicyTagsUrl = 11,

  /**
   * The internal URL of the Exchange Control Panel for Publishing.
   */
  InternalEcpPublishingUrl = 12,

  /**
   * The internal URL of the Exchange Control Panel for photos.
   */
  InternalEcpPhotoUrl = 13,

  /**
   * The internal URL of the Exchange Control Panel for People Connect subscriptions.
   */
  InternalEcpConnectUrl = 14,

  /**
   * The internal URL of the Exchange Control Panel for Team Mailbox.
   */
  InternalEcpTeamMailboxUrl = 15,

  /**
   * The internal URL of the Exchange Control Panel for creating Team Mailbox.
   */
  InternalEcpTeamMailboxCreatingUrl = 16,

  /**
   * The internal URL of the Exchange Control Panel for editing Team Mailbox.
   */
  InternalEcpTeamMailboxEditingUrl = 17,

  /**
   * The internal URL of the Exchange Control Panel for hiding Team Mailbox.
   */
  InternalEcpTeamMailboxHidingUrl = 18,

  /**
   * The internal URL of the Exchange Control Panel for the extension installation.
   */
  InternalEcpExtensionInstallationUrl = 19,

  /**
   * The internal URL of the Exchange Web Services.
   */
  InternalEwsUrl = 20,

  /**
   * The internal URL of the Exchange Management Web Services.
   */
  InternalEmwsUrl = 21,

  /**
   * The internal URL of the Offline Address Book.
   */
  InternalOABUrl = 22,

  /**
   * The internal URL of the Photos service.
   */
  InternalPhotosUrl = 23,

  /**
   * The internal URL of the Unified Messaging services.
   */
  InternalUMUrl = 24,

  /**
   * The internal URLs of the Exchange web client.
   */
  InternalWebClientUrls = 25,

  /**
   * The distinguished name of the mailbox database of the user's mailbox.
   */
  MailboxDN = 26,

  /**
   * The name of the Public Folders server.
   */
  PublicFolderServer = 27,

  /**
   * The name of the Active Directory server.
   */
  ActiveDirectoryServer = 28,

  /**
   * The name of the RPC over HTTP server.
   */
  ExternalMailboxServer = 29,

  /**
   * Indicates whether the RPC over HTTP server requires SSL.
   */
  ExternalMailboxServerRequiresSSL = 30,

  /**
   * The authentication methods supported by the RPC over HTTP server.
   */
  ExternalMailboxServerAuthenticationMethods = 31,

  /**
   * The URL fragment of the Exchange Control Panel for VoiceMail Customization.
   */
  EcpVoicemailUrlFragment = 32,

  /**
   * The URL fragment of the Exchange Control Panel for Email Subscriptions.
   */
  EcpEmailSubscriptionsUrlFragment = 33,

  /**
   * The URL fragment of the Exchange Control Panel for Text Messaging.
   */
  EcpTextMessagingUrlFragment = 34,

  /**
   * The URL fragment of the Exchange Control Panel for Delivery Reports.
   */
  EcpDeliveryReportUrlFragment = 35,

  /**
   * The URL fragment of the Exchange Control Panel for RetentionPolicy Tags.
   */
  EcpRetentionPolicyTagsUrlFragment = 36,

  /**
   * The URL fragment of the Exchange Control Panel for Publishing.
   */
  EcpPublishingUrlFragment = 37,

  /**
   * The URL fragment of the Exchange Control Panel for photos.
   */
  EcpPhotoUrlFragment = 38,

  /**
   * The URL fragment of the Exchange Control Panel for People Connect.
   */
  EcpConnectUrlFragment = 39,

  /**
   * The URL fragment of the Exchange Control Panel for Team Mailbox.
   */
  EcpTeamMailboxUrlFragment = 40,

  /**
   * The URL fragment of the Exchange Control Panel for creating Team Mailbox.
   */
  EcpTeamMailboxCreatingUrlFragment = 41,

  /**
   * The URL fragment of the Exchange Control Panel for editing Team Mailbox.
   */
  EcpTeamMailboxEditingUrlFragment = 42,

  /**
   * The URL fragment of the Exchange Control Panel for installing extension.
   */
  EcpExtensionInstallationUrlFragment = 43,

  /**
   * The external URL of the Exchange Control Panel.
   */
  ExternalEcpUrl = 44,

  /**
   * The external URL of the Exchange Control Panel for VoiceMail Customization.
   */
  ExternalEcpVoicemailUrl = 45,

  /**
   * The external URL of the Exchange Control Panel for Email Subscriptions.
   */
  ExternalEcpEmailSubscriptionsUrl = 46,

  /**
   * The external URL of the Exchange Control Panel for Text Messaging.
   */
  ExternalEcpTextMessagingUrl = 47,

  /**
   * The external URL of the Exchange Control Panel for Delivery Reports.
   */
  ExternalEcpDeliveryReportUrl = 48,

  /**
   * The external URL of the Exchange Control Panel for RetentionPolicy Tags.
   */
  ExternalEcpRetentionPolicyTagsUrl = 49,

  /**
   * The external URL of the Exchange Control Panel for Publishing.
   */
  ExternalEcpPublishingUrl = 50,

  /**
   * The external URL of the Exchange Control Panel for photos.
   */
  ExternalEcpPhotoUrl = 51,

  /**
   * The external URL of the Exchange Control Panel for People Connect subscriptions.
   */
  ExternalEcpConnectUrl = 52,

  /**
   * The external URL of the Exchange Control Panel for Team Mailbox.
   */
  ExternalEcpTeamMailboxUrl = 53,

  /**
   * The external URL of the Exchange Control Panel for creating Team Mailbox.
   */
  ExternalEcpTeamMailboxCreatingUrl = 54,

  /**
   * The external URL of the Exchange Control Panel for editing Team Mailbox.
   */
  ExternalEcpTeamMailboxEditingUrl = 55,

  /**
   * The external URL of the Exchange Control Panel for hiding Team Mailbox.
   */
  ExternalEcpTeamMailboxHidingUrl = 56,

  /**
   * The external URL of the Exchange Control Panel for the extension installation.
   */
  ExternalEcpExtensionInstallationUrl = 57,

  /**
   * The external URL of the Exchange Web Services.
   */
  ExternalEwsUrl = 58,

  /**
   * The external URL of the Exchange Management Web Services.
   */
  ExternalEmwsUrl = 59,

  /**
   * The external URL of the Offline Address Book.
   */
  ExternalOABUrl = 60,

  /**
   * The external URL of the Photos service.
   */
  ExternalPhotosUrl = 61,

  /**
   * The external URL of the Unified Messaging services.
   */
  ExternalUMUrl = 62,

  /**
   * The external URLs of the Exchange web client.
   */
  ExternalWebClientUrls = 63,

  /**
   * Indicates that cross-organization sharing is enabled.
   */
  CrossOrganizationSharingEnabled = 64,

  /**
   * Collection of alternate mailboxes.
   */
  AlternateMailboxes = 65,

  /**
   * The version of the Client Access Server serving the request (e.g. 14.XX.YYY.ZZZ)
   */
  CasVersion = 66,

  /**
   * Comma-separated list of schema versions supported by Exchange Web Services. The schema version values  /// will be the same as the values of the ExchangeServerVersion enumeration.
   */
  EwsSupportedSchemas = 67,

  /**
   * The internal connection settings list for pop protocol
   */
  InternalPop3Connections = 68,

  /**
   * The external connection settings list for pop protocol
   */
  ExternalPop3Connections = 69,

  /**
   * The internal connection settings list for imap4 protocol
   */
  InternalImap4Connections = 70,

  /**
   * The external connection settings list for imap4 protocol
   */
  ExternalImap4Connections = 71,

  /**
   * The internal connection settings list for smtp protocol
   */
  InternalSmtpConnections = 72,

  /**
   * The external connection settings list for smtp protocol
   */
  ExternalSmtpConnections = 73,

  /**
   * If set to "Off" then clients should not connect via this protocol.  /// The protocol contents are for informational purposes only.
   */
  InternalServerExclusiveConnect = 74,

  /**
   * The version of the Exchange Web Services server ExternalEwsUrl is pointing to.
   */
  ExternalEwsVersion = 75,

  /**
   * Mobile Mailbox policy settings.
   */
  MobileMailboxPolicy = 76,

  /**
   * Document sharing locations and their settings.
   */
  DocumentSharingLocations = 77,

  /**
   * Whether the user account is an MSOnline account.
   */
  UserMSOnline = 78,

  /**
   * The authentication methods supported by the RPC client server.
   */
  InternalMailboxServerAuthenticationMethods = 79,

  /**
   * Version of the server hosting the user's mailbox.
   */
  MailboxVersion = 80,

  /**
   * Sharepoint MySite Host URL.
   */
  SPMySiteHostURL = 81,

  /**
   * Site mailbox creation URL in SharePoint.
   */
  /// </summary>
  SiteMailboxCreationURL = 82,

  /**
   * The FQDN of the server used for internal RPC/HTTP connectivity.
   */
  InternalRpcHttpServer = 83,

  /**
   * Indicates whether SSL is required for internal RPC/HTTP connectivity.
   */
  InternalRpcHttpConnectivityRequiresSsl = 84,

  /**
   * The authentication method used for internal RPC/HTTP connectivity.
   */
  InternalRpcHttpAuthenticationMethod = 85,

  /**
   * If set to "On" then clients should only connect via this protocol.
   */
  ExternalServerExclusiveConnect = 86,

  /**
   * If set, then clients can call the server via XTC
   */
  ExchangeRpcUrl = 87,

  /**
   * If set to false then clients should not show the GAL by default, but show the contact list.
   */
  ShowGalAsDefaultView = 88,

  /**
   * AutoDiscover Primary SMTP Address for the user.
   */
  AutoDiscoverSMTPAddress = 89,

  /**
   * The 'interop' external URL of the Exchange Web Services.  /// By interop it means a URL to E14 (or later) server that can serve mailboxes  /// that are hosted in downlevel server (E2K3 and earlier).
   */
  InteropExternalEwsUrl = 90,

  /**
   * Version of server InteropExternalEwsUrl is pointing to.
   */
  InteropExternalEwsVersion = 91,

  /**
   * Public Folder (Hierarchy) information
   */
  PublicFolderInformation = 92,

  /**
   * The version appropriate URL of the AutoDiscover service that should answer this query.
   */
  RedirectUrl = 93,

  /**
   * The URL of the Exchange Web Services for Office365 partners.
   */
  EwsPartnerUrl = 94,

  /**
   * SSL certificate name
   */
  CertPrincipalName = 95,

  /**
   * The grouping hint for certain clients.
   */
  GroupingInformation = 96,

  /**
   * MapiHttpEnabled ///todo: not available any more in official repo
   */
  MapiHttpEnabled = 97,

  /**
   * Internal OutlookService URL
   */
  InternalOutlookServiceUrl = 98,

  /**
   * External OutlookService URL
   */
  ExternalOutlookServiceUrl = 99
}

/**
 * Defines the view filter for queries.
 */
export enum ViewFilter {

    /**
     * Show all item (no filter)
     */
    All = 0,

    /**
     * Item has flag
     */
    Flagged = 1,

    /**
     * Item has attachment
     */
    HasAttachment = 2,

    /**
     * Item is to or cc me
     */
    ToOrCcMe = 3,

    /**
     * Item is unread
     */
    Unread = 4,

    /**
     * Active task items
     */
    TaskActive = 5,

    /**
     * Overdue task items
     */
    TaskOverdue = 6,

    /**
     * Completed task items
     */
    TaskCompleted = 7,

    /**
     * Suggestions (aka Predicted Actions) from the Inference engine
     */
    Suggestions = 8,

    /**
     * Respond suggestions
     */
    SuggestionsRespond = 9,

    /**
     * Delete suggestions
     */
    SuggestionsDelete = 10
}

export module ViewFilter {

    /**RequiredServerVersionAttribute */
    export function RequiredServerVersion(value: ViewFilter): ExchangeVersion {
        if (value <= 10) //<=ViewFilter.SuggestionsDelete
            return ExchangeVersion.Exchange2013;

        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
}

/**
 * The values in this enumeration must match the values of the DistinguishedFolderIdNameType type in the schema.
 */
export enum WellKnownFolderName {

    /**
     * The Calendar folder.
     */
    Calendar,

    /**
     * The Contacts folder.
     */
    Contacts,

    /**
     * The Deleted Items folder
     */
    DeletedItems,

    /**
     * The Drafts folder.
     */
    Drafts,

    /**
     * The Inbox folder.
     */
    Inbox,

    /**
     * The Journal folder.
     */
    Journal,

    /**
     * The Notes folder.
     */
    Notes,

    /**
     * The Outbox folder.
     */
    Outbox,

    /**
     * The Sent Items folder.
     */
    SentItems,

    /**
     * The Tasks folder.
     */
    Tasks,

    /**
     * The message folder root.
     */
    MsgFolderRoot,

    /**
     * The root of the Public Folders hierarchy.
     */
    PublicFoldersRoot,

    /**
     * The root of the mailbox.
     */
    Root,

    /**
     * The Junk E-mail folder.
     */
    JunkEmail,

    /**
     * The Search Folders folder, also known as the Finder folder.
     */
    SearchFolders,

    /**
     * The Voicemail folder.
     */
    VoiceMail,

    /**
     * The Dumpster 2.0 root folder.
     */
    RecoverableItemsRoot,

    /**
     * The Dumpster 2.0 soft deletions folder.
     */
    RecoverableItemsDeletions,

    /**
     * The Dumpster 2.0 versions folder.
     */
    RecoverableItemsVersions,

    /**
     * The Dumpster 2.0 hard deletions folder.
     */
    RecoverableItemsPurges,

    /**
     * The Dumpster 2.0 discovery hold folder
     */
    RecoverableItemsDiscoveryHolds,

    /**
     * The root of the archive mailbox.
     */
    ArchiveRoot,

    /**
     * The root of the archive mailbox.
     */
    ArchiveInbox,

    /**
     * The message folder root in the archive mailbox.
     */
    ArchiveMsgFolderRoot,

    /**
     * The Deleted Items folder in the archive mailbox
     */
    ArchiveDeletedItems,

    /**
     * The Dumpster 2.0 root folder in the archive mailbox.
     */
    ArchiveRecoverableItemsRoot,

    /**
     * The Dumpster 2.0 soft deletions folder in the archive mailbox.
     */
    ArchiveRecoverableItemsDeletions,

    /**
     * The Dumpster 2.0 versions folder in the archive mailbox.
     */
    ArchiveRecoverableItemsVersions,

    /**
     * The Dumpster 2.0 hard deletions folder in the archive mailbox.
     */
    ArchiveRecoverableItemsPurges,

    /**
     * The Dumpster 2.0 discovery hold folder in the archive mailbox.
     */
    ArchiveRecoverableItemsDiscoveryHolds,

    /**
     * The Sync Issues folder.
     */
    SyncIssues,

    /**
     * The Conflicts folder
     */
    Conflicts,

    /**
     * The Local failures folder
     */
    LocalFailures,

    /**
     * The Server failures folder
     */
    ServerFailures,

    /**
     * The Recipient Cache folder
     */
    RecipientCache,

    /**
     * The Quick Contacts folder
     */
    QuickContacts,

    /**
     * Conversation history folder
     */
    ConversationHistory,

    /**
     * AdminAuditLogs folder
     */
    AdminAuditLogs,

    /**
     * ToDo search folder
     */
    ToDoSearch,

    /**
     * MyContacts folder
     */
    MyContacts,

    /**
     * Directory (GAL)
     * It is not a mailbox folder. It only indicates any GAL operation.
     */
    Directory,

    /**
     * IMContactList folder
     */
    IMContactList,

    /**
     * PeopleConnect folder
     */
    PeopleConnect,

    /**
     * Favorites folder
     */
    Favorites,
}

export module WellKnownFolderName {

    /**RequiredServerVersionAttribute */
    export function RequiredServerVersion(value: WellKnownFolderName): ExchangeVersion {
        if (value <= 15) //<= WellKnownFolderName.VoiceMail
            return ExchangeVersion.Exchange2007_SP1;
        if (value <= 28 && [20, 22].indexOf(value) < 0) //>= RecoverableItemsRoot && <= ArchiveRecoverableItemsPurges except RecoverableItemsDiscoveryHolds & ArchiveInbox
            return ExchangeVersion.Exchange2010_SP1;
        if (value >= 27 && value <= 43) //>= SyncIssues && <= Favorites except Directory
            return ExchangeVersion.Exchange2013;
        if ([20, 22, 29, 40].indexOf(value) >= 0) // RecoverableItemsDiscoveryHolds, ArchiveInbox, ArchiveRecoverableItemsDiscoveryHolds and Directory
            return ExchangeVersion.Exchange2013_SP1;

        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
}

/**
 * @internal Defines the namespaces as used by the EwsXmlReader, EwsServiceXmlReader, and EwsServiceXmlWriter classes.
 */
export enum XmlNamespace {
    
    /**
     * The namespace is not specified.
     */
    NotSpecified = 0,
    
    /**
     * The EWS Messages namespace.
     */
    Messages = 1,
    
    /**
     * The EWS Types namespace.
     */
    Types = 2,
    
    /**
     * The EWS Errors namespace.
     */
    Errors = 3,
    
    /**
     * The SOAP 1.1 namespace.
     */
    Soap = 4,
    
    /**
     * The SOAP 1.2 namespace.
     */
    Soap12 = 5,
    
    /**
     * XmlSchema-Instance namespace.
     */
    XmlSchemaInstance = 6,
    
    /**
     * The Passport SOAP services SOAP fault namespace.
     */
    PassportSoapFault = 7,
    
    /**
     * The WS-Trust February 2005 namespace.
     */
    WSTrustFebruary2005 = 8,
    
    /**
     * The WS Addressing 1.0 namespace.
     */
    WSAddressing = 9,
    
    /**
     * The Autodiscover SOAP service namespace.
     */
    Autodiscover = 10
}
export class LazyMember<T> {
    get Member(): T {
        if (!this.initialized) {
            //lock(this.lockObject)
            //{
            if (!this.initialized) {
                this.lazyMember = this.initializationDelegate();
            }
            this.initialized = true;
            //}
        }
        return this.lazyMember;
    }
    private lazyMember: T;
    private initializationDelegate: InitializeLazyMember<T>;//() => T;
    private lockObject: any;
    private initialized: boolean = false;

    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="initializationDelegate">The initialization delegate to call for the item on first access
    /// </param>
    constructor(initializationDelegate: InitializeLazyMember<T>) {
        this.initializationDelegate = initializationDelegate;
    }
}


export interface InitializeLazyMember<T> {
    (): T;

    //export class InitializeLazyMember<T> extends System.MulticastDelegate {
    //    BeginInvoke(callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("LazyMember.ts - BeginInvoke : Not implemented.");}
    //    EndInvoke(result: System.IAsyncResult): T{ throw new Error("LazyMember.ts - EndInvoke : Not implemented.");}
    //    Invoke(): T{ throw new Error("LazyMember.ts - Invoke : Not implemented.");}
    //}
}
/*@Updated <from SourceTree description>
 * Commit: 154dbc66ac018d861c73ce489839cd9f58a1b0cd [154dbc6]
 * Parents: 67756e1846, a9a3297c0f
 * Author: David Claux <dclaux@users.noreply.github.com>
 * Date: Friday, December 4, 2015 3:14:27 AM
 * Labels: upstream/master, origin/master, master
 * Merge pull request #71 from ysanghi/master
 * 
 * Publishing Latest Updates from Microsoft
 */
/**
 * XML attribute names.
 */
export module XmlAttributeNames {
    export var XmlNs: string = "xmlns";
    export var Id: string = "Id";
    export var ChangeKey: string = "ChangeKey";
    export var RecurringMasterId: string = "RecurringMasterId";
    export var InstanceIndex: string = "InstanceIndex";
    export var OccurrenceId: string = "OccurrenceId";
    export var Traversal: string = "Traversal";
    export var ViewFilter: string = "ViewFilter";
    export var Offset: string = "Offset";
    export var MaxEntriesReturned: string = "MaxEntriesReturned";
    export var BasePoint: string = "BasePoint";
    export var ResponseClass: string = "ResponseClass";
    export var IndexedPagingOffset: string = "IndexedPagingOffset";
    export var TotalItemsInView: string = "TotalItemsInView";
    export var IncludesLastItemInRange: string = "IncludesLastItemInRange";
    export var BodyType: string = "BodyType";
    export var MessageDisposition: string = "MessageDisposition";
    export var SaveItemToFolder: string = "SaveItemToFolder";
    export var RootItemChangeKey: string = "RootItemChangeKey";
    export var DeleteType: string = "DeleteType";
    export var DeleteSubFolders: string = "DeleteSubFolders";
    export var AffectedTaskOccurrences: string = "AffectedTaskOccurrences";
    export var SendMeetingCancellations: string = "SendMeetingCancellations";
    export var SuppressReadReceipts: string = "SuppressReadReceipts"; //XmlElementNames.SuppressReadReceipts;
    export var FieldURI: string = "FieldURI";
    export var FieldIndex: string = "FieldIndex";
    export var ConflictResolution: string = "ConflictResolution";
    export var SendMeetingInvitationsOrCancellations: string = "SendMeetingInvitationsOrCancellations";
    export var CharacterSet: string = "CharacterSet";
    export var HeaderName: string = "HeaderName";
    export var SendMeetingInvitations: string = "SendMeetingInvitations";
    export var Key: string = "Key";
    export var RoutingType: string = "RoutingType";
    export var MailboxType: string = "MailboxType";
    export var DistinguishedPropertySetId: string = "DistinguishedPropertySetId";
    export var PropertySetId: string = "PropertySetId";
    export var PropertyTag: string = "PropertyTag";
    export var PropertyName: string = "PropertyName";
    export var PropertyId: string = "PropertyId";
    export var PropertyType: string = "PropertyType";
    export var TimeZoneName: string = "TimeZoneName";
    export var ReturnFullContactData: string = "ReturnFullContactData";
    export var ContactDataShape: string = "ContactDataShape";
    export var Numerator: string = "Numerator";
    export var Denominator: string = "Numerator";
    export var Value: string = "Value";
    export var ContainmentMode: string = "ContainmentMode";
    export var ContainmentComparison: string = "ContainmentComparison";
    export var Order: string = "Order";
    export var StartDate: string = "StartDate";
    export var EndDate: string = "EndDate";
    export var Version: string = "Version";
    export var Aggregate: string = "Aggregate";
    export var SearchScope: string = "SearchScope";
    export var Format: string = "Format";
    export var Mailbox: string = "Mailbox";
    export var DestinationFormat: string = "DestinationFormat";
    export var FolderId: string = "FolderId";
    export var ItemId: string = "ItemId";
    export var IncludePermissions: string = "IncludePermissions";
    export var InitialName: string = "InitialName";
    export var FinalName: string = "FinalName";
    export var AuthenticationMethod: string = "AuthenticationMethod";
    export var Time: string = "Time";
    export var Name: string = "Name";
    export var Bias: string = "Bias";
    export var Kind: string = "Kind";
    export var SubscribeToAllFolders: string = "SubscribeToAllFolders";
    export var PublicFolderServer: string = "PublicFolderServer";
    export var IsArchive: string = "IsArchive";
    export var ReturnHighlightTerms: string = "ReturnHighlightTerms";
    export var IsExplicit: string = "IsExplicit";
    export var ClientExtensionUserIdentity: string = "UserId";
    export var ClientExtensionEnabledOnly: string = "EnabledOnly";
    export var SetClientExtensionActionId: string = "ActionId";
    export var ClientExtensionId: string = "ExtensionId";
    export var ClientExtensionIsAvailable: string = "IsAvailable";
    export var ClientExtensionIsMandatory: string = "IsMandatory";
    export var ClientExtensionIsEnabledByDefault: string = "IsEnabledByDefault";
    export var ClientExtensionProvidedTo: string = "ProvidedTo";
    export var ClientExtensionType: string = "Type";
    export var ClientExtensionScope: string = "Scope";
    export var ClientExtensionMarketplaceAssetID: string = "MarketplaceAssetId";
    export var ClientExtensionMarketplaceContentMarket: string = "MarketplaceContentMarket";
    export var ClientExtensionAppStatus: string = "AppStatus";
    export var ClientExtensionEtoken: string = "Etoken";
    export var ClientExtensionInstalledDateTime: string = "InstalledDateTime";
    export var IsTruncated: string = "IsTruncated";
    export var IsJunk: string = "IsJunk";
    export var MoveItem: string = "MoveItem";

    // xsi attributes
    export var Nil: string = "nil";
    export var Type: string = "type";
}
/*@Updated <from SourceTree description>
 * Commit: 154dbc66ac018d861c73ce489839cd9f58a1b0cd [154dbc6]
 * Parents: 67756e1846, a9a3297c0f
 * Author: David Claux <dclaux@users.noreply.github.com>
 * Date: Friday, December 4, 2015 3:14:27 AM
 * Labels: upstream/master, origin/master, master
 * Merge pull request #71 from ysanghi/master
 * 
 * Publishing Latest Updates from Microsoft
 */
/**
 * XML element names.
 */
export module XmlElementNames {
    export var AllProperties: string = "AllProperties";
    export var ParentFolderIds: string = "ParentFolderIds";
    export var DistinguishedFolderId: string = "DistinguishedFolderId";
    export var ItemId: string = "ItemId";
    export var ItemIds: string = "ItemIds";
    export var FolderId: string = "FolderId";
    export var FolderIds: string = "FolderIds";
    export var SourceId: string = "SourceId";
    export var OccurrenceItemId: string = "OccurrenceItemId";
    export var RecurringMasterItemId: string = "RecurringMasterItemId";
    export var ItemShape: string = "ItemShape";
    export var FolderShape: string = "FolderShape";
    export var BaseShape: string = "BaseShape";
    export var IndexedPageItemView: string = "IndexedPageItemView";
    export var IndexedPageFolderView: string = "IndexedPageFolderView";
    export var FractionalPageItemView: string = "FractionalPageItemView";
    export var FractionalPageFolderView: string = "FractionalPageFolderView";
    export var SeekToConditionPageItemView: string = "SeekToConditionPageItemView";
    export var ResponseCode: string = "ResponseCode";
    export var RootFolder: string = "RootFolder";
    export var Folder: string = "Folder";
    export var ContactsFolder: string = "ContactsFolder";
    export var TasksFolder: string = "TasksFolder";
    export var SearchFolder: string = "SearchFolder";
    export var Folders: string = "Folders";
    export var Item: string = "Item";
    export var Items: string = "Items";
    export var Message: string = "Message";
    export var Mailbox: string = "Mailbox";
    export var Body: string = "Body";
    export var From: string = "From";
    export var Sender: string = "Sender";
    export var Name: string = "Name";
    export var Address: string = "Address";
    export var EmailAddress: string = "EmailAddress";
    export var RoutingType: string = "RoutingType";
    export var MailboxType: string = "MailboxType";
    export var ToRecipients: string = "ToRecipients";
    export var CcRecipients: string = "CcRecipients";
    export var BccRecipients: string = "BccRecipients";
    export var ReplyTo: string = "ReplyTo";
    export var ConversationTopic: string = "ConversationTopic";
    export var ConversationIndex: string = "ConversationIndex";
    export var IsDeliveryReceiptRequested: string = "IsDeliveryReceiptRequested";
    export var IsRead: string = "IsRead";
    export var IsReadReceiptRequested: string = "IsReadReceiptRequested";
    export var IsResponseRequested: string = "IsResponseRequested";
    export var InternetMessageId: string = "InternetMessageId";
    export var References: string = "References";
    export var ParentItemId: string = "ParentItemId";
    export var ParentFolderId: string = "ParentFolderId";
    export var ChildFolderCount: string = "ChildFolderCount";
    export var DisplayName: string = "DisplayName";
    export var TotalCount: string = "TotalCount";
    export var ItemClass: string = "ItemClass";
    export var FolderClass: string = "FolderClass";
    export var Subject: string = "Subject";
    export var MimeContent: string = "MimeContent";
    export var MimeContentUTF8: string = "MimeContentUTF8";
    export var Sensitivity: string = "Sensitivity";
    export var Attachments: string = "Attachments";
    export var DateTimeReceived: string = "DateTimeReceived";
    export var Size: string = "Size";
    export var Categories: string = "Categories";
    export var Importance: string = "Importance";
    export var InReplyTo: string = "InReplyTo";
    export var IsSubmitted: string = "IsSubmitted";
    export var IsAssociated: string = "IsAssociated";
    export var IsDraft: string = "IsDraft";
    export var IsFromMe: string = "IsFromMe";
    export var IsHidden: string = "IsHidden";
    export var IsQuickContact: string = "IsQuickContact";
    export var IsResend: string = "IsResend";
    export var IsUnmodified: string = "IsUnmodified";
    export var IsWritable: string = "IsWritable";
    export var InternetMessageHeader: string = "InternetMessageHeader";
    export var InternetMessageHeaders: string = "InternetMessageHeaders";
    export var DateTimeSent: string = "DateTimeSent";
    export var DateTimeCreated: string = "DateTimeCreated";
    export var ResponseObjects: string = "ResponseObjects";
    export var ReminderDueBy: string = "ReminderDueBy";
    export var ReminderIsSet: string = "ReminderIsSet";
    export var ReminderMinutesBeforeStart: string = "ReminderMinutesBeforeStart";
    export var DisplayCc: string = "DisplayCc";
    export var DisplayTo: string = "DisplayTo";
    export var HasAttachments: string = "HasAttachments";
    export var ExtendedProperty: string = "ExtendedProperty";
    export var Culture: string = "Culture";
    export var FileAttachment: string = "FileAttachment";
    export var ItemAttachment: string = "ItemAttachment";
    export var AttachmentIds: string = "AttachmentIds";
    export var AttachmentId: string = "AttachmentId";
    export var ContentType: string = "ContentType";
    export var ContentLocation: string = "ContentLocation";
    export var ContentId: string = "ContentId";
    export var Content: string = "Content";
    export var SavedItemFolderId: string = "SavedItemFolderId";
    export var MessageText: string = "MessageText";
    export var DescriptiveLinkKey: string = "DescriptiveLinkKey";
    export var ItemChange: string = "ItemChange";
    export var ItemChanges: string = "ItemChanges";
    export var FolderChange: string = "FolderChange";
    export var FolderChanges: string = "FolderChanges";
    export var Updates: string = "Updates";
    export var AppendToItemField: string = "AppendToItemField";
    export var SetItemField: string = "SetItemField";
    export var DeleteItemField: string = "DeleteItemField";
    export var SetFolderField: string = "SetFolderField";
    export var DeleteFolderField: string = "DeleteFolderField";
    export var FieldURI: string = "FieldURI";
    export var RootItemId: string = "RootItemId";
    export var ReferenceItemId: string = "ReferenceItemId";
    export var NewBodyContent: string = "NewBodyContent";
    export var ReplyToItem: string = "ReplyToItem";
    export var ReplyAllToItem: string = "ReplyAllToItem";
    export var ForwardItem: string = "ForwardItem";
    export var AcceptItem: string = "AcceptItem";
    export var TentativelyAcceptItem: string = "TentativelyAcceptItem";
    export var DeclineItem: string = "DeclineItem";
    export var CancelCalendarItem: string = "CancelCalendarItem";
    export var RemoveItem: string = "RemoveItem";
    export var SuppressReadReceipt: string = "SuppressReadReceipt";
    export var SuppressReadReceipts: string = "SuppressReadReceipts";
    export var String: string = "String";
    export var Start: string = "Start";
    export var End: string = "End";
    export var ProposedStart: string = "ProposedStart";
    export var ProposedEnd: string = "ProposedEnd";
    export var OriginalStart: string = "OriginalStart";
    export var IsAllDayEvent: string = "IsAllDayEvent";
    export var LegacyFreeBusyStatus: string = "LegacyFreeBusyStatus";
    export var Location: string = "Location";
    export var When: string = "When";
    export var IsMeeting: string = "IsMeeting";
    export var IsCancelled: string = "IsCancelled";
    export var IsRecurring: string = "IsRecurring";
    export var MeetingRequestWasSent: string = "MeetingRequestWasSent";
    export var CalendarItemType: string = "CalendarItemType";
    export var MyResponseType: string = "MyResponseType";
    export var Organizer: string = "Organizer";
    export var RequiredAttendees: string = "RequiredAttendees";
    export var OptionalAttendees: string = "OptionalAttendees";
    export var Resources: string = "Resources";
    export var ConflictingMeetingCount: string = "ConflictingMeetingCount";
    export var AdjacentMeetingCount: string = "AdjacentMeetingCount";
    export var ConflictingMeetings: string = "ConflictingMeetings";
    export var AdjacentMeetings: string = "AdjacentMeetings";
    export var Duration: string = "Duration";
    export var TimeZone: string = "TimeZone";
    export var AppointmentReplyTime: string = "AppointmentReplyTime";
    export var AppointmentSequenceNumber: string = "AppointmentSequenceNumber";
    export var AppointmentState: string = "AppointmentState";
    export var Recurrence: string = "Recurrence";
    export var FirstOccurrence: string = "FirstOccurrence";
    export var LastOccurrence: string = "LastOccurrence";
    export var ModifiedOccurrences: string = "ModifiedOccurrences";
    export var DeletedOccurrences: string = "DeletedOccurrences";
    export var MeetingTimeZone: string = "MeetingTimeZone";
    export var ConferenceType: string = "ConferenceType";
    export var AllowNewTimeProposal: string = "AllowNewTimeProposal";
    export var IsOnlineMeeting: string = "IsOnlineMeeting";
    export var MeetingWorkspaceUrl: string = "MeetingWorkspaceUrl";
    export var NetShowUrl: string = "NetShowUrl";
    export var JoinOnlineMeetingUrl: string = "JoinOnlineMeetingUrl";
    export var OnlineMeetingSettings: string = "OnlineMeetingSettings";
    export var LobbyBypass: string = "LobbyBypass";
    export var AccessLevel: string = "AccessLevel";
    export var Presenters: string = "Presenters";
    export var CalendarItem: string = "CalendarItem";
    export var CalendarFolder: string = "CalendarFolder";
    export var Attendee: string = "Attendee";
    export var ResponseType: string = "ResponseType";
    export var LastResponseTime: string = "LastResponseTime";
    export var Occurrence: string = "Occurrence";
    export var DeletedOccurrence: string = "DeletedOccurrence";
    export var RelativeYearlyRecurrence: string = "RelativeYearlyRecurrence";
    export var AbsoluteYearlyRecurrence: string = "AbsoluteYearlyRecurrence";
    export var RelativeMonthlyRecurrence: string = "RelativeMonthlyRecurrence";
    export var AbsoluteMonthlyRecurrence: string = "AbsoluteMonthlyRecurrence";
    export var WeeklyRecurrence: string = "WeeklyRecurrence";
    export var DailyRecurrence: string = "DailyRecurrence";
    export var DailyRegeneration: string = "DailyRegeneration";
    export var WeeklyRegeneration: string = "WeeklyRegeneration";
    export var MonthlyRegeneration: string = "MonthlyRegeneration";
    export var YearlyRegeneration: string = "YearlyRegeneration";
    export var NoEndRecurrence: string = "NoEndRecurrence";
    export var EndDateRecurrence: string = "EndDateRecurrence";
    export var NumberedRecurrence: string = "NumberedRecurrence";
    export var Interval: string = "Interval";
    export var DayOfMonth: string = "DayOfMonth";
    export var DayOfWeek: string = "DayOfWeek";
    export var DaysOfWeek: string = "DaysOfWeek";
    export var DayOfWeekIndex: string = "DayOfWeekIndex";
    export var Month: string = "Month";
    export var StartDate: string = "StartDate";
    export var EndDate: string = "EndDate";
    export var StartTime: string = "StartTime";
    export var EndTime: string = "EndTime";
    export var NumberOfOccurrences: string = "NumberOfOccurrences";
    export var AssociatedCalendarItemId: string = "AssociatedCalendarItemId";
    export var IsDelegated: string = "IsDelegated";
    export var IsOutOfDate: string = "IsOutOfDate";
    export var HasBeenProcessed: string = "HasBeenProcessed";
    export var IsOrganizer: string = "IsOrganizer";
    export var MeetingMessage: string = "MeetingMessage";
    export var FileAs: string = "FileAs";
    export var FileAsMapping: string = "FileAsMapping";
    export var GivenName: string = "GivenName";
    export var Initials: string = "Initials";
    export var MiddleName: string = "MiddleName";
    export var NickName: string = "Nickname";
    export var CompleteName: string = "CompleteName";
    export var CompanyName: string = "CompanyName";
    export var EmailAddresses: string = "EmailAddresses";
    export var PhysicalAddresses: string = "PhysicalAddresses";
    export var PhoneNumbers: string = "PhoneNumbers";
    export var PhoneNumber: string = "PhoneNumber";
    export var AssistantName: string = "AssistantName";
    export var Birthday: string = "Birthday";
    export var BusinessHomePage: string = "BusinessHomePage";
    export var Children: string = "Children";
    export var Companies: string = "Companies";
    export var ContactSource: string = "ContactSource";
    export var Department: string = "Department";
    export var Generation: string = "Generation";
    export var ImAddresses: string = "ImAddresses";
    export var ImAddress: string = "ImAddress";
    export var JobTitle: string = "JobTitle";
    export var Manager: string = "Manager";
    export var Mileage: string = "Mileage";
    export var OfficeLocation: string = "OfficeLocation";
    export var PostalAddressIndex: string = "PostalAddressIndex";
    export var Profession: string = "Profession";
    export var SpouseName: string = "SpouseName";
    export var Surname: string = "Surname";
    export var WeddingAnniversary: string = "WeddingAnniversary";
    export var HasPicture: string = "HasPicture";
    export var Title: string = "Title";
    export var FirstName: string = "FirstName";
    export var LastName: string = "LastName";
    export var Suffix: string = "Suffix";
    export var FullName: string = "FullName";
    export var YomiFirstName: string = "YomiFirstName";
    export var YomiLastName: string = "YomiLastName";
    export var Contact: string = "Contact";
    export var Entry: string = "Entry";
    export var Street: string = "Street";
    export var City: string = "City";
    export var State: string = "State";
    export var SharePointSiteUrl: string = "SharePointSiteUrl";
    export var Country: string = "Country";
    export var CountryOrRegion: string = "CountryOrRegion";
    export var PostalCode: string = "PostalCode";
    export var PostOfficeBox: string = "PostOfficeBox";
    export var Members: string = "Members";
    export var Member: string = "Member";
    export var AdditionalProperties: string = "AdditionalProperties";
    export var ExtendedFieldURI: string = "ExtendedFieldURI";
    export var Value: string = "Value";
    export var Values: string = "Values";
    export var ToFolderId: string = "ToFolderId";
    export var ActualWork: string = "ActualWork";
    export var AssignedTime: string = "AssignedTime";
    export var BillingInformation: string = "BillingInformation";
    export var ChangeCount: string = "ChangeCount";
    export var CompleteDate: string = "CompleteDate";
    export var Contacts: string = "Contacts";
    export var DelegationState: string = "DelegationState";
    export var Delegator: string = "Delegator";
    export var DueDate: string = "DueDate";
    export var IsAssignmentEditable: string = "IsAssignmentEditable";
    export var IsComplete: string = "IsComplete";
    export var IsTeamTask: string = "IsTeamTask";
    export var Owner: string = "Owner";
    export var PercentComplete: string = "PercentComplete";
    export var Status: string = "Status";
    export var StatusDescription: string = "StatusDescription";
    export var TotalWork: string = "TotalWork";
    export var Task: string = "Task";
    export var MailboxCulture: string = "MailboxCulture";
    export var MeetingRequestType: string = "MeetingRequestType";
    export var IntendedFreeBusyStatus: string = "IntendedFreeBusyStatus";
    export var MeetingRequest: string = "MeetingRequest";
    export var MeetingResponse: string = "MeetingResponse";
    export var MeetingCancellation: string = "MeetingCancellation";
    export var ChangeHighlights: string = "ChangeHighlights";
    export var HasLocationChanged: string = "HasLocationChanged";
    export var HasStartTimeChanged: string = "HasStartTimeChanged";
    export var HasEndTimeChanged: string = "HasEndTimeChanged";
    export var BaseOffset: string = "BaseOffset";
    export var Offset: string = "Offset";
    export var Standard: string = "Standard";
    export var Daylight: string = "Daylight";
    export var Time: string = "Time";
    export var AbsoluteDate: string = "AbsoluteDate";
    export var UnresolvedEntry: string = "UnresolvedEntry";
    export var ResolutionSet: string = "ResolutionSet";
    export var Resolution: string = "Resolution";
    export var DistributionList: string = "DistributionList";
    export var DLExpansion: string = "DLExpansion";
    export var IndexedFieldURI: string = "IndexedFieldURI";
    export var PullSubscriptionRequest: string = "PullSubscriptionRequest";
    export var PushSubscriptionRequest: string = "PushSubscriptionRequest";
    export var StreamingSubscriptionRequest: string = "StreamingSubscriptionRequest";
    export var EventTypes: string = "EventTypes";
    export var EventType: string = "EventType";
    export var Timeout: string = "Timeout";
    export var Watermark: string = "Watermark";
    export var SubscriptionId: string = "SubscriptionId";
    export var SubscriptionIds: string = "SubscriptionIds";
    export var StatusFrequency: string = "StatusFrequency";
    export var URL: string = "URL";
    export var CallerData: string = "CallerData";
    export var Notification: string = "Notification";
    export var Notifications: string = "Notifications";
    export var PreviousWatermark: string = "PreviousWatermark";
    export var MoreEvents: string = "MoreEvents";
    export var TimeStamp: string = "TimeStamp";
    export var UnreadCount: string = "UnreadCount";
    export var OldParentFolderId: string = "OldParentFolderId";
    export var CopiedEvent: string = "CopiedEvent";
    export var CreatedEvent: string = "CreatedEvent";
    export var DeletedEvent: string = "DeletedEvent";
    export var ModifiedEvent: string = "ModifiedEvent";
    export var MovedEvent: string = "MovedEvent";
    export var NewMailEvent: string = "NewMailEvent";
    export var StatusEvent: string = "StatusEvent";
    export var FreeBusyChangedEvent: string = "FreeBusyChangedEvent";
    export var ExchangeImpersonation: string = "ExchangeImpersonation";
    export var ConnectingSID: string = "ConnectingSID";
    export var OpenAsAdminOrSystemService: string = "OpenAsAdminOrSystemService";
    export var LogonType: string = "LogonType";
    export var BudgetType: string = "BudgetType";
    export var ManagementRole: string = "ManagementRole";
    export var UserRoles: string = "UserRoles";
    export var ApplicationRoles: string = "ApplicationRoles";
    export var Role: string = "Role";
    export var SyncFolderId: string = "SyncFolderId";
    export var SyncScope: string = "SyncScope";
    export var SyncState: string = "SyncState";
    export var Ignore: string = "Ignore";
    export var MaxChangesReturned: string = "MaxChangesReturned";
    export var Changes: string = "Changes";
    export var IncludesLastItemInRange: string = "IncludesLastItemInRange";
    export var IncludesLastFolderInRange: string = "IncludesLastFolderInRange";
    export var Create: string = "Create";
    export var Update: string = "Update";
    export var Delete: string = "Delete";
    export var ReadFlagChange: string = "ReadFlagChange";
    export var SearchParameters: string = "SearchParameters";
    export var SoftDeleted: string = "SoftDeleted";
    export var Shallow: string = "Shallow";
    export var Associated: string = "Associated";
    export var BaseFolderId: string = "BaseFolderId";
    export var BaseFolderIds: string = "BaseFolderIds";
    export var SortOrder: string = "SortOrder";
    export var FieldOrder: string = "FieldOrder";
    export var CanDelete: string = "CanDelete";
    export var CanRenameOrMove: string = "CanRenameOrMove";
    export var MustDisplayComment: string = "MustDisplayComment";
    export var HasQuota: string = "HasQuota";
    export var IsManagedFoldersRoot: string = "IsManagedFoldersRoot";
    export var ManagedFolderId: string = "ManagedFolderId";
    export var Comment: string = "Comment";
    export var StorageQuota: string = "StorageQuota";
    export var FolderSize: string = "FolderSize";
    export var HomePage: string = "HomePage";
    export var ManagedFolderInformation: string = "ManagedFolderInformation";
    export var CalendarView: string = "CalendarView";
    export var PostedTime: string = "PostedTime";
    export var PostItem: string = "PostItem";
    export var RequestServerVersion: string = "RequestServerVersion";
    export var PostReplyItem: string = "PostReplyItem";
    export var CreateAssociated: string = "CreateAssociated";
    export var CreateContents: string = "CreateContents";
    export var CreateHierarchy: string = "CreateHierarchy";
    export var Modify: string = "Modify";
    export var Read: string = "Read";
    export var EffectiveRights: string = "EffectiveRights";
    export var LastModifiedName: string = "LastModifiedName";
    export var LastModifiedTime: string = "LastModifiedTime";
    export var ConversationId: string = "ConversationId";
    export var UniqueBody: string = "UniqueBody";
    export var BodyType: string = "BodyType";
    export var NormalizedBodyType: string = "NormalizedBodyType";
    export var UniqueBodyType: string = "UniqueBodyType";
    export var AttachmentShape: string = "AttachmentShape";
    export var UserId: string = "UserId";
    export var UserIds: string = "UserIds";
    export var CanCreateItems: string = "CanCreateItems";
    export var CanCreateSubFolders: string = "CanCreateSubFolders";
    export var IsFolderOwner: string = "IsFolderOwner";
    export var IsFolderVisible: string = "IsFolderVisible";
    export var IsFolderContact: string = "IsFolderContact";
    export var EditItems: string = "EditItems";
    export var DeleteItems: string = "DeleteItems";
    export var ReadItems: string = "ReadItems";
    export var PermissionLevel: string = "PermissionLevel";
    export var CalendarPermissionLevel: string = "CalendarPermissionLevel";
    export var SID: string = "SID";
    export var PrimarySmtpAddress: string = "PrimarySmtpAddress";
    export var DistinguishedUser: string = "DistinguishedUser";
    export var PermissionSet: string = "PermissionSet";
    export var Permissions: string = "Permissions";
    export var Permission: string = "Permission";
    export var CalendarPermissions: string = "CalendarPermissions";
    export var CalendarPermission: string = "CalendarPermission";
    export var GroupBy: string = "GroupBy";
    export var AggregateOn: string = "AggregateOn";
    export var Groups: string = "Groups";
    export var GroupedItems: string = "GroupedItems";
    export var GroupIndex: string = "GroupIndex";
    export var ConflictResults: string = "ConflictResults";
    export var Count: string = "Count";
    export var OofSettings: string = "OofSettings";
    export var UserOofSettings: string = "UserOofSettings";
    export var OofState: string = "OofState";
    export var ExternalAudience: string = "ExternalAudience";
    export var AllowExternalOof: string = "AllowExternalOof";
    export var InternalReply: string = "InternalReply";
    export var ExternalReply: string = "ExternalReply";
    export var Bias: string = "Bias";
    export var DayOrder: string = "DayOrder";
    export var Year: string = "Year";
    export var StandardTime: string = "StandardTime";
    export var DaylightTime: string = "DaylightTime";
    export var MailboxData: string = "MailboxData";
    export var MailboxDataArray: string = "MailboxDataArray";
    export var Email: string = "Email";
    export var AttendeeType: string = "AttendeeType";
    export var ExcludeConflicts: string = "ExcludeConflicts";
    export var FreeBusyViewOptions: string = "FreeBusyViewOptions";
    export var SuggestionsViewOptions: string = "SuggestionsViewOptions";
    export var FreeBusyView: string = "FreeBusyView";
    export var TimeWindow: string = "TimeWindow";
    export var MergedFreeBusyIntervalInMinutes: string = "MergedFreeBusyIntervalInMinutes";
    export var RequestedView: string = "RequestedView";
    export var FreeBusyViewType: string = "FreeBusyViewType";
    export var CalendarEventArray: string = "CalendarEventArray";
    export var CalendarEvent: string = "CalendarEvent";
    export var BusyType: string = "BusyType";
    export var MergedFreeBusy: string = "MergedFreeBusy";
    export var WorkingHours: string = "WorkingHours";
    export var WorkingPeriodArray: string = "WorkingPeriodArray";
    export var WorkingPeriod: string = "WorkingPeriod";
    export var StartTimeInMinutes: string = "StartTimeInMinutes";
    export var EndTimeInMinutes: string = "EndTimeInMinutes";
    export var GoodThreshold: string = "GoodThreshold";
    export var MaximumResultsByDay: string = "MaximumResultsByDay";
    export var MaximumNonWorkHourResultsByDay: string = "MaximumNonWorkHourResultsByDay";
    export var MeetingDurationInMinutes: string = "MeetingDurationInMinutes";
    export var MinimumSuggestionQuality: string = "MinimumSuggestionQuality";
    export var DetailedSuggestionsWindow: string = "DetailedSuggestionsWindow";
    export var CurrentMeetingTime: string = "CurrentMeetingTime";
    export var GlobalObjectId: string = "GlobalObjectId";
    export var SuggestionDayResultArray: string = "SuggestionDayResultArray";
    export var SuggestionDayResult: string = "SuggestionDayResult";
    export var Date: string = "Date";
    export var DayQuality: string = "DayQuality";
    export var SuggestionArray: string = "SuggestionArray";
    export var Suggestion: string = "Suggestion";
    export var MeetingTime: string = "MeetingTime";
    export var IsWorkTime: string = "IsWorkTime";
    export var SuggestionQuality: string = "SuggestionQuality";
    export var AttendeeConflictDataArray: string = "AttendeeConflictDataArray";
    export var UnknownAttendeeConflictData: string = "UnknownAttendeeConflictData";
    export var TooBigGroupAttendeeConflictData: string = "TooBigGroupAttendeeConflictData";
    export var IndividualAttendeeConflictData: string = "IndividualAttendeeConflictData";
    export var GroupAttendeeConflictData: string = "GroupAttendeeConflictData";
    export var NumberOfMembers: string = "NumberOfMembers";
    export var NumberOfMembersAvailable: string = "NumberOfMembersAvailable";
    export var NumberOfMembersWithConflict: string = "NumberOfMembersWithConflict";
    export var NumberOfMembersWithNoData: string = "NumberOfMembersWithNoData";
    export var SourceIds: string = "SourceIds";
    export var AlternateId: string = "AlternateId";
    export var AlternatePublicFolderId: string = "AlternatePublicFolderId";
    export var AlternatePublicFolderItemId: string = "AlternatePublicFolderItemId";
    export var DelegatePermissions: string = "DelegatePermissions";
    export var ReceiveCopiesOfMeetingMessages: string = "ReceiveCopiesOfMeetingMessages";
    export var ViewPrivateItems: string = "ViewPrivateItems";
    export var CalendarFolderPermissionLevel: string = "CalendarFolderPermissionLevel";
    export var TasksFolderPermissionLevel: string = "TasksFolderPermissionLevel";
    export var InboxFolderPermissionLevel: string = "InboxFolderPermissionLevel";
    export var ContactsFolderPermissionLevel: string = "ContactsFolderPermissionLevel";
    export var NotesFolderPermissionLevel: string = "NotesFolderPermissionLevel";
    export var JournalFolderPermissionLevel: string = "JournalFolderPermissionLevel";
    export var DelegateUser: string = "DelegateUser";
    export var DelegateUsers: string = "DelegateUsers";
    export var DeliverMeetingRequests: string = "DeliverMeetingRequests";
    export var MessageXml: string = "MessageXml";
    export var UserConfiguration: string = "UserConfiguration";
    export var UserConfigurationName: string = "UserConfigurationName";
    export var UserConfigurationProperties: string = "UserConfigurationProperties";
    export var Dictionary: string = "Dictionary";
    export var DictionaryEntry: string = "DictionaryEntry";
    export var DictionaryKey: string = "DictionaryKey";
    export var DictionaryValue: string = "DictionaryValue";
    export var XmlData: string = "XmlData";
    export var BinaryData: string = "BinaryData";
    export var FilterHtmlContent: string = "FilterHtmlContent";
    export var ConvertHtmlCodePageToUTF8: string = "ConvertHtmlCodePageToUTF8";
    export var UnknownEntries: string = "UnknownEntries";
    export var UnknownEntry: string = "UnknownEntry";
    export var PasswordExpirationDate: string = "PasswordExpirationDate";
    export var Flag: string = "Flag";
    export var PersonaPostalAddress: string = "PostalAddress";
    export var PostalAddressType: string = "Type";
    export var EnhancedLocation: string = "EnhancedLocation";
    export var LocationDisplayName: string = "DisplayName";
    export var LocationAnnotation: string = "Annotation";
    export var LocationSource: string = "LocationSource";
    export var LocationUri: string = "LocationUri";
    export var Latitude: string = "Latitude";
    export var Longitude: string = "Longitude";
    export var Accuracy: string = "Accuracy";
    export var Altitude: string = "Altitude";
    export var AltitudeAccuracy: string = "AltitudeAccuracy";
    export var FormattedAddress: string = "FormattedAddress";
    export var Guid: string = "Guid";
    export var PhoneCallId: string = "PhoneCallId";
    export var DialString: string = "DialString";
    export var PhoneCallInformation: string = "PhoneCallInformation";
    export var PhoneCallState: string = "PhoneCallState";
    export var ConnectionFailureCause: string = "ConnectionFailureCause";
    export var SIPResponseCode: string = "SIPResponseCode";
    export var SIPResponseText: string = "SIPResponseText";
    export var WebClientReadFormQueryString: string = "WebClientReadFormQueryString";
    export var WebClientEditFormQueryString: string = "WebClientEditFormQueryString";
    export var Ids: string = "Ids";
    export var Id: string = "Id";
    export var TimeZoneDefinitions: string = "TimeZoneDefinitions";
    export var TimeZoneDefinition: string = "TimeZoneDefinition";
    export var Periods: string = "Periods";
    export var Period: string = "Period";
    export var TransitionsGroups: string = "TransitionsGroups";
    export var TransitionsGroup: string = "TransitionsGroup";
    export var Transitions: string = "Transitions";
    export var Transition: string = "Transition";
    export var AbsoluteDateTransition: string = "AbsoluteDateTransition";
    export var RecurringDayTransition: string = "RecurringDayTransition";
    export var RecurringDateTransition: string = "RecurringDateTransition";
    export var DateTime: string = "DateTime";
    export var TimeOffset: string = "TimeOffset";
    export var Day: string = "Day";
    export var TimeZoneContext: string = "TimeZoneContext";
    export var StartTimeZone: string = "StartTimeZone";
    export var EndTimeZone: string = "EndTimeZone";
    export var ReceivedBy: string = "ReceivedBy";
    export var ReceivedRepresenting: string = "ReceivedRepresenting";
    export var Uid: string = "UID";
    export var RecurrenceId: string = "RecurrenceId";
    export var DateTimeStamp: string = "DateTimeStamp";
    export var IsInline: string = "IsInline";
    export var IsContactPhoto: string = "IsContactPhoto";
    export var QueryString: string = "QueryString";
    export var HighlightTerms: string = "HighlightTerms";
    export var HighlightTerm: string = "Term";
    export var HighlightTermScope: string = "Scope";
    export var HighlightTermValue: string = "Value";
    export var CalendarEventDetails: string = "CalendarEventDetails";
    export var ID: string = "ID";
    export var IsException: string = "IsException";
    export var IsReminderSet: string = "IsReminderSet";
    export var IsPrivate: string = "IsPrivate";
    export var FirstDayOfWeek: string = "FirstDayOfWeek";
    export var Verb: string = "Verb";
    export var Parameter: string = "Parameter";
    export var ReturnValue: string = "ReturnValue";
    export var ReturnNewItemIds: string = "ReturnNewItemIds";
    export var DateTimePrecision: string = "DateTimePrecision";
    export var ConvertInlineImagesToDataUrls: string = "ConvertInlineImagesToDataUrls";
    export var InlineImageUrlTemplate: string = "InlineImageUrlTemplate";
    export var BlockExternalImages: string = "BlockExternalImages";
    export var AddBlankTargetToLinks: string = "AddBlankTargetToLinks";
    export var MaximumBodySize: string = "MaximumBodySize";
    export var StoreEntryId: string = "StoreEntryId";
    export var InstanceKey: string = "InstanceKey";
    export var NormalizedBody: string = "NormalizedBody";
    export var PolicyTag: string = "PolicyTag";
    export var ArchiveTag: string = "ArchiveTag";
    export var RetentionDate: string = "RetentionDate";
    export var DisableReason: string = "DisableReason";
    export var AppMarketplaceUrl: string = "AppMarketplaceUrl";
    export var TextBody: string = "TextBody";
    export var IconIndex: string = "IconIndex";
    export var GlobalIconIndex: string = "GlobalIconIndex";
    export var DraftItemIds: string = "DraftItemIds";
    export var HasIrm: string = "HasIrm";
    export var GlobalHasIrm: string = "GlobalHasIrm";
    export var ApprovalRequestData: string = "ApprovalRequestData";
    export var IsUndecidedApprovalRequest: string = "IsUndecidedApprovalRequest";
    export var ApprovalDecision: string = "ApprovalDecision";
    export var ApprovalDecisionMaker: string = "ApprovalDecisionMaker";
    export var ApprovalDecisionTime: string = "ApprovalDecisionTime";
    export var VotingOptionData: string = "VotingOptionData";
    export var VotingOptionDisplayName: string = "DisplayName";
    export var SendPrompt: string = "SendPrompt";
    export var VotingInformation: string = "VotingInformation";
    export var UserOptions: string = "UserOptions";
    export var VotingResponse: string = "VotingResponse";
    export var NumberOfDays: string = "NumberOfDays";
    export var AcceptanceState: string = "AcceptanceState";

    export var NlgEntityExtractionResult: string = "EntityExtractionResult";
    export var NlgAddresses: string = "Addresses";
    export var NlgAddress: string = "Address";
    export var NlgMeetingSuggestions: string = "MeetingSuggestions";
    export var NlgMeetingSuggestion: string = "MeetingSuggestion";
    export var NlgTaskSuggestions: string = "TaskSuggestions";
    export var NlgTaskSuggestion: string = "TaskSuggestion";
    export var NlgBusinessName: string = "BusinessName";
    export var NlgPeopleName: string = "PeopleName";
    export var NlgEmailAddresses: string = "EmailAddresses";
    export var NlgEmailAddress: string = "EmailAddress";
    export var NlgEmailPosition: string = "Position";
    export var NlgContacts: string = "Contacts";
    export var NlgContact: string = "Contact";
    export var NlgContactString: string = "ContactString";
    export var NlgUrls: string = "Urls";
    export var NlgUrl: string = "Url";
    export var NlgPhoneNumbers: string = "PhoneNumbers";
    export var NlgPhone: string = "Phone";
    export var NlgAttendees: string = "Attendees";
    export var NlgEmailUser: string = "EmailUser";
    export var NlgLocation: string = "Location";
    export var NlgSubject: string = "Subject";
    export var NlgMeetingString: string = "MeetingString";
    export var NlgStartTime: string = "StartTime";
    export var NlgEndTime: string = "EndTime";
    export var NlgTaskString: string = "TaskString";
    export var NlgAssignees: string = "Assignees";
    export var NlgPersonName: string = "PersonName";
    export var NlgOriginalPhoneString: string = "OriginalPhoneString";
    export var NlgPhoneString: string = "PhoneString";
    export var NlgType: string = "Type";
    export var NlgName: string = "Name";
    export var NlgUserId: string = "UserId";

    export var GetClientAccessToken: string = "GetClientAccessToken";
    export var GetClientAccessTokenResponse: string = "GetClientAccessTokenResponse";
    export var GetClientAccessTokenResponseMessage: string = "GetClientAccessTokenResponseMessage";
    export var TokenRequests: string = "TokenRequests";
    export var TokenRequest: string = "TokenRequest";
    export var TokenType: string = "TokenType";
    export var TokenValue: string = "TokenValue";
    export var TTL: string = "TTL";
    export var Tokens: string = "Tokens";

    export var MarkAsJunk: string = "MarkAsJunk";
    export var MarkAsJunkResponse: string = "MarkAsJunkResponse";
    export var MarkAsJunkResponseMessage: string = "MarkAsJunkResponseMessage";
    export var MovedItemId: string = "MovedItemId";

    /* #region Persona */

    export var CreationTime: string = "CreationTime";
    export var People: string = "People";
    export var Persona: string = "Persona";
    export var PersonaId: string = "PersonaId";
    export var PersonaShape: string = "PersonaShape";
    export var RelevanceScore: string = "RelevanceScore";
    export var TotalNumberOfPeopleInView: string = "TotalNumberOfPeopleInView";
    export var FirstMatchingRowIndex: string = "FirstMatchingRowIndex";
    export var FirstLoadedRowIndex: string = "FirstLoadedRowIndex";
    export var YomiCompanyName: string = "YomiCompanyName";
    export var Emails1: string = "Emails1";
    export var Emails2: string = "Emails2";
    export var Emails3: string = "Emails3";
    export var HomeAddresses: string = "HomeAddresses";
    export var BusinessAddresses: string = "BusinessAddresses";
    export var OtherAddresses: string = "OtherAddresses";
    export var BusinessPhoneNumbers: string = "BusinessPhoneNumbers";
    export var BusinessPhoneNumbers2: string = "BusinessPhoneNumbers2";
    export var AssistantPhoneNumbers: string = "AssistantPhoneNumbers";
    export var TTYTDDPhoneNumbers: string = "TTYTDDPhoneNumbers";
    export var HomePhones: string = "HomePhones";
    export var HomePhones2: string = "HomePhones2";
    export var MobilePhones: string = "MobilePhones";
    export var MobilePhones2: string = "MobilePhones2";
    export var CallbackPhones: string = "CallbackPhones";
    export var CarPhones: string = "CarPhones";
    export var HomeFaxes: string = "HomeFaxes";
    export var OrganizationMainPhones: string = "OrganizationMainPhones";
    export var OtherFaxes: string = "OtherFaxes";
    export var OtherTelephones: string = "OtherTelephones";
    export var OtherPhones2: string = "OtherPhones2";
    export var Pagers: string = "Pagers";
    export var RadioPhones: string = "RadioPhones";
    export var TelexNumbers: string = "TelexNumbers";
    export var WorkFaxes: string = "WorkFaxes";
    export var FileAses: string = "FileAses";
    export var CompanyNames: string = "CompanyNames";
    export var DisplayNames: string = "DisplayNames";
    export var DisplayNamePrefixes: string = "DisplayNamePrefixes";
    export var GivenNames: string = "GivenNames";
    export var MiddleNames: string = "MiddleNames";
    export var Surnames: string = "Surnames";
    export var Generations: string = "Generations";
    export var Nicknames: string = "Nicknames";
    export var YomiCompanyNames: string = "YomiCompanyNames";
    export var YomiFirstNames: string = "YomiFirstNames";
    export var YomiLastNames: string = "YomiLastNames";
    export var Managers: string = "Managers";
    export var AssistantNames: string = "AssistantNames";
    export var Professions: string = "Professions";
    export var SpouseNames: string = "SpouseNames";
    export var Departments: string = "Departments";
    export var Titles: string = "Titles";
    export var ImAddresses2: string = "ImAddresses2";
    export var ImAddresses3: string = "ImAddresses3";
    export var DisplayNamePrefix: string = "DisplayNamePrefix";
    export var DisplayNameFirstLast: string = "DisplayNameFirstLast";
    export var DisplayNameLastFirst: string = "DisplayNameLastFirst";
    export var DisplayNameFirstLastHeader: string = "DisplayNameFirstLastHeader";
    export var DisplayNameLastFirstHeader: string = "DisplayNameLastFirstHeader";
    export var IsFavorite: string = "IsFavorite";
    export var Schools: string = "Schools";
    export var Hobbies: string = "Hobbies";
    export var Locations: string = "Locations";
    export var OfficeLocations: string = "OfficeLocations";
    export var BusinessHomePages: string = "BusinessHomePages";
    export var PersonalHomePages: string = "PersonalHomePages";
    export var ThirdPartyPhotoUrls: string = "ThirdPartyPhotoUrls";
    export var Attribution: string = "Attribution";
    export var Attributions: string = "Attributions";
    export var StringAttributedValue: string = "StringAttributedValue";
    export var DisplayNameFirstLastSortKey: string = "DisplayNameFirstLastSortKey";
    export var DisplayNameLastFirstSortKey: string = "DisplayNameLastFirstSortKey";
    export var CompanyNameSortKey: string = "CompanyNameSortKey";
    export var HomeCitySortKey: string = "HomeCitySortKey";
    export var WorkCitySortKey: string = "WorkCitySortKey";
    export var FileAsId: string = "FileAsId";
    export var FileAsIds: string = "FileAsIds";
    export var HomeCity: string = "HomeCity";
    export var WorkCity: string = "WorkCity";
    export var PersonaType: string = "PersonaType";
    export var Birthdays: string = "Birthdays";
    export var BirthdaysLocal: string = "BirthdaysLocal";
    export var WeddingAnniversaries: string = "WeddingAnniversaries";
    export var WeddingAnniversariesLocal: string = "WeddingAnniversariesLocal";
    export var OriginalDisplayName: string = "OriginalDisplayName";

    /* #endregion */

    /* #region People Insights */
    export var Person: string = "Person";
    export var Insights: string = "Insights";
    export var Insight: string = "Insight";
    export var InsightGroupType: string = "InsightGroupType";
    export var InsightType: string = "InsightType";
    export var InsightSourceType: string = "InsightSourceType";
    export var InsightValue: string = "InsightValue";
    export var InsightSource: string = "InsightSource";
    export var UpdatedUtcTicks: string = "UpdatedUtcTicks";
    export var StringInsightValue: string = "StringInsightValue";
    export var ProfileInsightValue: string = "ProfileInsightValue";
    export var JobInsightValue: string = "JobInsightValue";
    export var UserProfilePicture: string = "UserProfilePicture";
    export var EducationInsightValue: string = "EducationInsightValue";
    export var SkillInsightValue: string = "SkillInsightValue";
    export var DelveDoc: string = "DelveDoc";
    export var CompanyInsightValue: string = "CompanyInsightValue";
    export var ArrayOfInsightValue: string = "ArrayOfInsightValue";
    export var InsightContent: string = "InsightContent";
    export var SingleValueInsightContent: string = "SingleValueInsightContent";
    export var MultiValueInsightContent: string = "MultiValueInsightContent";
    export var ArrayOfInsight: string = "ArrayOfInsight";
    export var PersonType: string = "PersonType";
    export var SatoriId: string = "SatoriId";
    export var DescriptionAttribution: string = "DescriptionAttribution";
    export var ImageUrl: string = "ImageUrl";
    export var ImageUrlAttribution: string = "ImageUrlAttribution";
    export var YearFound: string = "YearFound";
    export var FinanceSymbol: string = "FinanceSymbol";
    export var WebsiteUrl: string = "WebsiteUrl";
    export var Rank: string = "Rank";
    export var Author: string = "Author";
    export var Created: string = "Created";
    export var DefaultEncodingURL: string = "DefaultEncodingURL";
    export var FileType: string = "FileType";
    export var Data: string = "Data";
    export var ItemList: string = "ItemList";
    export var Avatar: string = "Avatar";
    export var JoinedUtcTicks: string = "JoinedUtcTicks";
    export var Company: string = "Company";
    export var StartUtcTicks: string = "StartUtcTicks";
    export var EndUtcTicks: string = "EndUtcTicks";
    export var Blob: string = "Blob";
    export var PhotoSize: string = "PhotoSize";
    export var Institute: string = "Institute";
    export var Degree: string = "Degree";
    export var Strength: string = "Strength";
        
    /* #endregion */

    /* #region Conversations */

    export var Conversations: string = "Conversations";
    export var Conversation: string = "Conversation";
    export var UniqueRecipients: string = "UniqueRecipients";
    export var GlobalUniqueRecipients: string = "GlobalUniqueRecipients";
    export var UniqueUnreadSenders: string = "UniqueUnreadSenders";
    export var GlobalUniqueUnreadSenders: string = "GlobalUniqueUnreadSenders";
    export var UniqueSenders: string = "UniqueSenders";
    export var GlobalUniqueSenders: string = "GlobalUniqueSenders";
    export var LastDeliveryTime: string = "LastDeliveryTime";
    export var GlobalLastDeliveryTime: string = "GlobalLastDeliveryTime";
    export var GlobalCategories: string = "GlobalCategories";
    export var FlagStatus: string = "FlagStatus";
    export var GlobalFlagStatus: string = "GlobalFlagStatus";
    export var GlobalHasAttachments: string = "GlobalHasAttachments";
    export var MessageCount: string = "MessageCount";
    export var GlobalMessageCount: string = "GlobalMessageCount";
    export var GlobalUnreadCount: string = "GlobalUnreadCount";
    export var GlobalSize: string = "GlobalSize";
    export var ItemClasses: string = "ItemClasses";
    export var GlobalItemClasses: string = "GlobalItemClasses";
    export var GlobalImportance: string = "GlobalImportance";
    export var GlobalInferredImportance: string = "GlobalInferredImportance";
    export var GlobalItemIds: string = "GlobalItemIds";
    export var ChangeType: string = "ChangeType";
    export var ReadFlag: string = "ReadFlag";
    export var TotalConversationsInView: string = "TotalConversationsInView";
    export var IndexedOffset: string = "IndexedOffset";
    export var ConversationShape: string = "ConversationShape";
    export var MailboxScope: string = "MailboxScope";

    // ApplyConversationAction
    export var ApplyConversationAction: string = "ApplyConversationAction";
    export var ConversationActions: string = "ConversationActions";
    export var ConversationAction: string = "ConversationAction";
    export var ApplyConversationActionResponse: string = "ApplyConversationActionResponse";
    export var ApplyConversationActionResponseMessage: string = "ApplyConversationActionResponseMessage";
    export var EnableAlwaysDelete: string = "EnableAlwaysDelete";
    export var ProcessRightAway: string = "ProcessRightAway";
    export var DestinationFolderId: string = "DestinationFolderId";
    export var ContextFolderId: string = "ContextFolderId";
    export var ConversationLastSyncTime: string = "ConversationLastSyncTime";
    export var AlwaysCategorize: string = "AlwaysCategorize";
    export var AlwaysDelete: string = "AlwaysDelete";
    export var AlwaysMove: string = "AlwaysMove";
    export var Move: string = "Move";
    export var Copy: string = "Copy";
    export var SetReadState: string = "SetReadState";
    export var SetRetentionPolicy: string = "SetRetentionPolicy";
    export var DeleteType: string = "DeleteType";
    export var RetentionPolicyType: string = "RetentionPolicyType";
    export var RetentionPolicyTagId: string = "RetentionPolicyTagId";

    // GetConversationItems
    export var FoldersToIgnore: string = "FoldersToIgnore";
    export var ParentInternetMessageId: string = "ParentInternetMessageId";
    export var ConversationNode: string = "ConversationNode";
    export var ConversationNodes: string = "ConversationNodes";
    export var MaxItemsToReturn: string = "MaxItemsToReturn";

    /* #endregion */

    /* #region TeamMailbox */

    export var SetTeamMailbox: string = "SetTeamMailbox";
    export var SetTeamMailboxResponse: string = "SetTeamMailboxResponse";
    export var UnpinTeamMailbox: string = "UnpinTeamMailbox";
    export var UnpinTeamMailboxResponse: string = "UnpinTeamMailboxResponse";

    /* #endregion */

    /* #region RoomList & Room */

    export var RoomLists: string = "RoomLists";
    export var Rooms: string = "Rooms";
    export var Room: string = "Room";
    export var RoomList: string = "RoomList";
    export var RoomId: string = "Id";

    /* #endregion */

    /* #region Autodiscover */

    export var Autodiscover: string = "Autodiscover";
    export var BinarySecret: string = "BinarySecret";
    export var Response: string = "Response";
    export var User: string = "User";
    export var LegacyDN: string = "LegacyDN";
    export var DeploymentId: string = "DeploymentId";
    export var Account: string = "Account";
    export var AccountType: string = "AccountType";
    export var Action: string = "Action";
    export var To: string = "To";
    export var RedirectAddr: string = "RedirectAddr";
    export var RedirectUrl: string = "RedirectUrl";
    export var Protocol: string = "Protocol";
    export var Type: string = "Type";
    export var Server: string = "Server";
    export var OwnerSmtpAddress: string = "OwnerSmtpAddress";
    export var ServerDN: string = "ServerDN";
    export var ServerVersion: string = "ServerVersion";
    export var ServerVersionInfo: string = "ServerVersionInfo";
    export var AD: string = "AD";
    export var AuthPackage: string = "AuthPackage";
    export var MdbDN: string = "MdbDN";
    export var EWSUrl: string = "EwsUrl"; // Server side emits "Ews", not "EWS".
    export var EwsPartnerUrl: string = "EwsPartnerUrl";
    export var EmwsUrl: string = "EmwsUrl";
    export var ASUrl: string = "ASUrl";
    export var OOFUrl: string = "OOFUrl";
    export var UMUrl: string = "UMUrl";
    export var OABUrl: string = "OABUrl";
    export var Internal: string = "Internal";
    export var External: string = "External";
    export var OWAUrl: string = "OWAUrl";
    export var Error: string = "Error";
    export var ErrorCode: string = "ErrorCode";
    export var DebugData: string = "DebugData";
    export var Users: string = "Users";
    export var RequestedSettings: string = "RequestedSettings";
    export var Setting: string = "Setting";
    export var GetUserSettingsRequestMessage: string = "GetUserSettingsRequestMessage";
    export var RequestedServerVersion: string = "RequestedServerVersion";
    export var Request: string = "Request";
    export var RedirectTarget: string = "RedirectTarget";
    export var UserSettings: string = "UserSettings";
    export var UserSettingErrors: string = "UserSettingErrors";
    export var GetUserSettingsResponseMessage: string = "GetUserSettingsResponseMessage";
    export var ErrorMessage: string = "ErrorMessage";
    export var UserResponse: string = "UserResponse";
    export var UserResponses: string = "UserResponses";
    export var UserSettingError: string = "UserSettingError";
    export var Domain: string = "Domain";
    export var Domains: string = "Domains";
    export var DomainResponse: string = "DomainResponse";
    export var DomainResponses: string = "DomainResponses";
    export var DomainSetting: string = "DomainSetting";
    export var DomainSettings: string = "DomainSettings";
    export var DomainStringSetting: string = "DomainStringSetting";
    export var DomainSettingError: string = "DomainSettingError";
    export var DomainSettingErrors: string = "DomainSettingErrors";
    export var GetDomainSettingsRequestMessage: string = "GetDomainSettingsRequestMessage";
    export var GetDomainSettingsResponseMessage: string = "GetDomainSettingsResponseMessage";
    export var SettingName: string = "SettingName";
    export var UserSetting: string = "UserSetting";
    export var StringSetting: string = "StringSetting";
    export var WebClientUrlCollectionSetting: string = "WebClientUrlCollectionSetting";
    export var WebClientUrls: string = "WebClientUrls";
    export var WebClientUrl: string = "WebClientUrl";
    export var AuthenticationMethods: string = "AuthenticationMethods";
    export var Url: string = "Url";
    export var AlternateMailboxCollectionSetting: string = "AlternateMailboxCollectionSetting";
    export var AlternateMailboxes: string = "AlternateMailboxes";
    export var AlternateMailbox: string = "AlternateMailbox";
    export var ProtocolConnectionCollectionSetting: string = "ProtocolConnectionCollectionSetting";
    export var ProtocolConnections: string = "ProtocolConnections";
    export var ProtocolConnection: string = "ProtocolConnection";
    export var DocumentSharingLocationCollectionSetting: string = "DocumentSharingLocationCollectionSetting";
    export var DocumentSharingLocations: string = "DocumentSharingLocations";
    export var DocumentSharingLocation: string = "DocumentSharingLocation";
    export var ServiceUrl: string = "ServiceUrl";
    export var LocationUrl: string = "LocationUrl";
    export var SupportedFileExtensions: string = "SupportedFileExtensions";
    export var FileExtension: string = "FileExtension";
    export var ExternalAccessAllowed: string = "ExternalAccessAllowed";
    export var AnonymousAccessAllowed: string = "AnonymousAccessAllowed";
    export var CanModifyPermissions: string = "CanModifyPermissions";
    export var IsDefault: string = "IsDefault";
    export var EncryptionMethod: string = "EncryptionMethod";
    export var Hostname: string = "Hostname";
    export var Port: string = "Port";
    export var Version: string = "Version";
    export var MajorVersion: string = "MajorVersion";
    export var MinorVersion: string = "MinorVersion";
    export var MajorBuildNumber: string = "MajorBuildNumber";
    export var MinorBuildNumber: string = "MinorBuildNumber";
    export var RequestedVersion: string = "RequestedVersion";
    export var PublicFolderServer: string = "PublicFolderServer";
    export var Ssl: string = "SSL";
    export var SharingUrl: string = "SharingUrl";
    export var EcpUrl: string = "EcpUrl";
    export var EcpUrl_um: string = "EcpUrl-um";
    export var EcpUrl_aggr: string = "EcpUrl-aggr";
    export var EcpUrl_sms: string = "EcpUrl-sms";
    export var EcpUrl_mt: string = "EcpUrl-mt";
    export var EcpUrl_ret: string = "EcpUrl-ret";
    export var EcpUrl_publish: string = "EcpUrl-publish";
    export var EcpUrl_photo: string = "EcpUrl-photo";
    export var ExchangeRpcUrl: string = "ExchangeRpcUrl";
    export var EcpUrl_connect: string = "EcpUrl-connect";
    export var EcpUrl_tm: string = "EcpUrl-tm";
    export var EcpUrl_tmCreating: string = "EcpUrl-tmCreating";
    export var EcpUrl_tmEditing: string = "EcpUrl-tmEditing";
    export var EcpUrl_tmHiding: string = "EcpUrl-tmHiding";
    export var SiteMailboxCreationURL: string = "SiteMailboxCreationURL";
    export var EcpUrl_extinstall: string = "EcpUrl-extinstall";
    export var PartnerToken: string = "PartnerToken";
    export var PartnerTokenReference: string = "PartnerTokenReference";
    export var ServerExclusiveConnect: string = "ServerExclusiveConnect";
    export var AutoDiscoverSMTPAddress: string = "AutoDiscoverSMTPAddress";
    export var CertPrincipalName: string = "CertPrincipalName";
    export var GroupingInformation: string = "GroupingInformation";
    /* #endregion */

    /* #region InboxRule */
    export var MailboxSmtpAddress: string = "MailboxSmtpAddress";
    export var RuleId: string = "RuleId";
    export var Priority: string = "Priority";
    export var IsEnabled: string = "IsEnabled";
    export var IsNotSupported: string = "IsNotSupported";
    export var IsInError: string = "IsInError";
    export var Conditions: string = "Conditions";
    export var Exceptions: string = "Exceptions";
    export var Actions: string = "Actions";
    export var InboxRules: string = "InboxRules";
    export var Rule: string = "Rule";
    export var OutlookRuleBlobExists: string = "OutlookRuleBlobExists";
    export var RemoveOutlookRuleBlob: string = "RemoveOutlookRuleBlob";
    export var ContainsBodyStrings: string = "ContainsBodyStrings";
    export var ContainsHeaderStrings: string = "ContainsHeaderStrings";
    export var ContainsRecipientStrings: string = "ContainsRecipientStrings";
    export var ContainsSenderStrings: string = "ContainsSenderStrings";
    export var ContainsSubjectOrBodyStrings: string = "ContainsSubjectOrBodyStrings";
    export var ContainsSubjectStrings: string = "ContainsSubjectStrings";
    export var FlaggedForAction: string = "FlaggedForAction";
    export var FromAddresses: string = "FromAddresses";
    export var FromConnectedAccounts: string = "FromConnectedAccounts";
    export var IsApprovalRequest: string = "IsApprovalRequest";
    export var IsAutomaticForward: string = "IsAutomaticForward";
    export var IsAutomaticReply: string = "IsAutomaticReply";
    export var IsEncrypted: string = "IsEncrypted";
    export var IsMeetingRequest: string = "IsMeetingRequest";
    export var IsMeetingResponse: string = "IsMeetingResponse";
    export var IsNDR: string = "IsNDR";
    export var IsPermissionControlled: string = "IsPermissionControlled";
    export var IsSigned: string = "IsSigned";
    export var IsVoicemail: string = "IsVoicemail";
    export var IsReadReceipt: string = "IsReadReceipt";
    export var MessageClassifications: string = "MessageClassifications";
    export var NotSentToMe: string = "NotSentToMe";
    export var SentCcMe: string = "SentCcMe";
    export var SentOnlyToMe: string = "SentOnlyToMe";
    export var SentToAddresses: string = "SentToAddresses";
    export var SentToMe: string = "SentToMe";
    export var SentToOrCcMe: string = "SentToOrCcMe";
    export var WithinDateRange: string = "WithinDateRange";
    export var WithinSizeRange: string = "WithinSizeRange";
    export var MinimumSize: string = "MinimumSize";
    export var MaximumSize: string = "MaximumSize";
    export var StartDateTime: string = "StartDateTime";
    export var EndDateTime: string = "EndDateTime";
    export var AssignCategories: string = "AssignCategories";
    export var CopyToFolder: string = "CopyToFolder";
    export var FlagMessage: string = "FlagMessage";
    export var ForwardAsAttachmentToRecipients: string = "ForwardAsAttachmentToRecipients";
    export var ForwardToRecipients: string = "ForwardToRecipients";
    export var MarkImportance: string = "MarkImportance";
    export var MarkAsRead: string = "MarkAsRead";
    export var MoveToFolder: string = "MoveToFolder";
    export var PermanentDelete: string = "PermanentDelete";
    export var RedirectToRecipients: string = "RedirectToRecipients";
    export var SendSMSAlertToRecipients: string = "SendSMSAlertToRecipients";
    export var ServerReplyWithMessage: string = "ServerReplyWithMessage";
    export var StopProcessingRules: string = "StopProcessingRules";
    export var CreateRuleOperation: string = "CreateRuleOperation";
    export var SetRuleOperation: string = "SetRuleOperation";
    export var DeleteRuleOperation: string = "DeleteRuleOperation";
    export var Operations: string = "Operations";
    export var RuleOperationErrors: string = "RuleOperationErrors";
    export var RuleOperationError: string = "RuleOperationError";
    export var OperationIndex: string = "OperationIndex";
    export var ValidationErrors: string = "ValidationErrors";
    export var FieldValue: string = "FieldValue";
    /* #endregion */

    /* #region Restrictions */
    export var Not: string = "Not";
    export var Bitmask: string = "Bitmask";
    export var Constant: string = "Constant";
    export var Restriction: string = "Restriction";
    export var Condition: string = "Condition";
    export var Contains: string = "Contains";
    export var Excludes: string = "Excludes";
    export var Exists: string = "Exists";
    export var FieldURIOrConstant: string = "FieldURIOrConstant";
    export var And: string = "And";
    export var Or: string = "Or";
    export var IsEqualTo: string = "IsEqualTo";
    export var IsNotEqualTo: string = "IsNotEqualTo";
    export var IsGreaterThan: string = "IsGreaterThan";
    export var IsGreaterThanOrEqualTo: string = "IsGreaterThanOrEqualTo";
    export var IsLessThan: string = "IsLessThan";
    export var IsLessThanOrEqualTo: string = "IsLessThanOrEqualTo";
    /* #endregion */
        
    /* #region Directory only contact properties */
    export var PhoneticFullName: string = "PhoneticFullName";
    export var PhoneticFirstName: string = "PhoneticFirstName";
    export var PhoneticLastName: string = "PhoneticLastName";
    export var Alias: string = "Alias";
    export var Notes: string = "Notes";
    export var Photo: string = "Photo";
    export var UserSMIMECertificate: string = "UserSMIMECertificate";
    export var MSExchangeCertificate: string = "MSExchangeCertificate";
    export var DirectoryId: string = "DirectoryId";
    export var ManagerMailbox: string = "ManagerMailbox";
    export var DirectReports: string = "DirectReports";
    /* #endregion */

    /* #region Photos */

    export var SizeRequested: string = "SizeRequested";
    export var HasChanged: string = "HasChanged";
    export var PictureData: string = "PictureData";

    /* #endregion */

    /* #region Request/response element names */
    export var ResponseMessage: string = "ResponseMessage";
    export var ResponseMessages: string = "ResponseMessages";

    // FindConversation
    export var FindConversation: string = "FindConversation";
    export var FindConversationResponse: string = "FindConversationResponse";
    export var FindConversationResponseMessage: string = "FindConversationResponseMessage";

    // GetConversationItems
    export var GetConversationItems: string = "GetConversationItems";
    export var GetConversationItemsResponse: string = "GetConversationItemsResponse";
    export var GetConversationItemsResponseMessage: string = "GetConversationItemsResponseMessage";

    // FindItem
    export var FindItem: string = "FindItem";
    export var FindItemResponse: string = "FindItemResponse";
    export var FindItemResponseMessage: string = "FindItemResponseMessage";

    // GetItem
    export var GetItem: string = "GetItem";
    export var GetItemResponse: string = "GetItemResponse";
    export var GetItemResponseMessage: string = "GetItemResponseMessage";

    // CreateItem
    export var CreateItem: string = "CreateItem";
    export var CreateItemResponse: string = "CreateItemResponse";
    export var CreateItemResponseMessage: string = "CreateItemResponseMessage";

    // SendItem
    export var SendItem: string = "SendItem";
    export var SendItemResponse: string = "SendItemResponse";
    export var SendItemResponseMessage: string = "SendItemResponseMessage";

    // DeleteItem
    export var DeleteItem: string = "DeleteItem";
    export var DeleteItemResponse: string = "DeleteItemResponse";
    export var DeleteItemResponseMessage: string = "DeleteItemResponseMessage";

    // UpdateItem
    export var UpdateItem: string = "UpdateItem";
    export var UpdateItemResponse: string = "UpdateItemResponse";
    export var UpdateItemResponseMessage: string = "UpdateItemResponseMessage";

    // CopyItem
    export var CopyItem: string = "CopyItem";
    export var CopyItemResponse: string = "CopyItemResponse";
    export var CopyItemResponseMessage: string = "CopyItemResponseMessage";

    // MoveItem
    export var MoveItem: string = "MoveItem";
    export var MoveItemResponse: string = "MoveItemResponse";
    export var MoveItemResponseMessage: string = "MoveItemResponseMessage";

    // ArchiveItem
    export var ArchiveItem: string = "ArchiveItem";
    export var ArchiveItemResponse: string = "ArchiveItemResponse";
    export var ArchiveItemResponseMessage: string = "ArchiveItemResponseMessage";
    export var ArchiveSourceFolderId: string = "ArchiveSourceFolderId";

    // FindFolder
    export var FindFolder: string = "FindFolder";
    export var FindFolderResponse: string = "FindFolderResponse";
    export var FindFolderResponseMessage: string = "FindFolderResponseMessage";

    // GetFolder
    export var GetFolder: string = "GetFolder";
    export var GetFolderResponse: string = "GetFolderResponse";
    export var GetFolderResponseMessage: string = "GetFolderResponseMessage";

    // CreateFolder
    export var CreateFolder: string = "CreateFolder";
    export var CreateFolderResponse: string = "CreateFolderResponse";
    export var CreateFolderResponseMessage: string = "CreateFolderResponseMessage";

    // DeleteFolder
    export var DeleteFolder: string = "DeleteFolder";
    export var DeleteFolderResponse: string = "DeleteFolderResponse";
    export var DeleteFolderResponseMessage: string = "DeleteFolderResponseMessage";

    // EmptyFolder
    export var EmptyFolder: string = "EmptyFolder";
    export var EmptyFolderResponse: string = "EmptyFolderResponse";
    export var EmptyFolderResponseMessage: string = "EmptyFolderResponseMessage";

    // UpdateFolder
    export var UpdateFolder: string = "UpdateFolder";
    export var UpdateFolderResponse: string = "UpdateFolderResponse";
    export var UpdateFolderResponseMessage: string = "UpdateFolderResponseMessage";

    // CopyFolder
    export var CopyFolder: string = "CopyFolder";
    export var CopyFolderResponse: string = "CopyFolderResponse";
    export var CopyFolderResponseMessage: string = "CopyFolderResponseMessage";

    // MoveFolder
    export var MoveFolder: string = "MoveFolder";
    export var MoveFolderResponse: string = "MoveFolderResponse";
    export var MoveFolderResponseMessage: string = "MoveFolderResponseMessage";

    // MarkAllItemsAsRead
    export var MarkAllItemsAsRead: string = "MarkAllItemsAsRead";
    export var MarkAllItemsAsReadResponse: string = "MarkAllItemsAsReadResponse";
    export var MarkAllItemsAsReadResponseMessage: string = "MarkAllItemsAsReadResponseMessage";

    // FindPeople
    export var FindPeople: string = "FindPeople";
    export var FindPeopleResponse: string = "FindPeopleResponse";
    export var FindPeopleResponseMessage: string = "FindPeopleResponseMessage";

    // GetPeopleInsights
    export var GetPeopleInsights: string = "GetPeopleInsights";
    export var GetPeopleInsightsResponse: string = "GetPeopleInsightsResponse";
    export var GetPeopleInsightsResponseMessage: string = "GetPeopleInsightsResponseMessage";

    // GetUserPhoto
    export var GetUserPhoto: string = "GetUserPhoto";
    export var GetUserPhotoResponse: string = "GetUserPhotoResponse";
    export var GetUserPhotoResponseMessage: string = "GetUserPhotoResponseMessage";

    // GetAttachment
    export var GetAttachment: string = "GetAttachment";
    export var GetAttachmentResponse: string = "GetAttachmentResponse";
    export var GetAttachmentResponseMessage: string = "GetAttachmentResponseMessage";

    // CreateAttachment
    export var CreateAttachment: string = "CreateAttachment";
    export var CreateAttachmentResponse: string = "CreateAttachmentResponse";
    export var CreateAttachmentResponseMessage: string = "CreateAttachmentResponseMessage";

    // DeleteAttachment
    export var DeleteAttachment: string = "DeleteAttachment";
    export var DeleteAttachmentResponse: string = "DeleteAttachmentResponse";
    export var DeleteAttachmentResponseMessage: string = "DeleteAttachmentResponseMessage";

    // ResolveNames
    export var ResolveNames: string = "ResolveNames";
    export var ResolveNamesResponse: string = "ResolveNamesResponse";
    export var ResolveNamesResponseMessage: string = "ResolveNamesResponseMessage";

    // ExpandDL
    export var ExpandDL: string = "ExpandDL";
    export var ExpandDLResponse: string = "ExpandDLResponse";
    export var ExpandDLResponseMessage: string = "ExpandDLResponseMessage";

    // Subscribe
    export var Subscribe: string = "Subscribe";
    export var SubscribeResponse: string = "SubscribeResponse";
    export var SubscribeResponseMessage: string = "SubscribeResponseMessage";
    export var SubscriptionRequest: string = "SubscriptionRequest";

    // Unsubscribe
    export var Unsubscribe: string = "Unsubscribe";
    export var UnsubscribeResponse: string = "UnsubscribeResponse";
    export var UnsubscribeResponseMessage: string = "UnsubscribeResponseMessage";

    // GetEvents
    export var GetEvents: string = "GetEvents";
    export var GetEventsResponse: string = "GetEventsResponse";
    export var GetEventsResponseMessage: string = "GetEventsResponseMessage";

    // GetStreamingEvents
    export var GetStreamingEvents: string = "GetStreamingEvents";
    export var GetStreamingEventsResponse: string = "GetStreamingEventsResponse";
    export var GetStreamingEventsResponseMessage: string = "GetStreamingEventsResponseMessage";
    export var ConnectionStatus: string = "ConnectionStatus";
    export var ErrorSubscriptionIds: string = "ErrorSubscriptionIds";
    export var ConnectionTimeout: string = "ConnectionTimeout";
    export var HeartbeatFrequency: string = "HeartbeatFrequency";

    // SyncFolderItems
    export var SyncFolderItems: string = "SyncFolderItems";
    export var SyncFolderItemsResponse: string = "SyncFolderItemsResponse";
    export var SyncFolderItemsResponseMessage: string = "SyncFolderItemsResponseMessage";

    // SyncFolderHierarchy
    export var SyncFolderHierarchy: string = "SyncFolderHierarchy";
    export var SyncFolderHierarchyResponse: string = "SyncFolderHierarchyResponse";
    export var SyncFolderHierarchyResponseMessage: string = "SyncFolderHierarchyResponseMessage";

    // GetUserOofSettings
    export var GetUserOofSettingsRequest: string = "GetUserOofSettingsRequest";
    export var GetUserOofSettingsResponse: string = "GetUserOofSettingsResponse";

    // SetUserOofSettings
    export var SetUserOofSettingsRequest: string = "SetUserOofSettingsRequest";
    export var SetUserOofSettingsResponse: string = "SetUserOofSettingsResponse";

    // GetUserAvailability
    export var GetUserAvailabilityRequest: string = "GetUserAvailabilityRequest";
    export var GetUserAvailabilityResponse: string = "GetUserAvailabilityResponse";
    export var FreeBusyResponseArray: string = "FreeBusyResponseArray";
    export var FreeBusyResponse: string = "FreeBusyResponse";
    export var SuggestionsResponse: string = "SuggestionsResponse";

    // GetRoomLists
    export var GetRoomListsRequest: string = "GetRoomLists";
    export var GetRoomListsResponse: string = "GetRoomListsResponse";

    // GetRooms
    export var GetRoomsRequest: string = "GetRooms";
    export var GetRoomsResponse: string = "GetRoomsResponse";

    // ConvertId
    export var ConvertId: string = "ConvertId";
    export var ConvertIdResponse: string = "ConvertIdResponse";
    export var ConvertIdResponseMessage: string = "ConvertIdResponseMessage";

    // AddDelegate
    export var AddDelegate: string = "AddDelegate";
    export var AddDelegateResponse: string = "AddDelegateResponse";
    export var DelegateUserResponseMessageType: string = "DelegateUserResponseMessageType";

    // RemoveDelegte
    export var RemoveDelegate: string = "RemoveDelegate";
    export var RemoveDelegateResponse: string = "RemoveDelegateResponse";

    // GetDelegate
    export var GetDelegate: string = "GetDelegate";
    export var GetDelegateResponse: string = "GetDelegateResponse";

    // UpdateDelegate
    export var UpdateDelegate: string = "UpdateDelegate";
    export var UpdateDelegateResponse: string = "UpdateDelegateResponse";

    // CreateUserConfiguration
    export var CreateUserConfiguration: string = "CreateUserConfiguration";
    export var CreateUserConfigurationResponse: string = "CreateUserConfigurationResponse";
    export var CreateUserConfigurationResponseMessage: string = "CreateUserConfigurationResponseMessage";

    // DeleteUserConfiguration
    export var DeleteUserConfiguration: string = "DeleteUserConfiguration";
    export var DeleteUserConfigurationResponse: string = "DeleteUserConfigurationResponse";
    export var DeleteUserConfigurationResponseMessage: string = "DeleteUserConfigurationResponseMessage";

    // GetUserConfiguration
    export var GetUserConfiguration: string = "GetUserConfiguration";
    export var GetUserConfigurationResponse: string = "GetUserConfigurationResponse";
    export var GetUserConfigurationResponseMessage: string = "GetUserConfigurationResponseMessage";

    // UpdateUserConfiguration
    export var UpdateUserConfiguration: string = "UpdateUserConfiguration";
    export var UpdateUserConfigurationResponse: string = "UpdateUserConfigurationResponse";
    export var UpdateUserConfigurationResponseMessage: string = "UpdateUserConfigurationResponseMessage";

    // PlayOnPhone
    export var PlayOnPhone: string = "PlayOnPhone";
    export var PlayOnPhoneResponse: string = "PlayOnPhoneResponse";

    // GetPhoneCallInformation
    export var GetPhoneCall: string = "GetPhoneCallInformation";
    export var GetPhoneCallResponse: string = "GetPhoneCallInformationResponse";

    // DisconnectCall
    export var DisconnectPhoneCall: string = "DisconnectPhoneCall";
    export var DisconnectPhoneCallResponse: string = "DisconnectPhoneCallResponse";

    // GetServerTimeZones
    export var GetServerTimeZones: string = "GetServerTimeZones";
    export var GetServerTimeZonesResponse: string = "GetServerTimeZonesResponse";
    export var GetServerTimeZonesResponseMessage: string = "GetServerTimeZonesResponseMessage";

    // GetInboxRules
    export var GetInboxRules: string = "GetInboxRules";
    export var GetInboxRulesResponse: string = "GetInboxRulesResponse";

    // UpdateInboxRules
    export var UpdateInboxRules: string = "UpdateInboxRules";
    export var UpdateInboxRulesResponse: string = "UpdateInboxRulesResponse";

    // ExecuteDiagnosticMethod
    export var ExecuteDiagnosticMethod: string = "ExecuteDiagnosticMethod";
    export var ExecuteDiagnosticMethodResponse: string = "ExecuteDiagnosticMethodResponse";
    export var ExecuteDiagnosticMethodResponseMEssage: string = "ExecuteDiagnosticMethodResponseMessage";

    //GetPasswordExpirationDate
    export var GetPasswordExpirationDateRequest: string = "GetPasswordExpirationDate";
    export var GetPasswordExpirationDateResponse: string = "GetPasswordExpirationDateResponse";

    // GetSearchableMailboxes
    export var GetSearchableMailboxes: string = "GetSearchableMailboxes";
    export var GetSearchableMailboxesResponse: string = "GetSearchableMailboxesResponse";

    // GetDiscoverySearchConfiguration
    export var GetDiscoverySearchConfiguration: string = "GetDiscoverySearchConfiguration";
    export var GetDiscoverySearchConfigurationResponse: string = "GetDiscoverySearchConfigurationResponse";

    // GetHoldOnMailboxes
    export var GetHoldOnMailboxes: string = "GetHoldOnMailboxes";
    export var GetHoldOnMailboxesResponse: string = "GetHoldOnMailboxesResponse";

    // SetHoldOnMailboxes
    export var SetHoldOnMailboxes: string = "SetHoldOnMailboxes";
    export var SetHoldOnMailboxesResponse: string = "SetHoldOnMailboxesResponse";

    // SearchMailboxes
    export var SearchMailboxes: string = "SearchMailboxes";
    export var SearchMailboxesResponse: string = "SearchMailboxesResponse";
    export var SearchMailboxesResponseMessage: string = "SearchMailboxesResponseMessage";

    // GetNonIndexableItemDetails
    export var GetNonIndexableItemDetails: string = "GetNonIndexableItemDetails";
    export var GetNonIndexableItemDetailsResponse: string = "GetNonIndexableItemDetailsResponse";

    // GetNonIndexableItemStatistics
    export var GetNonIndexableItemStatistics: string = "GetNonIndexableItemStatistics";
    export var GetNonIndexableItemStatisticsResponse: string = "GetNonIndexableItemStatisticsResponse";

    // eDiscovery
    export var SearchQueries: string = "SearchQueries";
    export var SearchQuery: string = "SearchQuery";
    export var MailboxQuery: string = "MailboxQuery";
    export var Query: string = "Query";
    export var MailboxSearchScopes: string = "MailboxSearchScopes";
    export var MailboxSearchScope: string = "MailboxSearchScope";
    export var SearchScope: string = "SearchScope";
    export var ResultType: string = "ResultType";
    export var SortBy: string = "SortBy";
    export var Order: string = "Order";
    export var Language: string = "Language";
    export var Deduplication: string = "Deduplication";
    export var PageSize: string = "PageSize";
    export var PageItemReference: string = "PageItemReference";
    export var PageDirection: string = "PageDirection";
    export var PreviewItemResponseShape: string = "PreviewItemResponseShape";
    export var ExtendedProperties: string = "ExtendedProperties";
    export var PageItemSize: string = "PageItemSize";
    export var PageItemCount: string = "PageItemCount";
    export var ItemCount: string = "ItemCount";
    export var KeywordStats: string = "KeywordStats";
    export var KeywordStat: string = "KeywordStat";
    export var Keyword: string = "Keyword";
    export var ItemHits: string = "ItemHits";
    export var SearchPreviewItem: string = "SearchPreviewItem";
    export var ChangeKey: string = "ChangeKey";
    export var ParentId: string = "ParentId";
    export var MailboxId: string = "MailboxId";
    export var UniqueHash: string = "UniqueHash";
    export var SortValue: string = "SortValue";
    export var OwaLink: string = "OwaLink";
    export var SmtpAddress: string = "SmtpAddress";
    export var CreatedTime: string = "CreatedTime";
    export var ReceivedTime: string = "ReceivedTime";
    export var SentTime: string = "SentTime";
    export var Preview: string = "Preview";
    export var HasAttachment: string = "HasAttachment";
    export var FailedMailboxes: string = "FailedMailboxes";
    export var FailedMailbox: string = "FailedMailbox";
    export var Token: string = "Token";
    export var Refiners: string = "Refiners";
    export var Refiner: string = "Refiner";
    export var MailboxStats: string = "MailboxStats";
    export var MailboxStat: string = "MailboxStat";
    export var HoldId: string = "HoldId";
    export var ActionType: string = "ActionType";
    export var Mailboxes: string = "Mailboxes";
    export var SearchFilter: string = "SearchFilter";
    export var ReferenceId: string = "ReferenceId";
    export var IsMembershipGroup: string = "IsMembershipGroup";
    export var ExpandGroupMembership: string = "ExpandGroupMembership";
    export var SearchableMailboxes: string = "SearchableMailboxes";
    export var SearchableMailbox: string = "SearchableMailbox";
    export var SearchMailboxesResult: string = "SearchMailboxesResult";
    export var MailboxHoldResult: string = "MailboxHoldResult";
    export var Statuses: string = "Statuses";
    export var MailboxHoldStatuses: string = "MailboxHoldStatuses";
    export var MailboxHoldStatus: string = "MailboxHoldStatus";
    export var AdditionalInfo: string = "AdditionalInfo";
    export var NonIndexableItemDetail: string = "NonIndexableItemDetail";
    export var NonIndexableItemStatistic: string = "NonIndexableItemStatistic";
    export var NonIndexableItemDetails: string = "NonIndexableItemDetails";
    export var NonIndexableItemStatistics: string = "NonIndexableItemStatistics";
    export var NonIndexableItemDetailsResult: string = "NonIndexableItemDetailsResult";
    export var SearchArchiveOnly: string = "SearchArchiveOnly";
    export var ErrorDescription: string = "ErrorDescription";
    export var IsPartiallyIndexed: string = "IsPartiallyIndexed";
    export var IsPermanentFailure: string = "IsPermanentFailure";
    export var AttemptCount: string = "AttemptCount";
    export var LastAttemptTime: string = "LastAttemptTime";
    export var SearchId: string = "SearchId";
    export var DiscoverySearchConfigurations: string = "DiscoverySearchConfigurations";
    export var DiscoverySearchConfiguration: string = "DiscoverySearchConfiguration";
    export var InPlaceHoldConfigurationOnly: string = "InPlaceHoldConfigurationOnly";
    export var InPlaceHoldIdentity: string = "InPlaceHoldIdentity";
    export var ItemHoldPeriod: string = "ItemHoldPeriod";
    export var ManagedByOrganization: string = "ManagedByOrganization";
    export var IsExternalMailbox: string = "IsExternalMailbox";
    export var ExternalEmailAddress: string = "ExternalEmailAddress";
    export var ExtendedAttributes: string = "ExtendedAttributes";
    export var ExtendedAttribute: string = "ExtendedAttribute";
    export var ExtendedAttributeName: string = "Name";
    export var ExtendedAttributeValue: string = "Value";
    export var SearchScopeType: string = "SearchScopeType";
    /** per github issue #120 */
    export var IncludeNonIndexableItems: string = "IncludeNonIndexableItems";

    // GetAppManifests
    export var GetAppManifestsRequest: string = "GetAppManifests";
    export var GetAppManifestsResponse: string = "GetAppManifestsResponse";
    export var Manifests: string = "Manifests";
    export var Manifest: string = "Manifest";

    // GetAppManifests for TargetServerVersion > 2.5
    export var Apps: string = "Apps";
    export var App: string = "App";
    export var Metadata: string = "Metadata";
    export var ActionUrl: string = "ActionUrl";
    export var AppStatus: string = "AppStatus";
    export var EndNodeUrl: string = "EndNodeUrl";

    // GetClientExtension/SetClientExtension
    export var GetClientExtensionRequest: string = "GetClientExtension";
    export var ClientExtensionUserRequest: string = "UserParameters";
    export var ClientExtensionUserEnabled: string = "UserEnabledExtensions";
    export var ClientExtensionUserDisabled: string = "UserDisabledExtensions";
    export var ClientExtensionRequestedIds: string = "RequestedExtensionIds";
    export var ClientExtensionIsDebug: string = "IsDebug";
    export var ClientExtensionRawMasterTableXml: string = "RawMasterTableXml";
    export var GetClientExtensionResponse: string = "GetClientExtensionResponse";
    export var ClientExtensionSpecificUsers: string = "SpecificUsers";
    export var ClientExtensions: string = "ClientExtensions";
    export var ClientExtension: string = "ClientExtension";
    export var SetClientExtensionRequest: string = "SetClientExtension";
    export var SetClientExtensionActions: string = "Actions";
    export var SetClientExtensionAction: string = "Action";
    export var SetClientExtensionResponse: string = "SetClientExtensionResponse";
    export var SetClientExtensionResponseMessage: string = "SetClientExtensionResponseMessage";

    // GetEncryptionConfiguration/SetEncryptionConfiguration
    export var GetEncryptionConfigurationRequest: string = "GetEncryptionConfiguration";
    export var SetEncryptionConfigurationRequest: string = "SetEncryptionConfiguration";
    export var EncryptionConfigurationImageBase64: string = "ImageBase64";
    export var EncryptionConfigurationEmailText: string = "EmailText";
    export var EncryptionConfigurationPortalText: string = "PortalText";
    export var EncryptionConfigurationDisclaimerText: string = "DisclaimerText";
    export var EncryptionConfigurationOTPEnabled: string = "OTPEnabled";
    export var GetEncryptionConfigurationResponse: string = "GetEncryptionConfigurationResponse";
    export var SetEncryptionConfigurationResponse: string = "SetEncryptionConfigurationResponse";

    // GetOMEConfiguration/SetOMEConfiguration
    export var GetOMEConfigurationRequest: string = "GetOMEConfiguration";
    export var SetOMEConfigurationRequest: string = "SetOMEConfiguration";
    export var OMEConfigurationXml: string = "Xml";
    export var GetOMEConfigurationResponse: string = "GetOMEConfigurationResponse";
    export var SetOMEConfigurationResponse: string = "SetOMEConfigurationResponse";

    // InstallApp
    export var InstallAppRequest: string = "InstallApp";
    export var InstallAppResponse: string = "InstallAppResponse";

    // UninstallApp
    export var UninstallAppRequest: string = "UninstallApp";
    export var UninstallAppResponse: string = "UninstallAppResponse";

    // DisableApp
    export var DisableAppRequest: string = "DisableApp";
    export var DisableAppResponse: string = "DisableAppResponse";

    // RegisterConsent
    export var RegisterConsentRequest: string = "RegisterConsent";
    export var RegisterConsentResponse: string = "RegisterConsentResponse";

    // GetAppMarketplaceUrl
    export var GetAppMarketplaceUrlRequest: string = "GetAppMarketplaceUrl";
    export var GetAppMarketplaceUrlResponse: string = "GetAppMarketplaceUrlResponse";

    // GetUserRetentionPolicyTags
    export var GetUserRetentionPolicyTags: string = "GetUserRetentionPolicyTags";
    export var GetUserRetentionPolicyTagsResponse: string = "GetUserRetentionPolicyTagsResponse";

    // MRM
    export var RetentionPolicyTags: string = "RetentionPolicyTags";
    export var RetentionPolicyTag: string = "RetentionPolicyTag";
    export var RetentionId: string = "RetentionId";
    export var RetentionPeriod: string = "RetentionPeriod";
    export var RetentionAction: string = "RetentionAction";
    export var Description: string = "Description";
    export var IsVisible: string = "IsVisible";
    export var OptedInto: string = "OptedInto";
    export var IsArchive: string = "IsArchive";

    /* #endregion */

    /* #region Groups */

    // GetUserUnifiedGroups
    export var GetUserUnifiedGroups: string = "GetUserUnifiedGroups";
    export var RequestedGroupsSets: string = "RequestedGroupsSets";
    export var RequestedUnifiedGroupsSetItem: string = "RequestedUnifiedGroupsSet";
    export var SortType: string = "SortType";
    export var FilterType: string = "FilterType";
    export var SortDirection: string = "SortDirection";
    export var GroupsLimit: string = "GroupsLimit";
    export var UserSmtpAddress: string = "UserSmtpAddress";

    export var GetUserUnifiedGroupsResponseMessage: string = "GetUserUnifiedGroupsResponseMessage";
    export var GroupsSets: string = "GroupsSets";
    export var UnifiedGroupsSet: string = "UnifiedGroupsSet";
    export var TotalGroups: string = "TotalGroups";
    export var GroupsTag: string = "Groups";
    export var UnifiedGroup: string = "UnifiedGroup";
    export var MailboxGuid: string = "MailboxGuid";
    export var LastVisitedTimeUtc: string = "LastVisitedTimeUtc";
    export var AccessType: string = "AccessType";
    export var ExternalDirectoryObjectId: string = "ExternalDirectoryObjectId";

    // GetUnifiedGroupUnseenCount
    export var GetUnifiedGroupUnseenCount: string = "GetUnifiedGroupUnseenCount";
    export var GroupIdentity: string = "GroupIdentity";
    export var GroupIdentityType: string = "IdentityType";
    export var GroupIdentityValue: string = "Value";

    export var GetUnifiedGroupUnseenCountResponseMessage: string = "GetUnifiedGroupUnseenCountResponseMessage";
    export var UnseenCount: string = "UnseenCount";

    // SetUnifiedGroupLastVisitedTimeRequest
    export var SetUnifiedGroupLastVisitedTime: string = "SetUnifiedGroupLastVisitedTime";
    export var SetUnifiedGroupLastVisitedTimeResponseMessage: string = "SetUnifiedGroupLastVisitedTimeResponseMessage";
    /* #endregion */

    /* #region SOAP element names */

    export var SOAPEnvelopeElementName: string = "Envelope";
    export var SOAPHeaderElementName: string = "Header";
    export var SOAPBodyElementName: string = "Body";
    export var SOAPFaultElementName: string = "Fault";
    export var SOAPFaultCodeElementName: string = "faultcode";
    export var SOAPFaultStringElementName: string = "faultstring";
    export var SOAPFaultActorElementName: string = "faultactor";
    export var SOAPDetailElementName: string = "detail";
    export var EwsResponseCodeElementName: string = "ResponseCode";
    export var EwsMessageElementName: string = "Message";
    export var EwsLineElementName: string = "Line";
    export var EwsPositionElementName: string = "Position";
    export var EwsErrorCodeElementName: string = "ErrorCode";         // Generated by Availability
    export var EwsExceptionTypeElementName: string = "ExceptionType"; // Generated by UM

    /* #endregion */
}

/**
 * Represents a property that can be sent to or retrieved from EWS.
 */
export class ComplexProperty {
  
  /**@internal */
  Namespace: XmlNamespace = XmlNamespace.Types;
  //private xmlNamespace: XmlNamespace; ^ no need for pivate property
  OnChange: ComplexPropertyChangedDelegate[] = [];

  constructor() {
  }

  Changed(): void {
    if (this.OnChange && this.OnChange.length > 0) {
      this.OnChange.forEach((delegateInstance, index, array) => {
        if (delegateInstance)
          delegateInstance(this);
      });
    }
  }
  ClearChangeLog(): void { /*virtual method for derived class to implement if needed*/ }
  InternalLoadFromXmlJsObject(jsObject: any, service: ExchangeService, //xmlNamespace: XmlNamespace, xmlElementName: string,
    readAction: (jsonProperty: any, service: ExchangeService) => void /*System.Func<T, TResult>*/): void {
    //reader.EnsureCurrentNodeIsStartElement(xmlNamespace, xmlElementName);
    //debugger;//check how to implement with jsobject.
    EwsLogging.Assert(false, (<any>this.constructor).name + ".LoadFromXmlJsObject", "ComplexProperty - InternalLoadFromXmlJsObject: todo:convert to jsobjectload. object type = " + (<any>this.constructor).name);
    throw new Error("ComplexProperty - InternalLoadFromXmlJsObject: todo:convert to jsobjectload. object type = " + (<any>this).constructor.name)
    // this.ReadAttributesFromXmlJsObject(jsObject);

    // if (!jsObject.IsEmptyElement) {
    //   do {
    //     jsObject.Read();

    //     switch (jsObject.NodeType) {
    //       case Node.ELEMENT_NODE:
    //         if (!readAction(jsObject)) {
    //           jsObject.SkipCurrentElement();
    //         }
    //         break;
    //       case Node.TEXT_NODE:
    //         this.ReadTextValueFromXmlJsObject(jsObject);
    //         break;
    //     }
    //   }
    //   while (!jsObject.HasRecursiveParent(xmlElementName));
    //   jsObject.SeekLast(); // go back for next process to read.
    //}
  }
  //InternalToJson(service: ExchangeService): any { throw new Error("ComplexProperty.ts - InternalToJson : Not implemented."); }
  InternalValidate(): void { /*virtual method for derived class to implement if needed*/ }
  //LoadFromJson(jsonProperty: JsonObject, service: ExchangeService): any { throw new Error("ComplexProperty.ts - LoadFromJson : Not implemented."); }
  //LoadFromXml(reader: EwsServiceXmlReader, xmlElementName: string): any { throw new Error("ComplexProperty.ts - LoadFromXml : Not implemented."); }
  LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {//, xmlElementName: string
    this.InternalLoadFromXmlJsObject(
      jsObject,
      service,
      this.ReadElementsFromXmlJsObject);
    // xmlNamespace || this.Namespace,
    // xmlElementName,
  }
  /**@internal */
    ReadAttributesFromXmlJsObject(reader: EwsServiceXmlReader): void { debugger;/*virtual method for derived class to implement if needed*/ }
  /**@internal */
    ReadTextValueFromXmlJsObject(jsObject: EwsServiceXmlReader): void { debugger;/*virtual method for derived class to implement if needed*/ }
  SetFieldValue<T>(field: IRefParam<T>, value: T): void {  //irefparam to workaround ref parameters irefparam.value is actual value;
    var applyChange: boolean = false;

    if (field.getValue() == null) {
      applyChange = value != null;
    }
    else {
      var fieldAny = <any>field.getValue();
      if (fieldAny.CompareTo) //todo: fix this if find new ways to check if it implements certain interface - if( field is IComparable)
      {
        applyChange = fieldAny.CompareTo(value) != 0; //todo: until fix the interface check (field as IComparable).CompareTo(value) != 0;
      }
      else {
        applyChange = true;
      }
    }

    if (applyChange) {
      //debugger;//debug; check; check for ref value setting. 
      field.setValue(value);
      this.Changed();
    }
  }
  ReadElementsFromXmlJsObject(jsonProperty: any, service: ExchangeService): void { debugger; /* abstract method - should implement*/ }
  ReadElementsFromXmlJsObjectToPatch(jsonProperty: any, service: ExchangeService): void { debugger; /* abstract method - should implement*/ }
  //UpdateFromXml(reader: EwsServiceXmlReader, xmlElementName: string): any { throw new Error("ComplexProperty.ts - UpdateFromXml : Not implemented."); }
  UpdateFromXmlJsObject(jsObject: any, service: ExchangeService /*, xmlElementName: string, xmlNamespace?: XmlNamespace*/): void {

    this.InternalLoadFromXmlJsObject(
      jsObject,
      service,
      this.ReadElementsFromXmlJsObjectToPatch);
    // xmlNamespace || this.Namespace,
    // xmlElementName,
  }
  /// <summary>
  /// Implements ISelfValidate.Validate. Validates this instance.
  /// </summary>
  Validate(): void //ISelfValidate interface
  {
    this.InternalValidate();
  }
  /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void { /*virtual method for derived class to implement if needed*/ }
  /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { /*virtual method for derived class to implement if needed*/ }

  /** @internal reverted to simplify child class override - it breaks all derived/child class and throws error "incorrectly extends base class" due to TypeScript design */
  //WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void { throw new Error("ComplexProperty.ts - WriteToXml : Not implemented."); }
  /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string, xmlNamespace?: XmlNamespace): void {
    if (!xmlNamespace)
      xmlNamespace = this.Namespace;

    writer.WriteStartElement(xmlNamespace, xmlElementName);
    this.WriteAttributesToXml(writer);
    this.WriteElementsToXml(writer);
    writer.WriteEndElement();
  }
  // WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void;
  // WriteToXml(writer: EwsServiceXmlWriter, xmlNamespace: XmlNamespace, xmlElementName: string): void;
  // WriteToXml(writer: EwsServiceXmlWriter, xmlElementNameOrNameSpace: string | XmlNamespace, xmlElementName: string = null): void {
  //   let xmlNamespace = this.Namespace;
  //   if (typeof xmlElementNameOrNameSpace === 'number') {
  //     xmlNamespace = xmlElementNameOrNameSpace;
  //   }
  //   else {
  //     xmlElementName = xmlElementNameOrNameSpace;
  //   }

  //   writer.WriteStartElement(xmlNamespace, xmlElementName);
  //   this.WriteAttributesToXml(writer);
  //   this.WriteElementsToXml(writer);
  //   writer.WriteEndElement();
  // }
}

export class CalendarEvent extends ComplexProperty {

    private startTime: DateTime = null;
    private endTime: DateTime = null;
    private freeBusyStatus: LegacyFreeBusyStatus = 0;
    private details: CalendarEventDetails = null;
    get StartTime(): DateTime {
        return this.startTime;
    }
    get EndTime(): DateTime {
        return this.endTime;
    }
    get FreeBusyStatus(): LegacyFreeBusyStatus {
        return this.freeBusyStatus;
    }
    get Details(): CalendarEventDetails {
        return this.details;
    }

    LoadFromJson(jsonProperty: any, service: ExchangeService): any { throw new Error("CalendarEvent.ts - LoadFromJson : Not implemented."); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.StartTime:
                    this.startTime = EwsUtilities.ParseAsUnbiasedDatetimescopedToServicetimeZone(
                        jsonProperty[key],
                        service);
                    break;
                case XmlElementNames.EndTime:
                    this.endTime = EwsUtilities.ParseAsUnbiasedDatetimescopedToServicetimeZone(
                        jsonProperty[key],
                        service);
                    break;
                case XmlElementNames.BusyType:
                    this.freeBusyStatus = <LegacyFreeBusyStatus><any>LegacyFreeBusyStatus[jsonProperty[key]];
                    break;
                case XmlElementNames.CalendarEventDetails:
                    this.details = new CalendarEventDetails();
                    this.details.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                default:
                    break;
            }
        }
    }
}
export class CalendarEventDetails extends ComplexProperty {
    private storeId: string = null;
    private subject: string = null;
    private location: string = null;
    private isMeeting: boolean = false;
    private isRecurring: boolean = false;
    private isException: boolean = false;
    private isReminderSet: boolean = false;
    private isPrivate: boolean = false;
    get StoreId(): string {
        return this.storeId;
    }
    get Subject(): string {
        return this.subject;
    }
    get Location(): string {
        return this.location;
    }
    get IsMeeting(): boolean {
        return this.isMeeting;
    }
    get IsRecurring(): boolean {
        return this.isRecurring;
    }
    get IsException(): boolean {
        return this.isException;
    }
    get IsReminderSet(): boolean {
        return this.isReminderSet;
    }
    get IsPrivate(): boolean {
        return this.isPrivate;
    }
    LoadFromJson(jsonProperty: any, service: ExchangeService): any { throw new Error("CalendarEventDetails.ts - LoadFromJson : Not implemented."); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.ID:
                    this.storeId = jsonProperty[key];
                    break;
                case XmlElementNames.Subject:
                    this.subject = jsonProperty[key];
                    break;
                case XmlElementNames.Location:
                    this.location = jsonProperty[key];
                    break;
                case XmlElementNames.IsMeeting:
                    this.isMeeting = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.IsRecurring:
                    this.isRecurring = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.IsException:
                    this.isException = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.IsReminderSet:
                    this.isReminderSet = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.IsPrivate:
                    this.isPrivate = Convert.toBool(jsonProperty[key]);
                    break;
                default:
                    break;
            }
        }
    }
}
export class Conflict extends ComplexProperty {
    private conflictType: ConflictType = ConflictType.IndividualAttendeeConflict;
    private numberOfMembers: number = 0;
    private numberOfMembersAvailable: number = 0;
    private numberOfMembersWithConflict: number = 0;
    private numberOfMembersWithNoData: number = 0;
    private freeBusyStatus: LegacyFreeBusyStatus = LegacyFreeBusyStatus.Free;
    get ConflictType(): ConflictType {
        return this.conflictType;
    }
    get NumberOfMembers(): number {
        return this.numberOfMembers;
    }
    get NumberOfMembersAvailable(): number {
        return this.numberOfMembersAvailable;
    }
    get NumberOfMembersWithConflict(): number {
        return this.numberOfMembersWithConflict;
    }
    get NumberOfMembersWithNoData(): number {
        return this.numberOfMembersWithNoData;
    }
    get FreeBusyStatus(): LegacyFreeBusyStatus {
        return this.freeBusyStatus;
    }
    constructor(conflictType: ConflictType) {
        super();
        this.conflictType = conflictType;
    }
    //LoadFromJson(jsonProperty: JsonObject, service: ExchangeService): any { throw new Error("Conflict.ts - LoadFromJson : Not implemented."); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.NumberOfMembers:
                    this.numberOfMembers = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.NumberOfMembersAvailable:
                    this.numberOfMembersAvailable = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.NumberOfMembersWithConflict:
                    this.numberOfMembersWithConflict = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.NumberOfMembersWithNoData:
                    this.numberOfMembersWithNoData = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.BusyType:
                    this.freeBusyStatus = <LegacyFreeBusyStatus><any>LegacyFreeBusyStatus[jsonProperty[key]];
                    break;
                default:
                    break;
            }
        }
    }
}



/**
 * Represents a user's Out of Office (OOF) settings.
 */
export class OofSettings extends ComplexProperty implements ISelfValidate {
    private state: OofState = 0;
    private externalAudience: OofExternalAudience = 0;
    private allowExternalOof: OofExternalAudience = 0;
    private duration: TimeWindow = null;
    private internalReply: OofReply = null;
    private externalReply: OofReply = null;

    /**
     * Gets or sets the user's OOF state.
     * 
     * @value The user's OOF state.
     */
    get State(): OofState {
        return this.state;
    }
    set State(value: OofState) {
        this.state = value;
    }

    /**
     * Gets or sets a value indicating who should receive external OOF messages.
     */
    get ExternalAudience(): OofExternalAudience {
        return this.externalAudience;
    }
    set ExternalAudience(value: OofExternalAudience) {
        this.externalAudience = value;
    }

    /**
     * Gets or sets the duration of the OOF status when State is set to OofState.Scheduled.
     */
    get Duration(): TimeWindow {
        return this.duration;
    }
    set Duration(value: TimeWindow) {
        this.duration = value;
    }

    /**
     * Gets or sets the OOF response sent other users in the user's domain or trusted domain.
     */
    get InternalReply(): OofReply {
        return this.internalReply;
    }
    set InternalReply(value: OofReply) {
        this.internalReply = value;
    }

    /**
     * Gets or sets the OOF response sent to addresses outside the user's domain or trusted domain.
     */
    get ExternalReply(): OofReply {
        return this.externalReply;
    }
    set ExternalReply(value: OofReply) {
        this.externalReply = value;
    }

    /**
     * Gets a value indicating the authorized external OOF notifications.
     */
    get AllowExternalOof(): OofExternalAudience {
        return this.allowExternalOof;
    }
    set AllowExternalOof(value: OofExternalAudience) {
        this.allowExternalOof = value;
    }

    /**
     * Initializes a new instance of OofSettings.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads from xmlJsObject.
     *
     * @param   {any}               jsObject   The json property.
     * @param   {ExchangeService}   service        [description]
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.OofState:
                    this.state = <OofState><any>OofState[jsObject[key]];
                    break;
                case XmlElementNames.ExternalAudience:
                    this.externalAudience = <OofExternalAudience><any>OofExternalAudience[jsObject[key]];
                    break;
                case XmlElementNames.Duration:
                    this.duration = new TimeWindow();
                    this.duration.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.InternalReply:
                    this.internalReply = new OofReply();
                    this.internalReply.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ExternalReply:
                    this.externalReply = new OofReply();
                    this.externalReply.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Serializes an OofReply. Emits an empty OofReply in case the one passed in is null.
     *
     * @param   {OofReply}              oofReply         The oof reply.
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    private SerializeOofReply(oofReply: OofReply, writer: EwsServiceXmlWriter, xmlElementName: string): void {
        if (oofReply != null) {
            oofReply.WriteToXml(writer, xmlElementName);
        }
        else {
            OofReply.WriteEmptyReplyToXml(writer, xmlElementName);
        }
    }

    /**
     * Validates this instance.
     */
    Validate(): void { //ISelfValidate
        if (this.State == OofState.Scheduled) {
            if (this.Duration == null) {
                throw new ArgumentException(Strings.DurationMustBeSpecifiedWhenScheduled);
            }

            EwsUtilities.ValidateParam(this.Duration, "Duration");
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.OofState,
            OofState[this.State]);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.ExternalAudience,
            OofExternalAudience[this.ExternalAudience]);

        if (this.Duration != null && this.State == OofState.Scheduled) {
            this.Duration.WriteToXml(writer, XmlElementNames.Duration);
        }

        this.SerializeOofReply(
            this.InternalReply,
            writer,
            XmlElementNames.InternalReply);
        this.SerializeOofReply(
            this.ExternalReply,
            writer,
            XmlElementNames.ExternalReply);
    }
}
export class Suggestion extends ComplexProperty {
    private date: DateTime = null;
    private quality: SuggestionQuality = SuggestionQuality.Excellent;
    private timeSuggestions: TimeSuggestion[] = []; /*System.Collections.ObjectModel.Collection<TimeSuggestion>;*/
    get Date(): DateTime {
        return this.date;
    }
    get Quality(): SuggestionQuality {
        return this.quality;
    }
    get TimeSuggestions(): TimeSuggestion[] {
        return this.timeSuggestions;
    }
    constructor() {
        super();
    }
    //LoadFromJson(jsonProperty: any, service: ExchangeService): any { throw new Error("Suggestion.ts - LoadFromJson : Not implemented."); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {

        this.date = DateTime.Parse(jsonProperty[XmlElementNames.Date]);
        EwsLogging.Log("bug: Suggestion->LoadFromXml:    need to change to millisecond and with datetimekind", true)
        //debugger;
        this.quality = <SuggestionQuality><any>SuggestionQuality[jsonProperty[XmlElementNames.DayQuality]];

        var suggestionArrayObj: any = jsonProperty[XmlElementNames.SuggestionArray];
        var suggestions: any[] = EwsServiceJsonReader.ReadAsArray(suggestionArrayObj, XmlElementNames.Suggestion);
        for (var suggestion of suggestions) {
            var timeSuggestion: TimeSuggestion = new TimeSuggestion();
            timeSuggestion.LoadFromXmlJsObject(suggestion, service);
            this.timeSuggestions.push(timeSuggestion);
        }
    }
}
export class TimeSuggestion extends ComplexProperty {
    private meetingTime: DateTime = null;
    private isWorkTime: boolean = false;
    private quality: SuggestionQuality = SuggestionQuality.Excellent;
    private conflicts: Conflict[] = [];// System.Collections.ObjectModel.Collection<Conflict>;
    get MeetingTime(): DateTime {
        return this.meetingTime;
    }
    get IsWorkTime(): boolean {
        return this.isWorkTime;
    }
    get Quality(): SuggestionQuality {
        return this.quality;
    }
    get Conflicts(): Conflict[] {
        return this.conflicts;
    }
    constructor() {
        super();
    }
    //LoadFromJson(jsonProperty: any, service: ExchangeService): any { throw new Error("TimeSuggestion.ts - LoadFromJson : Not implemented."); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.MeetingTime:
                    this.meetingTime = EwsUtilities.ParseAsUnbiasedDatetimescopedToServicetimeZone(jsonProperty[key], service);
                    break;
                case XmlElementNames.IsWorkTime:
                    this.isWorkTime = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.SuggestionQuality:
                    this.quality = <SuggestionQuality><any>SuggestionQuality[jsonProperty[key]];
                    break;
                case XmlElementNames.AttendeeConflictDataArray:
                    var jsConflictDataArray: any = jsonProperty[key];
                    for (var conflictKey in jsConflictDataArray) {
                        if (conflictKey.indexOf("__") === 0) continue;
                        var conflictType: ConflictType = ConflictType.IndividualAttendeeConflict;
                        var jsConflicts: any = EwsServiceJsonReader.ReadAsArray(jsConflictDataArray, conflictKey);
                        switch (conflictKey) {
                            case XmlElementNames.UnknownAttendeeConflictData:
                                conflictType = ConflictType.UnknownAttendeeConflict;
                                break;
                            case XmlElementNames.TooBigGroupAttendeeConflictData:
                                conflictType = ConflictType.GroupTooBigConflict;
                                break;
                            case XmlElementNames.IndividualAttendeeConflictData:
                                conflictType = ConflictType.IndividualAttendeeConflict;
                                break;
                            case XmlElementNames.GroupAttendeeConflictData:
                                conflictType = ConflictType.GroupConflict;
                                break;
                            default:
                                EwsLogging.Assert(
                                    false,
                                    "TimeSuggestion.TryReadElementFromJson",
                                    StringHelper.Format("The {0} element name does not map to any AttendeeConflict descendant.", TypeSystem.GetJsObjectTypeName(jsConflicts)));

                                // The following line to please the compiler
                                break;
                        }

                        for (var conflictItem of jsConflicts) {
                            var conflict: Conflict = new Conflict(conflictType);
                            conflict.LoadFromXmlJsObject(conflictItem, service);
                            this.conflicts.push(conflict);
                        }
                    }

                    break;
                default:
                    break;
            }
        }
    }
}

export class WorkingHours extends ComplexProperty {
    LegacyTimeZone: LegacyAvailabilityTimeZone = new LegacyAvailabilityTimeZone();
    get TimeZone(): TimeZoneInfo {
        return this.timeZone;
    }
    get DaysOfTheWeek(): DayOfTheWeek[] { return this.daysOfTheWeek; }/*System.Collections.ObjectModel.Collection<DayOfTheWeek>*/
    get StartTime(): TimeSpan { return this.startTime; } /*System.TimeSpan*/
    get EndTime(): TimeSpan { return this.endTime; } /*System.TimeSpan*/
    private timeZone: TimeZoneInfo;
    private daysOfTheWeek: DayOfTheWeek[] = [] /*System.Collections.ObjectModel.Collection<DayOfTheWeek>*/;
    private startTime: TimeSpan /*System.TimeSpan*/;
    private endTime: TimeSpan /*System.TimeSpan*/;
    LoadFromJson(jsonProperty: any, service: ExchangeService): any { throw new Error("WorkingHours.ts - LoadFromJson : Not implemented."); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.TimeZone:
                    var legacyTimeZone: LegacyAvailabilityTimeZone = new LegacyAvailabilityTimeZone();
                    legacyTimeZone.LoadFromXmlJsObject(jsonProperty[key], service);

                    this.LegacyTimeZone = legacyTimeZone;
                    //this.timeZone = legacyTimeZone.ToTimeZoneInfo();

                    break;
                case XmlElementNames.WorkingPeriodArray:
                    var workingPeriods: WorkingPeriod[] = [];// new List<WorkingPeriod>();

                    var workingPeriodsArrayObject: any[] = jsonProperty[key];
                    var workingPeriodsArray: any[] = workingPeriodsArrayObject[XmlElementNames.WorkingPeriod];
                    if (!Array.isArray(workingPeriodsArray)) {
                        workingPeriodsArray = <any>[workingPeriodsArray];
                    }
                    for (var workingPeriodEntry of workingPeriodsArray) {
                        var workingPeriod: WorkingPeriod = new WorkingPeriod();

                        workingPeriod.LoadFromXmlJsObject(workingPeriodEntry, service);

                        workingPeriods.push(workingPeriod);
                    }

                    // Availability supports a structure that can technically represent different working
                    // times for each day of the week. This is apparently how the information is stored in
                    // Exchange. However, no client (Outlook, OWA) either will let you specify different
                    // working times for each day of the week, and Outlook won't either honor that complex
                    // structure if it happens to be in Exchange.
                    // So here we'll do what Outlook and OWA do: we'll use the start and end times of the
                    // first working period, but we'll use the week days of all the periods.
                    this.startTime = workingPeriods[0].StartTime;
                    this.endTime = workingPeriods[0].EndTime;

                    for (var workingPeriod of workingPeriods) {
                        for (var dayOfWeek of workingPeriods[0].DaysOfWeek) {
                            if (this.daysOfTheWeek.indexOf(dayOfWeek) < 0) {
                                this.daysOfTheWeek.push(dayOfWeek);
                            }
                        }
                    }

                    break;
                default:
                    break;
            }
        }
    }
    //ReadElementsFromXmlJsObject(reader: any): boolean { throw new Error("WorkingHours.ts - TryReadElementFromXmlJsObject : Not implemented."); }
}

export class WorkingPeriod extends ComplexProperty {
    get DaysOfWeek(): DayOfTheWeek[] { return this.daysOfWeek; } /*System.Collections.ObjectModel.Collection<DayOfTheWeek>*/
    get StartTime(): TimeSpan { return this.startTime; } /*System.TimeSpan*/
    get EndTime(): TimeSpan { return this.endTime; } /*System.TimeSpan*/
    private daysOfWeek: DayOfTheWeek[] = [] /*System.Collections.ObjectModel.Collection<DayOfTheWeek>*/;
    private startTime: TimeSpan = null /*System.TimeSpan*/;
    private endTime: TimeSpan = null/*System.TimeSpan*/;
    constructor() {
        super();
    }
    LoadFromJson(jsonProperty: any, service: ExchangeService): any { throw new Error("WorkingPeriod.ts - LoadFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(reader: any): boolean { throw new Error("WorkingPeriod.ts - TryReadElementFromXmlJsObject : Not implemented."); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.DayOfWeek:
                    EwsUtilities.ParseEnumValueList<DayOfTheWeek>(
                        this.daysOfWeek,
                        jsonProperty[key],
                        ' ',
                        DayOfTheWeek);
                    break;
                case XmlElementNames.StartTimeInMinutes:
                    this.startTime = TimeSpan.FromMinutes(Number(jsonProperty[key]));
                    break;
                case XmlElementNames.EndTimeInMinutes:
                    this.endTime = TimeSpan.FromMinutes(Number(jsonProperty[key]));
                    break;
                default:
                    break;
            }
        }
    }
}





/**
 * Represents a collection of DayOfTheWeek values.
 */
export class DayOfTheWeekCollection extends ComplexProperty implements IEnumerable<DayOfTheWeek> {

    private items: DayOfTheWeek[] = [];

    get Count(): number {
        return this.items.length;
    }

    /**
     * @internal Initializes a new instance of the **DayOfTheWeekCollection** class.
     */
    constructor() {
        super();
    }

    /**
     * Gets the DayOfTheWeek at a specific index in the collection.
     *
     * @param   {number}        index   Index
     * @return  {DayOfTheWeek}  DayOfTheWeek at index
     */
    _getItem(index: number): DayOfTheWeek {
        return this.items[index];
    }


    /**
     * Adds a day to the collection if it is not already present.
     *
     * @param   {DayOfTheWeek}   dayOfTheWeek   The day to add.
     */
    Add(dayOfTheWeek: DayOfTheWeek): void {
        if (this.items.indexOf(dayOfTheWeek) < 0) {
            this.items.push(dayOfTheWeek);
            this.Changed();
        }
    }

    /**
     * Adds multiple days to the collection if they are not already present.
     *
     * @param   {DayOfTheWeek[]}   daysOfTheWeek   The days to add.
     */
    AddRange(daysOfTheWeek: DayOfTheWeek[]): void {
        for (let dayOfTheWeek of daysOfTheWeek) {
            this.Add(dayOfTheWeek);
        }
    }

    /**
     * Clears the collection.
     */
    Clear(): void {
        if (this.Count > 0) {
            this.items.splice(0);
            this.Changed();
        }

    }

    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    GetEnumerator(): DayOfTheWeek[] {
        return this.items;
    }

    /**
     * @internal Loads service object from XMLJsObject Value.
     *
     * @param   {string}            jsObject                Json Object converted from XML.
     */
    LoadFromXmlJsObjectValue(jsObjectValue: string): void {
        EwsUtilities.ParseEnumValueList<DayOfTheWeek>(
            this.items,
            jsObjectValue,
            ' ', DayOfTheWeek);
    }

    /**
     * Remove a specific day from the collection.
     *
     * @param   {DayOfTheWeek}   dayOfTheWeek   The day to remove.
     * @return  {boolean}       True if the day was removed from the collection, false otherwise.
     */
    Remove(dayOfTheWeek: DayOfTheWeek): boolean {
        if (this.items.indexOf(dayOfTheWeek)) {

            let result = this.items.splice(this.items.indexOf(dayOfTheWeek));

            if (result.length > 0) {
                this.Changed();
            }

            return result.length > 0;
        }

        return false;
    }

    /**
     * Removes the day at a specific index.
     *
     * @param   {number}   index   The index of the day to remove.
     */
    RemoveAt(index: number): void {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }

        this.items.splice(index);
        this.Changed();
    }

    /**
     * Convert to string.
     *
     * @param   {string}   separator   The separator.
     * @return  {string}               String representation of collection.
     */
    ToString(): string;
    /**
     * Convert to string.
     *
     * @param   {string}   separator   The separator.
     * @return  {string}               String representation of collection.
     */
    ToString(separator: string): string;
    ToString(separator: string = " "): string {
        if (this.Count == 0) {
            return StringHelper.Empty;
        }
        else {
            let daysOfTheWeekArray: string[] = new Array(this.Count);

            for (let i = 0; i < this.Count; i++) {
                daysOfTheWeekArray[i] = DayOfTheWeek[this.items[i]];
            }

            return daysOfTheWeekArray.join(separator);
        }
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}   xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void {
        let daysOfWeekAsString: string = this.ToString(" ");

        if (!StringHelper.IsNullOrEmpty(daysOfWeekAsString)) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.DaysOfWeek,
                daysOfWeekAsString);
        }
    }
}

/**
 * Represents a recurrence pattern, as used by Appointment and Task items.
 */
export class Recurrence extends ComplexProperty {

    startDate: DateTime = null;
    numberOfOccurrences: number = null;
    endDate: DateTime = null;

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string { return null; };

    /**
     * @internal Gets a value indicating whether this instance is regeneration pattern.
     *
     * @value   *true* if this instance is regeneration pattern; otherwise, *false*.
     */
    get IsRegenerationPattern(): boolean {
        return false;
    }

    /**
     * Gets or sets the date and time when the recurrence start.
     */
    get StartDate(): DateTime {
        return this.GetFieldValueOrThrowIfNull<DateTime>(this.startDate, "StartDate");
    }
    set StartDate(value: DateTime) {
        this.startDate = new DateTime(value);
    }

    /**
     * Gets a value indicating whether the pattern has a fixed number of occurrences or an end date.
     */
    get HasEnd(): boolean {
        return this.numberOfOccurrences !== null || this.endDate !== null;
    }

    /**
     * Gets or sets the number of occurrences after which the recurrence ends. Setting NumberOfOccurrences resets EndDate.
     */
    get NumberOfOccurrences(): number {
        return this.numberOfOccurrences;
    }
    set NumberOfOccurrences(value: number) {
        if (value < 1) {
            throw new ArgumentException(Strings.NumberOfOccurrencesMustBeGreaterThanZero);
        }
        this.SetFieldValue<number>({ getValue: () => this.numberOfOccurrences, setValue: (updateValue) => { this.numberOfOccurrences = updateValue } }, value);
        this.endDate = null;
    }

    /**
     * Gets or sets the date after which the recurrence ends. Setting EndDate resets NumberOfOccurrences.
     */
    get EndDate(): DateTime {
        return this.endDate;
    }
    set EndDate(value: DateTime) {
        this.SetFieldValue<DateTime>({ getValue: () => this.endDate, setValue: (updateValue) => { this.endDate = updateValue } }, value);
        this.numberOfOccurrences = null;
    }

    /**
     * @internal Initializes a new instance of the **Recurrence** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **Recurrence** class.
     *
     * @param   {DateTime}   startDate   The start date.
     */
    constructor(startDate: DateTime);
    constructor(startDate?: DateTime) {
        super();
        if (arguments.length === 1) {
            this.startDate = startDate;
        }
    }

    /**
     * Gets a property value or throw if null.
     *
     * @typeparam   {T}     Value type.
     * @param   {T}         value   The value.
     * @param   {string}    name    The property name.
     * @return  {T}         Property value
     */
    GetFieldValueOrThrowIfNull<T>(value: any, name: string): T {
        if (typeof value !== 'undefined' && value !== null) {
            return value;
        }
        else {
            throw new ServiceValidationException(
                StringHelper.Format(Strings.PropertyValueMustBeSpecifiedForRecurrencePattern, name));
        }
    }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        super.InternalValidate();

        if (!this.startDate) {
            throw new ServiceValidationException(Strings.RecurrencePatternMustHaveStartDate);
        }
    }

    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternalWritePropertiesToXml(writer: EwsServiceXmlWriter): void {/** virtual method */ }

    /**
     * Compares two objects by converting them to JSON and comparing their string values
     *
     * @param   {Recurrence}    otherRecurrence   object to compare to
     * @return  {boolean}       true if the objects serialize to the same string
     */
    IsSame(otherRecurrence: Recurrence): boolean {
        throw new Error("Recurrence.ts - IsSame : Not implemented. - no method calls it");
        // if (otherRecurrence == null) {
        //     return false;
        // }

        // string jsonString;
        // using(MemoryStream memoryStream = new MemoryStream())
        // {
        //     ((JsonObject)this.InternalToJson(null)).SerializeToJson(memoryStream);
        //     memoryStream.Position = 0;
        //     using(StreamReader reader = new StreamReader(memoryStream))
        //     {
        //         jsonString = reader.ReadToEnd();
        //     }
        // }

        // string otherJsonString;
        // using(MemoryStream memoryStream = new MemoryStream())
        // {
        //     ((JsonObject)otherRecurrence.InternalToJson(null)).SerializeToJson(memoryStream);
        //     memoryStream.Position = 0;
        //     using(StreamReader reader = new StreamReader(memoryStream))
        //     {
        //         otherJsonString = reader.ReadToEnd();
        //     }
        // }

        // return String.Equals(jsonString, otherJsonString, StringComparison.Ordinal);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {        
    }

    /**
     * Sets up this recurrence so that it never ends. Calling NeverEnds is equivalent to setting both NumberOfOccurrences and EndDate to null.
     */
    NeverEnds(): void {
        this.numberOfOccurrences = null;
        this.endDate = null;
        this.Changed();
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, this.XmlElementName);
        this.InternalWritePropertiesToXml(writer);
        writer.WriteEndElement();

        let range: RecurrenceRange;

        if (!this.HasEnd) {
            range = new NoEndRecurrenceRange(this.StartDate);
        }
        else if (this.NumberOfOccurrences) {
            range = new NumberedRecurrenceRange(this.StartDate, this.NumberOfOccurrences);
        }
        else {
            range = new EndDateRecurrenceRange(this.StartDate, this.EndDate);
        }

        range.WriteToXml(writer, range.XmlElementName);
    }
}

export module Recurrence {
    export var DailyPattern: new () => DailyPattern;
    export var DailyRegenerationPattern: new () => DailyRegenerationPattern;
    export var IntervalPattern: new () => IntervalPattern;
    export var MonthlyPattern: new () => MonthlyPattern;
    export var MonthlyRegenerationPattern: new () => MonthlyRegenerationPattern;
    export var RelativeMonthlyPattern: new () => RelativeMonthlyPattern;
    export var RelativeYearlyPattern: new () => RelativeYearlyPattern;
    export var WeeklyPattern: new () => WeeklyPattern;
    export var WeeklyRegenerationPattern: new () => WeeklyRegenerationPattern;
    export var YearlyPattern: new () => YearlyPattern;
    export var YearlyRegenerationPattern: new () => YearlyRegenerationPattern;
}

/**
 * Represents a recurrence pattern where each occurrence happens at a specific interval after the previous one.
 */
export abstract class IntervalPattern extends Recurrence {

    private interval: number;

    /**
     * Gets or sets the interval between occurrences. 
     */
    get Interval(): number {
        return this.interval;
    }
    set Interval(value: number) {
        if (value < 1) {
            throw new ArgumentOutOfRangeException("value", Strings.IntervalMustBeGreaterOrEqualToOne);
        }
        this.SetFieldValue<number>({ getValue: () => this.interval, setValue: (updateValue) => { this.interval = updateValue } }, value);

    }

    /**
     * @internal Initializes a new instance of the **IntervalPattern** class.
     */
    constructor();
    /**
     * @internal nitializes a new instance of the **IntervalPattern** class.
     *
     * @param   {DateTime}  startDate   The date and time when the recurrence starts.
     * @param   {number}    interval    The number of days between each occurrence.
     */
    constructor(startDate: DateTime, interval: number);
    constructor(startDate?: DateTime, interval: number = 1) {
        if (arguments.length === 0) {
            super();
            this.interval = 1;
            return;
        }
        super(startDate);
        if (interval < 1) {
            throw new ArgumentOutOfRangeException("interval", Strings.IntervalMustBeGreaterOrEqualToOne);
        }

        this.Interval = interval;
    }

    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternalWritePropertiesToXml(writer: EwsServiceXmlWriter): void {
        super.InternalWritePropertiesToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Interval,
            this.Interval);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.Interval:
                    this.interval = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents a recurrence pattern where each occurrence happens a specific number of days after the previous one.
 */
export class DailyPattern extends IntervalPattern {

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.DailyRecurrence;
    }

    /**
     * Initializes a new instance of the **DailyPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **DailyPattern** class.
     *
     * @param   {DateTime}  startDate   The date and time when the recurrence starts.
     * @param   {number}    interval    The number of days between each occurrence.
     */
    constructor(startDate: DateTime, interval: number);
    constructor(startDate?: DateTime, interval?: number) {
        if (arguments.length === 0) {
            super();
            return;
        }
        super(startDate, interval);
    }
}

/**
 * Represents a regeneration pattern, as used with recurring tasks, where each occurrence happens a specified number of days after the previous one is completed.
 */
export class DailyRegenerationPattern extends IntervalPattern {

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.DailyRegeneration;
    }

    /**
     * Gets a value indicating whether this instance is a regeneration pattern.
     *
     * @value   *true* if this instance is a regeneration pattern; otherwise, *false*.</value>
     */
    get IsRegenerationPattern(): boolean {
        return true;
    }

    /**
     * Initializes a new instance of the **DailyRegenerationPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **DailyRegenerationPattern** class.
     *
     * @param   {DateTime}   startDate   The date and time when the recurrence starts.
     * @param   {number}   interval    The number of days between the current occurrence and the next, after the current occurrence is completed.
     */
    constructor(startDate: DateTime, interval: number);
    constructor(startDate?: DateTime, interval?: number) {
        if (arguments.length === 0) {
            super();
            return;
        }
        super(startDate, interval);
    }
}

/**
 * Represents a recurrence pattern where each occurrence happens on a specific day a specific number of months after the previous one.
 */
export class MonthlyPattern extends IntervalPattern {

    private dayOfMonth: number;

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.AbsoluteMonthlyRecurrence;
    }

    /**
     * Gets or sets the day of the month when each occurrence happens. DayOfMonth must be between 1 and 31.
     */
    get DayOfMonth(): number {
        return super.GetFieldValueOrThrowIfNull<number>(this.dayOfMonth, "DayOfMonth");
    }
    set DayOfMonth(value: number) {
        if (value < 1 || value > 31) {
            throw new ArgumentOutOfRangeException("DayOfMonth", Strings.DayOfMonthMustBeBetween1And31);
        }
        this.SetFieldValue<number>({ getValue: () => this.dayOfMonth, setValue: (updateValue) => { this.dayOfMonth = updateValue } }, value);
    }


    /**
     * Initializes a new instance of the **MonthlyPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **MonthlyPattern** class.
     *
     * @param   {DateTime}  startDate    The date and time when the recurrence starts.
     * @param   {number}    interval     The number of months between each occurrence.
     * @param   {number}    dayOfMonth   The day of the month when each occurrence happens.
     */
    constructor(startDate: DateTime, interval: number, dayOfMonth: number);
    constructor(startDate?: DateTime, interval?: number, dayOfMonth: number = null) {
        if (arguments.length === 0) {
            super()
            this.dayOfMonth = null;
            return;
        }
        super(startDate, interval);
        this.DayOfMonth = dayOfMonth;
    }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        super.InternalValidate();

        if (this.dayOfMonth === null) {
            throw new ServiceValidationException(Strings.DayOfMonthMustBeBetween1And31);
        }
    }

    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternalWritePropertiesToXml(writer: EwsServiceXmlWriter): void {
        super.InternalWritePropertiesToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DayOfMonth,
            this.DayOfMonth);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.DayOfMonth:
                    this.dayOfMonth = Convert.toNumber(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents a regeneration pattern, as used with recurring tasks, where each occurrence happens a specified number of months after the previous one is completed.
 */
export class MonthlyRegenerationPattern extends IntervalPattern {

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.MonthlyRegeneration;
    }

    /**
     * Gets a value indicating whether this instance is a regeneration pattern.
     *
     * @value   *true* if this instance is a regeneration pattern; otherwise, *false*.</value>
     */
    get IsRegenerationPattern(): boolean {
        return true;
    }

    /**
     * Initializes a new instance of the **MonthlyRegenerationPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **MonthlyRegenerationPattern** class.
     *
     * @param   {DateTime}   startDate   The date and time when the recurrence starts.
     * @param   {number}   interval    The number of days between the current occurrence and the next, after the current occurrence is completed.
     */
    constructor(startDate: DateTime, interval: number);
    constructor(startDate?: DateTime, interval?: number) {
        if (arguments.length === 0) {
            super();
            return;
        }
        super(startDate, interval);
    }
}

/**
 * Represents a recurrence pattern where each occurrence happens on a relative day a specific number of months after the previous one. 
*/
export class RelativeMonthlyPattern extends IntervalPattern {

    private dayOfTheWeek: DayOfTheWeek;
    private dayOfTheWeekIndex: DayOfTheWeekIndex;

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.RelativeMonthlyRecurrence;
    }

    /**
     * Gets or sets the relative position of the day specified in DayOfTheWeek within the month.
     */
    get DayOfTheWeekIndex(): DayOfTheWeekIndex {
        return super.GetFieldValueOrThrowIfNull<DayOfTheWeekIndex>(this.dayOfTheWeekIndex, "DayOfTheWeekIndex");
    }
    set DayOfTheWeekIndex(value: DayOfTheWeekIndex) {
        this.SetFieldValue<DayOfTheWeekIndex>({ getValue: () => this.dayOfTheWeekIndex, setValue: (updateValue) => { this.dayOfTheWeekIndex = updateValue } }, value);
    }

    /**
     * The day of the week when each occurrence happens.
     */
    get DayOfTheWeek(): DayOfTheWeek {
        return super.GetFieldValueOrThrowIfNull<DayOfTheWeek>(this.dayOfTheWeek, "DayOfTheWeek");
    }
    set DayOfTheWeek(value: DayOfTheWeek) {
        this.SetFieldValue<DayOfTheWeek>({ getValue: () => this.dayOfTheWeek, setValue: (updateValue) => { this.dayOfTheWeek = updateValue } }, value);
    }


    /**
     * Initializes a new instance of the **RelativeMonthlyPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **RelativeMonthlyPattern** class.
     *
     * @param   {DateTime}              startDate           The date and time when the recurrence starts.
     * @param   {number}                interval            The number of months between each occurrence.
     * @param   {DayOfTheWeek}          dayOfTheWeek        The day of the week each occurrence happens.
     * @param   {DayOfTheWeekIndex}   dayOfTheWeekIndex   The relative position of the day within the month.
     */
    constructor(startDate: DateTime, interval: number, dayOfTheWeek: DayOfTheWeek, dayOfTheWeekIndex: DayOfTheWeekIndex);
    constructor(startDate?: DateTime, interval?: number, dayOfTheWeek: DayOfTheWeek = null, dayOfTheWeekIndex: DayOfTheWeekIndex = null) {
        if (arguments.length === 0) {
            super();
            this.dayOfTheWeek = null;
            this.dayOfTheWeekIndex = null;
            return;
        }
        super(startDate, interval);
        this.DayOfTheWeek = dayOfTheWeek;
        this.DayOfTheWeekIndex = dayOfTheWeekIndex;
    }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        super.InternalValidate();

        if (this.dayOfTheWeek === null) {
            throw new ServiceValidationException(Strings.DayOfTheWeekMustBeSpecifiedForRecurrencePattern);
        }

        if (this.dayOfTheWeekIndex === null) {
            throw new ServiceValidationException(Strings.DayOfWeekIndexMustBeSpecifiedForRecurrencePattern);
        }
    }

    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternalWritePropertiesToXml(writer: EwsServiceXmlWriter): void {
        super.InternalWritePropertiesToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DaysOfWeek,
            DayOfTheWeek[this.DayOfTheWeek]);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DayOfWeekIndex,
            DayOfTheWeekIndex[this.DayOfTheWeekIndex]);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.DaysOfWeek:
                    this.dayOfTheWeek = DayOfTheWeek[<string>jsObject[key]];
                    break;
                case XmlElementNames.DayOfWeekIndex:
                    this.dayOfTheWeekIndex = DayOfTheWeekIndex[<string>jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents a recurrence pattern where each occurrence happens on specific days a specific number of weeks after the previous one.
 */
export class WeeklyPattern extends IntervalPattern {

    private daysOfTheWeek: DayOfTheWeekCollection;
    private firstDayOfWeek: DayOfWeek;

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.WeeklyRecurrence;
    }

    /**
     * Gets the list of the days of the week when occurrences happen.
     */
    get DaysOfTheWeek(): DayOfTheWeekCollection {
        return this.daysOfTheWeek;
    }

    /**
     * Gets or sets the first day of the week for this recurrence.
     */
    get FirstDayOfWeek(): DayOfWeek {
        return super.GetFieldValueOrThrowIfNull<DayOfWeek>(this.firstDayOfWeek, "FirstDayOfWeek");
    }
    set FirstDayOfWeek(value: DayOfWeek) {
        this.SetFieldValue<DayOfWeek>({ getValue: () => this.firstDayOfWeek, setValue: (updateValue) => { this.firstDayOfWeek = updateValue } }, value);
    }

    /**
     * Initializes a new instance of the **WeeklyPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **WeeklyPattern** class.
     *
     * @param   {DateTime}          startDate       The date and time when the recurrence starts.
     * @param   {number}            interval        The number of weeks between each occurrence.
     * @param   {DayOfTheWeek[]}    daysOfTheWeek   The days of the week when occurrences happen.
     */
    constructor(startDate: DateTime, interval: number, daysOfTheWeek: DayOfTheWeek[]);
    constructor(startDate?: DateTime, interval?: number, daysOfTheWeek: DayOfTheWeek[] = []) {
        if (arguments.length === 0) {
            super();
            this.daysOfTheWeek = new DayOfTheWeekCollection()
            this.daysOfTheWeek.OnChange.push(this.DaysOfTheWeekChanged.bind(this));
        }
        else {
            super(startDate, interval);
            this.daysOfTheWeek = new DayOfTheWeekCollection()
        }
        this.firstDayOfWeek = null;
        this.daysOfTheWeek.AddRange(daysOfTheWeek);
    }

    /**
     * Change event handler.
     *
     * @param   {ComplexProperty}   complexProperty   The complex property.
     */
    private DaysOfTheWeekChanged(complexProperty: ComplexProperty): void { this.Changed(); }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        super.InternalValidate();

        if (this.DaysOfTheWeek.Count == 0) {
            throw new ServiceValidationException(Strings.DaysOfTheWeekNotSpecified);
        }
    }

    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternalWritePropertiesToXml(writer: EwsServiceXmlWriter): void {
        super.InternalWritePropertiesToXml(writer);

        this.DaysOfTheWeek.WriteToXml(writer, XmlElementNames.DaysOfWeek);

        if (hasValue(this.firstDayOfWeek)) {
            //  We only allow the "FirstDayOfWeek" parameter for the Exchange2010_SP1 schema
            //  version.
            //
            EwsUtilities.ValidatePropertyVersion(
                <ExchangeService>writer.Service,
                ExchangeVersion.Exchange2010_SP1,
                "FirstDayOfWeek");

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.FirstDayOfWeek,
                DayOfWeek[this.firstDayOfWeek]);
        }
    }


    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.DaysOfWeek:
                    this.DaysOfTheWeek.LoadFromXmlJsObjectValue(jsObject[key]);
                    break;
                case XmlElementNames.FirstDayOfWeek:
                    this.FirstDayOfWeek = DayOfWeek[<string>jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents a regeneration pattern, as used with recurring tasks, where each occurrence happens a specified number of weeks after the previous one is completed.
 */
export class WeeklyRegenerationPattern extends IntervalPattern {

	/**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.WeeklyRegeneration;
    }

    /**
     * Gets a value indicating whether this instance is a regeneration pattern.
     *
     * @value   *true* if this instance is a regeneration pattern; otherwise, *false*.</value>
     */
    get IsRegenerationPattern(): boolean {
        return true;
    }

    /**
     * Initializes a new instance of the **WeeklyRegenerationPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **WeeklyRegenerationPattern** class.
     *
     * @param   {DateTime}   startDate   The date and time when the recurrence starts.
     * @param   {interval}   interval    The number of weeks between the current occurrence and the next, after the current occurrence is completed.
     */
    constructor(startDate: DateTime, interval: number);
    constructor(startDate?: DateTime, interval?: number) {
        if (arguments.length === 0) {
            super();
            return;
        }
        super(startDate, interval);
    }
}

/**
 * Represents a regeneration pattern, as used with recurring tasks, where each occurrence happens a specified number of years after the previous one is completed.
 */
export class YearlyRegenerationPattern extends IntervalPattern {

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.MonthlyRegeneration;
    }

    /**
     * Gets a value indicating whether this instance is a regeneration pattern.
     *
     * @value   *true* if this instance is a regeneration pattern; otherwise, *false*.</value>
     */
    get IsRegenerationPattern(): boolean {
        return true;
    }

    /**
     * Initializes a new instance of the **YearlyRegenerationPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **YearlyRegenerationPattern** class.
     *
     * @param   {DateTime}   startDate   The date and time when the recurrence starts.
     * @param   {number}   interval    The number of years between the current occurrence and the next, after the current occurrence is completed.
     */
    constructor(startDate: DateTime, interval: number);
    constructor(startDate?: DateTime, interval?: number) {
        if (arguments.length === 0) {
            super();
            return;
        }
        super(startDate, interval);
    }
}

/**
 * Represents a recurrence pattern where each occurrence happens on a relative day every year.
 */
export class RelativeYearlyPattern extends Recurrence {

    private dayOfTheWeek: DayOfTheWeek;
    private dayOfTheWeekIndex: DayOfTheWeekIndex;
    private month: Month;

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.RelativeYearlyRecurrence;
    }

    /**
     * Gets or sets the relative position of the day specified in DayOfTheWeek within the month.
     */
    get DayOfTheWeekIndex(): DayOfTheWeekIndex {
        return super.GetFieldValueOrThrowIfNull<DayOfTheWeekIndex>(this.dayOfTheWeekIndex, "DayOfTheWeekIndex");
    }
    set DayOfTheWeekIndex(value: DayOfTheWeekIndex) {
        this.SetFieldValue<DayOfTheWeekIndex>({ getValue: () => this.dayOfTheWeekIndex, setValue: (updateValue) => { this.dayOfTheWeekIndex = updateValue } }, value);

    }

    /**
     * Gets or sets the day of the week when each occurrence happens.
     */
    get DayOfTheWeek(): DayOfTheWeek {
        return super.GetFieldValueOrThrowIfNull<DayOfTheWeek>(this.dayOfTheWeek, "DayOfTheWeek");
    }
    set DayOfTheWeek(value: DayOfTheWeek) {
        this.SetFieldValue<DayOfTheWeek>({ getValue: () => this.dayOfTheWeek, setValue: (updateValue) => { this.dayOfTheWeek = updateValue } }, value);
    }

    /**
     * Gets or sets the month of the year when each occurrence happens.
     */
    get Month(): Month {
        return super.GetFieldValueOrThrowIfNull<Month>(this.month, "Month");
    }
    set Month(value: Month) {
        this.SetFieldValue<Month>({ getValue: () => this.month, setValue: (updateValue) => { this.month = updateValue } }, value);
    }


    /**
     * Initializes a new instance of the **RelativeYearlyPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **RelativeYearlyPattern** class.
     *
     * @param   {DateTime}              startDate           The date and time when the recurrence starts.
     * @param   {Month}                 month               The month of the year each occurrence happens.
     * @param   {DayOfTheWeek}          dayOfTheWeek        The day of the week each occurrence happens.
     * @param   {DayOfTheWeekIndex}     dayOfTheWeekIndex   The relative position of the day within the month.
     */
    constructor(startDate: DateTime, month: Month, dayOfTheWeek: DayOfTheWeek, dayOfTheWeekIndex: DayOfTheWeekIndex);
    constructor(startDate?: DateTime, month: Month = null, dayOfTheWeek: DayOfTheWeek = null, dayOfTheWeekIndex: DayOfTheWeekIndex = null) {
        if (arguments.length === 0) {
            super();
            this.dayOfTheWeek = null;
            this.dayOfTheWeekIndex = null;
            return;
        }
        super(startDate);
        this.Month = month;
        this.DayOfTheWeek = dayOfTheWeek;
        this.DayOfTheWeekIndex = dayOfTheWeekIndex;
    }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        super.InternalValidate();

        if (this.dayOfTheWeekIndex === null) {
            throw new ServiceValidationException(Strings.DayOfWeekIndexMustBeSpecifiedForRecurrencePattern);
        }

        if (this.dayOfTheWeek === null) {
            throw new ServiceValidationException(Strings.DayOfTheWeekMustBeSpecifiedForRecurrencePattern);
        }

        if (this.month === null) {
            throw new ServiceValidationException(Strings.MonthMustBeSpecifiedForRecurrencePattern);
        }
    }

    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternalWritePropertiesToXml(writer: EwsServiceXmlWriter): void {
        super.InternalWritePropertiesToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DaysOfWeek,
            DayOfTheWeek[this.DayOfTheWeek]);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DayOfWeekIndex,
            DayOfTheWeekIndex[this.DayOfTheWeekIndex]);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Month,
            Month[this.Month]);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.DaysOfWeek:
                    this.dayOfTheWeek = DayOfTheWeek[<string>jsObject[key]];
                    break;
                case XmlElementNames.DayOfWeekIndex:
                    this.dayOfTheWeekIndex = DayOfTheWeekIndex[<string>jsObject[key]];
                    break;
                case XmlElementNames.Month:
                    this.month = Month[<string>jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents a recurrence pattern where each occurrence happens on a specific day every year.
 */
export class YearlyPattern extends Recurrence {

    private month: Month;
    private dayOfMonth: number;

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.AbsoluteYearlyRecurrence;
    }

    /**
     * Gets or sets the month of the year when each occurrence happens.
     */
    get Month(): Month {
        return super.GetFieldValueOrThrowIfNull<Month>(this.month, "Month");
    }
    set Month(value: Month) {
        this.SetFieldValue<Month>({ getValue: () => this.month, setValue: (updateValue) => { this.month = updateValue } }, value);
    }

    /**
     * Gets or sets the day of the month when each occurrence happens. DayOfMonth must be between 1 and 31.
     */
    get DayOfMonth(): number {
        return super.GetFieldValueOrThrowIfNull<number>(this.dayOfMonth, "DayOfMonth");
    }
    set DayOfMonth(value: number) {
        if (value < 1 || value > 31) {
            throw new ArgumentOutOfRangeException("DayOfMonth", Strings.DayOfMonthMustBeBetween1And31);
        }
        this.SetFieldValue<number>({ getValue: () => this.dayOfMonth, setValue: (updateValue) => { this.dayOfMonth = updateValue } }, value);
    }


    /**
     * Initializes a new instance of the **YearlyPattern** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **YearlyPattern** class.
     *
     * @param   {DateTime}  startDate    The date and time when the recurrence starts.
     * @param   {Month}     month        The month of the year each occurrence happens.
     * @param   {number}    dayOfMonth   The day of the month each occurrence happens.
     */
    constructor(startDate: DateTime, month: Month, dayOfMonth: number);
    constructor(startDate?: DateTime, month: Month = null, dayOfMonth: number = null) {
        if (arguments.length === 0) {
            super();
            this.month = null;
            this.dayOfMonth = null;
            return;
        }
        super(startDate);
        this.Month = month;
        this.DayOfMonth = dayOfMonth;
    }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        super.InternalValidate();

        if (this.month === null) {
            throw new ServiceValidationException(Strings.MonthMustBeSpecifiedForRecurrencePattern);
        }

        if (this.dayOfMonth === null) {
            throw new ServiceValidationException(Strings.DayOfMonthMustBeSpecifiedForRecurrencePattern);
        }
    }

    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternalWritePropertiesToXml(writer: EwsServiceXmlWriter): void {
        super.InternalWritePropertiesToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DayOfMonth,
            this.DayOfMonth);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Month,
            Month[this.Month]);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.DayOfMonth:
                    this.dayOfMonth = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.Month:
                    this.month = Month[<string>jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * @internal Represents recurrence range with start and end dates.
 */
export abstract class RecurrenceRange extends ComplexProperty {


    private startDate: DateTime = null;
    private recurrence: Recurrence = null;

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string { return null; };

    /**
     * @internal Gets or sets the recurrence.
     *
     * @value   The recurrence.
     */
    get Recurrence(): Recurrence {
        return this.recurrence;
    }
    set Recurrence(value: Recurrence) {
        this.recurrence = value;
    }

    /**
     * @internal Gets or sets the start date.
     *
     * @value   The start date.
     */
    get StartDate(): DateTime {
        return this.startDate;
    }
    set StartDate(value: DateTime) {
        this.SetFieldValue<DateTime>({ getValue: () => this.startDate, setValue: (updateValue) => { this.startDate = updateValue } }, value);
    }


    /**
     * @internal Initializes a new instance of the **RecurrenceRange** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **RecurrenceRange** class.
     *
     * @param   {DateTime}   startDate   The start date.
     */
    constructor(startDate: DateTime);
    constructor(startDate: DateTime = null) {
        super();
        this.startDate = startDate;
    }

    /**
     * @internal Changes handler.
     */
    Changed(): void {
        if (this.Recurrence != null) {
            this.Recurrence.Changed();
        }
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.StartDate:

                    let startDate: DateTime = service.ConvertStartDateToUnspecifiedDateTime(jsObject[key]);
                    if (startDate) {
                        this.startDate = startDate;
                    }
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Setup the recurrence.
     *
     * @param   {Recurrence}   recurrence   The recurrence.
     */
    SetupRecurrence(recurrence: Recurrence): void { recurrence.StartDate = this.StartDate; }



    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.StartDate,
            EwsUtilities.DateTimeToXSDate(this.StartDate));
    }
}

/**
 * @internal Represents recurrent range with an end date.
 */
export class EndDateRecurrenceRange extends RecurrenceRange {

    private endDate: DateTime;

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.EndDateRecurrence;
    }

    /**
     * Gets or sets the end date.
     *
     * @value   The end date.
     */
    get EndDate(): DateTime {
        return this.endDate;
    }
    set EndDate(value: DateTime) {
        this.SetFieldValue<DateTime>({ getValue: () => this.endDate, setValue: (updateValue) => { this.endDate = updateValue } }, value);
    }

    /**
     * Initializes a new instance of the **EndDateRecurrenceRange** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **EndDateRecurrenceRange** class.
     *
     * @param   {DateTime}   startDate   The start date.
     * @param   {DateTime}   endDate     The end date.
     */
    constructor(startDate: DateTime, endDate: DateTime);
    constructor(startDate?: DateTime, endDate: DateTime = null) {
        if (arguments.length === 0) {
            super()
        }
        else {
            super(startDate)
        }
        this.endDate = endDate;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.EndDate:
                    this.endDate = service.ConvertStartDateToUnspecifiedDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Setups the recurrence.
     *
     * @param   {Recurrence}   recurrence   The recurrence.
     */
    SetupRecurrence(recurrence: Recurrence): void {
        super.SetupRecurrence(recurrence);

        recurrence.EndDate = this.EndDate;
    }

    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.EndDate,
            EwsUtilities.DateTimeToXSDate(this.EndDate));
    }
}

/**
 * @internal Represents recurrence range with no end date.
 */
export class NoEndRecurrenceRange extends RecurrenceRange {

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.NoEndRecurrence;
    }

    /**
     * Initializes a new instance of the **NoEndRecurrenceRange** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **NoEndRecurrenceRange** class.
     *
     * @param   {DateTime}   startDate   The start date.
     */
    constructor(startDate: DateTime);
    constructor(startDate: DateTime = null) {
        arguments.length === 0 ? super() : super(startDate);
    }
    /**
     * @internal Setups the recurrence.
     *
     * @param   {Recurrence}   recurrence   The recurrence.
     */
    SetupRecurrence(recurrence: Recurrence): void {
        super.SetupRecurrence(recurrence);

        recurrence.NeverEnds();
    }
}

/**
 * @internal Represents recurrence range with start and number of occurance.
 */
export class NumberedRecurrenceRange extends RecurrenceRange {

    private numberOfOccurrences: number;

    /**
     * @internal Gets the name of the XML element.
     *
     * @value   The name of the XML element.
     */
    get XmlElementName(): string {
        return XmlElementNames.NumberedRecurrence;
    }

    /**
     * Gets or sets the number of occurrences.
     *
     * @value   The number of occurrences.
     */
    get NumberOfOccurrences(): number {
        return this.numberOfOccurrences;
    }
    set NumberOfOccurrences(value: number) {
        this.SetFieldValue<number>({ getValue: () => this.numberOfOccurrences, setValue: (updateValue) => { this.numberOfOccurrences = updateValue } }, value);

    }


    /**
     * Initializes a new instance of the **NumberedRecurrenceRange** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **NumberedRecurrenceRange** class.
     *
     * @param   {DateTime}   startDate             The start date.
     * @param   {number}   numberOfOccurrences   The number of occurrences.
     */
    constructor(startDate: DateTime, numberOfOccurrences: number);
    constructor(startDate: DateTime = null, numberOfOccurrences: number = null) {
        if (arguments.length === 0) {
            super();
            return;
        }
        super(startDate);
        this.numberOfOccurrences = numberOfOccurrences;

    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NumberOfOccurrences:
                    this.numberOfOccurrences = Convert.toNumber(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Setups the recurrence.
     *
     * @param   {Recurrence}   recurrence   The recurrence.
     */
    SetupRecurrence(recurrence: Recurrence): void {
        super.SetupRecurrence(recurrence);

        recurrence.NumberOfOccurrences = this.NumberOfOccurrences;
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

            if (this.NumberOfOccurrences)
            {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.NumberOfOccurrences,
                    this.NumberOfOccurrences);
            }
    }
}
Recurrence.DailyPattern = DailyPattern;
Recurrence.DailyRegenerationPattern = DailyRegenerationPattern;
Recurrence.IntervalPattern = <any>IntervalPattern;
Recurrence.MonthlyPattern = MonthlyPattern;
Recurrence.MonthlyRegenerationPattern = MonthlyRegenerationPattern;
Recurrence.RelativeMonthlyPattern = RelativeMonthlyPattern;
Recurrence.RelativeYearlyPattern = RelativeYearlyPattern;
Recurrence.WeeklyPattern = WeeklyPattern;
Recurrence.WeeklyRegenerationPattern = WeeklyRegenerationPattern;
Recurrence.YearlyPattern = YearlyPattern;
Recurrence.YearlyRegenerationPattern = YearlyRegenerationPattern;

/**
 * @internal Represents a time zone period as defined in the EWS schema.
 */
export class TimeZoneDefinition extends ComplexProperty {

    /**
     * Prefix for generated ids.
     */
    private static readonly NoIdPrefix: string = "NoId_";

    private periods: Dictionary<string, TimeZonePeriod> = new DictionaryWithStringKey<TimeZonePeriod>();
    private transitionGroups: Dictionary<string, TimeZoneTransitionGroup> = new DictionaryWithStringKey<TimeZoneTransitionGroup>();
    private transitions: TimeZoneTransition[] = [];

    /**
     * @internal Gets or sets the name of this time zone definition.
     */
    Name: string;

    /**
     * @internal Gets or sets the Id of this time zone definition.
     */
    Id: string;

    /**
     * @internal Gets the periods associated with this time zone definition, indexed by Id.
     */
    get Periods(): Dictionary<string, TimeZonePeriod> {
        return this.periods;
    }

    /**
     * @internal Gets the transition groups associated with this time zone definition, indexed by Id.
     */
    get TransitionGroups(): Dictionary<string, TimeZoneTransitionGroup> {
        return this.transitionGroups;
    }

    /**
     * @internal Initializes a new instance of the **TimeZoneDefinition** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **TimeZoneDefinition** class.
     *
     * @param   {TimeZoneInfo}   timeZoneInfo   The time zone info used to initialize this definition.
     */
    constructor(timeZoneInfo: TimeZoneInfo);
    constructor(timeZoneInfo: TimeZoneInfo = null) {
        super()
        if (timeZoneInfo != null && typeof timeZoneInfo !== 'undefined') {
            this.Id = timeZoneInfo.Id;
            this.Name = timeZoneInfo.DisplayName;

            // TimeZoneInfo only supports one standard period, which bias is the time zone's base
            // offset to UTC.
            let standardPeriod: TimeZonePeriod = new TimeZonePeriod();
            standardPeriod.Id = TimeZonePeriod.StandardPeriodId;
            standardPeriod.Name = TimeZonePeriod.StandardPeriodName;
            standardPeriod.Bias = new TimeSpan(-timeZoneInfo.BaseUtcOffset.TotalMilliseconds);

            //ref: very complex to calculate timezone rules and transitions. it works without adding those elements as they are optional, need to find scenario where it is mandatory.

            // let adjustmentRules: TimeZoneInfo.AdjustmentRule[] = []; // = timeZoneInfo.GetAdjustmentRules();

            // let transitionToStandardPeriod: TimeZoneTransition = new TimeZoneTransition(this, standardPeriod);

            // if (adjustmentRules.length == 0) {
            //     this.periods.Add(standardPeriod.Id, standardPeriod);

            //     // If the time zone info doesn't support Daylight Saving Time, we just need to
            //     // create one transition to one group with one transition to the standard period.
            //     let transitionGroup: TimeZoneTransitionGroup = new TimeZoneTransitionGroup(this, "0");
            //     transitionGroup.Transitions.push(transitionToStandardPeriod);

            //     this.transitionGroups.Add(transitionGroup.Id, transitionGroup);

            //     let initialTransition: TimeZoneTransition = new TimeZoneTransition(this, transitionGroup);

            //     this.transitions.push(initialTransition);
            // }
            // else {
            //     for (let i = 0; i < adjustmentRules.length; i++) {
            //         let transitionGroup: TimeZoneTransitionGroup = new TimeZoneTransitionGroup(this, this.transitionGroups.Count.toString());
            //         transitionGroup.InitializeFromAdjustmentRule(adjustmentRules[i], standardPeriod);

            //         this.transitionGroups.Add(transitionGroup.Id, transitionGroup);

            //         let transition: TimeZoneTransition;

            //         if (i == 0) {
            //             // If the first adjustment rule's start date in not undefined (DateTime.MinValue)
            //             // we need to add a dummy group with a single, simple transition to the Standard
            //             // period and a group containing the transitions mapping to the adjustment rule.
            //             if (adjustmentRules[i].DateStart > DateTime.MinValue.Date) {
            //                 let transitionToDummyGroup: TimeZoneTransition = new TimeZoneTransition(
            //                     this,
            //                     this.CreateTransitionGroupToPeriod(standardPeriod));

            //                 this.transitions.push(transitionToDummyGroup);

            //                 let absoluteDateTransition: AbsoluteDateTransition = new AbsoluteDateTransition(this, transitionGroup);
            //                 absoluteDateTransition.DateTime = adjustmentRules[i].DateStart;

            //                 transition = absoluteDateTransition;
            //                 this.periods.Add(standardPeriod.Id, standardPeriod);
            //             }
            //             else {
            //                 transition = new TimeZoneTransition(this, transitionGroup);
            //             }
            //         }
            //         else {
            //             let absoluteDateTransition: AbsoluteDateTransition = new AbsoluteDateTransition(this, transitionGroup);
            //             absoluteDateTransition.DateTime = adjustmentRules[i].DateStart;

            //             transition = absoluteDateTransition;
            //         }

            //         this.transitions.push(transition);
            //     }

            //     // If the last adjustment rule's end date is not undefined (DateTime.MaxValue),
            //     // we need to create another absolute date transition that occurs the date after
            //     // the last rule's end date. We target this additional transition to a group that
            //     // contains a single simple transition to the Standard period.
            //     let lastAdjustmentRuleEndDate: DateTime = adjustmentRules[adjustmentRules.length - 1].DateEnd;

            //     if (lastAdjustmentRuleEndDate < DateTime.MaxValue.Date) {
            //         let transitionToDummyGroup: AbsoluteDateTransition = new AbsoluteDateTransition(
            //             this,
            //             this.CreateTransitionGroupToPeriod(standardPeriod));
            //         transitionToDummyGroup.DateTime = lastAdjustmentRuleEndDate.AddDays(1);

            //         this.transitions.push(transitionToDummyGroup);
            //     }
            // }
        }
    }

    /**
     * Compares the transitions.
     *
     * @param   {TimeZoneTransition}   x   The first transition.
     * @param   {TimeZoneTransition}   y   The second transition.
     * @return  {number}       A negative number if x is less than y, 0 if x and y are equal, a positive number if x is greater than y.
     */
    private CompareTransitions(x: TimeZoneTransition, y: TimeZoneTransition): number {
        if (x == y) {
            return 0;
        }
        else if (x instanceof TimeZoneTransition) {
            return -1;
        }
        else if (y instanceof TimeZoneTransition) {
            return 1;
        }
        else {
            let firstTransition: AbsoluteDateTransition = <AbsoluteDateTransition>x;
            let secondTransition: AbsoluteDateTransition = <AbsoluteDateTransition>y;

            return DateTime.Compare(firstTransition.DateTime, secondTransition.DateTime);
        }
    }

    /**
     * Adds a transition group with a single transition to the specified period.
     *
     * @param   {TimeZonePeriod}   timeZonePeriod   The time zone period.
     * @return  {TimeZoneTransitionGroup}           A TimeZoneTransitionGroup.
     */
    private CreateTransitionGroupToPeriod(timeZonePeriod: TimeZonePeriod): TimeZoneTransitionGroup {
        let transitionToPeriod: TimeZoneTransition = new TimeZoneTransition(this, timeZonePeriod);

        let transitionGroup: TimeZoneTransitionGroup = new TimeZoneTransitionGroup(this, this.transitionGroups.Count.toString());
        transitionGroup.Transitions.push(transitionToPeriod);

        this.transitionGroups.Add(transitionGroup.Id, transitionGroup);

        return transitionGroup;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {

        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.Name:
                    this.Name = jsObject[key];
                    break;
                case XmlAttributeNames.Id:
                    this.Id = jsObject[key];
                    break;
                case XmlElementNames.Periods:
                    var jsperiods: any[] = EwsServiceJsonReader.ReadAsArray(jsObject[key], XmlElementNames.Period);
                    for (var jsPeriod of jsperiods) {
                        var period: TimeZonePeriod = new TimeZonePeriod();
                        period.LoadFromXmlJsObject(jsPeriod, service);

                        // OM:1648848 Bad timezone data from clients can include duplicate rules
                        // for one year, with duplicate ID. In that case, let the first one win.
                        if (!this.periods.containsKey(period.Id)) {
                            this.periods.Add(period.Id, period);
                        }
                        else {
                            service.TraceMessage(
                                TraceFlags.EwsTimeZones,
                                StringHelper.Format(
                                    "An entry with the same key (Id) '{0}' already exists in Periods. Cannot add another one. Existing entry: [Name='{1}', Bias='{2}']. Entry to skip: [Name='{3}', Bias='{4}'].",
                                    period.Id,
                                    this.Periods.get(period.Id).Name,
                                    this.Periods.get(period.Id).Bias,
                                    period.Name,
                                    period.Bias));
                        }
                    }
                    break;

                case XmlElementNames.TransitionsGroups:
                    var arrayOfTransitionsType: any[] = EwsServiceJsonReader.ReadAsArray(jsObject[key], XmlElementNames.TransitionsGroup);
                    for (var arrayOfTransitionsTypeInstance of arrayOfTransitionsType) {
                        var transitionGroup: TimeZoneTransitionGroup = new TimeZoneTransitionGroup(this);
                        transitionGroup.LoadFromXmlJsObject(arrayOfTransitionsTypeInstance, service);

                        this.transitionGroups.addUpdate(transitionGroup.Id, transitionGroup);
                    }
                    break;

                case XmlElementNames.Transitions:

                    for (let _key in jsObject[key]) {
                        if (TimeZoneTransitionGroup.transitionTypes.indexOf(_key) >= 0) {
                            let transitions: string[] = EwsServiceJsonReader.ReadAsArray(jsObject[key], _key);
                            for (let item of transitions) {
                                let transition: TimeZoneTransition = TimeZoneTransition.Create(this, _key);
                                transition.LoadFromXmlJsObject(item, service);
                                this.transitions.push(transition);
                            }
                        }
                    }
                    break;
                default:
                    break;
            }
        }

        // EWS can return a TimeZone definition with no Id. Generate a new Id in this case.
        if (StringHelper.IsNullOrEmpty(this.Id)) {
            let nameValue: string = StringHelper.IsNullOrEmpty(this.Name) ? StringHelper.Empty : this.Name;
            //this.Id = TimeZoneDefinition.NoIdPrefix + Math.abs(nameValue.GetHashCode()).ToString();
            this.Id = TimeZoneDefinition.NoIdPrefix + nameValue;
        }

        this.transitions.sort(this.CompareTransitions);
    }

    /**
     * @internal Converts this time zone definition into a TimeZoneInfo structure.
     *
     * @param   {ExchangeService}   service   The service.
     * @return  {TimeZoneInfo}      A TimeZoneInfo representing the same time zone as this definition.
     */
    ToTimeZoneInfo(service?: ExchangeService, parse: boolean = false): TimeZoneInfo {
        this.Validate();

        if (!parse) {
            //ref: skipped creation based on server data, directly creating using TimeZone Mapping data. complex to translate Windows TimeZoneInfo subclasses to javascript.
            return TimeZoneInfo.FindSystemTimeZoneById(this.Id);
        }
        let result: TimeZoneInfo;

        // Retrieve the base offset to UTC, standard and daylight display names from
        // the last transition group, which is the one that currently applies given that
        // transitions are ordered chronologically.
        let creationParams: TimeZoneTransitionGroup.CustomTimeZoneCreateParams =
            this.transitions[this.transitions.length - 1].TargetGroup.GetCustomTimeZoneCreationParams();

        let adjustmentRules: TimeZoneInfo.AdjustmentRule[] = [];

        let startDate: DateTime = DateTime.MinValue;
        let endDate: DateTime;
        let effectiveEndDate: DateTime;

        for (let i = 0; i < this.transitions.length; i++) {
            if (i < this.transitions.length - 1) {
                endDate = (this.transitions[i + 1] as AbsoluteDateTransition).DateTime;
                effectiveEndDate = endDate.AddDays(-1);
            }
            else {
                endDate = DateTime.MaxValue;
                effectiveEndDate = endDate;
            }

            // OM:1648848 Due to bad timezone data from clients the 
            // startDate may not always come before the effectiveEndDate
            if (startDate < effectiveEndDate) {
                let adjustmentRule: TimeZoneInfo.AdjustmentRule = this.transitions[i].TargetGroup.CreateAdjustmentRule(startDate, effectiveEndDate);

                if (adjustmentRule != null) {
                    adjustmentRules.push(adjustmentRule);
                }

                startDate = endDate;
            }
            else {
                // service.TraceMessage(
                //     TraceFlags.EwsTimeZones,
                //         string.Format(
                //             "The startDate '{0}' is not before the effectiveEndDate '{1}'. Will skip creating adjustment rule.",
                //             startDate,
                //             effectiveEndDate));
            }
        }

        if (adjustmentRules.length == 0) {
            // If there are no adjustment rule, the time zone does not support Daylight
            // saving time.
            result = TimeZoneInfo.CreateCustomTimeZone(
                this.Id,
                creationParams.BaseOffsetToUtc,
                this.Name,
                creationParams.StandardDisplayName);
        }
        else {
            result = TimeZoneInfo.CreateCustomTimeZone(
                this.Id,
                creationParams.BaseOffsetToUtc,
                this.Name,
                creationParams.StandardDisplayName,
                creationParams.DaylightDisplayName,
                adjustmentRules);
        }

        return result;
    }

    /**
     * @internal Validates this time zone definition.
     */
    Validate(): void {
        // The definition must have at least one period, one transition group and one transition,
        // and there must be as many transitions as there are transition groups.
        if (this.periods.Count < 1 || this.transitions.length < 1 || this.transitionGroups.Count < 1 ||
            this.transitionGroups.Count != this.transitions.length) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }

        // The first transition must be of type TimeZoneTransition.
        if (!(this.transitions[0] instanceof TimeZoneTransition)) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }

        // All transitions must be to transition groups and be either TimeZoneTransition or
        // AbsoluteDateTransition instances.
        for (let transition of this.transitions) {
            //Type transitionType = transition.GetType();

            if (!(transition instanceof TimeZoneTransition) && !(<any>transition instanceof AbsoluteDateTransition)) {
                throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
            }

            if (transition.TargetGroup == null) {
                throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
            }
        }

        // All transition groups must be valid.
        for (let transitionGroup of this.transitionGroups.Values) {
            transitionGroup.Validate();
        }
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        // The Name attribute is only supported in Exchange 2010 and above.
        if (writer.Service.RequestedServerVersion != ExchangeVersion.Exchange2007_SP1) {
            writer.WriteAttributeValue(XmlAttributeNames.Name, this.Name);
        }

        writer.WriteAttributeValue(XmlAttributeNames.Id, this.Id);
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        // We only emit the full time zone definition against Exchange 2010 servers and above.
        if (writer.Service.RequestedServerVersion != ExchangeVersion.Exchange2007_SP1) {
            if (this.periods.Count > 0) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Periods);

                for (let keyValuePair of this.periods.Items) {
                    keyValuePair.value.WriteToXml(writer);
                }

                writer.WriteEndElement(); // Periods
            }

            if (this.transitionGroups.Count > 0) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.TransitionsGroups);

                for (let transitionPair of this.transitionGroups.Items) {
                    transitionPair.value.WriteToXml(writer);
                }

                writer.WriteEndElement(); // TransitionGroups
            }

            if (this.transitions.length > 0) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Transitions);

                for (let transition of this.transitions) {
                    transition.WriteToXml(writer);
                }

                writer.WriteEndElement(); // Transitions
            }
        }
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName?: string): void {
        super.WriteToXml(writer, xmlElementName || XmlElementNames.TimeZoneDefinition);
    }
}

/**
 * @internal Represents a time zone period as defined in the EWS schema.
 */
export class TimeZonePeriod extends ComplexProperty {

    /** @internal */
    static readonly StandardPeriodId: string = "Std";
    /** @internal */
    static readonly StandardPeriodName: string = "Standard";
    /** @internal */
    static readonly DaylightPeriodId: string = "Dlt";
    /** @internal */
    static readonly DaylightPeriodName: string = "Daylight";

    /**
     * Gets a value indicating whether this period represents the Standard period.
     *
     * @value   <c>true</c> if this instance is standard period; otherwise, <c>false</c>.
     */
    get IsStandardPeriod(): boolean {
        return this.Name.toUpperCase() === TimeZonePeriod.StandardPeriodName.toUpperCase();
        // return string.Compare(
        //     this.name,
        //     TimeZonePeriod.StandardPeriodName,
        //     StringComparison.OrdinalIgnoreCase) == 0;
    }

    // private bias: TimeSpan; backing property not needed 
    // private name: string;
    // private id: string;

    /**
     * @internal Gets or sets the bias to UTC associated with this period.
     */
    Bias: TimeSpan;

    /**
     * @internal Gets or sets the name of this period.
     */
    Name: string;

    /**
     * @internal Gets or sets the id of this period.
     */
    Id: string;

    /**
     * @internal Initializes a new instance of the **TimeZonePeriod** class.
     */
    constructor() {
        super()
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {

        for (let key in jsObject) {
            switch (key) {
                case XmlAttributeNames.Id:
                    this.Id = jsObject[key];
                    break;
                case XmlAttributeNames.Name:
                    this.Name = jsObject[key];
                    break;
                case XmlAttributeNames.Bias:
                    this.Bias = EwsUtilities.XSDurationToTimeSpan(jsObject[key]);
                    break;
            }
        }
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.Bias, EwsUtilities.TimeSpanToXSDuration(this.Bias));
        writer.WriteAttributeValue(XmlAttributeNames.Name, this.Name);
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.Id);
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void { super.WriteToXml(writer, XmlElementNames.Period); }
}

/**
 * @internal Represents the base class for all time zone transitions.
 */
export class TimeZoneTransition extends ComplexProperty {

    private static readonly PeriodTarget: string = "Period";
    private static readonly GroupTarget: string = "Group";

    private timeZoneDefinition: TimeZoneDefinition;
    private targetPeriod: TimeZonePeriod;
    private targetGroup: TimeZoneTransitionGroup;

    /**
     * @internal Gets the target period of the transition.
     */
    get TargetPeriod(): TimeZonePeriod { return this.targetPeriod; 
    }

    /**
     * @internal Gets the target transition group of the transition.
     */
    get TargetGroup(): TimeZoneTransitionGroup { return this.targetGroup; 
    }

    /**
     * @internal Initializes a new instance of the **TimeZoneTransition** class.
     *
     * @param   {TimeZoneDefinition}   timeZoneDefinition   The time zone definition the transition will belong to.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition);
    /**
     * @internal Initializes a new instance of the **TimeZoneTransition** class.
     *
     * @param   {TimeZoneDefinition}        timeZoneDefinition   The time zone definition the transition will belong to.
     * @param   {TimeZoneTransitionGroup}   targetGroup          The transition group the transition will target.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition, targetGroup: TimeZoneTransitionGroup);
    /**
     * @internal Initializes a new instance of the **TimeZoneTransition** class.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition the transition will belong to.
     * @param   {TimeZonePeriod}        targetPeriod         The period the transition will target.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition, targetPeriod: TimeZonePeriod);
    constructor(timeZoneDefinition: TimeZoneDefinition, targetPeriodOrGroup?: TimeZonePeriod | TimeZoneTransitionGroup) {
        super();
        this.timeZoneDefinition = timeZoneDefinition;

        if (targetPeriodOrGroup instanceof TimeZonePeriod) {
            this.targetPeriod = targetPeriodOrGroup;
        }
        else if (targetPeriodOrGroup instanceof TimeZoneTransitionGroup) {
            this.targetGroup = targetPeriodOrGroup;
        }
    }

    /**
     * @internal Creates a time zone period transition of the appropriate type given an XML element name.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition to which the transition will belong.
     * @param   {string}                xmlElementName       The XML element name.
     * @return  {TimeZoneTransition}    A TimeZonePeriodTransition instance.
     */
    static Create(timeZoneDefinition: TimeZoneDefinition, xmlElementName: string): TimeZoneTransition {
        switch (xmlElementName) {
            case XmlElementNames.AbsoluteDateTransition:
                return new TypeContainer.AbsoluteDateTransition(timeZoneDefinition);
            case XmlElementNames.RecurringDayTransition:
                return new TypeContainer.RelativeDayOfMonthTransition(timeZoneDefinition);
            case XmlElementNames.RecurringDateTransition:
                return new TypeContainer.AbsoluteDayOfMonthTransition(timeZoneDefinition);
            case XmlElementNames.Transition:
                return new TimeZoneTransition(timeZoneDefinition);
            default:
                throw new ServiceLocalException(
                    StringHelper.Format(
                        Strings.UnknownTimeZonePeriodTransitionType,
                        xmlElementName));
        }
    }

    /**
     * @internal Creates a time zone transition based on the specified transition time.
     *
     * @param   {TimeZoneDefinition}            timeZoneDefinition   The time zone definition that will own the transition.
     * @param   {TimeZonePeriod}                targetPeriod         The period the transition will target.
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime       The transition time to initialize from.
     * @return  {TimeZoneTransition}            A TimeZoneTransition.
     */
    static CreateTimeZoneTransition(timeZoneDefinition: TimeZoneDefinition, targetPeriod: TimeZonePeriod, transitionTime: TimeZoneInfo.TransitionTime): TimeZoneTransition {
        var transition: TimeZoneTransition;

        if (transitionTime.IsFixedDateRule) {
            transition = new TypeContainer.AbsoluteDayOfMonthTransition(timeZoneDefinition, targetPeriod);
        }
        else {
            transition = new TypeContainer.RelativeDayOfMonthTransition(timeZoneDefinition, targetPeriod);
        }

        transition.InitializeFromTransitionTime(transitionTime);

        return transition;
    }

    /**
     * @internal Creates a time zone transition time.
     * @virtual
     *
     * @return  {TimeZoneInfo.TransitionTime}      A TimeZoneInfo.TransitionTime.
     */
    CreateTransitionTime(): TimeZoneInfo.TransitionTime {
        throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.Transition;
    }

    /**
     * @internal Initializes this transition based on the specified transition time.
     * @virtual
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
    InitializeFromTransitionTime(transitionTime: TimeZoneInfo.TransitionTime): void { }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {

        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.To:
                    let targetKind: string = jsObject[key][XmlAttributeNames.Kind];
                    let targetId: string = jsObject[key][XmlElementNames.To];

                    switch (targetKind) {
                        case TimeZoneTransition.PeriodTarget:
                            let targetPeriod: IOutParam<TimeZonePeriod> = { outValue: null }
                            if (!this.timeZoneDefinition.Periods.tryGetValue(targetId, targetPeriod)) {
                                throw new ServiceLocalException(
                                    StringHelper.Format(
                                        Strings.PeriodNotFound,
                                        targetId));
                            }
                            else {
                                this.targetPeriod = targetPeriod.outValue;
                            }

                            break;
                        case TimeZoneTransition.GroupTarget:
                            let targetGroup: IOutParam<TimeZoneTransitionGroup> = { outValue: null }

                            if (!this.timeZoneDefinition.TransitionGroups.tryGetValue(targetId, targetGroup)) {
                                throw new ServiceLocalException(
                                    StringHelper.Format(
                                        Strings.TransitionGroupNotFound,
                                        targetId));
                            }
                            else {
                                this.targetGroup = targetGroup.outValue;
                            }

                            break;
                        default:
                            throw new ServiceLocalException(Strings.UnsupportedTimeZonePeriodTransitionTarget);
                    }
                    break;
            }
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.To);

        if (this.targetPeriod != null) {
            writer.WriteAttributeValue(XmlAttributeNames.Kind, TimeZoneTransition.PeriodTarget);
            writer.WriteValue(this.targetPeriod.Id, XmlElementNames.To);
        }
        else {
            writer.WriteAttributeValue(XmlAttributeNames.Kind, TimeZoneTransition.GroupTarget);
            writer.WriteValue(this.targetGroup.Id, XmlElementNames.To);
        }

        writer.WriteEndElement(); // To
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        super.WriteToXml(writer, this.GetXmlElementName());
    }
}

export module TimeZoneTransition {
    export var AbsoluteDateTransition;
    export var AbsoluteDayOfMonthTransition;
    export var RelativeDayOfMonthTransition;
}

/**
 * @internal Represents a time zone period transition that occurs on a fixed (absolute) date.
 */
export class AbsoluteDateTransition extends TimeZoneTransition {

    /**
     * Gets or sets the absolute date and time when the transition occurs.
     */
    DateTime: DateTime;

    /**
     * @internal Initializes a new instance of the **AbsoluteDateTransition** class.
     *
     * @param   {TimeZoneDefinition}        timeZoneDefinition   The time zone definition the transition will belong to.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition);
    /**
     * @internal Initializes a new instance of the **AbsoluteDateTransition** class.
     *
     * @param   {TimeZoneDefinition}        timeZoneDefinition   The time zone definition the transition will belong to.
     * @param   {TimeZoneTransitionGroup}   targetGroup          The transition group the transition will target.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition, targetGroup: TimeZoneTransitionGroup);
    constructor(timeZoneDefinition: TimeZoneDefinition, targetGroup?: TimeZoneTransitionGroup) {
        super(timeZoneDefinition, targetGroup);
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.AbsoluteDateTransition;
    }

    /**
     * @internal Initializes this transition based on the specified transition time.
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
    InitializeFromTransitionTime(transitionTime: TimeZoneInfo.TransitionTime): TimeZoneInfo.TransitionTime {
        throw new ServiceLocalException(Strings.UnsupportedTimeZonePeriodTransitionTarget);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        if (jsObject[XmlElementNames.DateTime]) {
            this.DateTime = DateTime.Parse(jsObject[XmlElementNames.DateTime]);
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */

    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DateTime,
            this.DateTime);
    }
}

/**
 * @internal Represents the base class for all recurring time zone period transitions.
 */
export abstract class AbsoluteMonthTransition extends TimeZoneTransition {
    private timeOffset: TimeSpan = null;
    private month: number = null;

    /**
     * @internal Gets the time offset from midnight when the transition occurs.
     */
    get TimeOffset(): TimeSpan {
        return this.timeOffset;
    }

    /**
     * @internal Gets the month when the transition occurs.
     */
    get Month(): number {
        return this.month;
    }

    /**
     * @internal Initializes a new instance of the **AbsoluteMonthTransition** class.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition this transition belongs to.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition);
    /**
     * @internal Initializes a new instance of the **AbsoluteMonthTransition** class.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition this transition belongs to.
     * @param   {TimeZonePeriod}        targetPeriod         The period the transition will target.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition, targetPeriod: TimeZonePeriod);
    constructor(timeZoneDefinition: TimeZoneDefinition, targetPeriod?: TimeZonePeriod) {
        super(timeZoneDefinition, targetPeriod);
    }

    /**
     * @internal Initializes this transition based on the specified transition time.
     * @virtual
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
    InitializeFromTransitionTime(transitionTime: TimeZoneInfo.TransitionTime): void {

    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        if (jsObject[XmlElementNames.TimeOffset]) {
            this.timeOffset = EwsUtilities.XSDurationToTimeSpan(jsObject[XmlElementNames.TimeOffset]);
        }

        if (jsObject[XmlElementNames.Month]) {
            this.month = Convert.toInt(jsObject[XmlElementNames.Month]);

            EwsLogging.Assert(
                this.month > 0 && this.month <= 12,
                "AbsoluteMonthTransition.TryReadElementFromXml",
                "month is not in the valid 1 - 12 range.");
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.TimeOffset,
            EwsUtilities.TimeSpanToXSDuration(this.timeOffset));

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Month,
            this.month);
    }
}

/**
 * @internal Represents a time zone period transition that occurs on a specific day of a specific month.
 */
export class AbsoluteDayOfMonthTransition extends AbsoluteMonthTransition {

    private dayOfMonth: number = null;

    /**
     * @internal Gets the day of then month when this transition occurs.
     */
    get DayOfMonth(): number {
        return this.dayOfMonth;
    }

    /**
     * @internal Initializes a new instance of the **AbsoluteDayOfMonthTransition** class.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition this transition belongs to.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition);
    /**
     * @internal Initializes a new instance of the **AbsoluteDayOfMonthTransition** class.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition this transition belongs to.
     * @param   {TimeZonePeriod}        targetPeriod         The period the transition will target.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition, targetPeriod: TimeZonePeriod);
    constructor(timeZoneDefinition: TimeZoneDefinition, targetPeriod?: TimeZonePeriod) {
        super(timeZoneDefinition, targetPeriod);
    }

    /**
     * @internal Creates a time zone transition time.
     * @virtual
     *
     * @return  {TimeZoneInfo.TransitionTime}      A TimeZoneInfo.TransitionTime.
     */
    CreateTransitionTime(): TimeZoneInfo.TransitionTime {
        return TimeZoneInfo.TransitionTime.CreateFixedDateRule(
            new DateTime(this.TimeOffset.Milliseconds),
            this.Month,
            this.DayOfMonth);
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.RecurringDateTransition;
    }

    /**
     * @internal Initializes this transition based on the specified transition time.
     * @virtual
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
    InitializeFromTransitionTime(transitionTime: TimeZoneInfo.TransitionTime): void {
        super.InitializeFromTransitionTime(transitionTime);

        this.dayOfMonth = transitionTime.Day;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        if (jsObject[XmlElementNames.Day]) {
            this.dayOfMonth = Convert.toInt(jsObject[XmlElementNames.Day]);

            EwsLogging.Assert(
                this.dayOfMonth > 0 && this.dayOfMonth <= 31,
                "AbsoluteDayOfMonthTransition.TryReadElementFromXml",
                "dayOfMonth is not in the valid 1 - 31 range.");
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Day,
            this.dayOfMonth);
    }
}

/**
 * @internal Represents a time zone period transition that occurs on a relative day of a specific month.
 */
export class RelativeDayOfMonthTransition extends AbsoluteMonthTransition {

	private dayOfTheWeek: DayOfTheWeek = DayOfTheWeek.Sunday;
	private weekIndex: number = null;

	/**
	 * @internal Gets the day of the week when the transition occurs.
	 */
	get DayOfTheWeek(): DayOfTheWeek {
		return this.dayOfTheWeek;
	}

	/**
	 * @internal Gets the index of the week in the month when the transition occurs.
	 */
	get WeekIndex(): number {
		return this.weekIndex;
	}

	/**
     * @internal Initializes a new instance of the **RelativeDayOfMonthTransition** class.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition this transition belongs to.
     */
	constructor(timeZoneDefinition: TimeZoneDefinition);
    /**
     * @internal Initializes a new instance of the **RelativeDayOfMonthTransition** class.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition this transition belongs to.
     * @param   {TimeZonePeriod}        targetPeriod         The period the transition will target.
     */
	constructor(timeZoneDefinition: TimeZoneDefinition, targetPeriod: TimeZonePeriod);
	constructor(timeZoneDefinition: TimeZoneDefinition, targetPeriod?: TimeZonePeriod) {
		super(timeZoneDefinition, targetPeriod);
	}

	/**
     * @internal Creates a time zone transition time.
     * @virtual
     *
     * @return  {TimeZoneInfo.TransitionTime}      A TimeZoneInfo.TransitionTime.
     */
	CreateTransitionTime(): TimeZoneInfo.TransitionTime {
		return TimeZoneInfo.TransitionTime.CreateFloatingDateRule(
			new DateTime(this.TimeOffset.Milliseconds - msToEpoch),
			this.Month,
			this.WeekIndex == -1 ? 5 : this.WeekIndex,
			EwsUtilities.EwsToSystemDayOfWeek(this.DayOfTheWeek));
	}

	/**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
	GetXmlElementName(): string {
		return XmlElementNames.RecurringDayTransition;
	}

	/**
     * @internal Initializes this transition based on the specified transition time.
     * @virtual
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
	InitializeFromTransitionTime(transitionTime: TimeZoneInfo.TransitionTime): void {
		super.InitializeFromTransitionTime(transitionTime);

		this.dayOfTheWeek = EwsUtilities.SystemToEwsDayOfTheWeek(transitionTime.DayOfWeek);

		// TimeZoneInfo uses week indices from 1 to 5, 5 being the last week of the month.
		// EWS uses -1 to denote the last week of the month.
		this.weekIndex = transitionTime.Week == 5 ? -1 : transitionTime.Week;
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
	LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		super.LoadFromXmlJsObject(jsObject, service);

		if (jsObject[XmlElementNames.DayOfWeek]) {
			this.dayOfTheWeek = DayOfTheWeek[<string>jsObject[XmlElementNames.DayOfWeek]];
		}

		if (jsObject[XmlElementNames.Occurrence]) {
			this.weekIndex = Convert.toInt(jsObject[XmlElementNames.Occurrence]);
		}
	}

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		super.WriteElementsToXml(writer);

		writer.WriteElementValue(
			XmlNamespace.Types,
			XmlElementNames.DayOfWeek,
			DayOfTheWeek[this.dayOfTheWeek]);

		writer.WriteElementValue(
			XmlNamespace.Types,
			XmlElementNames.Occurrence,
			this.weekIndex);
	}
}

/**
 * @internal Represents a group of time zone period transitions.
 */
export class TimeZoneTransitionGroup extends ComplexProperty {

    /** @internal */
    static transitionTypes = [XmlElementNames.AbsoluteDateTransition, XmlElementNames.RecurringDayTransition, XmlElementNames.RecurringDateTransition, XmlElementNames.Transition];

    private timeZoneDefinition: TimeZoneDefinition;
    //private id: string;
    private transitions: TimeZoneTransition[] = [];
    private transitionToStandard: TimeZoneTransition;
    private transitionToDaylight: TimeZoneTransition;

    /**
     * @internal Gets a value indicating whether this group contains a transition to the Daylight period.
     * 
     * @value   *true* if this group contains a transition to daylight; otherwise, *false*.
     */
    get SupportsDaylight(): boolean {
        return this.transitions.length == 2;
    }

    /**
     * Gets the transition to the Daylight period.
     */
    private get TransitionToDaylight(): TimeZoneTransition {
        this.InitializeTransitions();
        return this.transitionToDaylight;
    }

    /**
     * Gets the transition to the Standard period.
     */
    private get TransitionToStandard(): TimeZoneTransition {
        this.InitializeTransitions();
        return this.transitionToStandard;
    }

    /**
     * @internal Gets or sets the id of this group.
     */
    Id: string;

    /**
     * @internal Gets the transitions in this group.
     */
    get Transitions(): TimeZoneTransition[] {
        return this.transitions;
    }

    /**
     * @internal Initializes a new instance of the **TimeZoneTransitionGroup** class.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition.
     * @param   {string}                id                   The Id of the new transition group.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition);
    /**
     * @internal Initializes a new instance of the **TimeZoneTransitionGroup** class.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition.
     * @param   {string}                id                   The Id of the new transition group.
     */
    constructor(timeZoneDefinition: TimeZoneDefinition, id: string);
    constructor(timeZoneDefinition: TimeZoneDefinition, id?: string) {
        super();
        this.timeZoneDefinition = timeZoneDefinition;
        this.Id = id;
    }

    /**
     * @internal Creates a time zone adjustment rule.
     *
     * @param   {DateTime}   startDate   The start date of the adjustment rule.
     * @param   {DateTime}   endDate     The end date of the adjustment rule.
     * @return  {TimeZoneInfo.AdjustmentRule}   An TimeZoneInfo.AdjustmentRule.
     */
    CreateAdjustmentRule(startDate: DateTime, endDate: DateTime): TimeZoneInfo.AdjustmentRule {
        // If there is only one transition, we can't create an adjustment rule. We have to assume
        // that the base offset to UTC is unchanged.
        if (this.transitions.length == 1) {
            return null;
        }

        return TimeZoneInfo.AdjustmentRule.CreateAdjustmentRule(
            startDate.Date,
            endDate.Date,
            this.GetDaylightDelta(),
            this.TransitionToDaylight.CreateTransitionTime(),
            this.TransitionToStandard.CreateTransitionTime());

    }

    /**
     * @internal Gets the offset to UTC based on this group's transitions.
     * 
     * @returns {TimeZoneTransitionGroup.CustomTimeZoneCreateParams}  
     */
    GetCustomTimeZoneCreationParams(): TimeZoneTransitionGroup.CustomTimeZoneCreateParams {
        let result: TimeZoneTransitionGroup.CustomTimeZoneCreateParams = new TimeZoneTransitionGroup.CustomTimeZoneCreateParams();

        if (this.TransitionToDaylight != null) {
            result.DaylightDisplayName = this.TransitionToDaylight.TargetPeriod.Name;
        }

        result.StandardDisplayName = this.TransitionToStandard.TargetPeriod.Name;

        // Assume that the standard period's offset is the base offset to UTC.
        // EWS returns a positive offset for time zones that are behind UTC, and
        // a negative one for time zones ahead of UTC. TimeZoneInfo does it the other
        // way around.
        result.BaseOffsetToUtc = new TimeSpan(-this.TransitionToStandard.TargetPeriod.Bias);

        return result;

    }


    /**
     * @internal Gets the delta offset for the daylight.
     * 
     * @returns {TimeSpan}  
     */
    GetDaylightDelta(): TimeSpan {
        if (this.SupportsDaylight) {
            // EWS returns a positive offset for time zones that are behind UTC, and
            // a negative one for time zones ahead of UTC. TimeZoneInfo does it the other
            // way around.
            return this.TransitionToStandard.TargetPeriod.Bias.Subtract(this.TransitionToDaylight.TargetPeriod.Bias);
        }
        else {
            return TimeSpan.Zero;
        }
    }

    /**
     * Initializes this transition group based on the specified asjustment rule.
     *
     * @param   {TimeZoneInfo.AdjustmentRule}   adjustmentRule   The adjustment rule to initialize from.
     * @param   {TimeZonePeriod}                standardPeriod   A reference to the pre-created standard period.
     */
    InitializeFromAdjustmentRule(adjustmentRule: TimeZoneInfo.AdjustmentRule, standardPeriod: TimeZonePeriod): void {
        let daylightPeriod: TimeZonePeriod = new TimeZonePeriod();

        // Generate an Id of the form "Daylight/2008"
        daylightPeriod.Id = StringHelper.Format(
            "{0}/{1}",
            TimeZonePeriod.DaylightPeriodId,
            adjustmentRule.DateStart.Year);
        daylightPeriod.Name = TimeZonePeriod.DaylightPeriodName;
        daylightPeriod.Bias = new TimeSpan(standardPeriod.Bias.TotalMilliseconds - adjustmentRule.DaylightDelta.TotalMilliseconds);

        this.timeZoneDefinition.Periods.Add(daylightPeriod.Id, daylightPeriod);

        this.transitionToDaylight = TimeZoneTransition.CreateTimeZoneTransition(
            this.timeZoneDefinition,
            daylightPeriod,
            adjustmentRule.DaylightTransitionStart);

        let standardPeriodToSet: TimeZonePeriod = new TimeZonePeriod();
        standardPeriodToSet.Id = StringHelper.Format(
            "{0}/{1}",
            standardPeriod.Id,
            adjustmentRule.DateStart.Year);
        standardPeriodToSet.Name = standardPeriod.Name;
        standardPeriodToSet.Bias = standardPeriod.Bias;
        this.timeZoneDefinition.Periods.Add(standardPeriodToSet.Id, standardPeriodToSet);

        this.transitionToStandard = TimeZoneTransition.CreateTimeZoneTransition(
            this.timeZoneDefinition,
            standardPeriodToSet,
            adjustmentRule.DaylightTransitionEnd);

        this.transitions.push(this.transitionToDaylight);
        this.transitions.push(this.transitionToStandard);
    }

    /**
     * Initializes the private members holding references to the transitions to the Daylight and Standard periods.
     */
    private InitializeTransitions(): void {
        if (this.transitionToStandard == null) {
            for (let transition of this.transitions) {
                if (transition.TargetPeriod.IsStandardPeriod || (this.transitions.length == 1)) {
                    this.transitionToStandard = transition;
                }
                else {
                    this.transitionToDaylight = transition;
                }
            }
        }

        // If we didn't find a Standard period, this is an invalid time zone group.
        if (this.transitionToStandard == null) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        if (jsObject[XmlElementNames.Id]) {
            this.Id = jsObject[XmlElementNames.Id];
        }

        for (let key in jsObject) {
            if (TimeZoneTransitionGroup.transitionTypes.indexOf(key) >= 0) {
                let transitions: string[] = EwsServiceJsonReader.ReadAsArray(jsObject, key);
                for (let item of transitions) {
                    let transition: TimeZoneTransition = TimeZoneTransition.Create(this.timeZoneDefinition, key);
                    transition.LoadFromXmlJsObject(item, service);
                    this.transitions.push(transition);
                }
            }
        }
    }

    /**
     * @internal Validates this transition group.
     */
    Validate(): void {
        // There must be exactly one or two transitions in the group.
        if (this.transitions.length < 1 || this.transitions.length > 2) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }

        // If there is only one transition, it must be of type TimeZoneTransition
        if (this.transitions.length == 1 && !(this.transitions[0] instanceof TimeZoneTransition)) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }

        // If there are two transitions, none of them should be of type TimeZoneTransition
        if (this.transitions.length == 2) {
            for (let transition of this.transitions) {
                try {
                    let type = (<any>transition.constructor).name;
                    //if (transition instanceof TimeZoneTransition) { // ref:  can not use due to prototype chain issue
                    if (type === "TimeZoneTransition") {
                        throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
                    }
                } catch (error) {

                }

            }
        }

        // All the transitions in the group must be to a period.
        for (let transition of this.transitions) {
            if (transition.TargetPeriod == null) {
                throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
            }
        }
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.Id);
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        for (let transition of this.transitions) {
            transition.WriteToXml(writer);
        }
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        super.WriteToXml(writer, XmlElementNames.TransitionsGroup);
    }
}

export module TimeZoneTransitionGroup {
    /**
     * @internal Represents custom time zone creation parameters.
     */
    export class CustomTimeZoneCreateParams {
        private baseOffsetToUtc: TimeSpan = null;
        private standardDisplayName: string = null;
        private daylightDisplayName: string = null;

        /**
         * @internal Gets or sets the base offset to UTC.
         */
        get BaseOffsetToUtc(): TimeSpan {
            return this.baseOffsetToUtc;
        }
        set BaseOffsetToUtc(value) {
            this.baseOffsetToUtc = value;
        }

        /**
         * @internal Gets or sets the display name of the standard period.
         */
        get StandardDisplayName(): string {
            return this.standardDisplayName;
        }
        set StandardDisplayName(value: string) {
            this.standardDisplayName = value;
        }

        /**
         * @internal Gets or sets the display name of the daylight period.
         */
        get DaylightDisplayName(): string {
            return this.daylightDisplayName;
        }
        set DaylightDisplayName(value: string) {
            this.daylightDisplayName = value;
        }

        /**
         * @internal Gets a value indicating whether the custom time zone should have a daylight period.
         * 
         * @value   *true* if the custom time zone should have a daylight period; otherwise, *false*.
         */
        get HasDaylightPeriod(): boolean {
            return !StringHelper.IsNullOrEmpty(this.daylightDisplayName);
        }

        /**
         * @internal Initializes a new instance of the **CustomTimeZoneCreateParams** class.
         */
        constructor() {
        }
    }
}
TypeContainer.AbsoluteDateTransition = AbsoluteDateTransition;
TypeContainer.AbsoluteDayOfMonthTransition = AbsoluteDayOfMonthTransition;
TypeContainer.RelativeDayOfMonthTransition = RelativeDayOfMonthTransition;
// TimeZoneTransition.AbsoluteDateTransition = (timeZoneDefinition: TimeZoneDefinition) => {
//     return new AbsoluteDateTransition(timeZoneDefinition);
// }
// TimeZoneTransition.AbsoluteDayOfMonthTransition = (timeZoneDefinition: TimeZoneDefinition, targetPeriod?: TimeZonePeriod) => {
//     return new AbsoluteDayOfMonthTransition(timeZoneDefinition, targetPeriod);
// }
// TimeZoneTransition.RelativeDayOfMonthTransition = (timeZoneDefinition: TimeZoneDefinition, targetPeriod?: TimeZonePeriod) => {
//     return new RelativeDayOfMonthTransition(timeZoneDefinition, targetPeriod);
// }
export class ApprovalRequestData extends ComplexProperty {
    IsUndecidedApprovalRequest: boolean;
    ApprovalDecision: number;
    ApprovalDecisionMaker: string;
    ApprovalDecisionTime: Date;
    private isUndecidedApprovalRequest: boolean;
    private approvalDecision: number;
    private approvalDecisionMaker: string;
    private approvalDecisionTime: Date;
    LoadFromJson(jsonProperty: JsonObject, service: ExchangeService): any { throw new Error("ApprovalRequestData.ts - LoadFromJson : Not implemented."); }
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): boolean { throw new Error("ApprovalRequestData.ts - TryReadElementFromXmlJsObject : Not implemented."); }
}

export class ByteArrayArray extends ComplexProperty {
    private static ItemXmlElementName: string = "Base64Binary";
    //ref: bytearray not implemented here, storing base64 value instead
    private content: string[] = [];// System.Byte[][];//System.Collections.Generic.List<T>;
    get Content(): string[] {// System.Byte[][];
        return this.content;
    }

    InternalToJson(service: ExchangeService): any { throw new Error("ByteArrayArray.ts - InternalToJson : Not implemented."); }
    LoadFromXmlJsObject(jsonCollection: any, serviceExchangeService): void {
        if (jsonCollection !== null && jsonCollection[ByteArrayArray.ItemXmlElementName]) {
            var binarydata: any[] = EwsServiceJsonReader.ReadAsArray(jsonCollection, ByteArrayArray.ItemXmlElementName);
            for (var blob of binarydata) {
                this.content.push(blob);//ref: storing original base64 content //EwsServiceJsonReader.ReadBase64ElementValue(blob));
            }
        }

    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        for (var item of this.content) {
            writer.WriteStartElement(XmlNamespace.Types, ByteArrayArray.ItemXmlElementName);
            writer.WriteValue(item, null);
            //writer.WriteBase64ElementValue(item);
            writer.WriteEndElement();
        }
    }
}



/**
 * Encapsulates information on the changehighlights of a meeting request.
 * 
 * @sealed
 */
export class ChangeHighlights extends ComplexProperty {

    private hasLocationChanged: boolean = false;
    private location: string = null;
    private hasStartTimeChanged: boolean = false;
    private start: DateTime = null;
    private hasEndTimeChanged: boolean = false;
    private end: DateTime = null;

    /**
     * Gets a value indicating whether the location has changed.
     */
    get HasLocationChanged(): boolean {
        return this.hasLocationChanged;
    }

    /**
     * Gets the old location
     */
    get Location(): string {
        return this.location;
    }

    /**
     * Gets a value indicating whether the the start time has changed.
     */
    get HasStartTimeChanged(): boolean {
        return this.hasStartTimeChanged;
    }

    /**
     * Gets the old start date and time of the meeting.
     */
    get Start(): DateTime {
        return this.start;
    }

    /**
     * Gets a value indicating whether the the end time has changed.
     */
    get HasEndTimeChanged(): boolean {
        return this.hasEndTimeChanged;
    }

    /**
     * Gets the old end date and time of the meeting.
     */
    get End(): DateTime {
        return this.end;
    }

    /**
     * @internal Initializes a new instance of the **ChangeHighlights** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.HasLocationChanged:
                    this.hasLocationChanged = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Location:
                    this.location = jsObject[key];
                    break;
                case XmlElementNames.HasStartTimeChanged:
                    this.hasStartTimeChanged = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Start:
                    this.start = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.HasEndTimeChanged:
                    this.hasEndTimeChanged = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.End:
                    this.end = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents a client token access request
 */
export class ClientAccessTokenRequest extends ComplexProperty {

    private id: string;
    private tokenType: ClientAccessTokenType;
    private scope: string;

    /**
     * Gets the App Id.
     */
    get Id(): string {
        return this.id;
    }

    /**
     * Gets token type.
     */
    get TokenType(): ClientAccessTokenType {
        return this.tokenType;
    }

    /**
     * Gets the token scope.
     */
    get Scope(): string {
        return this.scope;
    }

    /**
     * Initializes a new instance of the **ClientAccessTokenRequest** class.
     *
     * @param   {string}                    id          id
     * @param   {ClientAccessTokenType}     tokenType   The tokenType.
     * @param   {string}                    scope       The scope.
     */
    constructor(id: string, tokenType: ClientAccessTokenType);
    /**
     * Initializes a new instance of the **ClientAccessTokenRequest** class.
     *
     * @param   {string}                    id          id
     * @param   {ClientAccessTokenType}     tokenType   The tokenType.
     * @param   {string}                    scope       The scope.
     */
    constructor(id: string, tokenType: ClientAccessTokenType, scope: string);
    constructor(id: string = null, tokenType: ClientAccessTokenType = ClientAccessTokenType.CallerIdentity, scope: string = null) {
        super();
        this.id = id;
        this.tokenType = tokenType;
        this.scope = scope;
    }
}

/**
 * Represents a app in GetAppManifests response.
 * 
 * @sealed
 */
export class ClientApp extends ComplexProperty {

    /**
     * The manifest for the app.
     * 
     * internal set
     */
    Manifest: string;// System.Xml.XmlDocument; // base64 data from xml document

    /**
     * Metadata related to the app.
     * 
     * internal set
     */
    Metadata: ClientAppMetadata;

    /**
     * Initializes a new instance of the **ClientApp** class.
     */
    constructor() {
        super();
        this.Namespace = XmlNamespace.Types;
    }

    //ReadToXmlDocument(reader: EwsServiceXmlReader): any { throw new Error("ClientApp.ts - ReadToXmlDocument : Not implemented."); } //not needed.

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        if (jsObject[XmlElementNames.Manifest]) {
            this.Manifest = jsObject[XmlElementNames.Manifest];
        }
        if (jsObject[XmlElementNames.Metadata]) {
            this.Metadata = new ClientAppMetadata();
            this.Metadata.LoadFromXmlJsObject(jsObject[XmlElementNames.Metadata], service);
        }
    }
}

/**
 * Represents a ClientAppMetadata object.
 * 
 * @sealed
 */
export class ClientAppMetadata extends ComplexProperty {

    /**
     * The End node url for the app.
     * 
     * @private set
     */
    EndNodeUrl: string;

    /**
     * The action url for the app.
     * 
     * @private set
     */
    ActionUrl: string;

    /**
     * The app status for the app.
     * 
     * @private set
     */
    AppStatus: string;

    /**
     * Initializes a new instance of the **ClientAppMetadata** class.
     */
    constructor() {
        super();
        this.Namespace = XmlNamespace.Types;
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.EndNodeUrl:
                    this.EndNodeUrl = <string>jsObject[key];
                    break;
                case XmlElementNames.ActionUrl:
                    this.ActionUrl = <string>jsObject[key];
                    break;
                case XmlElementNames.AppStatus:
                    this.AppStatus = <string>jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }
}

export class ClientExtension extends ComplexProperty {
    Type: ExtensionType;
    Scope: ExtensionInstallScope;
    ManifestStream: any;// System.IO.Stream;
    MarketplaceAssetID: string;
    MarketplaceContentMarket: string;
    AppStatus: string;
    Etoken: string;
    IsAvailable: boolean;
    IsMandatory: boolean;
    IsEnabledByDefault: boolean;
    ProvidedTo: ClientExtensionProvidedTo;
    SpecificUsers: StringList;
    /**@internal */
    ReadAttributesFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("ClientExtension.ts - ReadAttributesFromXml : Not implemented."); }
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): boolean { throw new Error("ClientExtension.ts - TryReadElementFromXmlJsObject : Not implemented."); }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): any { throw new Error("ClientExtension.ts - WriteAttributesToXml : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("ClientExtension.ts - WriteElementsToXml : Not implemented."); }
}


/**
 * Represents the complete name of a contact.
 */
export class CompleteName extends ComplexProperty {

    private title: string = null;
    private givenName: string = null;
    private middleName: string = null;
    private surname: string = null;
    private suffix: string = null;
    private initials: string = null;
    private fullName: string = null;
    private nickname: string = null;
    private yomiGivenName: string = null;
    private yomiSurname: string = null;

    /**
     * Gets the contact's title.
     */
    get Title(): string {
        return this.title;
    }

    /**
     * Gets the given name (first name) of the contact.
     */
    get GivenName(): string {
        return this.givenName;
    }

    /**
     * Gets the middle name of the contact.
     */
    get MiddleName(): string {
        return this.middleName;
    }

    /**
     * Gets the surname (last name) of the contact.
     */
    get Surname(): string {
        return this.surname;
    }

    /**
     * Gets the suffix of the contact.
     */
    get Suffix(): string {
        return this.suffix;
    }

    /**
     * Gets the initials of the contact.
     */
    get Initials(): string {
        return this.initials;
    }

    /**
     * Gets the full name of the contact.
     */
    get FullName(): string {
        return this.fullName;
    }

    /**
     * Gets the nickname of the contact.
     */
    get NickName(): string {
        return this.nickname;
    }

    /**
     * Gets the Yomi given name (first name) of the contact.
     */
    get YomiGivenName(): string {
        return this.yomiGivenName;
    }

    /**
     * Gets the Yomi surname (last name) of the contact.
     */
    get YomiSurname(): string {
        return this.yomiSurname;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.Title:
                    this.title = jsObject[key];
                    break;
                case XmlElementNames.FirstName:
                    this.givenName = jsObject[key];
                    break;
                case XmlElementNames.MiddleName:
                    this.middleName = jsObject[key];
                    break;
                case XmlElementNames.LastName:
                    this.surname = jsObject[key];
                    break;
                case XmlElementNames.Suffix:
                    this.suffix = jsObject[key];
                    break;
                case XmlElementNames.Initials:
                    this.initials = jsObject[key];
                    break;
                case XmlElementNames.FullName:
                    this.fullName = jsObject[key];
                    break;
                case XmlElementNames.NickName:
                    this.nickname = jsObject[key];
                    break;
                case XmlElementNames.YomiFirstName:
                    this.yomiGivenName = jsObject[key];
                    break;
                case XmlElementNames.YomiLastName:
                    this.yomiSurname = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Writes elements to XML.
     * 
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Title, this.Title);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FirstName, this.GivenName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MiddleName, this.MiddleName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LastName, this.Surname);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Suffix, this.Suffix);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Initials, this.Initials);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FullName, this.FullName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.NickName, this.NickName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.YomiFirstName, this.YomiGivenName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.YomiLastName, this.YomiSurname);
    }
}


/**
 * Represents an ContactPhoneEntity object.
 */
export class ContactPhoneEntity extends ComplexProperty {

    /**
     * Gets the phone entity OriginalPhoneString.
     */
    OriginalPhoneString: string = null;

    /**
     * Gets the phone entity PhoneString.
     */
    PhoneString: string = null;

    /**
     * Gets the phone entity Type.
     */
    Type: string = null;

    /**
     * Initializes a new instance of the **ContactPhoneEntity** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgOriginalPhoneString:
                    this.OriginalPhoneString = jsObject[key];
                    break;
                case XmlElementNames.NlgPhoneString:
                    this.PhoneString = jsObject[key];
                    break;
                case XmlElementNames.NlgType:
                    this.Type = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents the response to a GetConversationItems operation.
 * 
 * @sealed
 */
export class ConversationNode extends ComplexProperty {

    private propertySet: PropertySet = null;

    /**
     * Gets or sets the Internet message id of the node.
     */
    InternetMessageId: string = null;

    /**
     * Gets or sets the Internet message id of the parent node.
     */
    ParentInternetMessageId: string = null;

    /**
     * Gets or sets the items.
     */
    Items: Item[];

    /**
     * @internal Initializes a new instance of the **ConversationNode** class.
     *
     * @param   {PropertySet}   propertySet   The property set.
     */
    constructor(propertySet: PropertySet) {
        super();
        this.propertySet = propertySet;
    }

    /**
     * Gets the item instance.
     *
     * @param   {ExchangeService}   service          The service.
     * @param   {string}            xmlElementName   Name of the XML element.
     * @return  {Item}              Item.
     */
    private GetObjectInstance(service: ExchangeService, xmlElementName: string): Item {
        return (new ItemInfo()).CreateEwsObjectFromXmlElementName<Item>(service, xmlElementName);
    }

    /**
     * @internal Obtains EWS XML element name for this object.
     *
     * @return  {string}      The XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.ConversationNode;
    }

    /**
     * @internal Loads from XMLjsObject.
     *
     * @param   {any}               jsObject   The json property.
     * @param   {ExchangeService}   service        [description]
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        this.InternetMessageId = jsObject[XmlElementNames.InternetMessageId];

        if (jsObject[XmlElementNames.ParentInternetMessageId]) {
            this.ParentInternetMessageId = jsObject[XmlElementNames.ParentInternetMessageId];
        }

        if (jsObject[XmlElementNames.Items]) {

            this.Items = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Item>(
                jsObject,
                service,
                XmlElementNames.Items,
                this.GetObjectInstance.bind(this),
                false,              /* clearPropertyBag */
                this.propertySet,   /* requestedPropertySet */
                false);             /* summaryPropertiesOnly */
        }
    }
}

/**
 * 
 * 
 * @sealed
 */
export class ConversationRequest extends ComplexProperty implements ISelfValidate {

    /**
     * Gets or sets the conversation id.
     */
    ConversationId: ConversationId;

    /**
     * Gets or sets the sync state representing the current state of the conversation for synchronization purposes.
     */
    SyncState: string;

    /**
     * Initializes a new instance of the **ConversationRequest** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **ConversationRequest** class.
     *
     * @param   {ConversationId}    conversationId   The conversation id.
     * @param   {string}            syncState        State of the sync.
     */
    constructor(conversationId: ConversationId, syncState: string);
    constructor(conversationId: ConversationId = null, syncState: string = null) {
        super();
        this.ConversationId = conversationId;
        this.SyncState = syncState;
    }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        EwsUtilities.ValidateParam(this.ConversationId, "ConversationId");
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void {
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);

        this.ConversationId.WriteToXml(writer);

        if (this.SyncState != null) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SyncState, this.SyncState);
        }

        writer.WriteEndElement();
    }
}

/**
 * 
 * 
 * @sealed
 */
export class ConversationResponse extends ComplexProperty {

    /**
     * Property set used to fetch items in the conversation.
     */
    private propertySet: PropertySet = null;

    /**
     * Gets the conversation id.
     * 
     * internal set
     */
    ConversationId: ConversationId = null;

    /**
     * Gets the sync state.
     * 
     * internal set
     */
    SyncState: string = null;

    /**
     * Gets the conversation nodes.
     * 
     * internal set
     */
    ConversationNodes: ConversationNodeCollection = null;

    /**
     * @internal Initializes a new instance of the **ConversationResponse** class.
     *
     * @param   {PropertySet}   propertySet   The property set.
     */
    constructor(propertySet: PropertySet) {
        super();
        this.propertySet = propertySet;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {

        this.ConversationId = new ConversationId();
        this.ConversationId.LoadFromXmlJsObject(jsObject[XmlElementNames.ConversationId], service);

        if (jsObject[XmlElementNames.SyncState]) {
            this.SyncState = jsObject[XmlElementNames.SyncState];
        }

        this.ConversationNodes = new ConversationNodeCollection(this.propertySet);
        if (jsObject[XmlElementNames.ConversationNodes]) {

            this.ConversationNodes.LoadFromXmlJsObject(
                EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.ConversationNodes], XmlElementNames.ConversationNode),
                service);
        }
    }
}

/**
 * Represents the permissions of a delegate user.
 * 
 * @sealed
 */
export class DelegatePermissions extends ComplexProperty {

    private delegateFolderPermissions: Dictionary<string, DelegateFolderPermission> = null;

    /**
     * Gets or sets the delegate user's permission on the principal's calendar.
     */
    get CalendarFolderPermissionLevel(): DelegateFolderPermissionLevel {
        return this.delegateFolderPermissions.get(XmlElementNames.CalendarFolderPermissionLevel).PermissionLevel;
    }
    set CalendarFolderPermissionLevel(value: DelegateFolderPermissionLevel) {
        this.delegateFolderPermissions.get(XmlElementNames.CalendarFolderPermissionLevel).PermissionLevel = value;
    }

    /**
     * Gets or sets the delegate user's permission on the principal's tasks folder.
     */
    get TasksFolderPermissionLevel(): DelegateFolderPermissionLevel {
        return this.delegateFolderPermissions.get(XmlElementNames.TasksFolderPermissionLevel).PermissionLevel;
    }
    set TasksFolderPermissionLevel(value: DelegateFolderPermissionLevel) {
        this.delegateFolderPermissions.get(XmlElementNames.TasksFolderPermissionLevel).PermissionLevel = value;
    }

    /**
     * Gets or sets the delegate user's permission on the principal's inbox.
     */
    get InboxFolderPermissionLevel(): DelegateFolderPermissionLevel {
        return this.delegateFolderPermissions.get(XmlElementNames.InboxFolderPermissionLevel).PermissionLevel;
    }
    set InboxFolderPermissionLevel(value: DelegateFolderPermissionLevel) {
        this.delegateFolderPermissions.get(XmlElementNames.InboxFolderPermissionLevel).PermissionLevel = value;
    }

    /**
     * Gets or sets the delegate user's permission on the principal's contacts folder.
     */
    get ContactsFolderPermissionLevel(): DelegateFolderPermissionLevel {
        return this.delegateFolderPermissions.get(XmlElementNames.ContactsFolderPermissionLevel).PermissionLevel;
    }
    set ContactsFolderPermissionLevel(value: DelegateFolderPermissionLevel) {
        this.delegateFolderPermissions.get(XmlElementNames.ContactsFolderPermissionLevel).PermissionLevel = value;
    }

    /**
     * Gets or sets the delegate user's permission on the principal's notes folder.
     */
    get NotesFolderPermissionLevel(): DelegateFolderPermissionLevel {
        return this.delegateFolderPermissions.get(XmlElementNames.NotesFolderPermissionLevel).PermissionLevel;
    }
    set NotesFolderPermissionLevel(value: DelegateFolderPermissionLevel) {
        this.delegateFolderPermissions.get(XmlElementNames.NotesFolderPermissionLevel).PermissionLevel = value;
    }

    /**
     * Gets or sets the delegate user's permission on the principal's journal folder.
     */
    get JournalFolderPermissionLevel(): DelegateFolderPermissionLevel {
        return this.delegateFolderPermissions.get(XmlElementNames.JournalFolderPermissionLevel).PermissionLevel;
    }
    set JournalFolderPermissionLevel(value: DelegateFolderPermissionLevel) {
        this.delegateFolderPermissions.get(XmlElementNames.JournalFolderPermissionLevel).PermissionLevel = value;
    }

    /**
     * @internal Initializes a new instance of the **DelegatePermissions** class.
     */
    constructor() {
        super();
        var dictionary: Dictionary<string, DelegateFolderPermission> = new DictionaryWithStringKey<DelegateFolderPermission>();
        dictionary.Add(XmlElementNames.CalendarFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.TasksFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.InboxFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.ContactsFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.NotesFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.JournalFolderPermissionLevel, new DelegateFolderPermission());
        this.delegateFolderPermissions = dictionary;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            let delegateFolderPermission: DelegateFolderPermission = null;

            if (this.delegateFolderPermissions.containsKey(key)) {
                delegateFolderPermission = this.delegateFolderPermissions.get(key);
                delegateFolderPermission.Initialize(DelegateFolderPermissionLevel[<string>jsObject[key]]);
            }
        }
    }

    /**
     * @internal Resets this instance.
     */
    Reset(): void {
        for (let delegateFolderPermission of this.delegateFolderPermissions.Values) {
            delegateFolderPermission.Reset();
        }
    }

    /**
     * @internal Validates this instance for AddDelegate.
     */
    ValidateAddDelegate(): void {
        // If any folder permission is Custom, throw
        //
        this.delegateFolderPermissions.Values.forEach(permission => {
            if (permission.PermissionLevel == DelegateFolderPermissionLevel.Custom) {
                throw new ServiceValidationException(Strings.CannotSetDelegateFolderPermissionLevelToCustom);
            }
        });
    }

    /**
     * @internal Validates this instance for UpdateDelegate.
     */
    ValidateUpdateDelegate(): void {
        // If any folder permission was changed to custom, throw
        //
        this.delegateFolderPermissions.Values.forEach(permission => {
            if (permission.PermissionLevel == DelegateFolderPermissionLevel.Custom && !permission.IsExistingPermissionLevelCustom) {
                throw new ServiceValidationException(Strings.CannotSetDelegateFolderPermissionLevelToCustom);
            }
        });
    }

    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.WritePermissionToXml(
            writer,
            XmlElementNames.CalendarFolderPermissionLevel);

        this.WritePermissionToXml(
            writer,
            XmlElementNames.TasksFolderPermissionLevel);

        this.WritePermissionToXml(
            writer,
            XmlElementNames.InboxFolderPermissionLevel);

        this.WritePermissionToXml(
            writer,
            XmlElementNames.ContactsFolderPermissionLevel);

        this.WritePermissionToXml(
            writer,
            XmlElementNames.NotesFolderPermissionLevel);

        this.WritePermissionToXml(
            writer,
            XmlElementNames.JournalFolderPermissionLevel);
    }

    /**
     * Write permission to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   The element name.
     */
    private WritePermissionToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void {
        let delegateFolderPermissionLevel: DelegateFolderPermissionLevel = this.delegateFolderPermissions.get(xmlElementName).PermissionLevel;

        // UpdateDelegate fails if Custom permission level is round tripped
        //
        if (delegateFolderPermissionLevel != DelegateFolderPermissionLevel.Custom) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                xmlElementName,
                DelegateFolderPermissionLevel[delegateFolderPermissionLevel]);
        }
    }
}

/**
 * @internal Represents a folder's DelegateFolderPermissionLevel
 */
class DelegateFolderPermission {

    /**
     * @internal Gets or sets the delegate user's permission on a principal's folder.
     */
    PermissionLevel: DelegateFolderPermissionLevel = DelegateFolderPermissionLevel.None;

    /**
     * @internal Gets IsExistingPermissionLevelCustom.
     */
    IsExistingPermissionLevelCustom: boolean = false;

    /**
     * Intializes this DelegateFolderPermission.
     *
     * @param   {DelegateFolderPermissionLevel}   permissionLevel   The DelegateFolderPermissionLevel
     */
    Initialize(permissionLevel: DelegateFolderPermissionLevel): void {
        this.PermissionLevel = permissionLevel;
        this.IsExistingPermissionLevelCustom = (permissionLevel === DelegateFolderPermissionLevel.Custom);
    }

    /**
     * @internal Resets this DelegateFolderPermission.
     */
    Reset(): void {
        this.Initialize(DelegateFolderPermissionLevel.None);
    }
}

/**
 * Represents a delegate user.
 * 
 * @sealed
 */
export class DelegateUser extends ComplexProperty {

    private userId: UserId = new UserId();
    private permissions: DelegatePermissions = new DelegatePermissions();
    private receiveCopiesOfMeetingMessages: boolean = false;
    private viewPrivateItems: boolean = false;

    /**
     * Gets the user Id of the delegate user.
     */
    get UserId(): UserId {
        return this.userId;
    }

    /**
     * Gets the list of delegate user's permissions.
     */
    get Permissions(): DelegatePermissions {
        return this.permissions;
    }

    /**
     * Gets or sets a value indicating if the delegate user should receive copies of meeting requests.
     */
    get ReceiveCopiesOfMeetingMessages(): boolean {
        return this.receiveCopiesOfMeetingMessages;
    }
    set ReceiveCopiesOfMeetingMessages(value: boolean) {
        this.receiveCopiesOfMeetingMessages = value;
    }

    /**
     * Gets or sets a value indicating if the delegate user should be able to view the principal's private items.
     */
    get ViewPrivateItems(): boolean {
        return this.viewPrivateItems;
    }
    set ViewPrivateItems(value: boolean) {
        this.viewPrivateItems = value;
    }

    /**
     * Initializes a new instance of the **DelegateUser** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **DelegateUser** class.
     *
     * @param   {string}   primarySmtpAddress   The primary SMTP address of the delegate user.
     */
    constructor(primarySmtpAddress: string);
    /**
     * Initializes a new instance of the **DelegateUser** class.
     *
     * @param   {StandardUser}   standardUser   The standard delegate user.
     */
    constructor(standardUser: StandardUser);
    constructor(primarySmtpAddressOrStandardUser?: string | StandardUser) {
        super();

        // Confusing error message refers to Calendar folder permissions when adding delegate access for a user
        // without including Calendar Folder permissions.
        //
        this.receiveCopiesOfMeetingMessages = false;
        this.viewPrivateItems = false;

        if (typeof primarySmtpAddressOrStandardUser === 'string') {
            this.userId.PrimarySmtpAddress = primarySmtpAddressOrStandardUser;
        }
        else {
            this.userId.StandardUser = primarySmtpAddressOrStandardUser;
        }
    }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        if (this.UserId == null) {
            throw new ServiceValidationException(Strings.UserIdForDelegateUserNotSpecified);
        }
        else if (!this.UserId.IsValid()) {
            throw new ServiceValidationException(Strings.DelegateUserHasInvalidUserId);
        }
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.UserId:
                    this.userId = new UserId();
                    this.userId.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.DelegatePermissions:
                    this.permissions.Reset();
                    this.permissions.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ReceiveCopiesOfMeetingMessages:
                    this.receiveCopiesOfMeetingMessages = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.ViewPrivateItems:
                    this.viewPrivateItems = Convert.toBool(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Validates this instance for AddDelegate.
     */
    ValidateAddDelegate(): void {
        this.permissions.ValidateAddDelegate();
    }

    /**
     * @internal Validates this instance for UpdateDelegate.
     */
    ValidateUpdateDelegate(): void {
        this.permissions.ValidateUpdateDelegate();
    }

    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.UserId.WriteToXml(writer, XmlElementNames.UserId);
        this.Permissions.WriteToXml(writer, XmlElementNames.DelegatePermissions);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.ReceiveCopiesOfMeetingMessages,
            this.ReceiveCopiesOfMeetingMessages);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.ViewPrivateItems,
            this.ViewPrivateItems);
    }
}

/**
 * Encapsulates information on the deleted occurrence of a recurring appointment.
 */
export class DeletedOccurrenceInfo extends ComplexProperty {

    /**
     * The original start date and time of the deleted occurrence.
     *
     * /remarks/    The EWS schema contains a Start property for deleted occurrences but it's really the original start date and time of the occurrence.
     */
    private originalStart: DateTime = null;

    /**
     * Gets the original start date and time of the deleted occurrence.
     */
    get OriginalStart(): DateTime {
        return this.originalStart;
    }

    /**
     * @internal Initializes a new instance of the **DeletedOccurrenceInfo** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        if (jsObject[XmlElementNames.Start]) {
            this.originalStart = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[XmlElementNames.Start]);
        }
    }
}

/**
 * Represents an EmailUserEntity object.
 */
export class EmailUserEntity extends ComplexProperty {

    /**
     * Gets the EmailUser entity Name.
     */
    Name: string;

    /**
     * Gets the EmailUser entity UserId.
     */
    UserId: string;

    /**
     * Initializes a new instance of the **EmailUserEntity** class.
     */
    constructor() {
        super();
        this.Namespace = XmlNamespace.Types;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgName:
                    this.Name = jsObject[key]
                    break;
                case XmlElementNames.NlgUserId:
                    this.UserId = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents Enhanced Location.
 */
export class EnhancedLocation extends ComplexProperty {

    private displayName: string = null;
    private annotation: string = null;
    private personaPostalAddress: PersonaPostalAddress = null;

    /**
     * Gets or sets the Location DisplayName.
     */
    get DisplayName(): string {
        return this.displayName;
    }
    set DisplayName(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.displayName, setValue: (fieldValue) => { this.displayName = fieldValue } }, value);
    }

    /**
     * Gets or sets the Location Annotation.
     */
    get Annotation(): string {
        return this.annotation;
    }
    set Annotation(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.annotation, setValue: (fieldValue) => { this.annotation = fieldValue } }, value);
    }

    /**
     * Gets or sets the Persona Postal Address.
     */
    get PersonaPostalAddress(): PersonaPostalAddress {
        return this.personaPostalAddress;
    }
    set PersonaPostalAddress(value: PersonaPostalAddress) {
        if (this.personaPostalAddress !== value) {
            if (this.personaPostalAddress !== null) {
                ArrayHelper.RemoveEntry(this.personaPostalAddress.OnChange, this.PersonaPostalAddress_OnChange);
            }

            this.SetFieldValue<PersonaPostalAddress>({ getValue: () => this.personaPostalAddress, setValue: (fieldValue) => { this.personaPostalAddress = fieldValue } }, value);

            this.personaPostalAddress.OnChange.push(this.PersonaPostalAddress_OnChange.bind(this));
        }
    }

    /**
     * @internal Initializes a new instance of the **EnhancedLocation** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **EnhancedLocation** class.
     *
     * @param   {string}   displayName            The location DisplayName.
     */
    constructor(displayName: string);
    /**
     * Initializes a new instance of the **EnhancedLocation** class.
     *
     * @param   {string}   displayName            The location DisplayName.
     * @param   {string}   annotation             The annotation on the location.
     */
    constructor(displayName: string, annotation: string);
    /**
     * Initializes a new instance of the **EnhancedLocation** class.
     *
     * @param   {string}                displayName            The location DisplayName.
     * @param   {string}                annotation             The annotation on the location.
     * @param   {PersonaPostalAddress}  personaPostalAddress   The persona postal address.
     */
    constructor(displayName: string, annotation: string, personaPostalAddress: PersonaPostalAddress);
    constructor(displayName?: string, annotation: string = StringHelper.Empty, personaPostalAddress: PersonaPostalAddress = new PersonaPostalAddress()) {
        super();

        this.displayName = displayName;
        this.annotation = annotation;
        this.personaPostalAddress = personaPostalAddress;
        this.personaPostalAddress.OnChange.push(this.PersonaPostalAddress_OnChange.bind(this));
    }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        super.InternalValidate();
        EwsUtilities.ValidateParam(this.displayName, "DisplayName");
        EwsUtilities.ValidateParamAllowNull(this.annotation, "Annotation");
        EwsUtilities.ValidateParamAllowNull(this.personaPostalAddress, "PersonaPostalAddress");
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.LocationDisplayName:
                    this.displayName = jsObject[key];
                    break;
                case XmlElementNames.LocationAnnotation:
                    this.annotation = jsObject[key];
                    break;
                case XmlElementNames.PersonaPostalAddress:
                    this.personaPostalAddress = new PersonaPostalAddress();
                    this.personaPostalAddress.LoadFromXmlJsObject(jsObject[key], service);
                    this.personaPostalAddress.OnChange.push(this.PersonaPostalAddress_OnChange.bind(this));
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * PersonaPostalAddress OnChange.
     *
     * @param   {ComplexProperty}   complexProperty   ComplexProperty object.
     */
    private PersonaPostalAddress_OnChange(complexProperty: ComplexProperty): void { this.Changed(); }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LocationDisplayName, this.displayName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LocationAnnotation, this.annotation);
        this.personaPostalAddress.WriteToXml(writer);
    }
}

/**
 * Represents an EntityExtractionResult object.
 */
export class EntityExtractionResult extends ComplexProperty {

    /**
     * Gets the extracted Addresses.
     */
    Addresses: AddressEntityCollection = null;

    /**
     * Gets the extracted MeetingSuggestions.
     */
    MeetingSuggestions: MeetingSuggestionCollection = null;

    /**
     * Gets the extracted TaskSuggestions.
     */
    TaskSuggestions: TaskSuggestionCollection = null;

    /**
     * Gets the extracted EmailAddresses.
     */
    EmailAddresses: EmailAddressEntityCollection = null;

    /**
     * Gets the extracted Contacts.
     */
    Contacts: ContactEntityCollection = null;

    /**
     * Gets the extracted Urls.
     */
    Urls: UrlEntityCollection = null;

    /**
     * Gets the extracted PhoneNumbers
     */
    PhoneNumbers: PhoneEntityCollection = null;

    /**
     * @internal Initializes a new instance of the **EntityExtractionResult** class.
     */
    constructor() {
        super();
        this.Namespace = XmlNamespace.Types;
    }

    /**
     * @internal Read element from XMLJsObject.
     *
     * @param   {any}   jsObject   xmljsonObject
     * @return  {ExchangeService} the ExchangeService
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            if (jsObject.hasOwnProperty(key)) {
                switch (key) {
                    case XmlElementNames.NlgAddresses:
                        this.Addresses = new AddressEntityCollection();
                        this.Addresses.LoadFromXmlJsObject(jsObject[key], service);
                        break;

                    case XmlElementNames.NlgMeetingSuggestions:
                        this.MeetingSuggestions = new MeetingSuggestionCollection();
                        this.MeetingSuggestions.LoadFromXmlJsObject(jsObject[key], service);
                        break;

                    case XmlElementNames.NlgTaskSuggestions:
                        this.TaskSuggestions = new TaskSuggestionCollection();
                        this.TaskSuggestions.LoadFromXmlJsObject(jsObject[key], service);
                        break;

                    case XmlElementNames.NlgEmailAddresses:
                        this.EmailAddresses = new EmailAddressEntityCollection();
                        this.EmailAddresses.LoadFromXmlJsObject(jsObject[key], service);
                        break;

                    case XmlElementNames.NlgContacts:
                        this.Contacts = new ContactEntityCollection();
                        this.Contacts.LoadFromXmlJsObject(jsObject[key], service);
                        break;

                    case XmlElementNames.NlgUrls:
                        this.Urls = new UrlEntityCollection();
                        this.Urls.LoadFromXmlJsObject(jsObject[key], service);
                        break;

                    case XmlElementNames.NlgPhoneNumbers:
                        this.PhoneNumbers = new PhoneEntityCollection();
                        this.PhoneNumbers.LoadFromXmlJsObject(jsObject[key], service);
                        break;
                    default:
                        break;
                }
            }
        }
    }
}
export class ExtendedProperty extends ComplexProperty {
    private propertyDefinition: ExtendedPropertyDefinition = null;
    private value: any = null;

    get PropertyDefinition(): ExtendedPropertyDefinition {
        return this.propertyDefinition;
    }

    get Value(): any {
        return this.value;
    }

    set Value(value: any) {
        EwsUtilities.ValidateParam(value, "value");
        this.SetFieldValue<any>({ getValue: () => this.value, setValue: (val) => this.value = val }, value);
    }

    constructor(propertyDefinition?: ExtendedPropertyDefinition) {
        super();
        //EwsUtilities.ValidateParam(propertyDefinition, "propertyDefinition");
        if (typeof propertyDefinition !== 'undefined')
            this.propertyDefinition = propertyDefinition;
    }

    Equals(obj: any): boolean { throw new Error("ExtendedProperty.ts - Equals : Not implemented."); }
    GetHashCode(): number { throw new Error("ExtendedProperty.ts - GetHashCode : Not implemented."); }
    GetStringValue(): string { throw new Error("ExtendedProperty.ts - GetStringValue : Not implemented."); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        if (jsonProperty[XmlElementNames.ExtendedFieldURI]) {
            this.propertyDefinition = new ExtendedPropertyDefinition();
            this.propertyDefinition.LoadPropertyValueFromXmlJsObject(jsonProperty[XmlElementNames.ExtendedFieldURI]);
        }

        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.ExtendedFieldURI:
                    //pre processed above
                    break;
                case XmlElementNames.Value:
                    EwsLogging.Assert(
                        this.PropertyDefinition != null,
                        "ExtendedProperty.TryReadElementFromXml",
                        "PropertyDefintion is missing");

                    var stringValue: string = jsonProperty[key];
                    this.value = MapiTypeConverter.ConvertToValue(this.PropertyDefinition.MapiType, stringValue);
                    break;
                case XmlElementNames.Values:
                    EwsLogging.Assert(
                        this.PropertyDefinition != null,
                        "ExtendedProperty.TryReadElementFromXml",
                        "PropertyDefintion is missing");

                    var stringList: StringList = new StringList(XmlElementNames.Value);
                    var jsonCollection = EwsServiceJsonReader.ReadAsArray(jsonProperty, key);
                    stringList.CreateFromXmlJsObjectCollection(jsonCollection, service);
                    this.value = MapiTypeConverter.ConvertToValue(this.PropertyDefinition.MapiType, stringList.GetEnumerator());
                    break;
                default:
                    break;
            }
        }
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.PropertyDefinition.WriteToXml(writer);
        if (MapiTypeConverter.IsArrayType(this.PropertyDefinition.MapiType)) {
            var array: any[] = this.Value;
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Values);
            for (var index = 0; index < array.length; index++) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.Value,
                    MapiTypeConverter.ConvertToString(this.PropertyDefinition.MapiType, array[index]));
            }
            writer.WriteEndElement();
        }
        else {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.Value,
                MapiTypeConverter.ConvertToString(this.PropertyDefinition.MapiType, this.Value));
        }
    }
}

/**
 * Encapsulates information on the occurrence of a recurring appointment. 
 */
export class Flag extends ComplexProperty {
    private flagStatus: ItemFlagStatus = ItemFlagStatus.NotFlagged;
    private startDate: DateTime = null;
    private dueDate: DateTime = null;
    private completeDate: DateTime = null;

    /**
     * Gets or sets the flag status.
     */
    get FlagStatus(): ItemFlagStatus {
        return this.flagStatus;
    }
    set FlagStatus(value: ItemFlagStatus) {
        this.SetFieldValue<ItemFlagStatus>({ getValue: () => this.flagStatus, setValue: (updateValue) => { this.flagStatus = updateValue } }, value);
    }

    /**
     * Gets the start date.
     */
    get StartDate(): DateTime {
        return this.startDate;
    }
    set StartDate(value: DateTime) {
        this.SetFieldValue<DateTime>({ getValue: () => this.startDate, setValue: (updateValue) => { this.startDate = updateValue } }, value);
    }

    /**
     * Gets the due date.
     */
    get DueDate(): DateTime {
        return this.dueDate;
    }
    set DueDate(value: DateTime) {
        this.SetFieldValue<DateTime>({ getValue: () => this.dueDate, setValue: (updateValue) => { this.dueDate = updateValue } }, value);
    }

    /**
     * Gets the complete date.
     */
    get CompleteDate(): DateTime {
        return this.completeDate;
    }
    set CompleteDate(value: DateTime) {
        this.SetFieldValue<DateTime>({ getValue: () => this.completeDate, setValue: (updateValue) => { this.completeDate = updateValue } }, value);
    }

    /**
     * Initializes a new instance of the **Flag** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.FlagStatus:
                    this.flagStatus = ItemFlagStatus[<string>jsObject[key]];
                    break;
                case XmlElementNames.StartDate:
                    this.startDate = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.DueDate:
                    this.dueDate = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.CompleteDate:
                    this.completeDate = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Validates this instance.
     */
    Validate(): void {
        EwsUtilities.ValidateParam(this.flagStatus, "FlagStatus");
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FlagStatus, ItemFlagStatus[this.FlagStatus]);

        if (this.FlagStatus == ItemFlagStatus.Flagged && this.StartDate != null && this.DueDate != null) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.StartDate, this.StartDate);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DueDate, this.DueDate);
        }
        else if (this.FlagStatus == ItemFlagStatus.Complete && this.CompleteDate != null) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.CompleteDate, this.CompleteDate);
        }
    }
}

/**
 * Represents a permission on a folder.
 * 
 * @sealed
 */
export class FolderPermission extends ComplexProperty {

    private static defaultPermissions: LazyMember<IndexerWithEnumKey<FolderPermissionLevel, FolderPermission>> = new LazyMember<IndexerWithEnumKey<FolderPermissionLevel, FolderPermission>>(
        () => {
            var result: IndexerWithEnumKey<FolderPermissionLevel, FolderPermission> = {};// new Dictionary<FolderPermissionLevel, FolderPermission>();

            var permission: FolderPermission = new FolderPermission();
            permission.canCreateItems = false;
            permission.canCreateSubFolders = false;
            permission.deleteItems = PermissionScope.None;
            permission.editItems = PermissionScope.None;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = false;
            permission.readItems = FolderPermissionReadAccess.None;

            result[FolderPermissionLevel.None] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = true;
            permission.canCreateSubFolders = false;
            permission.deleteItems = PermissionScope.None;
            permission.editItems = PermissionScope.None;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = true;
            permission.readItems = FolderPermissionReadAccess.None;

            result[FolderPermissionLevel.Contributor] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = false;
            permission.canCreateSubFolders = false;
            permission.deleteItems = PermissionScope.None;
            permission.editItems = PermissionScope.None;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = true;
            permission.readItems = FolderPermissionReadAccess.FullDetails;

            result[FolderPermissionLevel.Reviewer] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = true;
            permission.canCreateSubFolders = false;
            permission.deleteItems = PermissionScope.Owned;
            permission.editItems = PermissionScope.None;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = true;
            permission.readItems = FolderPermissionReadAccess.FullDetails;

            result[FolderPermissionLevel.NoneditingAuthor] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = true;
            permission.canCreateSubFolders = false;
            permission.deleteItems = PermissionScope.Owned;
            permission.editItems = PermissionScope.Owned;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = true;
            permission.readItems = FolderPermissionReadAccess.FullDetails;

            result[FolderPermissionLevel.Author] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = true;
            permission.canCreateSubFolders = true;
            permission.deleteItems = PermissionScope.Owned;
            permission.editItems = PermissionScope.Owned;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = true;
            permission.readItems = FolderPermissionReadAccess.FullDetails;

            result[FolderPermissionLevel.PublishingAuthor] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = true;
            permission.canCreateSubFolders = false;
            permission.deleteItems = PermissionScope.All;
            permission.editItems = PermissionScope.All;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = true;
            permission.readItems = FolderPermissionReadAccess.FullDetails;

            result[FolderPermissionLevel.Editor] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = true;
            permission.canCreateSubFolders = true;
            permission.deleteItems = PermissionScope.All;
            permission.editItems = PermissionScope.All;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = true;
            permission.readItems = FolderPermissionReadAccess.FullDetails;

            result[FolderPermissionLevel.PublishingEditor] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = true;
            permission.canCreateSubFolders = true;
            permission.deleteItems = PermissionScope.All;
            permission.editItems = PermissionScope.All;
            permission.isFolderContact = true;
            permission.isFolderOwner = true;
            permission.isFolderVisible = true;
            permission.readItems = FolderPermissionReadAccess.FullDetails;

            result[FolderPermissionLevel.Owner] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = false;
            permission.canCreateSubFolders = false;
            permission.deleteItems = PermissionScope.None;
            permission.editItems = PermissionScope.None;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = false;
            permission.readItems = FolderPermissionReadAccess.TimeOnly;

            result[FolderPermissionLevel.FreeBusyTimeOnly] = permission;

            permission = new FolderPermission();
            permission.canCreateItems = false;
            permission.canCreateSubFolders = false;
            permission.deleteItems = PermissionScope.None;
            permission.editItems = PermissionScope.None;
            permission.isFolderContact = false;
            permission.isFolderOwner = false;
            permission.isFolderVisible = false;
            permission.readItems = FolderPermissionReadAccess.TimeAndSubjectAndLocation;

            result[FolderPermissionLevel.FreeBusyTimeAndSubjectAndLocation] = permission;

            return result;
        });

    /**
     * Variants of pre-defined permission levels that Outlook also displays with the same levels.
     */
    private static levelVariants: LazyMember<FolderPermission[]> = new LazyMember<FolderPermission[]>(
        () => {
            var results: FolderPermission[] = [];// new List<FolderPermission>();

            var permissionNone: FolderPermission = FolderPermission.defaultPermissions.Member[FolderPermissionLevel.None];
            var permissionOwner: FolderPermission = FolderPermission.defaultPermissions.Member[FolderPermissionLevel.Owner];

            // PermissionLevelNoneOption1
            var permission: FolderPermission = permissionNone.Clone();
            permission.isFolderVisible = true;
            results.push(permission);

            // PermissionLevelNoneOption2
            permission = permissionNone.Clone();
            permission.isFolderContact = true;
            results.push(permission);

            // PermissionLevelNoneOption3
            permission = permissionNone.Clone();
            permission.isFolderContact = true;
            permission.isFolderVisible = true;
            results.push(permission);

            // PermissionLevelOwnerOption1
            permission = permissionOwner.Clone();
            permission.isFolderContact = false;
            results.push(permission);

            return results;
        });

    private userId: UserId;
    private canCreateItems: boolean;
    private canCreateSubFolders: boolean;
    private isFolderOwner: boolean;
    private isFolderVisible: boolean;
    private isFolderContact: boolean;
    private editItems: PermissionScope;
    private deleteItems: PermissionScope;
    private readItems: FolderPermissionReadAccess;
    private permissionLevel: FolderPermissionLevel;


    /**
     * Gets the Id of the user the permission applies to.
     */
    get UserId(): UserId {
        return this.userId;
    }
    set UserId(value) {
        if (this.userId != null) {
            ArrayHelper.RemoveEntry(this.userId.OnChange, this.PropertyChanged);
        }
        this.SetFieldValue<UserId>({ getValue: () => this.userId, setValue: (id) => this.userId = id }, value);
        if (this.userId != null) {
            this.userId.OnChange.push(this.PropertyChanged.bind(this));
        }
    }

    /**
     * Gets or sets a value indicating whether the user can create new items.
     */
    get CanCreateItems(): boolean {
        return this.canCreateItems;
    }
    set CanCreateItems(value) {
        this.SetFieldValue<boolean>({ getValue: () => this.canCreateItems, setValue: (data) => this.canCreateItems = data }, value);
        this.AdjustPermissionLevel();
    }

    /**
     * Gets or sets a value indicating whether the user can create sub-folders.
     */
    get CanCreateSubFolders(): boolean {
        return this.canCreateSubFolders;
    }
    set CanCreateSubFolders(value) {
        this.SetFieldValue<boolean>({ getValue: () => this.canCreateSubFolders, setValue: (data) => this.canCreateSubFolders = data }, value);
        this.AdjustPermissionLevel();
    }

    /**
     * Gets or sets a value indicating whether the user owns the folder.
     */
    get IsFolderOwner(): boolean {
        return this.isFolderOwner;
    }
    set IsFolderOwner(value) {
        this.SetFieldValue<boolean>({ getValue: () => this.isFolderOwner, setValue: (data) => this.isFolderOwner = data }, value);
        this.AdjustPermissionLevel();
    }

    /**
     * Gets or sets a value indicating whether the folder is visible to the user.
     */
    get IsFolderVisible(): boolean {
        return this.isFolderVisible;
    }
    set IsFolderVisible(value) {
        this.SetFieldValue<boolean>({ getValue: () => this.isFolderVisible, setValue: (data) => this.isFolderVisible = data }, value);
        this.AdjustPermissionLevel();
    }

    /**
     * Gets or sets a value indicating whether the user is a contact for the folder.
     */
    get IsFolderContact(): boolean {
        return this.isFolderContact;
    }
    set IsFolderContact(value) {
        this.SetFieldValue<boolean>({ getValue: () => this.isFolderContact, setValue: (data) => this.isFolderContact = data }, value);
        this.AdjustPermissionLevel();
    }

    /**
     * Gets or sets a value indicating if/how the user can edit existing items.
     */
    get EditItems(): PermissionScope {
        return this.editItems;
    }
    set EditItems(value) {
        this.SetFieldValue<PermissionScope>({ getValue: () => this.editItems, setValue: (data) => this.editItems = data }, value);
        this.AdjustPermissionLevel();
    }

    /**
     * Gets or sets a value indicating if/how the user can delete existing items.
     */
    get DeleteItems(): PermissionScope {
        return this.deleteItems;
    }
    set DeleteItems(value) {
        this.SetFieldValue<PermissionScope>({ getValue: () => this.deleteItems, setValue: (data) => this.deleteItems = data }, value);
        this.AdjustPermissionLevel();
    }

    /**
     * Gets or sets the read items access permission.
     */
    get ReadItems(): FolderPermissionReadAccess {
        return this.readItems;
    }
    set ReadItems(value) {
        this.SetFieldValue<FolderPermissionReadAccess>({ getValue: () => this.readItems, setValue: (data) => this.readItems = data }, value);
        this.AdjustPermissionLevel();
    }

    /**
     * Gets or sets the permission level.
     */
    get PermissionLevel(): FolderPermissionLevel {
        return this.permissionLevel;
    }
    set PermissionLevel(value) {
        if (this.permissionLevel != value) {
            if (value == FolderPermissionLevel.Custom) {
                throw new ServiceLocalException(Strings.CannotSetPermissionLevelToCustom);
            }
            this.AssignIndividualPermissions(FolderPermission.defaultPermissions.Member[value]);
            this.SetFieldValue<FolderPermissionLevel>({ getValue: () => this.permissionLevel, setValue: (data) => this.permissionLevel = data }, value);
        }
    }

    /**
     * Gets the permission level that Outlook would display for this folder permission.
     */
    get DisplayPermissionLevel(): FolderPermissionLevel {
        // If permission level is set to Custom, see if there's a variant
        // that Outlook would map to the same permission level.
        if (this.permissionLevel == FolderPermissionLevel.Custom) {
            for (var variant of FolderPermission.levelVariants.Member) {
                if (this.IsEqualTo(variant)) {
                    return variant.PermissionLevel;
                }
            }
        }
        return this.permissionLevel;
    }

    /**
     * Initializes a new instance of the **FolderPermission** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **FolderPermission** class.
     *
     * @param   {UserId}                    userId            The Id of the user  the permission applies to.
     * @param   {FolderPermissionLevel}     permissionLevel   The level of the permission.
     */
    constructor(userId: UserId, permissionLevel: FolderPermissionLevel);
    /**
     * Initializes a new instance of the **FolderPermission** class.
     *
     * @param   {string}                    primarySmtpAddress  The primary SMTP address of the user the permission applies to.
     * @param   {FolderPermissionLevel}     permissionLevel     The level of the permission.
     */
    constructor(primarySmtpAddress: string, permissionLevel: FolderPermissionLevel);
    /**
     * Initializes a new instance of the **FolderPermission** class.
     *
     * @param   {StandardUser}              standardUser        The standard user the permission applies to.
     * @param   {FolderPermissionLevel}     permissionLevel     The level of the permission.
     */
    constructor(standardUser: StandardUser, permissionLevel: FolderPermissionLevel);
    constructor(userIdOrStandardUserOrSmtpAddress?: UserId | StandardUser | string, permissionLevel?: FolderPermissionLevel) {
        super();
        if (typeof userIdOrStandardUserOrSmtpAddress !== 'undefined' && typeof permissionLevel === 'undefined')
            throw new Error("FolderPermission - Constructor: permission level parameter cant be undefined or null when userid/smtpaddress/standarduser is provided in first place.");

        if (typeof userIdOrStandardUserOrSmtpAddress === 'undefined') {
            this.userId = new UserId();
        }
        else {
            this.permissionLevel = permissionLevel;
            if (typeof userIdOrStandardUserOrSmtpAddress === 'string' || typeof userIdOrStandardUserOrSmtpAddress === 'number') {
                this.userId = new UserId(userIdOrStandardUserOrSmtpAddress);
            }
            else {
                this.userId = userIdOrStandardUserOrSmtpAddress;
            }
        }
    }

    /**
     * Determines the permission level of this folder permission based on its individual settings, and sets the PermissionLevel property accordingly.
     */
    private AdjustPermissionLevel(): void {
        for (var key in FolderPermission.defaultPermissions.Member) {
            var value = FolderPermission.defaultPermissions.Member[key];
            if (this.IsEqualTo(value)) {
                this.permissionLevel = <FolderPermissionLevel><any>key;
                return;
            }
        }

        this.permissionLevel = FolderPermissionLevel.Custom;
    }

    /**
     * Copies the values of the individual permissions of the specified folder permission to this folder permissions.
     *
     * @param   {FolderPermission}   permission   The folder permission to copy the values from.
     */
    private AssignIndividualPermissions(permission: FolderPermission): void {
        this.canCreateItems = permission.CanCreateItems;
        this.canCreateSubFolders = permission.CanCreateSubFolders;
        this.isFolderContact = permission.IsFolderContact;
        this.isFolderOwner = permission.IsFolderOwner;
        this.isFolderVisible = permission.IsFolderVisible;
        this.editItems = permission.EditItems;
        this.deleteItems = permission.DeleteItems;
        this.readItems = permission.ReadItems;
    }

    /**
     * Create a copy of this FolderPermission instance.
     *
     * @return  {FolderPermission}      Clone of this instance.
     */
    private Clone(): FolderPermission {
        var res = new FolderPermission();
        res.canCreateItems = this.canCreateItems;
        res.canCreateSubFolders = this.canCreateSubFolders;
        res.deleteItems = this.deleteItems;
        res.editItems = this.editItems;
        res.isFolderContact = this.isFolderContact;
        res.isFolderOwner = this.isFolderOwner;
        res.isFolderVisible = this.isFolderVisible;
        res.permissionLevel = this.permissionLevel;
        res.readItems = this.readItems;
        res.userId = this.userId;
        return res;
    }

    /**
     * Determines whether the specified folder permission is the same as this one. The comparison does not take UserId and PermissionLevel into consideration.
     *
     * @param   {FolderPermission}  permission   The folder permission to compare with this folder permission.
     * @return  {boolean}           True is the specified folder permission is equal to this one, false otherwise.
     */
    private IsEqualTo(permission: FolderPermission): boolean {
        return this.CanCreateItems == permission.CanCreateItems &&
            this.CanCreateSubFolders == permission.CanCreateSubFolders &&
            this.IsFolderContact == permission.IsFolderContact &&
            this.IsFolderVisible == permission.IsFolderVisible &&
            this.IsFolderOwner == permission.IsFolderOwner &&
            this.EditItems == permission.EditItems &&
            this.DeleteItems == permission.DeleteItems &&
            this.ReadItems == permission.ReadItems;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any/*JsonObject*/, service: ExchangeService): void {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.UserId:
                    this.UserId = new UserId();
                    this.UserId.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.CanCreateItems:
                    this.canCreateItems = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.CanCreateSubFolders:
                    this.canCreateSubFolders = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsFolderOwner:
                    this.isFolderOwner = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsFolderVisible:
                    this.isFolderVisible = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsFolderContact:
                    this.isFolderContact = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.EditItems:
                    //debugger;//check for assignable enumeration type
                    this.editItems = <PermissionScope><any>PermissionScope[jsObject[key]];
                    break;
                case XmlElementNames.DeleteItems:
                    //debugger;//check for assignable enumeration type
                    this.deleteItems = <PermissionScope><any>PermissionScope[jsObject[key]];
                    break;
                case XmlElementNames.ReadItems:
                    //debugger;//check for assignable enumeration type
                    this.readItems = <FolderPermissionReadAccess><any>FolderPermissionReadAccess[jsObject[key]]
                    break;
                case XmlElementNames.PermissionLevel:
                case XmlElementNames.CalendarPermissionLevel:
                    //debugger;//check for assignable enumeration type
                    this.permissionLevel = <FolderPermissionLevel><any>FolderPermissionLevel[jsObject[key]];
                    break;
                default:
                    break;
            }
        }

        this.AdjustPermissionLevel();
    }

    /**
     * Property was changed.
     *
     * @param   {ComplexProperty}   complexProperty   The complex property.
     */
    private PropertyChanged(complexProperty: ComplexProperty): void {
        this.Changed();
    }

    //Validate(isCalendarFolder: boolean, permissionIndex: number): void { throw new Error("FolderPermission.ts - Validate : Not implemented."); }

    /**
     * @internal Validates this instance.
     * ## parameters not optional: Typescript inheritance issue if not set as optional in code.
     *
     * @param   {boolean}   isCalendarFolder   if set to true calendar permissions are allowed.
     * @param   {number}    permissionIndex    Index of the permission.
     */
    Validate(isCalendarFolder?: boolean, permissionIndex?: number): void { //ref: inheritance issue if parameters are not optional

        if (typeof isCalendarFolder === 'undefined' || typeof permissionIndex === 'undefined')
            throw new Error("FolderPermission - Validate: incorrect call to validate, without the isCalendar or permissionIndex pearameter. this signature makes it optional to comply with typescript inheritance system and to avoid compiletime error.");
        // Check UserId
        if (!this.UserId.IsValid()) {
            throw new ServiceValidationException(
                StringHelper.Format(
                    Strings.FolderPermissionHasInvalidUserId,
                    permissionIndex));
        }

        // If this permission is to be used for a non-calendar folder make sure that read access and permission level aren't set to Calendar-only values
        if (!isCalendarFolder) {
            if ((this.readItems == FolderPermissionReadAccess.TimeAndSubjectAndLocation) ||
                (this.readItems == FolderPermissionReadAccess.TimeOnly)) {
                throw new ServiceLocalException(
                    StringHelper.Format(
                        Strings.ReadAccessInvalidForNonCalendarFolder,
                        this.readItems));
            }

            if ((this.permissionLevel == FolderPermissionLevel.FreeBusyTimeAndSubjectAndLocation) ||
                (this.permissionLevel == FolderPermissionLevel.FreeBusyTimeOnly)) {
                throw new ServiceLocalException(
                    StringHelper.Format(
                        Strings.PermissionLevelInvalidForNonCalendarFolder,
                        FolderPermissionLevel[this.permissionLevel]));
            }
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer             The writer.
     * @param   {boolean}               isCalendarFolder   If true, this permission is for a calendar folder.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter, isCalendarFolder: boolean = false): void {
        if (this.UserId != null) {
            this.UserId.WriteToXml(writer, XmlElementNames.UserId);
        }

        if (this.PermissionLevel == FolderPermissionLevel.Custom) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.CanCreateItems,
                this.CanCreateItems);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.CanCreateSubFolders,
                this.CanCreateSubFolders);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.IsFolderOwner,
                this.IsFolderOwner);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.IsFolderVisible,
                this.IsFolderVisible);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.IsFolderContact,
                this.IsFolderContact);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.EditItems,
                this.EditItems);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.DeleteItems,
                this.DeleteItems);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.ReadItems,
                this.ReadItems);
        }

        writer.WriteElementValue(
            XmlNamespace.Types,
            isCalendarFolder ? XmlElementNames.CalendarPermissionLevel : XmlElementNames.PermissionLevel,
            FolderPermissionLevel[this.PermissionLevel]);
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer             The writer.
     * @param   {string}                xmlElementName     Name of the XML element.
     * @param   {XmlNamespace}          xmlNamespace       
     * @param   {isCalendarFolder}      isCalendarFolder   If true, this permission is for a calendar folder.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string, xmlNamespace?: XmlNamespace, isCalendarFolder: boolean = false): void { //ref: XmlNamespace - incorrect inheritance error with typesctipt in folderpermission class if removed xmlnamespace parameter
        writer.WriteStartElement(this.Namespace, xmlElementName);
        this.WriteAttributesToXml(writer);
        this.WriteElementsToXml(writer, isCalendarFolder);
        writer.WriteEndElement();
    }
}


/**
 * Represents a group member 
 * [RequiredServerVersion(ExchangeVersion.Exchange2010)] ** needs implementation
 */
export class GroupMember extends ComplexProperty { // todo: need implementation for [RequiredServerVersion(ExchangeVersion.Exchange2010)]

    /**
     * AddressInformation field.
     */
    private addressInformation: EmailAddress = null;

    /**
     * Status field.
     */
    private status: MemberStatus;

    /**
     * Member key field.
     */
    private key: string;


    /**
     * ets the key of the member.
     */
    get Key(): string {
        return this.key;
    }

    /**
     * Gets the address information of the member.
     */
    get AddressInformation(): EmailAddress {
        return this.addressInformation;
    }

    /**
     * @internal Sets the address information of the member.
     */
    set AddressInformation(value: EmailAddress) {
        if (this.addressInformation !== null) {
            ArrayHelper.RemoveEntry(this.addressInformation.OnChange, this.AddressInformationChanged);
        }
        this.addressInformation = value;
        if (this.addressInformation !== null) {
            this.addressInformation.OnChange.push(this.AddressInformationChanged.bind(this));
        }
    }

    /**
     * Gets the status of the member.
     */
    get Status(): MemberStatus {
        return this.status;
    }


    /**
     * Initializes a new instance of the **GroupMember** class.
     *
     */
    constructor();
    /**
     * Initializes a new instance of the **GroupMember** class.
     *
     * @param   {string}   smtpAddress   The SMTP address of the member.
     */
    constructor(smtpAddress: string);
    /**
     * Initializes a new instance of the **GroupMember** class.
     *
     * @param   {ItemId}   contactGroupId   The Id of the contact group to link the member to.
     */
    constructor(contactGroupId: ItemId);
    /**
     * Initializes a new instance of the **GroupMember** class.
     *
     * @param   {EmailAddress}   addressInformation   The e-mail address of the member.
     */
    constructor(addressInformation: EmailAddress);
    /**
     * @internal Initializes a new instance of the **GroupMember** class from another GroupMember instance.
     *
     * @param   {GroupMember}   member   GroupMember class instance to copy.
     */
    constructor(member: GroupMember);
    /**
     * Initializes a new instance of the **GroupMember** class.
     *
     * @param   {string}   smtpAddress   The SMTP address of the member.
     * @param   {MailboxType}   mailboxType   The mailbox type of the member.
     */
    constructor(smtpAddress: string, mailboxType: MailboxType);
    /**
     * Initializes a new instance of the **GroupMember** class.
     *
     * @param   {string}   name          The name of the one-off member.
     * @param   {string}   smtpAddress   The SMTP address of the one-off member.
     */
    constructor(name: string, smtpAddress: string);
    /**
     * Initializes a new instance of the **GroupMember** class.
     *
     * @param   {ItemId}   contactId       The Id of the contact member.
     * @param   {string}   addressToLink   The Id of the contact to link the member to.
     */
    constructor(contactId: ItemId, addressToLink: string);
    /**
     * Initializes a new instance of the **GroupMember** class from a Contact instance indexed by the specified key.
     *
     * @param   {Contact}           contact           The contact to link to.
     * @param   {EmailAddressKey}   emailAddressKey   The contact's e-mail address to link to.
     */
    constructor(contact: Contact, emailAddressKey: EmailAddressKey);
    /**
     * Initializes a new instance of the **GroupMember** class.
     *
     * @param   {string}   address       The address of the member.
     * @param   {string}   routingType   The routing type of the address.
     * @param   {MailboxType}   mailboxType   The mailbox type of the member.
     */
    constructor(address: string, routingType: string, mailboxType: MailboxType);
    /**
     * Initializes a new instance of the **GroupMember** class.
     *
     * @param   {string}   name          The name of the one-off member.
     * @param   {string}   address       The address of the one-off member.
     * @param   {string}   routingType   The routing type of the address.
     */
    constructor(name: string, address: string, routingType: string);
    constructor(_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId?: string | ItemId | EmailAddress | GroupMember | Contact,
        _2routingTypeOrMbxTypeOrAddressOrSmtpOrAddr2LinkOrEmailKey?: string | MailboxType | EmailAddressKey, _3mbxTypeOrRoutingType?: MailboxType | string) {
        super();
        // Key is assigned by server
        this.key = null;

        // Member status is calculated by server
        this.status = MemberStatus.Unrecognized;

        let argsLength = arguments.length;
        if (argsLength == 1) {
            if (typeof _1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId === 'string') { // smtpAddress
                this.AddressInformation = new EmailAddress(_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId);
            } else if (_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId instanceof ItemId) { // contactGroupId
                this.AddressInformation = new EmailAddress(
                    null,
                    null,
                    null,
                    MailboxType.ContactGroup,
                    _1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId);
            } else if (_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId instanceof GroupMember) { // contactGroupId
                EwsUtilities.ValidateParam(_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId, "member");
                this.AddressInformation = new EmailAddress(_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId.AddressInformation);
            } else {
                this.AddressInformation = new EmailAddress(<EmailAddress>_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId);
            }
        }

        if (argsLength === 2) {
            if (typeof _1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId === 'string') {
                if (typeof _2routingTypeOrMbxTypeOrAddressOrSmtpOrAddr2LinkOrEmailKey === 'string') {
                    this.AddressInformation = new EmailAddress(<string>_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId, <string>_2routingTypeOrMbxTypeOrAddressOrSmtpOrAddr2LinkOrEmailKey, EmailAddress.SmtpRoutingType, MailboxType.OneOff);
                }
                else {
                    this.constructor_str_str_mbType(<string>_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId,
                        EmailAddress.SmtpRoutingType,
                        <MailboxType>_2routingTypeOrMbxTypeOrAddressOrSmtpOrAddr2LinkOrEmailKey);
                }
            } else if (_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId instanceof ItemId) {
                this.AddressInformation = new EmailAddress(
                    null,
                    <string>_2routingTypeOrMbxTypeOrAddressOrSmtpOrAddr2LinkOrEmailKey, // addressToLink
                    null,
                    MailboxType.Contact,
                    _1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId); //contactId
            } else {

                let contact: Contact = <Contact>_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId;
                EwsUtilities.ValidateParam(contact, "contact");

                let emailAddress: EmailAddress = contact.EmailAddresses[_2routingTypeOrMbxTypeOrAddressOrSmtpOrAddr2LinkOrEmailKey /* emailAddressKey */];

                this.AddressInformation = new EmailAddress(emailAddress);

                this.addressInformation.Id = contact.Id;
            }
        }

        if (argsLength === 3) {
            if (typeof _3mbxTypeOrRoutingType === 'string') { // mailboxType
                this.AddressInformation = new EmailAddress(<string>_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId, <string>_2routingTypeOrMbxTypeOrAddressOrSmtpOrAddr2LinkOrEmailKey, _3mbxTypeOrRoutingType, MailboxType.OneOff);
            } else {

                this.constructor_str_str_mbType(<string>_1smtpOrCGIdOrAddrInfoOrMemberOrAddrOrNameOrContactOrCId, <string>_2routingTypeOrMbxTypeOrAddressOrSmtpOrAddr2LinkOrEmailKey, _3mbxTypeOrRoutingType);
            }
        }
    }

    //#region Constructor methods
    private constructor_str_str_mbType(address: string, routingType: string, mailboxType: MailboxType) {
        switch (mailboxType) {
            case MailboxType.PublicGroup:
            case MailboxType.PublicFolder:
            case MailboxType.Mailbox:
            case MailboxType.Contact:
            case MailboxType.OneOff:
                this.AddressInformation = new EmailAddress(null, address, routingType, mailboxType);
                break;

            default:
                throw new ServiceLocalException(Strings.InvalidMailboxType);
        }
    }
    //#endregion


    /**
     * AddressInformation instance is changed.
     *
     * @param   {}   complexProperty   Changed property.
     */
    private AddressInformationChanged(complexProperty: ComplexProperty): void {
        this.Changed();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlAttributeNames.Key:
                    this.key = jsObject[key];
                    break;
                case XmlElementNames.Status:
                    this.status = MemberStatus[<string>jsObject[key]];
                    break;
                case XmlElementNames.Mailbox:
                    this.AddressInformation = new EmailAddress();
                    this.AddressInformation.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Writes the member key attribute to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        // if this.key is null or empty, writer skips the attribute
        writer.WriteAttributeValue(XmlAttributeNames.Key, this.key);
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        // No need to write member Status back to server
        // Write only AddressInformation container element
        this.AddressInformation.WriteToXml(
            writer,
            XmlElementNames.Mailbox,
            XmlNamespace.Types);
    }
}

/**
 * Represents an AQS highlight term. 
 * 
 * @sealed
 */
export class HighlightTerm extends ComplexProperty {

    /**
     * Term scope.
     */
    private scope: string = null;

    /**
     * Term value.
     */
    private value: string = null;

    /**
     * Gets term scope.
     */
    get Scope(): string {
        return this.scope;
    }

    /**
     * Gets term value.
     */
    get Value(): string {
        return this.value;
    }

    /**
     * @internal Initializes a new instance of the **HighlightTerm** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        if (jsObject[XmlElementNames.HighlightTermScope]) {
            this.scope = jsObject[XmlElementNames.HighlightTermScope];
        }

        if (jsObject[XmlElementNames.HighlightTermValue]) {
            this.value = jsObject[XmlElementNames.HighlightTermValue];
        }
    }
}

/**
 * Represents an Internet message header.
 */
export class InternetMessageHeader extends ComplexProperty {
    
    private name: string = null;
    private value: string = null;

    /**
     * The name of the header.
     */
    get Name(): string {
        return this.name;
    }
    set Name(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.name, setValue: (nameValue: string) => { this.name = nameValue } }, value);
    }

    /**
     * The value of the header.
     */
    get Value(): string {
        return this.value;
    }
    set Value(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.value, setValue: (valueValue: string) => { this.value = valueValue } }, value);
    }

    /**
     * @internal Initializes a new instance of the **InternetMessageHeader** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads from XMLJsObject.
     *
     * @param   {any}   jsonProperty   The json property.
     * @param   {ExchangeService}   service        The ExchangeService instance
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlAttributeNames.HeaderName:
                    this.name = jsObject[key];
                    break;
                case XmlElementNames.InternetMessageHeader: //JsonObject.JsonValueString: //ref: //info: custom parser in ExtensionMethods uses name of type when there is attribute value as well as text value
                    this.value = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Obtains a string representation of the header.
     *
     * @return  {string}      The string representation of the header.
     */
    ToString(): string { return StringHelper.Format("{0}={1}", this.Name, this.Value); }
    toString(): string { return this.ToString(); }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void { writer.WriteAttributeValue(XmlAttributeNames.HeaderName, this.Name); }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { writer.WriteValue(this.Value, this.Name); }
}

/**
 * Represents a collection of items.
 */
export class ItemCollection<TItem extends Item> extends ComplexProperty { // IEnumerable<TItem>, IJsonCollectionDeserializer
    __implements: string[] = ["ISelfValidate", "IJsonSerializable", "IEnumerable<TItem>", "IJsonCollectionDeserializer"];

    private items: Array<TItem> = [];// System.Collections.Generic.List<T>;

    /**
     * Gets the total number of items in the collection.
     */
    get Count(): number {
        return this.items.length;
    }

    /**
     * Gets the item at the specified index.
     *
     * @param   {number}   index   The zero-based index of the item to get.
     * @return  {TItem}     The item at the specified index.
     */
    _getItem(index: number): TItem {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        return this.items[index];
    }

    /**
     * Initializes a new instance of the **ItemCollection** class.
     *
     */
    constructor() {
        super();
    }

    GetEnumerator(): any { throw new Error("ItemCollection.ts - GetEnumerator : Not implemented."); }//wil be implementedfor ES6 later with yield

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {

        let collectionObj = undefined;
        if (ArrayHelper.isArray(jsObject)) {
            collectionObj = jsObject;
        }
        else {
            collectionObj = [jsObject];
        }

        for (let entry of collectionObj) {
            let jsonServiceObject = entry;
            let item: TItem = (new ItemInfo()).CreateEwsObjectFromXmlElementName<Item>(
                service,
                TypeSystem.GetJsObjectTypeName(jsonServiceObject)) as TItem;

            item.LoadFromXmlJsObject(jsonServiceObject, service, true);

            this.items.push(item);
        }

    }
}

/**
 * Represents a mailbox reference.
 */
export class Mailbox extends ComplexProperty implements ISearchStringProvider {

    /**
     * True if this instance is valid, false otherthise.
     * 
     * @value   *true* if this instance is valid; otherwise, *false*.
     */
    get IsValid(): boolean {
        return !StringHelper.IsNullOrEmpty(this.Address);
    }

    /**
     * Gets or sets the address used to refer to the user mailbox.
     */
    Address: string;

    /**
     * Gets or sets the routing type of the address used to refer to the user mailbox.
     */
    RoutingType: string;

    /**
     * Initializes a new instance of the **Mailbox** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **Mailbox** class.
     *
     * @param   {string}   smtpAddress   The primary SMTP address of the mailbox.
     */
    constructor(smtpAddress: string);
    /**
     * Initializes a new instance of the **Mailbox** class.
     *
     * @param   {string}   address       The address used to reference the user mailbox.
     * @param   {string}   routingType   The routing type of the address used to reference the user mailbox.
     */
    constructor(address: string, routingType: string);
    constructor(smtpAddressOrAddress: string = null, routingType: string = null) {
        super();

        this.Address = smtpAddressOrAddress;
        this.RoutingType = routingType;
    }

    /**
     * Determines whether the specified  is equal to the current .
     *
     * @param   {any}   obj   The  to compare with the current .
     * @return  {boolean}       true if the specified  is equal to the current ; otherwise, false.
     * 
     * @exception   {NullReferenceException}    The **obj** parameter is null.
     */
    Equals(obj: any): boolean {
        if (this === obj) {
            return true;
        }
        else {
            var other: Mailbox = obj;

            if (!(other instanceof Mailbox)) {
                return false;
            }
            else if (((this.Address == null) && (other.Address == null)) ||
                ((this.Address != null) && this.Address === other.Address)) {
                return ((this.RoutingType == null) && (other.RoutingType == null)) ||
                    ((this.RoutingType != null) && this.RoutingType === other.RoutingType);
            }
            else {
                return false;
            }
        }
    }

    //GetHashCode(): number { throw new Error("Mailbox.ts - GetHashCode : Not implemented."); }

    /**
	 * @internal Validates this instance.
	 */
    InternalValidate(): void {
        super.InternalValidate();

        EwsUtilities.ValidateNonBlankStringParamAllowNull(this.Address, "address");
        EwsUtilities.ValidateNonBlankStringParamAllowNull(this.RoutingType, "routingType");
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        //debug:
        if (jsonProperty[XmlElementNames.EmailAddress]) {
            this.Address = jsonProperty[XmlElementNames.EmailAddress];//.ReadAsString(XmlElementNames.EmailAddress);
        }

        if (jsonProperty[XmlElementNames.RoutingType]) {
            this.RoutingType = jsonProperty[XmlElementNames.RoutingType];//.ReadAsString(XmlElementNames.RoutingType);
        }
    }

    /**
     * Returns a  that represents the current .
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    ToString(): string {
        if (!this.IsValid) {
            return StringHelper.Empty;
        }
        else if (!StringHelper.IsNullOrEmpty(this.RoutingType)) {
            return this.RoutingType + ":" + this.Address;
        }
        else {
            return this.Address;
        }
    }
    toString(): string {
        return this.ToString();
    }


    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EmailAddress, this.Address);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RoutingType, this.RoutingType);
    }

    /**
     * Get a string representation for using this instance in a search filter.
     * ISearchStringProvider.GetSearchString
     *
     * @return  {string}      String representation of instance.
     */
    GetSearchString(): string {
        return this.Address;
    }
}
export class ManagedFolderInformation extends ComplexProperty {
    CanDelete: boolean;
    CanRenameOrMove: boolean;
    MustDisplayComment: boolean;
    HasQuota: boolean;
    IsManagedFoldersRoot: boolean;
    ManagedFolderId: string;
    Comment: string;
    StorageQuota: number;
    FolderSize: number;
    HomePage: string;
    private canDelete: boolean;
    private canRenameOrMove: boolean;
    private mustDisplayComment: boolean;
    private hasQuota: boolean;
    private isManagedFoldersRoot: boolean;
    private managedFolderId: string;
    private comment: string;
    private storageQuota: number;
    private folderSize: number;
    private homePage: string;
    LoadFromJson(jsonProperty: any/*JsonObject*/, service: ExchangeService): any { throw new Error("ManagedFolderInformation.ts - LoadFromJson : Not implemented."); }
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): boolean { throw new Error("ManagedFolderInformation.ts - TryReadElementFromXmlJsObject : Not implemented."); }
}


//}




/**
 * @internal Represents a time zone in which a meeting is defined.
 * @sealed
 */
export class MeetingTimeZone extends ComplexProperty {

    private name: string = null;
    private baseOffset: TimeSpan = null;
    private standard: TimeChange = null;
    private daylight: TimeChange = null;

    /**
     * Gets or sets the name of the time zone.
     */
    get Name(): string {
        return this.name;
    }
    set Name(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.name, setValue: (fieldValue) => { this.name = fieldValue } }, value);
    }

    /**
     * Gets or sets the base offset of the time zone from the UTC time zone.
     */
    get BaseOffset(): TimeSpan {
        return this.baseOffset;
    }
    set BaseOffset(value: TimeSpan) {
        this.SetFieldValue<TimeSpan>({ getValue: () => this.baseOffset, setValue: (fieldValue) => { this.baseOffset = fieldValue } }, value);
    }

    /**
     * Gets or sets a TimeChange defining when the time changes to Standard Time.
     */
    get Standard(): TimeChange {
        return this.standard;
    }
    set Standard(value: TimeChange) {
        this.SetFieldValue<TimeChange>({ getValue: () => this.standard, setValue: (fieldValue) => { this.standard = fieldValue } }, value);
    }

    /**
     * Gets or sets a TimeChange defining when the time changes to Daylight Saving Time.
     */
    get Daylight(): TimeChange {
        return this.daylight;
    }
    set Daylight(value: TimeChange) {
        this.SetFieldValue<TimeChange>({ getValue: () => this.daylight, setValue: (fieldValue) => { this.daylight = fieldValue } }, value);
    }

    /**
     * Initializes a new instance of the **MeetingTimeZone** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **MeetingTimeZone** class.
     *
     * @param   {TimeZoneInfo}   timeZone   The time zone used to initialize this instance.
     */
    constructor(timeZone: TimeZoneInfo);
    /**
     * Initializes a new instance of the **MeetingTimeZone** class.
     *
     * @param   {string}   name   The name of the time zone.
     */
    constructor(name: string);
    constructor(timeZoneOrName: TimeZoneInfo | string = null) {
        super();
        if (arguments.length === 1) {
            if (timeZoneOrName instanceof TimeZoneInfo) {
                // Unfortunately, MeetingTimeZone does not support all the time transition types
                // supported by TimeZoneInfo. That leaves us unable to accurately convert TimeZoneInfo
                // into MeetingTimeZone. So we don't... Instead, we emit the time zone's Id and
                // hope the server will find a match (which it should).
                this.Name = timeZoneOrName.Id;
            }
            else {
                this.name = timeZoneOrName;
            }
        }
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (let key in jsonProperty) {
            switch (key) {
                case XmlElementNames.BaseOffset:
                    this.baseOffset = EwsUtilities.XSDurationToTimeSpan(jsonProperty[key]);
                    break;
                case XmlElementNames.Standard:
                    this.standard = new TimeChange();
                    this.standard.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                case XmlElementNames.Daylight:
                    this.daylight = new TimeChange();
                    this.daylight.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                case XmlAttributeNames.TimeZoneName:
                    this.name = jsonProperty[key];
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Converts this meeting time zone into a TimeZoneInfo structure.
    */
    ToTimeZoneInfo(): TimeZoneInfo {
        // MeetingTimeZone.ToTimeZoneInfo throws ArgumentNullException if name is null
        // TimeZoneName is optional, may not show in the response.
        if (StringHelper.IsNullOrEmpty(this.Name)) {
            return null;
        }

        let result: TimeZoneInfo = null;

        try {
            result = TimeZoneInfo.FindSystemTimeZoneById(this.Name);
        }
        catch (exception) {
            // Could not find a time zone with that Id on the local system.
        }

        // Again, we cannot accurately convert MeetingTimeZone into TimeZoneInfo
        // because TimeZoneInfo doesn't support absolute date transitions. So if
        // there is no system time zone that has a matching Id, we return null.
        return result;
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.TimeZoneName, this.Name);
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (this.BaseOffset) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.BaseOffset,
                EwsUtilities.TimeSpanToXSDuration(this.BaseOffset));
        }

        if (this.Standard != null) {
            this.Standard.WriteToXml(writer, XmlElementNames.Standard);
        }

        if (this.Daylight != null) {
            this.Daylight.WriteToXml(writer, XmlElementNames.Daylight);
        }
    }
}

/**
 * Represents the normalized body of an item - the HTML fragment representation of the body.
 */
export class NormalizedBody extends ComplexProperty {

    private bodyType: BodyType = BodyType.HTML;
    private text: string = null;
    private isTruncated: boolean = false;

    /**
     * Gets the type of the normalized body's text.
     */
    get BodyType(): BodyType {
        return this.bodyType;
    }
    set BodyType(value: BodyType) {
        this.bodyType = value;
    }

    /**
     * Gets the text of the normalized body.
     */
    get Text(): string {
        return this.text;
    }
    set Text(value: string) {
        this.text = value;
    }

    /**
     * Gets whether the body is truncated.
     */
    get IsTruncated(): boolean {
        return this.isTruncated;
    }
    set IsTruncated(value: boolean) {
        this.isTruncated = value;
    }

    /**
     * Initializes a new instance of the **NormalizedBody** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlAttributeNames.BodyType:
                    this.bodyType = BodyType[<string>jsObject[key]];
                    break;
                case XmlAttributeNames.IsTruncated:
                    this.isTruncated = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.NormalizedBody:
                    this.text = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    ToString(): string { return this.Text || StringHelper.Empty; }
    toString(): string { return this.ToString(); }

    /**
     * @internal Writes attributes to XML.
     * 
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.BodyType, this.BodyType);
    }

    /**
     * @internal Writes elements to XML.
     * 
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (!StringHelper.IsNullOrEmpty(this.Text)) {
            writer.WriteValue(this.Text, XmlElementNames.NormalizedBody);
        }
    }
}

/**
 * Encapsulates information on the occurrence of a recurring appointment.
 */
export class OccurrenceInfo extends ComplexProperty {

    private itemId: ItemId = null;
    private start: DateTime = null;
    private end: DateTime = null;
    private originalStart: DateTime = null;

    /**
     * Gets the Id of the occurrence.
     */
    get ItemId(): ItemId {
        return this.itemId;
    }

    /**
     * Gets the start date and time of the occurrence.
     */
    get Start(): DateTime {
        return this.start;
    }

    /**
     * Gets the end date and time of the occurrence.
     */
    get End(): DateTime {
        return this.end;
    }

    /**
     * Gets the original start date and time of the occurrence.
     */
    get OriginalStart(): DateTime {
        return this.originalStart;
    }

    /**
     *  @internal Initializes a new instance of the **OccurrenceInfo** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.ItemId:
                    this.itemId = new ItemId();
                    this.itemId.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.Start:
                    this.start = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.End:
                    this.end = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.OriginalStart:
                    this.originalStart = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents Lync online meeting settings.
 */
export class OnlineMeetingSettings extends ComplexProperty {

    private lobbyBypass: LobbyBypass = LobbyBypass.Disabled;
    private accessLevel: OnlineMeetingAccessLevel = OnlineMeetingAccessLevel.Locked;
    private presenters: Presenters = Presenters.Disabled;

    /**
     * Gets or sets the online meeting setting that describes whether users dialing in by phone have to wait in the lobby.
     */
    get LobbyBypass(): LobbyBypass {
        return this.lobbyBypass;
    }
    set LobbyBypass(value: LobbyBypass) {
        this.SetFieldValue<LobbyBypass>({ getValue: () => this.lobbyBypass, setValue: (fieldValue) => { this.LobbyBypass = fieldValue } }, value);
    }

    /**
     * Gets or sets the online meeting setting that describes access permission to the meeting.
     */
    get AccessLevel(): OnlineMeetingAccessLevel {
        return this.accessLevel;
    }
    set AccessLevel(value: OnlineMeetingAccessLevel) {
        this.SetFieldValue<OnlineMeetingAccessLevel>({ getValue: () => this.accessLevel, setValue: (fieldValue) => { this.accessLevel = fieldValue } }, value);
    }

    /**
     * Gets or sets the online meeting setting that defines the meeting leaders.
     */
    get Presenters(): Presenters {
        return this.presenters;
    }
    set Presenters(value: Presenters) {
        this.SetFieldValue<Presenters>({ getValue: () => this.presenters, setValue: (fieldValue) => { this.presenters = fieldValue } }, value);
    }

    /**
     * Initializes a new instance of the **OnlineMeetingSettings** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **OnlineMeetingSettings** class from another OnlineMeetingSettings instance.
     *
     * @param   {OnlineMeetingSettings}   onlineMeetingSettings   OnlineMeetingSettings instance to copy.
     */
    constructor(onlineMeetingSettings: OnlineMeetingSettings);
    /**
     * @internal Initializes a new instance of the **OnlineMeetingSettings** class.
     *
     * @param   {LobbyBypass}               lobbyBypass   The address used to initialize the OnlineMeetingSettings.
     * @param   {OnlineMeetingAccessLevel}  accessLevel   The routing type used to initialize the OnlineMeetingSettings.
     * @param   {Presenters}                presenters    Mailbox type of the participant.
     */
    constructor(lobbyBypass: LobbyBypass, accessLevel: OnlineMeetingAccessLevel, presenters: Presenters);
    constructor(lobbyBypassOrOnlineMeetingSettings?: LobbyBypass | OnlineMeetingSettings, accessLevel?: OnlineMeetingAccessLevel, presenters?: Presenters) {
        super();
        switch (arguments.length) {
            case 1:
                let onlineMeetingSettings = <OnlineMeetingSettings>lobbyBypassOrOnlineMeetingSettings;
                EwsUtilities.ValidateParam(lobbyBypassOrOnlineMeetingSettings, "OnlineMeetingSettings");

                this.LobbyBypass = onlineMeetingSettings.LobbyBypass;
                this.AccessLevel = onlineMeetingSettings.AccessLevel;
                this.Presenters = onlineMeetingSettings.Presenters;
                break;
            case 3:
                this.lobbyBypass = <LobbyBypass>lobbyBypassOrOnlineMeetingSettings;
                this.accessLevel = accessLevel;
                this.presenters = presenters;
                break;
            default:
                break;
        }
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.LobbyBypass:
                    this.lobbyBypass = LobbyBypass[<string>jsObject[key]];
                    break;
                case XmlElementNames.AccessLevel:
                    this.accessLevel = OnlineMeetingAccessLevel[<string>jsObject[key]];
                    break;
                case XmlElementNames.Presenters:
                    this.presenters = Presenters[<string>jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LobbyBypass, this.LobbyBypass);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.AccessLevel, this.AccessLevel);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Presenters, this.Presenters);
    }
}

/**
 * Represents PersonaPostalAddress.
 */
export class PersonaPostalAddress extends ComplexProperty {

    private street: string = null;
    private city: string = null;
    private state: string = null;
    private country: string = null;
    private postalCode: string = null;
    private postOfficeBox: string = null;
    private type: string = null;
    private latitude: number = null;
    private longitude: number = null;
    private accuracy: number = null;
    private altitude: number = null;
    private altitudeAccuracy: number = null;
    private formattedAddress: string = null;
    private uri: string = null;
    private source: LocationSource = 0;

    /**
     * Gets or sets the Street.
     */
    get Street(): string {
        return this.street;
    }
    set Street(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.street, setValue: (fieldValue) => { this.street = fieldValue } }, value);
    }

    /**
     * Gets or sets the City.
     */
    get City(): string {
        return this.city;
    }
    set City(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.city, setValue: (fieldValue) => { this.city = fieldValue } }, value);
    }

    /**
     * Gets or sets the state.
     */
    get State(): string {
        return this.state;
    }
    set State(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.state, setValue: (fieldValue) => { this.state = fieldValue } }, value);
    }

    /**
     * Gets or sets the Country.
     */
    get Country(): string {
        return this.country;
    }
    set Country(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.country, setValue: (fieldValue) => { this.country = fieldValue } }, value);
    }

    /**
     * Gets or sets the PostalCode.
     */
    get PostalCode(): string {
        return this.postalCode;
    }
    set PostalCode(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.postalCode, setValue: (fieldValue) => { this.postalCode = fieldValue } }, value);
    }

    /**
     * Gets or sets the PostOfficeBox.
     */
    get PostOfficeBox(): string {
        return this.postOfficeBox;
    }
    set PostOfficeBox(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.postOfficeBox, setValue: (fieldValue) => { this.postOfficeBox = fieldValue } }, value);
    }

    /**
     * Gets or sets the Type.
     */
    get Type(): string {
        return this.type;
    }
    set Type(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.type, setValue: (fieldValue) => { this.type = fieldValue } }, value);
    }

    /**
     * Gets or sets the location source type.
     */
    get Source(): LocationSource {
        return this.source;
    }
    set Source(value: LocationSource) {
        this.SetFieldValue<LocationSource>({ getValue: () => this.source, setValue: (fieldValue) => { this.source = fieldValue } }, value);
    }

    /**
     * Gets or sets the location Uri.
     */
    get Uri(): string {
        return this.uri;
    }
    set Uri(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.uri, setValue: (fieldValue) => { this.uri = fieldValue } }, value);
    }

    /**
     * Gets or sets a value indicating location latitude.
     */
    get Latitude(): number {
        return this.latitude;
    }
    set Latitude(value: number) {
        this.SetFieldValue<number>({ getValue: () => this.latitude, setValue: (fieldValue) => { this.latitude = fieldValue } }, value);
    }

    /**
     * Gets or sets a value indicating location longitude.
     */
    get Longitude(): number {
        return this.longitude;
    }
    set Longitude(value: number) {
        this.SetFieldValue<number>({ getValue: () => this.longitude, setValue: (fieldValue) => { this.longitude = fieldValue } }, value);
    }

    /**
     * Gets or sets the location accuracy.
     */
    get Accuracy(): number {
        return this.accuracy;
    }
    set Accuracy(value: number) {
        this.SetFieldValue<number>({ getValue: () => this.accuracy, setValue: (fieldValue) => { this.accuracy = fieldValue } }, value);
    }

    /**
     * Gets or sets the location altitude.
     */
    get Altitude(): number {
        return this.altitude;
    }
    set Altitude(value: number) {
        this.SetFieldValue<number>({ getValue: () => this.altitude, setValue: (fieldValue) => { this.altitude = fieldValue } }, value);
    }

    /**
     * Gets or sets the location altitude accuracy.
     */
    get AltitudeAccuracy(): number {
        return this.altitudeAccuracy;
    }
    set AltitudeAccuracy(value: number) {
        this.SetFieldValue<number>({ getValue: () => this.altitudeAccuracy, setValue: (fieldValue) => { this.altitudeAccuracy = fieldValue } }, value);
    }

    /**
     * Gets or sets the street address.
     */
    get FormattedAddress(): string {
        return this.formattedAddress;
    }
    set FormattedAddress(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.formattedAddress, setValue: (fieldValue) => { this.formattedAddress = fieldValue } }, value);
    }

    /**
     * @internal Initializes a new instance of the **PersonaPostalAddress** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **PersonaPostalAddress** class.
     *
     * @param   {string}            street             The Street Address.
     * @param   {string}            city               The City value.
     * @param   {string}            state              The State value.
     * @param   {string}            country            The country value.
     * @param   {string}            postalCode         The postal code value.
     * @param   {string}            postOfficeBox      The Post Office Box.
     * @param   {LocationSource}    locationSource     The location Source.
     * @param   {string}            locationUri        The location Uri.
     * @param   {string}            formattedAddress   The location street Address in formatted address.
     * @param   {number}            latitude           The location latitude.
     * @param   {number}            longitude          The location longitude.
     * @param   {number}            accuracy           The location accuracy.
     * @param   {number}            altitude           The location altitude.
     * @param   {number}            altitudeAccuracy   The location altitude Accuracy.
     */
    constructor(street: string, city: string, state: string, country: string, postalCode: string, postOfficeBox: string, locationSource: LocationSource, locationUri: string, formattedAddress: string, latitude: number, longitude: number, accuracy: number, altitude: number, altitudeAccuracy: number);
    constructor(street?: string, city?: string, state?: string, country?: string, postalCode?: string, postOfficeBox?: string, locationSource?: LocationSource, locationUri?: string, formattedAddress?: string, latitude?: number, longitude?: number, accuracy?: number, altitude?: number, altitudeAccuracy?: number) {
        super();
        if (arguments.length === 0) return;

        this.street = street;
        this.city = city;
        this.state = state;
        this.country = country;
        this.postalCode = postalCode;
        this.postOfficeBox = postOfficeBox;
        this.latitude = latitude;
        this.longitude = longitude;
        this.source = locationSource;
        this.uri = locationUri;
        this.formattedAddress = formattedAddress;
        this.accuracy = accuracy;
        this.altitude = altitude;
        this.altitudeAccuracy = altitudeAccuracy;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.Street:
                    this.street = jsObject[key];
                    break;
                case XmlElementNames.City:
                    this.city = jsObject[key];
                    break;
                case XmlElementNames.Country:
                    this.country = jsObject[key];
                    break;
                case XmlElementNames.PostalCode:
                    this.postalCode = jsObject[key];
                    break;
                case XmlElementNames.PostOfficeBox:
                    this.postOfficeBox = jsObject[key];
                    break;
                case XmlElementNames.PostalAddressType:
                    this.type = jsObject[key];
                    break;
                case XmlElementNames.Latitude:
                    this.latitude = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.Longitude:
                    this.longitude = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.Accuracy:
                    this.accuracy = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.Altitude:
                    this.altitude = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.AltitudeAccuracy:
                    this.altitudeAccuracy = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.FormattedAddress:
                    this.formattedAddress = jsObject[key];
                    break;
                case XmlElementNames.LocationUri:
                    this.uri = jsObject[key];
                    break;
                case XmlElementNames.LocationSource:
                    this.source = LocationSource[<string>jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Street, this.street);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.City, this.city);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.State, this.state);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Country, this.country);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.PostalCode, this.postalCode);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.PostOfficeBox, this.postOfficeBox);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.PostalAddressType, this.type);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Latitude, this.latitude);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Longitude, this.longitude);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Accuracy, this.accuracy);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Altitude, this.altitude);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.AltitudeAccuracy, this.altitudeAccuracy);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FormattedAddress, this.formattedAddress);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LocationUri, this.uri);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LocationSource, this.source);
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.PersonaPostalAddress);

        this.WriteElementsToXml(writer);

        writer.WriteEndElement(); // xmlElementName
    }
}

/**
 * Represents a rule that automatically handles incoming messages.
 * A rule consists of a set of conditions and exceptions that determine whether or not a set of actions should be executed on incoming messages.
 * 
 * @sealed
 */
export class Rule extends ComplexProperty {

	/**
	 * The rule ID.
	 */
	private ruleId: string = null;

	/**
	 * The rule display name.
	 */
	private displayName: string = null;

	/**
	 * The rule priority.
	 */
	private priority: number = 0;

	/**
	 * The rule status of enabled or not.
	 */
	private isEnabled: boolean = false;

	/**
	 * The rule status of is supported or not.
	 */
	private isNotSupported: boolean = false;

	/**
	 * The rule status of in error or not.
	 */
	private isInError: boolean = false;

	/**
	 * The rule conditions. 
	 */
	private conditions: RulePredicates = null;

	/**
	 * The rule actions. 
	 */
	private actions: RuleActions = null;

	/**
	 * The rule exceptions. 
	 */
	private exceptions: RulePredicates = null;

	/**
	 * Gets or sets the Id of this rule.
	 */
	get Id(): string {
		return this.ruleId;
	}
	set Id(value: string) {
		this.SetFieldValue<string>({ getValue: () => this.Id, setValue: (updateValue) => { this.Id = updateValue } }, value);
	}

	/**
	 * Gets or sets the name of this rule as it should be displayed to the user.
	 */
	get DisplayName(): string {
		return this.displayName;
	}
	set DisplayName(value: string) {
		this.SetFieldValue<string>({ getValue: () => this.displayName, setValue: (updateValue) => { this.displayName = updateValue } }, value);
	}

	/**
	 * Gets or sets the priority of this rule, which determines its execution order.
	 */
	get Priority(): number {
		return this.priority;
	}
	set Priority(value: number) {
		this.SetFieldValue<number>({ getValue: () => this.priority, setValue: (updateValue) => { this.priority = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether this rule is enabled.
	 */
	get IsEnabled(): boolean {
		return this.isEnabled;
	}
	set IsEnabled(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isEnabled, setValue: (updateValue) => { this.isEnabled = updateValue } }, value);
	}

	/**
	 * Gets a value indicating whether this rule can be modified via EWS. If IsNotSupported is true, the rule cannot be modified via EWS.
	 */
	get IsNotSupported(): boolean {
		return this.isNotSupported;
	}

	/**
	 * Gets or sets a value indicating whether this rule has errors. A rule that is in error cannot be processed unless it is updated and the error is corrected.
	 */
	get IsInError(): boolean {
		return this.isInError;
	}
	set IsInError(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isInError, setValue: (updateValue) => { this.isInError = updateValue } }, value);
	}

	/**
	 * Gets the conditions that determine whether or not this rule should be executed against incoming messages.
	 */
	get Conditions(): RulePredicates {
		return this.conditions;
	}

	/**
	 * Gets the actions that should be executed against incoming messages if the conditions evaluate as true.
	 */
	get Actions(): RuleActions {
		return this.actions;
	}

	/**
	 * Gets the exceptions that determine if this rule should be skipped even if its conditions evaluate to true.
	 */
	get Exceptions(): RulePredicates {
		return this.exceptions;
	}

	/**
	 * Initializes a new instance of the **Rule** class.
	 */
	constructor() {
		super();
		//// New rule has priority as 0 by default //todo: fix 0 or 1 when it it changes in offical repo
		this.priority = 1;
		//// New rule is enabled by default
		this.isEnabled = true;
		this.conditions = new RulePredicates();
		this.actions = new RuleActions();
		this.exceptions = new RulePredicates();
	}

	/**
	 * @internal Validates this instance.
	 */
	InternalValidate(): void {
		super.InternalValidate();
		EwsUtilities.ValidateParam(this.displayName, "DisplayName");
		EwsUtilities.ValidateParam(this.conditions, "Conditions");
		EwsUtilities.ValidateParam(this.exceptions, "Exceptions");
		EwsUtilities.ValidateParam(this.actions, "Actions");
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		for (let key in jsObject) {
			switch (key) {
				case XmlElementNames.DisplayName:
					this.displayName = jsObject[key];
					break;
				case XmlElementNames.RuleId:
					this.ruleId = jsObject[key];
					break;
				case XmlElementNames.Priority:
					this.priority = Convert.toNumber(jsObject[key]);
					break;
				case XmlElementNames.IsEnabled:
					this.isEnabled = Convert.toBool(jsObject[key]);
					break;
				case XmlElementNames.IsNotSupported:
					this.isNotSupported = Convert.toBool(jsObject[key]);
					break;
				case XmlElementNames.IsInError:
					this.isInError = Convert.toBool(jsObject[key]);
					break;
				case XmlElementNames.Conditions:
					this.conditions.LoadFromXmlJsObject(jsObject[key], service);
					break;
				case XmlElementNames.Actions:
					this.actions.LoadFromXmlJsObject(jsObject[key], service);
					break;
				case XmlElementNames.Exceptions:
					this.exceptions.LoadFromXmlJsObject(jsObject[key], service);
					break;
				default:
					break;
			}
		}
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		if (!StringHelper.IsNullOrEmpty(this.Id)) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.RuleId,
				this.Id);
		}

		writer.WriteElementValue(
			XmlNamespace.Types,
			XmlElementNames.DisplayName,
			this.DisplayName);
		writer.WriteElementValue(
			XmlNamespace.Types,
			XmlElementNames.Priority,
			this.Priority);
		writer.WriteElementValue(
			XmlNamespace.Types,
			XmlElementNames.IsEnabled,
			this.IsEnabled);
		writer.WriteElementValue(
			XmlNamespace.Types,
			XmlElementNames.IsInError,
			this.IsInError);
		this.Conditions.WriteToXml(writer, XmlElementNames.Conditions);
		this.Exceptions.WriteToXml(writer, XmlElementNames.Exceptions);
		this.Actions.WriteToXml(writer, XmlElementNames.Actions);
	}
}

/**
 * Represents the set of actions available for a rule.
 * 
 * @sealed
 */
export class RuleActions extends ComplexProperty {

	/**
	 * SMS recipient address type.
	 */
	private static MobileType: string = "MOBILE";

	/**
	 * The AssignCategories action.
	 */
	private assignCategories: StringList = null;

	/**
	 * The CopyToFolder action.
	 */
	private copyToFolder: FolderId = null;

	/**
	 * The Delete action.
	 */
	private delete: boolean = false;

	/**
	 * The ForwardAsAttachmentToRecipients action.
	 */
	private forwardAsAttachmentToRecipients: EmailAddressCollection = null;

	/**
	 * The ForwardToRecipients action.
	 */
	private forwardToRecipients: EmailAddressCollection = null;

	/**
	 * The MarkImportance action.
	 */
	private markImportance: Importance = null; //Nullable

	/**
	 * The MarkAsRead action.
	 */
	private markAsRead: boolean = false;

	/**
	 * The MoveToFolder action.
	 */
	private moveToFolder: FolderId = null;

	/**
	 * The PermanentDelete action.
	 */
	private permanentDelete: boolean = false;

	/**
	 * The RedirectToRecipients action.
	 */
	private redirectToRecipients: EmailAddressCollection = null;

	/**
	 * The SendSMSAlertToRecipients action.
	 */
	private sendSMSAlertToRecipients: MobilePhone[] = null;

	/**
	 * The ServerReplyWithMessage action.
	 */
	private serverReplyWithMessage: ItemId = null;

	/**
	 * The StopProcessingRules action.
	 */
	private stopProcessingRules: boolean = false;

	/**
	 * Gets the categories that should be stamped on incoming messages.
	 * To disable stamping incoming messages with categories, set AssignCategories to null.
	 */
	get AssignCategories(): StringList {
		return this.assignCategories;
	}

	/**
	 * Gets or sets the Id of the folder incoming messages should be copied to.
	 * To disable copying incoming messages to a folder, set CopyToFolder to null.
	 */
	get CopyToFolder(): FolderId {
		return this.copyToFolder;
	}
	set CopyToFolder(value: FolderId) {
		this.SetFieldValue<FolderId>({ getValue: () => this.copyToFolder, setValue: (updateValue) => { this.copyToFolder = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages should be automatically moved to the Deleted Items folder.
	 */
	get Delete(): boolean {
		return this.delete;
	}
	set Delete(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.delete, setValue: (updateValue) => { this.delete = updateValue } }, value);
	}

	/**
	 * Gets the e-mail addresses to which incoming messages should be forwarded as attachments. 
	 * To disable forwarding incoming messages as attachments, empty the ForwardAsAttachmentToRecipients list.
	 */
	get ForwardAsAttachmentToRecipients(): EmailAddressCollection {
		return this.forwardAsAttachmentToRecipients;
	}

	/**
	 * Gets the e-mail addresses to which incoming messages should be forwarded. 
	 * To disable forwarding incoming messages, empty the ForwardToRecipients list.
	 */
	get ForwardToRecipients(): EmailAddressCollection {
		return this.forwardToRecipients;
	}

	/**
	 * @Nullable Gets or sets the importance that should be stamped on incoming messages. 
	 * To disable the stamping of incoming messages with an importance, set MarkImportance to null.
	 */
	get MarkImportance(): Importance {
		return this.markImportance;
	}
	set MarkImportance(value: Importance) {
		this.SetFieldValue<Importance>({ getValue: () => this.markImportance, setValue: (updateValue) => { this.markImportance = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages should be marked as read.
	 */
	get MarkAsRead(): boolean {
		return this.markAsRead;
	}
	set MarkAsRead(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.markAsRead, setValue: (updateValue) => { this.markAsRead = updateValue } }, value);
	}

	/**
	 * Gets or sets the Id of the folder to which incoming messages should be moved.
	 * To disable the moving of incoming messages to a folder, set CopyToFolder to null.
	 */
	get MoveToFolder(): FolderId {
		return this.moveToFolder;
	}
	set MoveToFolder(value: FolderId) {
		this.SetFieldValue<FolderId>({ getValue: () => this.moveToFolder, setValue: (updateValue) => { this.moveToFolder = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages should be permanently deleted. When a message is permanently deleted, it is never saved into the recipient's mailbox. To delete a message after it has been saved into the recipient's mailbox, use the Delete action.
	 */
	get PermanentDelete(): boolean {
		return this.permanentDelete;
	}
	set PermanentDelete(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.permanentDelete, setValue: (updateValue) => { this.permanentDelete = updateValue } }, value);
	}

	/**
	 * Gets the e-mail addresses to which incoming messages should be redirecteded. 
	 * To disable redirection of incoming messages, empty the RedirectToRecipients list. Unlike forwarded mail, redirected mail maintains the original sender and recipients. 
	 */
	get RedirectToRecipients(): EmailAddressCollection {
		return this.redirectToRecipients;
	}

	/**
	 * Gets the phone numbers to which an SMS alert should be sent. 
	 * To disable sending SMS alerts for incoming messages, empty the SendSMSAlertToRecipients list.
	 */
	get SendSMSAlertToRecipients(): MobilePhone[] {
		return this.sendSMSAlertToRecipients;
	}

	/**
	 * Gets or sets the Id of the template message that should be sent as a reply to incoming messages. 
	 * To disable automatic replies, set ServerReplyWithMessage to null. 
	 */
	get ServerReplyWithMessage(): ItemId {
		return this.serverReplyWithMessage;
	}
	set ServerReplyWithMessage(value: ItemId) {
		this.SetFieldValue<ItemId>({ getValue: () => this.serverReplyWithMessage, setValue: (updateValue) => { this.serverReplyWithMessage = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether subsequent rules should be evaluated. 
	 */
	get StopProcessingRules(): boolean {
		return this.stopProcessingRules;
	}
	set StopProcessingRules(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.stopProcessingRules, setValue: (updateValue) => { this.stopProcessingRules = updateValue } }, value);
	}

	/**
	 * @internal Initializes a new instance of the **RuleActions** class.
	 */
	constructor() {
		super();
		this.assignCategories = new StringList();
		this.forwardAsAttachmentToRecipients = new EmailAddressCollection(XmlElementNames.Address);
		this.forwardToRecipients = new EmailAddressCollection(XmlElementNames.Address);
		this.redirectToRecipients = new EmailAddressCollection(XmlElementNames.Address);
		this.sendSMSAlertToRecipients = [];
	}

	/**
	 * Convert the SMS recipient list from EmailAddressCollection type to MobilePhone collection type.
	 *
	 * @param   {EmailAddressCollection}   emailCollection   Recipient list in EmailAddressCollection type.
	 * @return  {MobilePhone[]}		A MobilePhone collection object containing all SMS recipient in MobilePhone type.
	 */
	private static ConvertSMSRecipientsFromEmailAddressCollectionToMobilePhoneCollection(emailCollection: EmailAddressCollection): MobilePhone[] {
		let mobilePhoneCollection: MobilePhone[] = [];
		for (let emailAddress of emailCollection.Items) {
			mobilePhoneCollection.push(new MobilePhone(emailAddress.Name, emailAddress.Address));
		}

		return mobilePhoneCollection;
	}

	/**
	 * Convert the SMS recipient list from MobilePhone collection type to EmailAddressCollection type.
	 *
	 * @param   {MobilePhone[]}   recipientCollection   Recipient list in a MobilePhone collection type.
	 * @return  {EmailAddressCollection}		An EmailAddressCollection object containing recipients with "MOBILE" address type.
	 */
	private static ConvertSMSRecipientsFromMobilePhoneCollectionToEmailAddressCollection(recipientCollection: MobilePhone[]): EmailAddressCollection {
		let emailCollection: EmailAddressCollection = new EmailAddressCollection(XmlElementNames.Address);
		for (let recipient of recipientCollection) {
			let emailAddress: EmailAddress = new EmailAddress(
				recipient.Name,
				recipient.PhoneNumber,
				RuleActions.MobileType);
			emailCollection.Add(emailAddress);
		}

		return emailCollection;
	}

	/**
	 * @internal Validates this instance.
	 */
	InternalValidate(): void {
		super.InternalValidate();
		EwsUtilities.ValidateParam(this.forwardAsAttachmentToRecipients, "ForwardAsAttachmentToRecipients");
		EwsUtilities.ValidateParam(this.forwardToRecipients, "ForwardToRecipients");
		EwsUtilities.ValidateParam(this.redirectToRecipients, "RedirectToRecipients");
		for (let sendSMSAlertToRecipient of this.sendSMSAlertToRecipients) {
			EwsUtilities.ValidateParam(sendSMSAlertToRecipient, "SendSMSAlertToRecipient");
		}
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		for (let key in jsObject) {
			switch (key) {
				case XmlElementNames.AssignCategories:
					this.assignCategories.LoadFromXmlJsObject(jsObject[key], service);
					break;
				case XmlElementNames.CopyToFolder:
					this.copyToFolder = new FolderId();
					this.copyToFolder.LoadFromXmlJsObject(jsObject[key][XmlElementNames.FolderId], service);
					break;
				case XmlElementNames.Delete:
					this.delete = Convert.toBool(jsObject[key]);
					break;
				case XmlElementNames.ForwardAsAttachmentToRecipients:
					this.forwardAsAttachmentToRecipients.LoadFromXmlJsObject(jsObject[key][XmlElementNames.Address], service);
					break;
				case XmlElementNames.ForwardToRecipients:
					this.forwardToRecipients.LoadFromXmlJsObject(jsObject[key][XmlElementNames.Address], service);
					break;
				case XmlElementNames.MarkImportance:
					this.markImportance = Importance[<string>jsObject[key]];
					break;
				case XmlElementNames.MarkAsRead:
					this.markAsRead = Convert.toBool(jsObject[key]);
					break;
				case XmlElementNames.MoveToFolder:
					this.moveToFolder = new FolderId();
					this.moveToFolder.LoadFromXmlJsObject(jsObject[key][XmlElementNames.FolderId], service)
					break;
				case XmlElementNames.PermanentDelete:
					this.permanentDelete = Convert.toBool(jsObject[key]);
					break;
				case XmlElementNames.RedirectToRecipients:
					this.redirectToRecipients.LoadFromXmlJsObject(jsObject[key][XmlElementNames.Address], service);
					break;
				case XmlElementNames.SendSMSAlertToRecipients:
					let smsRecipientCollection: EmailAddressCollection = new EmailAddressCollection(XmlElementNames.Address);
					smsRecipientCollection.LoadFromXmlJsObject(jsObject[key][XmlElementNames.Address], service);
					this.sendSMSAlertToRecipients = RuleActions.ConvertSMSRecipientsFromEmailAddressCollectionToMobilePhoneCollection(smsRecipientCollection);
					break;
				case XmlElementNames.ServerReplyWithMessage:
					this.serverReplyWithMessage = new ItemId();
					this.serverReplyWithMessage.LoadFromXmlJsObject(jsObject[key][XmlElementNames.ItemId], service);
					break;
				case XmlElementNames.StopProcessingRules:
					this.stopProcessingRules = Convert.toBool(jsObject[key]);
					break;
				default:
					break;
			}
		}
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		if (this.AssignCategories.Count > 0) {
			this.AssignCategories.WriteToXml(writer, XmlElementNames.AssignCategories);
		}

		if (this.CopyToFolder != null) {
			writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.CopyToFolder);
			this.CopyToFolder.WriteToXml(writer);
			writer.WriteEndElement();
		}

		if (this.Delete != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.Delete,
				this.Delete);
		}

		if (this.ForwardAsAttachmentToRecipients.Count > 0) {
			this.ForwardAsAttachmentToRecipients.WriteToXml(writer, XmlElementNames.ForwardAsAttachmentToRecipients);
		}

		if (this.ForwardToRecipients.Count > 0) {
			this.ForwardToRecipients.WriteToXml(writer, XmlElementNames.ForwardToRecipients);
		}

		if (hasValue(this.MarkImportance)) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.MarkImportance,
				Importance[this.MarkImportance]);
		}

		if (this.MarkAsRead != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.MarkAsRead,
				this.MarkAsRead);
		}

		if (this.MoveToFolder != null) {
			writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MoveToFolder);
			this.MoveToFolder.WriteToXml(writer);
			writer.WriteEndElement();
		}

		if (this.PermanentDelete != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.PermanentDelete,
				this.PermanentDelete);
		}

		if (this.RedirectToRecipients.Count > 0) {
			this.RedirectToRecipients.WriteToXml(writer, XmlElementNames.RedirectToRecipients);
		}

		if (this.SendSMSAlertToRecipients.length > 0) {
			let emailCollection: EmailAddressCollection = RuleActions.ConvertSMSRecipientsFromMobilePhoneCollectionToEmailAddressCollection(this.SendSMSAlertToRecipients);
			emailCollection.WriteToXml(writer, XmlElementNames.SendSMSAlertToRecipients);
		}

		if (this.ServerReplyWithMessage != null) {
			this.ServerReplyWithMessage.WriteToXml(writer, XmlElementNames.ServerReplyWithMessage);
		}

		if (this.StopProcessingRules != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.StopProcessingRules,
				this.StopProcessingRules);
		}
	}
}

/**
 * Represents a collection of rules.
 * 
 * @sealed
 */
export class RuleCollection extends ComplexProperty implements IEnumerable<Rule> {

	/**
	 * The OutlookRuleBlobExists flag.
	 */
	private outlookRuleBlobExists: boolean = false;

	/**
	 * The rules in the rule collection.
	 */
	private rules: Rule[] = null;

	/**
	 * Gets a value indicating whether an Outlook rule blob exists in the user's mailbox. To update rules with EWS when the Outlook rule blob exists, call SetInboxRules passing true as the value of the removeOutlookBlob parameter.
	 */
	get OutlookRuleBlobExists(): boolean {
		return this.outlookRuleBlobExists;
	}
	set OutlookRuleBlobExists(value: boolean) {
		this.outlookRuleBlobExists = value;
	}

	/**
	 * Gets the number of rules in this collection.
	 */
	get Count(): number {
		return this.rules.length;
	}

	/**
     * Gets the rule at the specified index in the collection.
     *
     * @param   {number}   index   The index of the rule to get.
     * @return  {Rule}	The rule at the specified index.
     */
	_getItem(index: number): Rule {
		if (index < 0 || index >= this.rules.length) {
			throw new ArgumentOutOfRangeException("Index");
		}
		return this.rules[index];
	}

	/**
	 * @internal Initializes a new instance of the **RuleCollection** class.
	 */
	constructor() {
		super();
		this.rules = [];
	}

	/**
     *  Returns an enumerator that iterates through the collection. this case this.rules
     */
	GetEnumerator(): Rule[] {
		return this.rules;
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
	LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		let jsRules = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.Rule);
		for (let jsRule of jsRules) {
			let rule: Rule = new Rule();
			rule.LoadFromXmlJsObject(jsRule, service)
			this.rules.push(rule);
		}
	}
}

/**
 * Represents an error that occurred as a result of executing a rule operation. 
 * 
 * @sealed
 */
export class RuleError extends ComplexProperty {

	/**
	 * Rule property.
	 */
	private ruleProperty: RuleProperty = RuleProperty.RuleId;

	/**
	 * Rule validation error code.
	 */
	private errorCode: RuleErrorCode = RuleErrorCode.ADOperationFailure;

	/**
	 * Error message.
	 */
	private errorMessage: string = null;

	/**
	 * Field value.
	 */
	private value: string = null;

	/**
	 * Gets the property which failed validation.
	 */
	get RuleProperty(): RuleProperty {
		return this.ruleProperty;
	}

	/**
	 * Gets the validation error code.
	 */
	get ErrorCode(): RuleErrorCode {
		return this.errorCode;
	}

	/**
	 * Gets the error message.
	 */
	get ErrorMessage(): string {
		return this.errorMessage;
	}

	/**
	 * Gets the value that failed validation.
	 */
	get Value(): string {
		return this.value;
	}

	/**
	 * @internal Initializes a new instance of the **RuleError** class.
	 */
	constructor() {
		super();
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		for (let key in jsObject) {
			switch (key) {
				case XmlElementNames.FieldURI:
                    this.ruleProperty = RuleProperty[<string>jsObject[key]];
                    break;
                case XmlElementNames.ErrorCode:
                    this.errorCode = RuleErrorCode[<string>jsObject[key]];
                    break;
                case XmlElementNames.ErrorMessage:
                    this.errorMessage = jsObject[key];
                    break;
                case XmlElementNames.FieldValue:
                    this.value = jsObject[key];
                    break;
                default:
                    break;
			}
		}
	}
}

/**
 * Represents an error that occurred while processing a rule operation.
 * 
 * @sealed
 */
export class RuleOperationError extends ComplexProperty implements IEnumerable<RuleError>{


	/**
	 * Index of the operation mapping to the error.
	 */
	private operationIndex: number = 0;

	/**
	 * RuleOperation object mapping to the error.
	 */
	private operation: RuleOperation = null;

	/**
	 * RuleError Collection.
	 */
	private ruleErrors: RuleErrorCollection = null;

	/**
	 * Gets the operation that resulted in an error.
	 */
	get Operation(): RuleOperation {
		return this.operation;
	}

	/**
	 * Gets the number of rule errors in the list.
	 */
	get Count(): number {
		return this.ruleErrors.Count;
	}

	/**
     * Gets the rule error at the specified index.
     *
     * @param   {number}   index   The index of the rule error to get.
     * @return  {RuleError}	The rule error at the specified index.
     */
	_getItem(index: number): RuleError {
		if (index < 0 || index >= this.ruleErrors.Count) {
			throw new ArgumentOutOfRangeException("Index");
		}
		return this.ruleErrors._getItem(index);
	}

	/**
	 * @internal Initializes a new instance of the **RuleOperationError** class.
	 */
	constructor() {
		super();
	}

	/**
     *  Returns an enumerator that iterates through the collection. this case this.rules
     */
	GetEnumerator(): RuleError[] {
		return this.ruleErrors.GetEnumerator();
	}

	/**
	 * @internal Set operation property by the index of a given opeation enumerator.
	 *
	 * @param   {RuleOperation[]}   operations   Operation enumerator.
	 */
	SetOperationByIndex(operations: RuleOperation[]): void {

		this.operation = operations[this.operationIndex];
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
	LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		for (let key in jsObject) {
			switch (key) {
				case XmlElementNames.OperationIndex:
					this.operationIndex = Convert.toNumber(jsObject[key]);
					break;
				case XmlElementNames.ValidationErrors:
					this.ruleErrors = new RuleErrorCollection();
					this.ruleErrors.CreateFromXmlJsObjectCollection(jsObject[key], service);
					break;
				default:
					break;
			}
		}
	}
}

/**
 * Represents the date and time range within which messages have been received.
 * 
 * @sealed
 */
export class RulePredicateDateRange extends ComplexProperty {

	/**
	 * The start DateTime.
	 */
	private start: DateTime = null; //Nullable

	/**
	 * The end DateTime.
	 */
	private end: DateTime = null; //Nullable

	/**
	 * @Nullable Gets or sets the range start date and time. 
	 * If Start is set to null, no start date applies.
	 */
	get Start(): DateTime {
		return this.start;
	}
	set Start(value: DateTime) {
		this.SetFieldValue<DateTime>({ getValue: () => this.start, setValue: (updateValue) => { this.start = updateValue } }, value);
	}

	/**
	 * @Nullable Gets or sets the range end date and time. 
	 * If End is set to null, no end date applies.
	 */
	get End(): DateTime {
		return this.end;
	}
	set End(value: DateTime) {
		this.SetFieldValue<DateTime>({ getValue: () => this.end, setValue: (updateValue) => { this.end = updateValue } }, value);
	}

	/**
	 * @internal Initializes a new instance of the **RulePredicateDateRange** class.
	 */
	constructor() {
		super();
	}

	/**
	 * @internal Validates this instance.
	 */
	InternalValidate(): void {
		super.InternalValidate();
		if (this.start &&
			this.end &&
			this.start.TotalMilliSeconds > this.end.TotalMilliSeconds) {
			throw new ServiceValidationException("Start date time cannot be bigger than end date time.");
		}
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		for (let key in jsObject) {
			switch (key) {
				case XmlElementNames.StartDateTime:
					this.start = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.EndDateTime:
                    this.end = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
					break;
                default:
                    break;
			}
		}
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		if (this.Start) {
			writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.StartDateTime, this.Start);
		}
		if (this.End) {
			writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EndDateTime, this.End);
		}
	}
}

/**
 * Represents the set of conditions and exceptions available for a rule.
 * 
 * @sealed
 */
export class RulePredicates extends ComplexProperty {

	/**
	 * The HasCategories predicate.
	 */
	private categories: StringList = null;
	/**
	 * The ContainsBodyStrings predicate.
	 */
	private containsBodyStrings: StringList = null;
	/**
	 * The ContainsHeaderStrings predicate.
	 */
	private containsHeaderStrings: StringList = null;
	/**
	 * The ContainsRecipientStrings predicate.
	 */
	private containsRecipientStrings: StringList = null;
	/**
	 * The ContainsSenderStrings predicate.
	 */
	private containsSenderStrings: StringList = null;
	/**
	 * The ContainsSubjectOrBodyStrings predicate.
	 */
	private containsSubjectOrBodyStrings: StringList = null;
	/**
	 * The ContainsSubjectStrings predicate.
	 */
	private containsSubjectStrings: StringList = null;
	/**
	 * The FlaggedForAction predicate.
	 */
	private flaggedForAction: FlaggedForAction = null; //Nullable
	/**
	 * The FromAddresses predicate.
	 */
	private fromAddresses: EmailAddressCollection = null;
	/**
	 * The FromConnectedAccounts predicate.
	 */
	private fromConnectedAccounts: StringList = null;
	/**
	 * The HasAttachments predicate.
	 */
	private hasAttachments: boolean = false;
	/**
	 * The Importance predicate.
	 */
	private importance: Importance = null; //Nullable
	/**
	 * The IsApprovalRequest predicate.
	 */
	private isApprovalRequest: boolean = false;
	/**
	 * The IsAutomaticForward predicate.
	 */
	private isAutomaticForward: boolean = false;
	/**
	 * The IsAutomaticReply predicate.
	 */
	private isAutomaticReply: boolean = false;
	/**
	 * The IsEncrypted predicate.
	 */
	private isEncrypted: boolean = false;
	/**
	 * The IsMeetingRequest predicate.
	 */
	private isMeetingRequest: boolean = false;
	/**
	 * The IsMeetingResponse predicate.
	 */
	private isMeetingResponse: boolean = false;
	/**
	 * The IsNDR predicate.
	 */
	private isNonDeliveryReport: boolean = false;
	/**
	 * The IsPermissionControlled predicate.
	 */
	private isPermissionControlled: boolean = false;
	/**
	 * The IsSigned predicate.
	 */
	private isSigned: boolean = false;
	/**
	 * The IsVoicemail predicate.
	 */
	private isVoicemail: boolean = false;
	/**
	 * The IsReadReceipt predicate.
	 */
	private isReadReceipt: boolean = false;
	/**
	 * The ItemClasses predicate.
	 */
	private itemClasses: StringList = null;
	/**
	 * The MessageClassifications predicate.
	 */
	private messageClassifications: StringList = null;
	/**
	 * The NotSentToMe predicate.
	 */
	private notSentToMe: boolean = false;
	/**
	 * The SentCcMe predicate.
	 */
	private sentCcMe: boolean = false;
	/**
	 * The SentOnlyToMe predicate.
	 */
	private sentOnlyToMe: boolean = false;
	/**
	 * The SentToAddresses predicate.
	 */
	private sentToAddresses: EmailAddressCollection = null;
	/**
	 * The SentToMe predicate.
	 */
	private sentToMe: boolean = false;
	/**
	 * The SentToOrCcMe predicate.
	 */
	private sentToOrCcMe: boolean = false;
	/**
	 * The Sensitivity predicate.
	 */
	private sensitivity: Sensitivity = null; //Nullable
	/**
	 * The WithinDateRange predicate.
	 */
	private withinDateRange: RulePredicateDateRange = null;
	/**
	 * The WithinSizeRange predicate.
	 */
	private withinSizeRange: RulePredicateSizeRange = null;

	/**
	 * Gets the categories that an incoming message should be stamped with for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get Categories(): StringList {
		return this.categories;
	}

	/**
	 * Gets the strings that should appear in the body of incoming messages for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get ContainsBodyStrings(): StringList {
		return this.containsBodyStrings;
	}

	/**
	 * Gets the strings that should appear in the headers of incoming messages for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get ContainsHeaderStrings(): StringList {
		return this.containsHeaderStrings;
	}

	/**
	 * Gets the strings that should appear in either the To or Cc fields of incoming messages for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get ContainsRecipientStrings(): StringList {
		return this.containsRecipientStrings;
	}

	/**
	 * Gets the strings that should appear in the From field of incoming messages for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get ContainsSenderStrings(): StringList {
		return this.containsSenderStrings;
	}

	/**
	 * Gets the strings that should appear in either the body or the subject of incoming messages for the condition or exception to apply.
	 * To disable this predicate, empty the list.
	 */
	get ContainsSubjectOrBodyStrings(): StringList {
		return this.containsSubjectOrBodyStrings;
	}

	/**
	 * Gets the strings that should appear in the subject of incoming messages for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get ContainsSubjectStrings(): StringList {
		return this.containsSubjectStrings;
	}

	/**
	 * @Nullable Gets or sets the flag for action value that should appear on incoming messages for the condition or execption to apply. 
	 * To disable this predicate, set it to null. 
	 */
	get FlaggedForAction(): FlaggedForAction {
		return this.flaggedForAction;
	}
	set FlaggedForAction(value: FlaggedForAction) {
		this.SetFieldValue<FlaggedForAction>({ getValue: () => this.flaggedForAction, setValue: (updateValue) => { this.flaggedForAction = updateValue } }, value);
	}

	/**
	 * Gets the e-mail addresses of the senders of incoming messages for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get FromAddresses(): EmailAddressCollection {
		return this.fromAddresses;
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must have attachments for the condition or exception to apply. 
	 */
	get HasAttachments(): boolean {
		return this.hasAttachments;
	}
	set HasAttachments(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.hasAttachments, setValue: (updateValue) => { this.hasAttachments = updateValue } }, value);
	}

	/**
	 * @Nullable Gets or sets the importance that should be stamped on incoming messages for the condition or exception to apply. 
	 * To disable this predicate, set it to null.
	 */
	get Importance(): Importance {
		return this.importance;
	}
	set Importance(value: Importance) {
		this.SetFieldValue<Importance>({ getValue: () => this.importance, setValue: (updateValue) => { this.importance = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be approval requests for the condition or exception to apply. 
	 */
	get IsApprovalRequest(): boolean {
		return this.isApprovalRequest;
	}
	set IsApprovalRequest(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isApprovalRequest, setValue: (updateValue) => { this.isApprovalRequest = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be automatic forwards for the condition or exception to apply.
	 */
	get IsAutomaticForward(): boolean {
		return this.isAutomaticForward;
	}
	set IsAutomaticForward(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isAutomaticForward, setValue: (updateValue) => { this.isAutomaticForward = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be automatic replies for the condition or exception to apply. 
	 */
	get IsAutomaticReply(): boolean {
		return this.isAutomaticReply;
	}
	set IsAutomaticReply(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isAutomaticReply, setValue: (updateValue) => { this.isAutomaticReply = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be S/MIME encrypted for the condition or exception to apply.
	 */
	get IsEncrypted(): boolean {
		return this.isEncrypted;
	}
	set IsEncrypted(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isEncrypted, setValue: (updateValue) => { this.isEncrypted = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be meeting requests for the condition or exception to apply. 
	 */
	get IsMeetingRequest(): boolean {
		return this.isMeetingRequest;
	}
	set IsMeetingRequest(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isMeetingRequest, setValue: (updateValue) => { this.isMeetingRequest = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be meeting responses for the condition or exception to apply. 
	 */
	get IsMeetingResponse(): boolean {
		return this.isMeetingResponse;
	}
	set IsMeetingResponse(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isMeetingResponse, setValue: (updateValue) => { this.isMeetingResponse = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be non-delivery reports (NDR) for the condition or exception to apply.
	 */
	get IsNonDeliveryReport(): boolean {
		return this.isNonDeliveryReport;
	}
	set IsNonDeliveryReport(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isNonDeliveryReport, setValue: (updateValue) => { this.isNonDeliveryReport = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be permission controlled (RMS protected) for the condition or exception to apply. 
	 */
	get IsPermissionControlled(): boolean {
		return this.isPermissionControlled;
	}
	set IsPermissionControlled(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isPermissionControlled, setValue: (updateValue) => { this.isPermissionControlled = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be S/MIME signed for the condition or exception to apply. 
	 */
	get IsSigned(): boolean {
		return this.isSigned;
	}
	set IsSigned(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isSigned, setValue: (updateValue) => { this.isSigned = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be voice mails for the condition or exception to apply. 
	 */
	get IsVoicemail(): boolean {
		return this.isVoicemail;
	}
	set IsVoicemail(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isVoicemail, setValue: (updateValue) => { this.isVoicemail = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether incoming messages must be read receipts for the condition or exception to apply. 
	 */
	get IsReadReceipt(): boolean {
		return this.isReadReceipt;
	}
	set IsReadReceipt(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.isReadReceipt, setValue: (updateValue) => { this.isReadReceipt = updateValue } }, value);
	}

	/**
	 * Gets the e-mail account names from which incoming messages must have been aggregated for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get FromConnectedAccounts(): StringList {
		return this.fromConnectedAccounts;
	}

	/**
	 * Gets the item classes that must be stamped on incoming messages for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get ItemClasses(): StringList {
		return this.itemClasses;
	}

	/**
	 * Gets the message classifications that must be stamped on incoming messages for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get MessageClassifications(): StringList {
		return this.messageClassifications;
	}

	/**
	 * Gets or sets a value indicating whether the owner of the mailbox must NOT be a To recipient of the incoming messages for the condition or exception to apply.
	 */
	get NotSentToMe(): boolean {
		return this.notSentToMe;
	}
	set NotSentToMe(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.notSentToMe, setValue: (updateValue) => { this.notSentToMe = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether the owner of the mailbox must be a Cc recipient of incoming messages for the condition or exception to apply.
	 */
	get SentCcMe(): boolean {
		return this.sentCcMe;
	}
	set SentCcMe(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.sentCcMe, setValue: (updateValue) => { this.sentCcMe = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether the owner of the mailbox must be the only To recipient of incoming messages for the condition or exception to apply.
	 */
	get SentOnlyToMe(): boolean {
		return this.sentOnlyToMe;
	}
	set SentOnlyToMe(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.sentOnlyToMe, setValue: (updateValue) => { this.sentOnlyToMe = updateValue } }, value);
	}

	/**
	 * Gets the e-mail addresses incoming messages must have been sent to for the condition or exception to apply. 
	 * To disable this predicate, empty the list.
	 */
	get SentToAddresses(): EmailAddressCollection {
		return this.sentToAddresses;
	}

	/**
	 * Gets or sets a value indicating whether the owner of the mailbox must be a To recipient of incoming messages for the condition or exception to apply. 
	 */
	get SentToMe(): boolean {
		return this.sentToMe;
	}
	set SentToMe(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.sentToMe, setValue: (updateValue) => { this.sentToMe = updateValue } }, value);
	}

	/**
	 * Gets or sets a value indicating whether the owner of the mailbox must be either a To or Cc recipient of incoming messages for the condition or exception to apply.
	 */
	get SentToOrCcMe(): boolean {
		return this.sentToOrCcMe;
	}
	set SentToOrCcMe(value: boolean) {
		this.SetFieldValue<boolean>({ getValue: () => this.sentToOrCcMe, setValue: (updateValue) => { this.sentToOrCcMe = updateValue } }, value);
	}

	/**
	 * @Nullable Gets or sets the sensitivity that must be stamped on incoming messages for the condition or exception to apply. 
	 * To disable this predicate, set it to null.
	 */
	get Sensitivity(): Sensitivity {
		return this.sensitivity;
	}
	set Sensitivity(value: Sensitivity) {
		this.SetFieldValue<Sensitivity>({ getValue: () => this.sensitivity, setValue: (updateValue) => { this.sensitivity = updateValue } }, value);
	}

	/**
	 * Gets the date range within which incoming messages must have been received for the condition or exception to apply. 
	 * To disable this predicate, set both its Start and End properties to null.
	 */
	get WithinDateRange(): RulePredicateDateRange {
		return this.withinDateRange;
	}

	/**
	 * Gets the minimum and maximum sizes incoming messages must have for the condition or exception to apply. 
	 * To disable this predicate, set both its MinimumSize and MaximumSize properties to null.
	 */
	get WithinSizeRange(): RulePredicateSizeRange {
		return this.withinSizeRange;
	}

	/**
	 * @internal Initializes a new instance of the **RulePredicates** class.
	 */
	constructor() {
		super();
		this.categories = new StringList();
		this.containsBodyStrings = new StringList();
		this.containsHeaderStrings = new StringList();
		this.containsRecipientStrings = new StringList();
		this.containsSenderStrings = new StringList();
		this.containsSubjectOrBodyStrings = new StringList();
		this.containsSubjectStrings = new StringList();
		this.fromAddresses = new EmailAddressCollection(XmlElementNames.Address);
		this.fromConnectedAccounts = new StringList();
		this.itemClasses = new StringList();
		this.messageClassifications = new StringList();
		this.sentToAddresses = new EmailAddressCollection(XmlElementNames.Address);
		this.withinDateRange = new RulePredicateDateRange();
		this.withinSizeRange = new RulePredicateSizeRange();
	}

	/**
	 * @internal Validates this instance.
	 */
	InternalValidate(): void {
		super.InternalValidate();
		EwsUtilities.ValidateParam(this.fromAddresses, "FromAddresses");
		EwsUtilities.ValidateParam(this.sentToAddresses, "SentToAddresses");
		EwsUtilities.ValidateParam(this.withinDateRange, "WithinDateRange");
		EwsUtilities.ValidateParam(this.withinSizeRange, "WithinSizeRange");
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		for (let key in jsObject) {
			switch (key) {
				case XmlElementNames.Categories:
                    this.categories.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsBodyStrings:
                    this.containsBodyStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsHeaderStrings:
                    this.containsHeaderStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsRecipientStrings:
                    this.containsRecipientStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsSenderStrings:
                    this.containsSenderStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsSubjectOrBodyStrings:
                    this.containsSubjectOrBodyStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsSubjectStrings:
                    this.containsSubjectStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.FlaggedForAction:
                    this.flaggedForAction = FlaggedForAction[<string>jsObject[key]];
                    break;
                case XmlElementNames.FromAddresses:
                    this.fromAddresses.CreateFromXmlJsObjectCollection(jsObject[key][XmlElementNames.Address], service);
                    break;
                case XmlElementNames.FromConnectedAccounts:
                    this.fromConnectedAccounts.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.HasAttachments:
                    this.hasAttachments = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Importance:
                    this.importance = Importance[<string>jsObject[key]];
                    break;
                case XmlElementNames.IsApprovalRequest:
                    this.isApprovalRequest = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsAutomaticForward:
                    this.isAutomaticForward = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsAutomaticReply:
                    this.isAutomaticReply = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsEncrypted:
                    this.isEncrypted = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsMeetingRequest:
                    this.isMeetingRequest = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsMeetingResponse:
                    this.isMeetingResponse = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsNDR:
                    this.isNonDeliveryReport = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsPermissionControlled:
                    this.isPermissionControlled = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsSigned:
                    this.isSigned = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsVoicemail:
                    this.isVoicemail = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsReadReceipt:
                    this.isReadReceipt = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.ItemClasses:
                    this.itemClasses.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.MessageClassifications:
                    this.messageClassifications.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NotSentToMe:
                    this.notSentToMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.SentCcMe:
                    this.sentCcMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.SentOnlyToMe:
                    this.sentOnlyToMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.SentToAddresses:
                    this.sentToAddresses.CreateFromXmlJsObjectCollection(jsObject[key][XmlElementNames.Address], service);
                    break;
                case XmlElementNames.SentToMe:
                    this.sentToMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.SentToOrCcMe:
                    this.sentToOrCcMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Sensitivity:
                    this.sensitivity = Sensitivity[<string>jsObject[key]];
                    break;
                case XmlElementNames.WithinDateRange:
                    this.withinDateRange.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.WithinSizeRange:
                    this.withinSizeRange.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break
			}
		}
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		if (this.Categories.Count > 0) {
			this.Categories.WriteToXml(writer, XmlElementNames.Categories);
		}

		if (this.ContainsBodyStrings.Count > 0) {
			this.ContainsBodyStrings.WriteToXml(writer, XmlElementNames.ContainsBodyStrings);
		}

		if (this.ContainsHeaderStrings.Count > 0) {
			this.ContainsHeaderStrings.WriteToXml(writer, XmlElementNames.ContainsHeaderStrings);
		}

		if (this.ContainsRecipientStrings.Count > 0) {
			this.ContainsRecipientStrings.WriteToXml(writer, XmlElementNames.ContainsRecipientStrings);
		}

		if (this.ContainsSenderStrings.Count > 0) {
			this.ContainsSenderStrings.WriteToXml(writer, XmlElementNames.ContainsSenderStrings);
		}

		if (this.ContainsSubjectOrBodyStrings.Count > 0) {
			this.ContainsSubjectOrBodyStrings.WriteToXml(writer, XmlElementNames.ContainsSubjectOrBodyStrings);
		}

		if (this.ContainsSubjectStrings.Count > 0) {
			this.ContainsSubjectStrings.WriteToXml(writer, XmlElementNames.ContainsSubjectStrings);
		}

		if (hasValue(this.FlaggedForAction)) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.FlaggedForAction,
				FlaggedForAction[this.FlaggedForAction]);
		}

		if (this.FromAddresses.Count > 0) {
			this.FromAddresses.WriteToXml(writer, XmlElementNames.FromAddresses);
		}

		if (this.FromConnectedAccounts.Count > 0) {
			this.FromConnectedAccounts.WriteToXml(writer, XmlElementNames.FromConnectedAccounts);
		}

		if (this.HasAttachments != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.HasAttachments,
				this.HasAttachments);
		}

		if (hasValue(this.Importance)) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.Importance,
				Importance[this.Importance]);
		}

		if (this.IsApprovalRequest != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsApprovalRequest,
				this.IsApprovalRequest);
		}

		if (this.IsAutomaticForward != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsAutomaticForward,
				this.IsAutomaticForward);
		}

		if (this.IsAutomaticReply != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsAutomaticReply,
				this.IsAutomaticReply);
		}

		if (this.IsEncrypted != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsEncrypted,
				this.IsEncrypted);
		}

		if (this.IsMeetingRequest != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsMeetingRequest,
				this.IsMeetingRequest);
		}

		if (this.IsMeetingResponse != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsMeetingResponse,
				this.IsMeetingResponse);
		}

		if (this.IsNonDeliveryReport != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsNDR,
				this.IsNonDeliveryReport);
		}

		if (this.IsPermissionControlled != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsPermissionControlled,
				this.IsPermissionControlled);
		}

		if (this.isReadReceipt != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsReadReceipt,
				this.IsReadReceipt);
		}

		if (this.IsSigned != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsSigned,
				this.IsSigned);
		}

		if (this.IsVoicemail != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.IsVoicemail,
				this.IsVoicemail);
		}

		if (this.ItemClasses.Count > 0) {
			this.ItemClasses.WriteToXml(writer, XmlElementNames.ItemClasses);
		}

		if (this.MessageClassifications.Count > 0) {
			this.MessageClassifications.WriteToXml(writer, XmlElementNames.MessageClassifications);
		}

		if (this.NotSentToMe != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.NotSentToMe,
				this.NotSentToMe);
		}

		if (this.SentCcMe != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.SentCcMe,
				this.SentCcMe);
		}

		if (this.SentOnlyToMe != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.SentOnlyToMe,
				this.SentOnlyToMe);
		}

		if (this.SentToAddresses.Count > 0) {
			this.SentToAddresses.WriteToXml(writer, XmlElementNames.SentToAddresses);
		}

		if (this.SentToMe != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.SentToMe,
				this.SentToMe);
		}

		if (this.SentToOrCcMe != false) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.SentToOrCcMe,
				this.SentToOrCcMe);
		}

		if (hasValue(this.Sensitivity)) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.Sensitivity,
				Sensitivity[this.Sensitivity]);
		}

		if (this.WithinDateRange.Start || this.WithinDateRange.End) {
			this.WithinDateRange.WriteToXml(writer, XmlElementNames.WithinDateRange);
		}

		if (this.WithinSizeRange.MaximumSize || this.WithinSizeRange.MinimumSize) {
			this.WithinSizeRange.WriteToXml(writer, XmlElementNames.WithinSizeRange);
		}
	}
}

/**
 * Represents the minimum and maximum size of a message.
 * 
 * @sealed
 */
export class RulePredicateSizeRange extends ComplexProperty {

	/**
	 * Minimum Size.
	 */
	private minimumSize: number = null; //Nullable

	/**
	 * Mamixmum Size.
	 */
	private maximumSize: number = null; //Nullable

	/**
	 * @Nullable Gets or sets the minimum size, in kilobytes. 
	 * If MinimumSize is set to null, no minimum size applies.
	 */
	get MinimumSize(): number {
		return this.minimumSize;
	}
	set MinimumSize(value: number) {
		this.SetFieldValue<number>({ getValue: () => this.minimumSize, setValue: (updateValue) => { this.minimumSize = updateValue } }, value);
	}

	/**
	 * @Nullable Gets or sets the maximum size, in kilobytes. 
	 * If MaximumSize is set to null, no maximum size applies.
	 */
	get MaximumSize(): number {
		return this.maximumSize;
	}
	set MaximumSize(value: number) {
		this.SetFieldValue<number>({ getValue: () => this.maximumSize, setValue: (updateValue) => { this.maximumSize = updateValue } }, value);
	}

	/**
	 * @internal Initializes a new instance of the **RulePredicateSizeRange** class.
	 */
	constructor() {
		super();
	}

	/**
	 * @internal Validates this instance.
	 */
	InternalValidate(): void {
		super.InternalValidate();
		if (this.minimumSize &&
			this.maximumSize &&
			this.minimumSize > this.maximumSize) {
			throw new ServiceValidationException("MinimumSize cannot be larger than MaximumSize.");
		}
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		for (let key in jsObject) {
			switch (key) {
				case XmlElementNames.MinimumSize:
                    this.minimumSize = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.MaximumSize:
                    this.maximumSize = Convert.toNumber(jsObject[key]);
                    break;
                default:
                    break;
			}
		}
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		if (this.MinimumSize) {
			writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MinimumSize, this.MinimumSize);
		}
		if (this.MaximumSize) {
			writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MaximumSize, this.MaximumSize);
		}
	}
}
export class SearchFolderParameters extends ComplexProperty {
    Traversal: SearchFolderTraversal;
    RootFolderIds: FolderIdCollection;
    SearchFilter: SearchFilter;
    private traversal: SearchFolderTraversal;
    private rootFolderIds: FolderIdCollection;
    private searchFilter: SearchFilter;
    InternalToJson(service: ExchangeService): any { throw new Error("SearchFolderParameters.ts - InternalToJson : Not implemented."); }
    LoadFromJson(jsonProperty: JsonObject, service: ExchangeService): any { throw new Error("SearchFolderParameters.ts - LoadFromJson : Not implemented."); }
    PropertyChanged(complexProperty: ComplexProperty): any { throw new Error("SearchFolderParameters.ts - PropertyChanged : Not implemented."); }
    /**@internal */
    ReadAttributesFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("SearchFolderParameters.ts - ReadAttributesFromXml : Not implemented."); }
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): boolean { throw new Error("SearchFolderParameters.ts - TryReadElementFromXmlJsObject : Not implemented."); }
    Validate(): any { throw new Error("SearchFolderParameters.ts - Validate : Not implemented."); }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): any { throw new Error("SearchFolderParameters.ts - WriteAttributesToXml : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("SearchFolderParameters.ts - WriteElementsToXml : Not implemented."); }
}


//}



export class SetClientExtensionAction extends ComplexProperty {
    private setClientExtensionActionId: SetClientExtensionActionId;
    private extensionId: string;
    private clientExtension: ClientExtension;
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): any { throw new Error("SetClientExtensionAction.ts - WriteAttributesToXml : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("SetClientExtensionAction.ts - WriteElementsToXml : Not implemented."); }
}


//}




/**
 * Represents a list of strings.
 * 
 * @sealed
 */
export class StringList extends ComplexProperty implements IEnumerable<string> {

    private items: string[] = [];
    private itemXmlElementName: string = XmlElementNames.String;

    /**
     * Gets the number of strings in the list.
     */
    get Count(): number {
        return this.items.length;
    }

    /**
     * Initializes a new instance of the **StringList** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **StringList** class.
     *
     * @param   {string}   itemXmlElementName   Name of the item XML element.
     */
    constructor(itemXmlElementName: string);
    /**
     * Initializes a new instance of the **StringList** class.
     *
     * @param   {string[]}   strings   The strings.
     */
    constructor(strings: string[]);
    constructor(stringOrItemXmlElementName: string | string[] = null) {
        super();
        if (stringOrItemXmlElementName !== null) {
            if (typeof stringOrItemXmlElementName === 'string') {
                this.itemXmlElementName = stringOrItemXmlElementName;
            }
            else {
                this.AddRange(stringOrItemXmlElementName);
            }
        }
    }

    /**
     * Gets or sets the string at the specified index.
     *
     * @param   {number}    index   The index of the string to get or set.
     * @return  {string}    The string at the specified index.
     */
    _getItem(index: number): string {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index - " + Strings.IndexIsOutOfRange);
        }
        return this.items[index];
    }

    /**
     * Gets or sets the string at the specified index.
     *
     * @param   {number}    index   The index of the string to get or set.
     * @return  {string}    The string at the specified index.
     */
    _setItem(index: number, value: string): void {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index - " + Strings.IndexIsOutOfRange);
        }
        if (this.items[index] !== value) {
            this.items[index] = value;
            this.Changed();
        }
    }

    /**
     * Adds a string to the list.
     *
     * @param   {string}   s   The string to add.
     */
    Add(s: string): void {
        this.items.push(s);
        this.Changed();
    }

    /**
     * Adds multiple strings to the list.
     *
     * @param   {string[]}   strings   The strings to add.
     */
    AddRange(strings: string[]): void {
        let changed = false;

        for (let s of strings) {
            if (!this.Contains(s)) {
                this.items.push(s);
                changed = true;
            }
        }

        if (changed) {
            this.Changed();
        }
    }

    /**
     * Clears the list.
     */
    Clear(): void {
        this.items.splice(0);
        this.Changed();
    }

    /**
     * Determines whether the list contains a specific string.
     *
     * @param   {string}    s   The string to check the presence of.
     * @return  {boolean}   True if s is present in the list, false otherwise.
     */
    Contains(s: string): boolean { return this.items.indexOf(s) >= 0; }

    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    CreateFromXmlJsObjectCollection(jsObjectCollection: any[], service: ExchangeService): void {
        let collection = jsObjectCollection[this.itemXmlElementName];
        if (!ArrayHelper.isArray(collection)) {
            collection = [collection];
        }

        for (let item of collection) {
            this.Add(<string>item);
        }
    }

    Equals(obj: any): boolean { throw new Error("StringList.ts - Equals : Not implemented."); }

    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    GetEnumerator(): string[] {
        return this.items;
    }

    GetHashCode(): number { throw new Error("StringList.ts - GetHashCode : Not implemented."); }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObjectCollection: any[], service: ExchangeService): void {
        this.CreateFromXmlJsObjectCollection(jsObjectCollection, service);
    }

    /**
     * Removes a string from the list.
     *
     * @param   {string}   s   The string to remove.
     * @return  {boolean}       True is s was removed, false otherwise.
     */
    Remove(s: string): boolean {
        let result: boolean = ArrayHelper.RemoveEntry(this.items, s);
        if (result) {
            this.Changed();
        }
        return result;
    }

    /**
     * Removes the string at the specified position from the list.
     *
     * @param   {number}   index   The index of the string to remove.
     */
    RemoveAt(index: number): void {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index - " + Strings.IndexIsOutOfRange);
        }
        this.items.splice(index, 1);
        this.Changed();
    }

    /**
     * Generates a string representation of all the items in the list.
     *
     * @return  {string}      A comma-separated list of the strings present in the list.
     */
    ToString(): string {
        return this.items.join(",");
    }

    /**
     * @internal Loads from XMLJsObject collection to update collection Items.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The XMLJsObject collection.
     * @param   {ExchangeService}   service          The service.
     */
    UpdateFromXmlJsObjectCollection(jsObjectCollection: any, service: ExchangeService): void {
        throw new Error("StringList.ts - UpdateFromXmlJsObjectCollection : Not implemented.");
    }

    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        for (let item of this.items) {
            writer.WriteStartElement(XmlNamespace.Types, this.itemXmlElementName);
            writer.WriteValue(item, this.itemXmlElementName);
            writer.WriteEndElement();
        }
    }
}

/**
 * @internal Represents a change of time for a time zone.
 * @sealed
 */
export class TimeChange extends ComplexProperty {

    private timeZoneName: string = null;
    private offset: TimeSpan = null;
    private time: Time = null;
    private absoluteDate: DateTime = null;
    private recurrence: TimeChangeRecurrence = null;

    /**
     * Gets or sets the name of the associated time zone.
     */
    get TimeZoneName(): string {
        return this.timeZoneName;
    }
    set TimeZoneName(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.timeZoneName, setValue: (fieldValue) => { this.timeZoneName = fieldValue } }, value);
    }

    /**
     * Gets or sets the offset since the beginning of the year when the change occurs.
     */
    get Offset(): TimeSpan {
        return this.offset;
    }
    set Offset(value: TimeSpan) {
        this.SetFieldValue<TimeSpan>({ getValue: () => this.offset, setValue: (fieldValue) => { this.offset = fieldValue } }, value);
    }

    /**
     * Gets or sets the time at which the change occurs.
     */
    get Time(): Time {
        return this.time;
    }
    set Time(value: Time) {
        this.SetFieldValue<Time>({ getValue: () => this.time, setValue: (fieldValue) => { this.time = fieldValue } }, value);
    }

    /**
     * Gets or sets the absolute date at which the change occurs. AbsoluteDate and Recurrence are mutually exclusive; setting one resets the other.
     */
    get AbsoluteDate(): DateTime {
        return this.absoluteDate;
    }
    set AbsoluteDate(value: DateTime) {
        this.SetFieldValue<DateTime>({ getValue: () => this.absoluteDate, setValue: (fieldValue) => { this.absoluteDate = fieldValue } }, value);
        if (this.absoluteDate != null) {
            this.recurrence = null;
        }
    }

    /**
     * Gets or sets the recurrence pattern defining when the change occurs. Recurrence and AbsoluteDate are mutually exclusive; setting one resets the other.
     */
    get Recurrence(): TimeChangeRecurrence {
        return this.recurrence;
    }
    set Recurrence(value: TimeChangeRecurrence) {
        this.SetFieldValue<TimeChangeRecurrence>({ getValue: () => this.recurrence, setValue: (fieldValue) => { this.recurrence = fieldValue } }, value);
        if (this.recurrence != null) {
            this.absoluteDate = null;
        }
    }

    /**
     * Initializes a new instance of the **TimeChange** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **TimeChange** class.
     *
     * @param   {TimeSpan}  offset   The offset since the beginning of the year when the change occurs.
     */
    constructor(offset: TimeSpan);
    /**
     * Initializes a new instance of the **TimeChange** class.
     *
     * @param   {TimeSpan}  offset   The offset since the beginning of the year when the change occurs.
     * @param   {Time}      time     The time at which the change occurs.
     */
    constructor(offset: TimeSpan, time: Time);
    constructor(offset: TimeSpan = null, time: Time = null) {
        super();
        if (offset) {
            this.offset = offset;
        }
        if (time) {
            this.time = time
        }
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (let key in jsonProperty) {
            switch (key) {
                case XmlElementNames.Offset:
                    this.offset = EwsUtilities.XSDurationToTimeSpan(jsonProperty[key]);
                case XmlElementNames.RelativeYearlyRecurrence:
                    this.Recurrence = new TimeChangeRecurrence();
                    this.Recurrence.LoadFromXmlJsObject(jsonProperty[key], service);
                case XmlElementNames.AbsoluteDate:
                    let dateTime: DateTime = DateTime.Parse(jsonProperty[key]);

                    // TODO: BUG
                    this.absoluteDate = new DateTime(dateTime.ToUniversalTime().TotalMilliSeconds, DateTimeKind.Unspecified);
                case XmlElementNames.Time:
                    this.time = new Time(DateTime.Parse(jsonProperty[key]));
                default:
            }
        }
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.TimeZoneName, this.TimeZoneName);
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (hasValue(this.Offset)) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.Offset,
                EwsUtilities.TimeSpanToXSDuration(this.Offset));
        }

        if (this.Recurrence != null) {
            this.Recurrence.WriteToXml(writer, XmlElementNames.RelativeYearlyRecurrence);
        }

        if (this.AbsoluteDate) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.AbsoluteDate,
                EwsUtilities.DateTimeToXSDate(new DateTime(this.AbsoluteDate.TotalMilliSeconds, DateTimeKind.Unspecified)));
        }

        if (this.Time != null) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.Time,
                this.Time.ToXSTime());
        }
    }
}

/**
 * @internal Represents a recurrence pattern for a time change in a time zone.
 * @sealed
 */
export class TimeChangeRecurrence extends ComplexProperty {

    private dayOfTheWeek: DayOfTheWeek;
    private dayOfTheWeekIndex: DayOfTheWeekIndex;
    private month: Month;

    /**
     * Gets or sets the index of the day in the month at which the time change occurs.
     */
    get DayOfTheWeekIndex(): DayOfTheWeekIndex {
        return this.dayOfTheWeekIndex;
    }
    set DayOfTheWeekIndex(value: DayOfTheWeekIndex) {
    }

    /**
     * Gets or sets the day of the week the time change occurs.
     */
    get DayOfTheWeek(): DayOfTheWeek {
        return this.dayOfTheWeek;
    }
    set DayOfTheWeek(value: DayOfTheWeek) {
    }

    /**
     * Gets or sets the month the time change occurs.
     */
    get Month(): Month {
        return this.month;
    }
    set Month(value: Month) {
    }

    /**
     * Initializes a new instance of the **TimeChangeRecurrence** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **TimeChangeRecurrence** class.
     *
     * @param   {DayOfTheWeekIndex} dayOfTheWeekIndex   The index of the day in the month at which the time change occurs.
     * @param   {DayOfTheWeek}      dayOfTheWeek        The day of the week the time change occurs.
     * @param   {Month}             month               The month the time change occurs.
     */
    constructor(dayOfTheWeekIndex: DayOfTheWeekIndex, dayOfTheWeek: DayOfTheWeek, month: Month);
    constructor(dayOfTheWeekIndex: DayOfTheWeekIndex = null, dayOfTheWeek: DayOfTheWeek = null, month: Month = null) {
        super();
        this.dayOfTheWeekIndex = dayOfTheWeekIndex;
        this.dayOfTheWeek = dayOfTheWeek;
        this.month = month;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (let key in jsonProperty) {
            switch (key) {
                case XmlElementNames.DaysOfWeek:
                    this.dayOfTheWeek = DayOfTheWeek[<string>jsonProperty[key]];
                case XmlElementNames.DayOfWeekIndex:
                    this.dayOfTheWeekIndex = DayOfTheWeekIndex[<string>jsonProperty[key]];
                case XmlElementNames.Month:
                    this.month = Month[<string>jsonProperty[key]];
                default:
            }
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (hasValue(this.DayOfTheWeek)) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.DaysOfWeek,
                this.DayOfTheWeek);
        }

        if (hasValue(this.dayOfTheWeekIndex)) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.DayOfWeekIndex,
                this.DayOfTheWeekIndex);
        }

        if (this.Month) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.Month,
                this.Month);
        }
    }
}

/**
 * Represents the body part of an item that is unique to the conversation the item is part of. 
 */
export class UniqueBody extends ComplexProperty {

    private bodyType: BodyType = BodyType.HTML;
    private text: string = null;
    private isTruncated: boolean = false;

    /**
     * Gets the type of the normalized body's text.
     */
    get BodyType(): BodyType {
        return this.bodyType;
    }

    /**
     * Gets the text of the normalized body.
     */
    get Text(): string {
        return this.text;
    }

    /**
     * Gets whether the body is truncated.
     */
    get IsTruncated(): boolean {
        return this.isTruncated;
    }

    /**
     * Initializes a new instance of the **UniqueBody** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlAttributeNames.BodyType:
                    this.bodyType = BodyType[<string>jsObject[key]];
                    break;
                case XmlAttributeNames.IsTruncated:
                    this.isTruncated = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.UniqueBody:
                    this.text = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    ToString(): string { return this.Text || StringHelper.Empty; }
    toString(): string { return this.ToString(); }

    /**
     * @internal Writes attributes to XML.
     * 
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.BodyType, this.BodyType);
    }

    /**
     * @internal Writes elements to XML.
     * 
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (!StringHelper.IsNullOrEmpty(this.Text)) {
            writer.WriteValue(this.Text, XmlElementNames.UniqueBody);
        }
    }
}

/**
 * Represents a user configuration's Dictionary property.
 * 
 * @sealed
 */
export class UserConfigurationDictionary extends ComplexProperty {//IEnumerable, IJsonCollectionDeserializer

    /**
     * required before initializing new UserConfigurationDictionary
     */
    public static _dictionaryKeyPicker: (key) => string = (key) => { return key ? key.toString() : '' }
    private dictionary: Dictionary<any, any> = null;
    private isDirty: boolean = false;

    /**
     * Gets the number of elements in the user configuration dictionary.
     */
    get Count(): number {
        return this.dictionary.Count;
    }

    /**
     * @internal Gets or sets the isDirty flag.
     */
    get IsDirty(): boolean {
        return this.isDirty;
    }
    set IsDirty(value: boolean) {
        this.isDirty = value;
    }

    /**
     * @internal Initializes a new instance of **UserConfigurationDictionary** class.
     */
    constructor() {
        super();
        this.dictionary = new Dictionary<any, any>(UserConfigurationDictionary._dictionaryKeyPicker);
    }

    /**
     * Gets or sets the element with the specified key.
     *
     * @param   {string | DateTime | boolean | number}                          key   The key of the element to get or set.
     * @return  {DateTime | string | number | boolean | string[] | number[]}    The element with the specified key.
     */
    _getItem(key: string | DateTime | boolean | number): DateTime | string | number | boolean | string[] | number[] {
        return this.dictionary.get(key);
    }

    /**
     * Gets or sets the element with the specified key.
     *
     * @param   {string | DateTime | boolean | number}                          key     The key of the element to get or set.
     * @param  {DateTime | string | number | boolean | string[] | number[]}     value    The element value to update at specified key.
     */
    _setItem(key: string | DateTime | boolean | number, value: DateTime | string | number | boolean | string[] | number[]): void {
        this.ValidateEntry(key, value);
        this.dictionary.set(key, value);
        this.Changed();
    }

    /**
     * Adds an element with the provided key and value to the user configuration dictionary.
     *
     * @param   {string | DateTime | boolean | number}                          key     The object to use as the key of the element to add. **Restrict usage of byteArray or complex type for key, consider using string and number only**.
     * @param   {DateTime | string | number | boolean | string[] | number[]}    value   The object to use as the value of the element to add.
     */
    Add(key: string | DateTime | boolean | number, value: DateTime | string | number | boolean | string[] | number[]): void {
        this.ValidateEntry(key, value);

        this.dictionary.Add(key, value);

        this.Changed();
    }

    /**
     * @internal Instance was changed.
     */
    Changed(): void {
        super.Changed();

        this.isDirty = true;
    }

    /**
     * Removes all items from the user configuration dictionary.
     */
    Clear(): void {
        if (this.dictionary.Count != 0) {
            this.dictionary.clear();

            this.Changed();
        }
    }

    /**
     * Constructs a dictionary object (key or entry value) from the specified type and string list.
     *
     * @param   {UserConfigurationDictionaryObjectType}     type      Object type to construct.
     * @param   {string[]}                                  value     Value of the dictionary object as a string list
     * @param   {ExchangeService}                           service   The service.
     * @return  {any}                                       Dictionary object.
     */
    private ConstructObject(type: UserConfigurationDictionaryObjectType, value: string[] /*System.Collections.Generic.List<string>*/, service: ExchangeService): any {
        EwsLogging.Assert(
            value != null,
            "UserConfigurationDictionary.ConstructObject",
            "value is null");
        EwsLogging.Assert(
            (value.length == 1 || type == UserConfigurationDictionaryObjectType.StringArray),
            "UserConfigurationDictionary.ConstructObject",
            "value is array but type is not StringArray");

        let dictionaryObject: any = null;

        switch (type) {
            case UserConfigurationDictionaryObjectType.Boolean:
                dictionaryObject = Convert.toBool(value[0]);
                break;

            case UserConfigurationDictionaryObjectType.Byte:
                dictionaryObject = Convert.toNumber(value[0]); //info: byte is number, no Byte type in js 
                break;

            case UserConfigurationDictionaryObjectType.ByteArray:
                dictionaryObject = value[0]; //Convert.FromBase64String(value[0]); //info: ByteArray is base64 string here, avoiding binary value here
                break;

            case UserConfigurationDictionaryObjectType.DateTime:
                let dateTime: DateTime = service.ConvertUniversalDateTimeStringToLocalDateTime(value[0]);

                if (dateTime) {
                    dictionaryObject = dateTime;
                }
                else {
                    EwsLogging.Assert(
                        false,
                        "UserConfigurationDictionary.ConstructObject",
                        "DateTime is null");
                }

                break;

            case UserConfigurationDictionaryObjectType.Integer32:
                dictionaryObject = Convert.toNumber(value[0]);
                break;

            case UserConfigurationDictionaryObjectType.Integer64:
                dictionaryObject = Convert.toNumber(value[0]);
                break;

            case UserConfigurationDictionaryObjectType.String:
                dictionaryObject = value[0];
                break;

            case UserConfigurationDictionaryObjectType.StringArray:
                dictionaryObject = value;
                break;

            case UserConfigurationDictionaryObjectType.UnsignedInteger32:
                dictionaryObject = Convert.toNumber(value[0]);
                break;

            case UserConfigurationDictionaryObjectType.UnsignedInteger64:
                dictionaryObject = Convert.toNumber(value[0]);
                break;

            default:
                EwsLogging.Assert(
                    false,
                    "UserConfigurationDictionary.ConstructObject",
                    "Type not recognized: " + UserConfigurationDictionaryObjectType[<any>type]);
                break;
        }

        return dictionaryObject;
    }

    /**
     * Determines whether the user configuration dictionary contains an element with the specified key.
     *
     * @param   {any}   key     The key to locate in the user configuration dictionary.
     * @return  {boolean}       true if the user configuration dictionary contains an element with the key; otherwise false.
     */
    ContainsKey(key: any): boolean {
        return this.dictionary.containsKey(key);
    }

    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    CreateFromXMLJsObjectCollection(jsObjectCollection: any, service: ExchangeService): void {
        let collection: any[] = EwsServiceJsonReader.ReadAsArray(jsObjectCollection, XmlElementNames.DictionaryEntry);

        for (let jsonEntry of collection) {
            let parsedKey: any = this.GetDictionaryObject(jsonEntry[XmlElementNames.DictionaryKey], service);
            let parsedValue: any = this.GetDictionaryObject(jsonEntry[XmlElementNames.DictionaryValue], service);
            this.dictionary.addUpdate(parsedKey, parsedValue);
        }
    }

    /**
     * Gets the dictionary object.
     *
     * @param   {any}               jsonObject   The json object.
     * @param   {ExchangeService}   service      The service.
     * @return  {any}               the dictionary object
     */
    private GetDictionaryObject(jsonObject: any, service: ExchangeService): any {
        if (jsonObject == null) {
            return null;
        }

        let type: UserConfigurationDictionaryObjectType = UserConfigurationDictionary.GetObjectType(jsonObject[XmlElementNames.Type]);

        let values: string[] = this.GetObjectValue(EwsServiceJsonReader.ReadAsArray(jsonObject, XmlElementNames.Value));

        return this.ConstructObject(type, values, service);
    }


    GetEnumerator(): Dictionary<any, any> { return this.dictionary; }

    /**
     * Gets the type of the object.
     *
     * @param   {string}   type   The type.
     * @return  {UserConfigurationDictionaryObjectType}     UserConfigurationDictionaryObjectType for the string value
     */
    private static GetObjectType(type: string): UserConfigurationDictionaryObjectType {
        return UserConfigurationDictionaryObjectType[type];
    }

    /**
     * Gets the object value.
     *
     * @param   {any[]}   valueArray   The value array.
     * @return  {string[]}  string array from object Array
     */
    private GetObjectValue(valueArray: any[]): string[] /*System.Collections.Generic.List<string>*/ {
        let stringArray: string[] = [];

        for (let value of valueArray) {
            stringArray.push(value as string);
        }

        return stringArray;
    }

    /**
     * Gets the type code.
     *
     * @param   {ExchangeServiceBase}                                   service                The service.
     * @param   {any}                                                   dictionaryObject       The dictionary object.
     * @param   {IRefParam<UserConfigurationDictionaryObjectType>}      dictionaryObjectType   Type of the dictionary object.
     * @param   {IRefParam<string>}                                     valueAsString          The value as string.
     */
    private static GetTypeCode(service: ExchangeServiceBase, dictionaryObject: any, dictionaryObjectType: IRefParam<UserConfigurationDictionaryObjectType>, valueAsString: IRefParam<string>): void {
        // Handle all other types by TypeCode

        let typeofDictionaryObject: string = typeof dictionaryObject;

        if (typeofDictionaryObject === 'string') {
            dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.String);
            valueAsString.setValue(dictionaryObject);
        }
        else if (typeofDictionaryObject === 'boolean') {
            dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.Boolean);
            valueAsString.setValue(EwsUtilities.BoolToXSBool(dictionaryObject));
        }
        else if (typeofDictionaryObject === 'number') {
            let num: number = Convert.toNumber(dictionaryObject);
            dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.Integer32);
            if (num >= 0 && num <= 255) {
                dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.Byte);
            }
            else if (num < 0 && num < -2147483648) {
                dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.Integer64);
            }
            else if (num >= 0 && num > 2147483647) {
                dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.UnsignedInteger64);
            }
            else if (num >= 0 && num <= 2147483647) {
                dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.UnsignedInteger32);
            }

            valueAsString.setValue(num.toString());
        }
        else if (dictionaryObject instanceof DateTime) {
            dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.DateTime);
            valueAsString.setValue(service.ConvertDateTimeToUniversalDateTimeString(dictionaryObject));
        }
        else {
            EwsLogging.Assert(
                false,
                "UserConfigurationDictionary.WriteObjectValueToXml",
                "Unsupported type: " + typeof dictionaryObject);
        }
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        this.CreateFromXMLJsObjectCollection(jsObject, service);
    }

    /**
     * Removes the element with the specified key from the user configuration dictionary.
     *
     * @param   {key}   key     The key of the element to remove.
     * @return  {boolean}       true if the element is successfully removed; otherwise false.
     */
    Remove(key: any): boolean {
        let isRemoved: boolean = this.dictionary.remove(key);

        if (isRemoved) {
            this.Changed();
        }

        return isRemoved;
    }

    /**
     * Gets the value associated with the specified key.
     *
     * @param   {any}   key     The key whose value to get.
     * @param   {any}   value   When this method returns, the value associated with the specified key, if the key is found; otherwise, null.
     * @return  {boolean}       true if the user configuration dictionary contains the key; otherwise false.
     */
    TryGetValue(key: any, value: IOutParam<any>): boolean {
        return this.dictionary.tryGetValue(key, value);
    }

    /**
     * @internal Loads from XMLJsObject collection to update collection Items.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The XMLJsObject collection.
     * @param   {ExchangeService}   service          The service.
     */
    UpdateFromXMLJsObjectCollection(jsObjectCollection: any, service: ExchangeService): void { throw new Error("UserConfigurationDictionary.ts - UpdateFromJsonCollection : Not implemented."); }

    /**
     * Validate the array object.
     *
     * @param   {Array<any>}   dictionaryObjectAsArray   Object to validate
     */
    private ValidateArrayObject(dictionaryObjectAsArray: Array<any> /*System.Array*/): void {
        // // This logic is based on Microsoft.Exchange.Data.Storage.ConfigurationDictionary.CheckElementSupportedType().
        // if (dictionaryObjectAsArray as string[]) {
        //     if (dictionaryObjectAsArray.Length > 0) {
        //         for (let arrayElement of dictionaryObjectAsArray) {
        //             if (arrayElement == null) {
        //                 throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
        //             }
        //         }
        //     }
        //     else {
        //         throw new ServiceLocalException(Strings.ZeroLengthArrayInvalid);
        //     }
        // }
        // else if (dictionaryObjectAsArray as byte[]) {
        //     if (dictionaryObjectAsArray.Length <= 0) {
        //         throw new ServiceLocalException(Strings.ZeroLengthArrayInvalid);
        //     }
        // }
        // else {
        //     throw new ServiceLocalException(string.Format(Strings.ObjectTypeNotSupported, dictionaryObjectAsArray.GetType()));
        // }

        // This logic is based on Microsoft.Exchange.Data.Storage.ConfigurationDictionary.CheckElementSupportedType().

        if (dictionaryObjectAsArray.length > 0) {
            let firstNonEmptyElement = ArrayHelper.Find(dictionaryObjectAsArray, (item) => { return item != null && typeof item !== 'undefined' });
            if (!firstNonEmptyElement) {
                throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
            }

            let arrayType: string = typeof firstNonEmptyElement;
            if (arrayType !== 'string' && arrayType !== 'number') {
                throw new ServiceLocalException(StringHelper.Format(Strings.ObjectTypeNotSupported, arrayType));
            }

            for (let arrayElement of dictionaryObjectAsArray) {
                let elementType: string = typeof arrayElement;
                if (arrayElement && elementType != arrayType) {
                    throw new ServiceLocalException(StringHelper.Format(Strings.ObjectTypeNotSupported, "<" + elementType + "," + arrayType + ">"));
                }

                if (arrayType === 'string' && arrayElement == null) {
                    throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
                }
            }
        }
        else {
            throw new ServiceLocalException(Strings.ZeroLengthArrayInvalid);
        }
    }

    /**
     * Validates the specified key and value.
     *
     * @param   {any}   key     The dictionary entry key.
     * @param   {any}   value   The dictionary entry value.
     */
    private ValidateEntry(key: any, value: any): void {
        this.ValidateObject(key);
        this.ValidateObject(value);
    }

    /**
     * Validates the dictionary object (key or entry value).
     *
     * @param   {any}   dictionaryObject   Object to validate.
     */
    private ValidateObject(dictionaryObject: any): void {
        // Keys may not be null but we rely on the internal dictionary to throw if the key is null.
        if (dictionaryObject != null) {
            let dictionaryObjectAsArray: Array<any> = dictionaryObject as Array<any>;
            if (ArrayHelper.isArray(dictionaryObjectAsArray)) //info: c# "as" keyword does not work here
            {
                this.ValidateArrayObject(dictionaryObjectAsArray);
            }
            else {
                this.ValidateObjectType(dictionaryObject);
            }
        }
    }

    /**
     * Validates the dictionary object type.
     *
     * @param   {any}   type   Type to validate.
     */
    private ValidateObjectType(dictionaryObject: any/*System.Type*/): void {

        let typeofDictionaryObject: string = typeof dictionaryObject;
        let type: UserConfigurationDictionaryObjectType = null;
        if (typeofDictionaryObject === 'string') {
            type = UserConfigurationDictionaryObjectType.String;
        }
        else if (typeofDictionaryObject === 'boolean') {
            type = UserConfigurationDictionaryObjectType.Boolean;
        }
        else if (typeofDictionaryObject === 'number') {
            let num: number = Convert.toNumber(dictionaryObject);
            type = UserConfigurationDictionaryObjectType.Integer32;
            if (num >= 0 && num <= 255) {
                type = UserConfigurationDictionaryObjectType.Byte;
            }
            else if (num < 0 && num < -2147483648) {
                type = UserConfigurationDictionaryObjectType.Integer64;
            }
            else if (num >= 0 && num > 2147483647) {
                type = UserConfigurationDictionaryObjectType.UnsignedInteger64;
            }
            else if (num >= 0 && num <= 2147483647) {
                type = UserConfigurationDictionaryObjectType.UnsignedInteger32;
            }
        }
        else if (dictionaryObject instanceof DateTime) {
            type = UserConfigurationDictionaryObjectType.DateTime;
        }

        let isValidType: boolean = false;

        switch (type) {
            case UserConfigurationDictionaryObjectType.Boolean:
            case UserConfigurationDictionaryObjectType.Byte:
            case UserConfigurationDictionaryObjectType.DateTime:
            case UserConfigurationDictionaryObjectType.Integer32:
            case UserConfigurationDictionaryObjectType.Integer64:
            case UserConfigurationDictionaryObjectType.String:
            case UserConfigurationDictionaryObjectType.UnsignedInteger32:
            case UserConfigurationDictionaryObjectType.UnsignedInteger64:
                isValidType = true;
                break;
        }

        if (!isValidType) {
            throw new ServiceLocalException(StringHelper.Format(Strings.ObjectTypeNotSupported, type));
        }

    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        EwsLogging.Assert(
            writer != null,
            "UserConfigurationDictionary.WriteElementsToXml",
            "writer is null");

        for (let dictionaryEntry of this.dictionary.Items) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.DictionaryEntry);

            this.WriteObjectToXml(
                writer,
                XmlElementNames.DictionaryKey,
                dictionaryEntry.key);

            this.WriteObjectToXml(
                writer,
                XmlElementNames.DictionaryValue,
                dictionaryEntry.value);

            writer.WriteEndElement();
        }
    }

    /**
     * Writes a dictionary entry type to Xml.
     *
     * @param   {EwsServiceXmlWriter}                       writer                 The writer.
     * @param   {UserConfigurationDictionaryObjectType}     dictionaryObjectType   Type to write.
     */
    private WriteEntryTypeToXml(writer: EwsServiceXmlWriter, dictionaryObjectType: UserConfigurationDictionaryObjectType): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Type);
        writer.WriteValue(UserConfigurationDictionaryObjectType[dictionaryObjectType], XmlElementNames.Type);
        writer.WriteEndElement();
    }

    /**
     * Writes a dictionary entry value to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     * @param   {string}                value    Value to write.
     */
    private WriteEntryValueToXml(writer: EwsServiceXmlWriter, value: string): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Value);

        // While an entry value can't be null, if the entry is an array, an element of the array can be null.
        if (value != null) {
            writer.WriteValue(value, XmlElementNames.Value);
        }

        writer.WriteEndElement();
    }

    /**
     * Writes a dictionary object (key or value) to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer             The writer.
     * @param   {string}                xmlElementName     The Xml element name.
     * @param   {any}                   dictionaryObject   The object to write.
     */
    private WriteObjectToXml(writer: EwsServiceXmlWriter, xmlElementName: string, dictionaryObject: any): void {
        EwsLogging.Assert(
            writer != null,
            "UserConfigurationDictionary.WriteObjectToXml",
            "writer is null");
        EwsLogging.Assert(
            xmlElementName != null,
            "UserConfigurationDictionary.WriteObjectToXml",
            "xmlElementName is null");

        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);

        if (dictionaryObject == null) {
            EwsLogging.Assert(
                xmlElementName != XmlElementNames.DictionaryKey,
                "UserConfigurationDictionary.WriteObjectToXml",
                "Key is null");

            writer.WriteAttributeValue(
                EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix,
                XmlAttributeNames.Nil,
                EwsUtilities.XSTrue);
        }
        else {
            this.WriteObjectValueToXml(writer, dictionaryObject);
        }

        writer.WriteEndElement();
    }

    /**
     * Writes a dictionary Object's value to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer             The writer.
     * @param   {any}                   dictionaryObject   The dictionary object to write.
     */
    private WriteObjectValueToXml(writer: EwsServiceXmlWriter, dictionaryObject: any): void {
        EwsLogging.Assert(
            writer != null,
            "UserConfigurationDictionary.WriteObjectValueToXml",
            "writer is null");
        EwsLogging.Assert(
            dictionaryObject != null,
            "UserConfigurationDictionary.WriteObjectValueToXml",
            "dictionaryObject is null");

        // This logic is based on Microsoft.Exchange.Services.Core.GetUserConfiguration.ConstructDictionaryObject().
        //
        // Object values are either:
        //   . an array of strings
        //   . a single value
        //
        // Single values can be:
        //   . base64 string (from a byte array)
        //   . datetime, boolean, byte, short, int, long, string, ushort, unint, ulong
        //

        //Assume string value for default
        let dictionaryObjectType: UserConfigurationDictionaryObjectType = UserConfigurationDictionaryObjectType.String;
        let valueAsString: string = null;

        //First check for Array
        if (ArrayHelper.isArray<any>(dictionaryObject)) {

            // First check for a string array         

            let dictionaryObjectAsStringArray: string[] = ArrayHelper.OfType<string, string>(dictionaryObject, (item) => { return typeof item === 'string' });
            if (dictionaryObjectAsStringArray.length > 0) {
                //array with string
                if (dictionaryObjectAsStringArray.length === dictionaryObject.length) {
                    //all array elements are string
                    this.WriteEntryTypeToXml(writer, UserConfigurationDictionaryObjectType.StringArray);

                    for (let arrayElement of dictionaryObjectAsStringArray) {
                        this.WriteEntryValueToXml(writer, arrayElement);
                    }
                }
                else {
                    throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
                }
            }
            else {
                //check for byte[] for base64 conversion to single element //todo: byte[] conversion to base64 using Buffer
                let dictionaryObjectAsByteArray: number[] = ArrayHelper.OfType<number, number>(dictionaryObject, (item) => { return typeof item === 'number' });
                if (dictionaryObjectAsByteArray.length > 0 && dictionaryObjectAsByteArray.length === dictionaryObject.length) {
                    // Convert byte array to base64 string
                    dictionaryObjectType = UserConfigurationDictionaryObjectType.ByteArray;
                    valueAsString = Convert.ToBase64String(dictionaryObjectAsByteArray);
                    this.WriteEntryTypeToXml(writer, dictionaryObjectType);
                    this.WriteEntryValueToXml(writer, valueAsString);
                } else {
                    throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
                }
            }
        }
        else {
            // if not a string array, all other object values are returned as a single element
            let refDictionaryObjectType: IRefParam<UserConfigurationDictionaryObjectType> = { getValue: () => { return dictionaryObjectType; }, setValue: (value) => { dictionaryObjectType = value; } };
            let refValueAsString: IRefParam<string> = { getValue: () => { return valueAsString; }, setValue: (value) => { valueAsString = value } };
            UserConfigurationDictionary.GetTypeCode(writer.Service, dictionaryObject, refDictionaryObjectType, refValueAsString);
            this.WriteEntryTypeToXml(writer, refDictionaryObjectType.getValue());
            this.WriteEntryValueToXml(writer, refValueAsString.getValue());
        }
    }
}

/**
 * Represents the Id of a user.
 * 
 * @sealed
 */
export class UserId extends ComplexProperty {

    private sID: string = null;
    private primarySmtpAddress: string = null;
    private displayName: string = null;
    private standardUser: StandardUser = null;

    /**
     * Gets or sets the SID of the user.
     */
    get SID(): string {
        return this.sID;
    }
    set SID(value) {
        this.SetFieldValue<string>({ getValue: () => this.sID, setValue: (data) => this.sID = data }, value);
    }

    /**
     * Gets or sets the primary SMTP address or the user.
     */
    get PrimarySmtpAddress(): string {
        return this.primarySmtpAddress;
    }
    set PrimarySmtpAddress(value) {
        this.SetFieldValue<string>({ getValue: () => this.primarySmtpAddress, setValue: (data) => this.primarySmtpAddress = data }, value);
    }

    /**
     * Gets or sets the display name of the user.
     */
    get DisplayName(): string {
        return this.displayName;
    }
    set DisplayName(value) {
        this.SetFieldValue<string>({ getValue: () => this.displayName, setValue: (data) => this.displayName = data }, value);
    }

    /**
     * Gets or sets a value indicating which standard user the user represents.
     * 
     * @Nullable
     */
    get StandardUser(): StandardUser {
        return this.standardUser;
    }
    set StandardUser(value) {
        this.SetFieldValue<StandardUser>({ getValue: () => this.standardUser, setValue: (data) => this.standardUser = data }, value);
    }

    /**
     * Initializes a new instance of the **UserId** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **UserId** class.
     *
     * @param   {StandardUser}   standardUser   The StandardUser value used to initialize the UserId.
     */
    constructor(standardUser: StandardUser);
    /**
     * Initializes a new instance of the **UserId** class.
     *
     * @param   {string}   primarySmtpAddress   The primary SMTP address used to initialize the UserId.
     */
    constructor(primarySmtpAddress: string);
    /** @internal this is to shim constructor with easy use within file/module. */
    constructor(primarySmtpAddressOrStandardUser?: string | StandardUser);
    constructor(primarySmtpAddressOrStandardUser?: string | StandardUser) {
        super();
        if (typeof primarySmtpAddressOrStandardUser !== 'undefined') {
            if (typeof primarySmtpAddressOrStandardUser === 'string') {
                this.primarySmtpAddress = primarySmtpAddressOrStandardUser;
            }
            else {
                this.standardUser = primarySmtpAddressOrStandardUser;
            }
        }
    }

    /**
     * @internal Determines whether this instance is valid.
     *
     * @return  {boolean}      true if this instance is valid; otherwise, false.
     */
    IsValid(): boolean {
        return typeof this.StandardUser === 'number' || !StringHelper.IsNullOrEmpty(this.PrimarySmtpAddress) || !StringHelper.IsNullOrEmpty(this.SID);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.SID:
                    this.sID = jsObject[key];
                    break;
                case XmlElementNames.PrimarySmtpAddress:
                    this.primarySmtpAddress = jsObject[key];
                    break;
                case XmlElementNames.DisplayName:
                    this.displayName = jsObject[key];
                    break;
                case XmlElementNames.DistinguishedUser:
                    //debugger;//check for enum value consistency
                    this.standardUser = <StandardUser><any>StandardUser[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.SID,
            this.SID);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.PrimarySmtpAddress,
            this.PrimarySmtpAddress);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DisplayName,
            this.DisplayName);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DistinguishedUser,
            StandardUser[this.StandardUser]);
    }
}

/**
 * Represents voting information.
 * @sealed
 */
export class VotingInformation extends ComplexProperty {

    private userOptions: VotingOptionData[] = [];
    private votingResponse: string = null;

    /**
     * Gets the list of user options.
     */
    get UserOptions(): VotingOptionData[] {
        return this.userOptions;
    }

    /**
     * Gets the voting response.
     */
    get VotingResponse(): string {
        return this.votingResponse;
    }

    /**
     * @internal Initializes a new instance of the **VotingInformation** class.
     */
    constructor() {
        super();
    }


    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        if (jsObject[XmlElementNames.UserOptions]) {
            let votingOptionObjects = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.UserOptions);
            for (let votingOptionObject of votingOptionObjects) {

                let option: VotingOptionData = new VotingOptionData();

                option.LoadFromXmlJsObject(votingOptionObject, service);
                this.userOptions.push(option);
            }
        }

        if (jsObject[XmlElementNames.VotingResponse]) {
            this.votingResponse = jsObject[XmlElementNames.VotingResponse];
        }
    }
}

/**
 * Represents voting option information.
 * @sealed
 */
export class VotingOptionData extends ComplexProperty {

    private displayName: string = null;
    private sendPrompt: SendPrompt = SendPrompt.None;

    /**
     * Gets the display name for the voting option.
     */
    get DisplayName(): string {
        return this.displayName;
    }

    /**
     * Gets the send prompt.
     */
    get SendPrompt(): SendPrompt {
        return this.sendPrompt;
    }

    /**
     * @internal Initializes a new instance of the **VotingOptionData** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.VotingOptionDisplayName:
                    this.displayName = jsObject[key];
                    break;
                case XmlElementNames.SendPrompt:
                    this.sendPrompt = SendPrompt[<string>jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents an attachment to an item.
 */
export class Attachment extends ComplexProperty {

    private owner: Item = null;
    private id: string = null;
    private name: string = null;
    private contentType: string = null;
    private contentId: string = null;
    private contentLocation: string = null;
    private size: number = 0;
    private lastModifiedTime: DateTime = null;
    private isInline: boolean = false;
    private service: ExchangeService = null;

    /**
     * Gets the Id of the attachment.
     */
    get Id(): string {
        return this.id;
    }
    set Id(value: string) {
        this.id = value;
    }

    /***
     * Gets or sets the name of the attachment.
     */
    get Name(): string {
        return this.name;
    }
    set Name(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.name, setValue: (updateValue) => { this.name = updateValue } }, value);
    }

    /**
     * Gets or sets the content type of the attachment.
     */
    get ContentType(): string {
        return this.contentType;
    }
    set ContentType(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.contentType, setValue: (updateValue) => { this.contentType = updateValue } }, value);
    }

    /**
     * Gets or sets the content Id of the attachment. ContentId can be used as a custom way to identify an attachment in order to reference it from within the body of the item the attachment belongs to.
     */
    get ContentId(): string {
        return this.contentId;
    }
    set ContentId(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.contentId, setValue: (updateValue) => { this.contentId = updateValue } }, value);
    }

    /**
     * Gets or sets the content location of the attachment. ContentLocation can be used to associate an attachment with a Url defining its location on the Web.
     */
    get ContentLocation(): string {
        return this.contentLocation;
    }
    set ContentLocation(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.contentLocation, setValue: (updateValue) => { this.contentLocation = updateValue } }, value);
    }

    /**
     * Gets the size of the attachment.
     */
    get Size(): number {
        EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "Size");
        return this.size;
    }
    set Size(value: number) {
        EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "Size");
        this.SetFieldValue<number>({ getValue: () => this.size, setValue: (updateValue) => { this.size = updateValue } }, value);
    }

    /**
     * Gets the date and time when this attachment was last modified.
     */
    get LastModifiedTime(): DateTime {
        EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "LastModifiedTime");
        return this.lastModifiedTime;
    }
    set LastModifiedTime(value: DateTime) {
        EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "LastModifiedTime");
        this.SetFieldValue<DateTime>({ getValue: () => this.lastModifiedTime, setValue: (updateValue) => { this.lastModifiedTime = updateValue } }, value);
    }

    /**
     * Gets or sets a value indicating whether this is an inline attachment. Inline attachments are not visible to end users.
     */
    get IsInline(): boolean {
        EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "IsInline");
        return this.isInline;
    }
    set IsInline(value: boolean) {
        EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "IsInline");
        this.SetFieldValue<boolean>({ getValue: () => this.isInline, setValue: (updateValue) => { this.isInline = updateValue } }, value);
    }

    /**
     * @internal True if the attachment has not yet been saved, false otherwise.
     */
    get IsNew(): boolean {
        return StringHelper.IsNullOrEmpty(this.Id);
    }

    /**
     * @internal Gets the owner of the attachment.
     */
    get Owner(): Item {
        return this.owner;
    }

    /**
     * @internal Gets the related exchange service.
     */
    get Service(): ExchangeService {
        return this.service;
    }

    /**
     * @internal Initializes a new instance of the Attachment class.
     *
     * @param   {Item}   owner   The owner.
     */
    constructor(owner: Item);
    /**
     * @internal Initializes a new instance of the Attachment class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService);
    /**
     * @internal  @protected unused - only for derived class call
     */
    constructor(ownerOrService: Item | ExchangeService)
    constructor(ownerOrService: Item | ExchangeService) {
        super();
        if (arguments.length === 1 && (ownerOrService === null || ownerOrService instanceof TypeContainer.Item)) {
            this.owner = <Item>ownerOrService;
            if (ownerOrService !== null) {
                this.service = this.owner.Service;
            }
            return;
        }
        this.service = <ExchangeService>ownerOrService;
    }

    /**
     * Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string { console.log("Attachment.ts - GetXmlElementName : Abstract - must implement."); return StringHelper.Empty; }

    /**
     * @internal Load the attachment.
     *
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     */
    InternalLoad(bodyType: BodyType, additionalProperties: PropertyDefinitionBase[]): Promise<void> {
        return this.service.GetAttachment(
            this,
            bodyType,
            additionalProperties);
    }

    //InternalToJson(service: ExchangeService): any { throw new Error("Attachment.ts - InternalToJson : Not implemented."); }

    /**
     * Loads the attachment. Calling this method results in a call to EWS.
     */
    Load(): Promise<void> {
        return this.InternalLoad(null, null);
    }

    /**
     * Loads the attachment id from json.
     *
     * @param   {any}   jsonObject   The json object.
     */
    private LoadAttachmentIdFromXMLJsObject(jsonObject: any): void {
        this.id = jsonObject[XmlAttributeNames.Id];

        if (this.Owner != null && jsonObject[XmlAttributeNames.RootItemChangeKey]) {
            var rootItemChangeKey: string = jsonObject[XmlAttributeNames.RootItemChangeKey];

            if (!StringHelper.IsNullOrEmpty(rootItemChangeKey)) {
                this.Owner.RootItemId.ChangeKey = rootItemChangeKey;
            }
        }
    }

    /**
     * @internal Loads from XMLjsObject.
     *
     * @param   {any}               jsonObject
     * @param   {ExchangeService}   service        
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.AttachmentId:
                    this.LoadAttachmentIdFromXMLJsObject(jsObject[key]);
                    break;
                case XmlElementNames.Name:
                    this.name = jsObject[key];
                    break;
                case XmlElementNames.ContentType:
                    this.contentType = jsObject[key];
                    break;
                case XmlElementNames.ContentId:
                    this.contentId = jsObject[key];
                    break;
                case XmlElementNames.ContentLocation:
                    this.contentLocation = jsObject[key];
                    break;
                case XmlElementNames.Size:
                    this.size = Convert.toInt(jsObject[key]);
                    break;
                case XmlElementNames.LastModifiedTime:
                    this.lastModifiedTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.IsInline:
                    this.isInline = Convert.toBool(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Sets value of field.
     * 
     * /remarks/    We override the base implementation. Attachments cannot be modified so any attempts the change a property on an existing attachment is an error.
     * 
     * @param   {IRefParam<T>}      field   The field.
     * @param   {T}                 value   The value.
     */
    SetFieldValue<T>(field: IRefParam<T>, value: T): void {
        this.ThrowIfThisIsNotNew();
        super.SetFieldValue(field, value);
    }

    /**
     * @internal Throws exception if this is not a new service object.
     */
    ThrowIfThisIsNotNew(): void {
        if (!this.IsNew) {
            throw new Error(Strings.AttachmentCannotBeUpdated);//InvalidOperationException
        }
    }

    //ReadElementsFromXmlJsObject(reader: any): boolean { throw new Error("Attachment.ts - TryReadElementFromXmlJsObject : Not implemented."); }

    /**
     * @internal Validates this instance.
     *
     * @param   {number}   attachmentIndex   Index of this attachment.
     */
    Validate(attachmentIndex?: number): void {
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Name, this.Name);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ContentType, this.ContentType);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ContentId, this.ContentId);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ContentLocation, this.ContentLocation);
        if (writer.Service.RequestedServerVersion > ExchangeVersion.Exchange2007_SP1) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsInline, this.IsInline);
        }
    }
}


/**
 * Represents a file attachment.
 */
export class FileAttachment extends Attachment {
    private fileName: string = null;
    //private contentStream: Stream = null;
    //private content: number[] = null;
    private base64Content: string = null;
    //private loadToStream: Stream = null;
    private isContactPhoto: boolean = false;

    /**
     * Gets the name of the file the attachment is linked to.
     */
    get FileName(): string {
        return this.fileName;
    }
    set FileName(value: string) {
        super.ThrowIfThisIsNotNew();
        this.fileName = value;
        //this.content = null;
        this.base64Content = null;
        //this.contentStream = null;
    }
    // /**
    //  * Gets or sets the content stream.
    //  */
    // get ContentStream(): Stream {
    //     return this.contentStream;
    // }
    // set ContentStream(value: Stream) {
    //     super.ThrowIfThisIsNotNew();
    //     this.contentStream = value;
    //     this.content = null;
    //     this.fileName = null;
    // }
    // /**
    //  * Gets the content of the attachment into memory. Content is set only when Load() is called.
    //  */
    // get Content(): number[] {
    //     return this.content;
    // }
    // set Content(value: number[]) {
    //     super.ThrowIfThisIsNotNew();
    //     this.content = value;
    //     this.fileName = null;
    //     this.contentStream = null;
    // }
    
    /**
     * Gets the base64 content of the attachment into memory. Content is set only when Load() is called.
     */
    get Base64Content(): string {
        return this.base64Content;
    }
    set Base64Content(value: string) {
        super.ThrowIfThisIsNotNew();
        this.base64Content = value;
        this.fileName = null;
    }

    /**
     * Gets or sets a value indicating whether this attachment is a contact photo.
     */
    get IsContactPhoto(): boolean {
        EwsUtilities.ValidatePropertyVersion(this.Service, ExchangeVersion.Exchange2010, "IsContactPhoto");
        return this.isContactPhoto;
    }
    set IsContactPhoto(value: boolean) {
        EwsUtilities.ValidatePropertyVersion(this.Service, ExchangeVersion.Exchange2010, "IsContactPhoto");
        super.ThrowIfThisIsNotNew();
        this.isContactPhoto = value;
    }
    
    /**
     * @internal Initializes a new instance of the **FileAttachment** class.
     *
     * @param   {Item}   owner   The owner of the attachment.
     */
    constructor(owner: Item);
    /**
     * @internal Initializes a new instance of the **FileAttachment** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService);
    constructor(ownerOrService: Item | ExchangeService) {
        super(ownerOrService);
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string { return XmlElementNames.FileAttachment; }
    
    // /**
    //  * Loads the content of the file attachment into the specified stream. Calling this method results in a call to EWS.
    //  *
    //  * @param   {any}   stream   The stream to load the content of the attachment into.
    //  */    
    // Load(stream: any /* System.IO.Stream */): void;
    // /**
    //  * Loads the content of the file attachment into the specified file. Calling this method results in a call to EWS.
    //  *
    //  * @param   {string}   fileName   The name of the file to load the content of the attachment into. If the file already exists, it is overwritten.
    //  */        
    // Load(fileName?: string): void;
    // Load(fileName?: string | any): Promise<void> {
    //     return  super.Load();
    // }
    //ref: //info: - skipped, this can be loaded from base class
    
    /**
     * @internal Loads from XMLjsObject.
     *
     * @param   {any}               jsonProperty   The json property.
     * @param   {ExchangeService}   service        [description]
     */
    LoadFromXmlJsObject(jsObject: any/*JsonObject*/, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.IsContactPhoto:
                    this.isContactPhoto = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Content:
                    this.base64Content = jsObject[key];
                    // if (this.loadToStream != null)
                    // {
                    //     jsObject.ReadAsBase64Content(key, this.loadToStream);
                    // }
                    // else
                    // {
                    //     // If there's a file attachment content handler, use it. Otherwise
                    //     // load the content into a byte array.
                    //     // TODO: Should we mark the attachment to indicate that content is stored elsewhere?
                    //     if (service.FileAttachmentContentHandler != null)
                    //     {
                    //         Stream outputStream = service.FileAttachmentContentHandler.GetOutputStream(this.Id);

                    //         if (outputStream != null)
                    //         {
                    //             jsObject.ReadAsBase64Content(key, outputStream);
                    //         }
                    //         else
                    //         {
                    //             this.content = jsObject.ReadAsBase64Content(key);
                    //         }
                    //     }
                    //     else
                    //     {
                    //         this.content = jsObject.ReadAsBase64Content(key);
                    //     }
                    // }
                    break;
                default:
                    break;
            }
        }
    }
    //ReadElementsFromXmlJsObject(reader: any): boolean { throw new Error("FileAttachment.ts - TryReadElementFromXmlJsObject : Not implemented."); }
    ReadElementsFromXmlJsObjectToPatch(reader: any): boolean { throw new Error("FileAttachment.ts - ReadElementsFromXmlJsObjectToPatch : Not implemented."); }
    
    /**
     * @internal Validates this instance.
     *
     * @param   {number}   attachmentIndex   Index of this attachment.
     */
    Validate(attachmentIndex?: number): void {
        if (StringHelper.IsNullOrEmpty(this.Name) && (this.base64Content == null)) {
            throw new ServiceValidationException(StringHelper.Format(Strings.FileAttachmentContentIsNotSet, attachmentIndex));
        }
    }
    
    /**
     * @internal Writes elements and content to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        if (writer.Service.RequestedServerVersion > ExchangeVersion.Exchange2007_SP1) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsContactPhoto, this.isContactPhoto);
        }

        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Content);

        if (!StringHelper.IsNullOrEmpty(this.FileName)) {
            throw new Error("FileAttachment.ts - File reading from disk is not implemented. Always use Base64Content property ")
                
            // using (FileStream fileStream = new FileStream(this.FileName, FileMode.Open, FileAccess.Read))
            // {
            //     writer.WriteBase64ElementValue(fileStream);
            // }
        }
        // else if (this.ContentStream != null)
        // {
        //     writer.WriteBase64ElementValue(this.ContentStream);
        // }
        // else if (this.Content != null)
        // {
        //     writer.WriteBase64ElementValue(this.Content);
        // }
        else if (!StringHelper.IsNullOrEmpty(this.base64Content)) {
            writer.WriteValue(this.base64Content, null);
        }
        else {
            EwsLogging.Assert(
                false,
                "FileAttachment.WriteElementsToXml",
                "The attachment's content is not set.");
        }

        writer.WriteEndElement();
    }
}

/**
 * Represents an item attachment.
 */
export class ItemAttachment extends Attachment {
    /**
     * The item associated with the attachment.
     */
    protected item: Item = null;
    /**
     * Gets the item associated with the attachment.
     */
    get Item(): Item {
        return this.item;
    }
    set Item(value: Item) {
        super.ThrowIfThisIsNotNew();
        //todo: implement logic for onchange
        if (this.item !== null) {
            //this.item.OnChange.Remove(this.ItemChanged);
        }
        this.item = value;
        if (this.item !== null) {
            //this.item.OnChange.Add(this.ItemChanged);
        }
    }
    /** to workaround base.Item property accessor of c# //ref: //info: */
    protected _setItem(value: Item): void {
        this.item = value;
    }
    /**
    * @internal Initializes a new instance of the **ItemAttachment** class.
    *
    * @param   {Item}   owner   The owner of the attachment.
    */
    constructor(owner: Item);
    /**
     * @internal Initializes a new instance of the **ItemAttachment** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService);
    constructor(ownerOrService: Item | ExchangeService) {
        super(ownerOrService);
    }

    /**
     * @internal Obtains EWS XML element name for this object.
     *
     * @return  {string}      The XML element name.
     */
    GetXmlElementName(): string { return XmlElementNames.ItemAttachment; }


    /**
     * Implements the OnChange event handler for the item associated with the attachment.
     *
     * @param   {ServiceObject}   serviceObject   The service object that triggered the OnChange event.
     */
    private ItemChanged(serviceObject: ServiceObject): void {
        if (this.Owner != null) {
            this.Owner.PropertyBag.Changed();
        }
    }

    //Load(...additionalProperties: PropertyDefinitionBase[]): Promise<void>;
    /**
     * Loads this attachment.
     *
     * @param   {PropertyDefinitionBase[]}   additionalProperties   The optional additional properties to load.
     */
    Load(additionalProperties?: PropertyDefinitionBase[]): Promise<void>;
    //Load(bodyType: BodyType, ...additionalProperties: PropertyDefinitionBase[]): Promise<void>; //info: not implemented - incompatible declaration type
    /**
     * Loads this attachment.
     *
     * @param   {BodyType}   bodyType               The body type to load.
     * @param   {PropertyDefinitionBase[]}   additionalProperties   The optional additional properties to load.
     */
    Load(bodyType?: BodyType, additionalProperties?: PropertyDefinitionBase[]): Promise<void>;
    Load(bodyTypeOrPeoperties?: BodyType | PropertyDefinitionBase[], additionalProperties?: PropertyDefinitionBase[]): Promise<void> {
        let argsLength = arguments.length;
        let props: PropertyDefinitionBase[] = null;
        let bodyType: BodyType = null;
        if (argsLength === 1) {
            props = <PropertyDefinitionBase[]>bodyTypeOrPeoperties;
        }
        if (argsLength === 2) {
            bodyType = <BodyType>bodyTypeOrPeoperties;
        }
        if (argsLength > 2) {
            throw new Error("ItemAttachment.ts - Load with " + argsLength + " parameters, invalid number of arguments, check documentation and try again.");
        }
        return this.InternalLoad(bodyType, props);
    }

    /**
     * @internal Loads from XMLjsObject.
     *
     * @param   {any}               jsObject   The json property.
     * @param   {ExchangeService}   service        [description]
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.Item:
                case XmlElementNames.CalendarItem:
                case XmlElementNames.Contact:
                case XmlElementNames.DistributionList:
                case XmlElementNames.Conversation:
                case XmlElementNames.Message:
                case XmlElementNames.MeetingCancellation:
                case XmlElementNames.MeetingMessage:
                case XmlElementNames.MeetingRequest:
                case XmlElementNames.MeetingResponse:
                case XmlElementNames.Persona:
                case XmlElementNames.PostItem:
                case XmlElementNames.Task:
                    let itemObj = jsObject[key];
                    if (itemObj != null) {
                        this.item = (new ItemInfo()).CreateEwsObjectFromXmlElementName<Item>(this.Service, key);
                        if (this.item != null) {
                            this.item.LoadFromXmlJsObject(itemObj, this.Service, true);
                        }
                    }
                    break;
                default:
                    break;
            }
        }
    }

    //ReadElementsFromXmlJsObject(reader: any): void { throw new Error("ItemAttachment.ts - TryReadElementFromXmlJsObject : Not implemented."); }    
    ReadElementsFromXmlJsObjectToPatch(reader: any): boolean { throw new Error("ItemAttachment.ts - TryReadElementFromXmlToPatch : Not implemented."); }

    /**
     * @internal Validates this instance.
     *
     * @param   {number}   attachmentIndex   Index of this attachment.
     */
    Validate(attachmentIndex: number): void {
        if (StringHelper.IsNullOrEmpty(this.Name)) {
            throw new ServiceValidationException(StringHelper.Format(Strings.ItemAttachmentMustBeNamed, attachmentIndex));
        }

        // Recurse through any items attached to item attachment.
        this.Item.Attachments.Validate();
    }

    /**
     * @internal Writes the properties of this object as XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer to write the elements to.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);
        this.Item.WriteToXml(writer);
    }
}

/**
 * Represents a strongly typed item attachment. **Workaround of ItemAttachment<TItem>** - not allowed in typescript to have two class, one generic and one non-generic
 */
export class ItemAttachmentOf<TItem extends Item> extends ItemAttachment {
    /**
     * Gets the item associated with the attachment.
     */
    get Item(): TItem { return <TItem>this.item; }
    set Item(value: TItem) { /** this.Item = value; */  super._setItem(value)}

    /**
     * @internal Initializes a new instance of the **ItemAttachmentOf** class.
     *
     * @param   {Item}   owner   The owner of the attachment.
     */
    constructor(owner: Item) {
        super(owner);
    }
}
//Moved to ItemAttachmentOf.ts for simplicity

/**
 * Represents an entry of a DictionaryProperty object.
 * @remarks All descendants of DictionaryEntryProperty must implement a parameterless constructor. That constructor does not have to be public.
 * @typeparam   {TKey}     The type of the key used by this dictionary.
 * [EditorBrowsable(EditorBrowsableState.Never)]
 */
export class DictionaryEntryProperty<TKey> extends ComplexProperty {

    /** ews-javascript-api specific workaround for inheritance */
    protected keyType: any;

    private key: TKey = null;

    /**
     * Gets or sets the key.
     * @value   The key.
     */
    get Key(): TKey {
        return this.key;
    }
    set Key(value: TKey) {
        this.key = value;
    }

    /**
     * @internal Initializes a new instance of the **DictionaryEntryProperty<TKey>** class.
     *
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **DictionaryEntryProperty<TKey>** class.
     *
     * @param   {}   key   The key.
     */
    constructor(key: TKey);
    constructor(key?: TKey) {
        super();
        this.key = key;
    }
    /**@internal */
    ReadAttributesFromXmlJsObject(reader: EwsServiceXmlReader): void { throw new Error("DictionaryEntryProperty.ts - ReadAttributesFromXml : Not used."); }

    /**
     * @internal Writes attributes to XML.
     * @override
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.Key, this.keyType[this.Key]);
    }

    /**
     * @internal Writes the delete update to XML.
     * @virtual
     * @param   {EwsServiceXmlWriter}   writer      The writer.
     * @param   {ServiceObject}         ewsObject   The ews object.
     * @return  {boolean}               True if update XML was written.
     */
    WriteDeleteUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject): boolean {
        return false;
    }

    /**
     * @internal Writes the set update to XML.
     * @virtual
     * @param   {EwsServiceXmlWriter}   writer                          The writer.
     * @param   {ServiceObject}         ewsObject                       The ews object.
     * @param   {string}                ownerDictionaryXmlElementName   Name of the owner dictionary XML element.
     * @return  {boolean}               True if update XML was written.
     */
    WriteSetUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject, ownerDictionaryXmlElementName: string): boolean {
        return false;
    }
}
export class EmailAddressEntry extends DictionaryEntryProperty<EmailAddressKey> {
    private emailAddress: EmailAddress = null;
    get EmailAddress(): EmailAddress {
        return this.emailAddress;
    }
    set EmailAddress(value: EmailAddress) {
        this.SetFieldValue<EmailAddress>({ getValue: () => this.emailAddress, setValue: (address: EmailAddress) => { this.emailAddress = address } }, value);

        if (this.emailAddress != null) {
            this.emailAddress.OnChange.push(this.EmailAddressChanged.bind(this));
        }
    }

    constructor();
    constructor(key: EmailAddressKey, emailAddress: EmailAddress);
    constructor(key: EmailAddressKey = EmailAddressKey.EmailAddress1, emailAddress: EmailAddress = new EmailAddress()) {
        super(key);
        this.keyType = EmailAddressKey;
        this.emailAddress = emailAddress;
        if (this.emailAddress != null) {
            this.emailAddress.OnChange.push(this.EmailAddressChanged.bind(this));
        }
    }
    EmailAddressChanged(complexProperty: ComplexProperty): void { this.Changed(); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlAttributeNames.Key:
                    this.Key = <EmailAddressKey><any>EmailAddressKey[jsonProperty[key]];
                    break;
                case XmlAttributeNames.Name:
                    this.EmailAddress.Name = jsonProperty[key];
                    break;
                case XmlAttributeNames.RoutingType:
                    this.EmailAddress.RoutingType = jsonProperty[key];
                    break;
                case XmlAttributeNames.MailboxType:
                    this.EmailAddress.MailboxType = MailboxType.FromEwsEnumString(jsonProperty[key]);
                    break;
                case XmlElementNames.EmailAddress:
                    this.EmailAddress.Address = jsonProperty[key];
                    break;
            }
        }
        //ref: ews-javascript-api specific workaround for text node in complexproperty
        if (jsonProperty[XmlElementNames.Entry]) {
            if (this.emailAddress.Address === null) {
                this.emailAddress.Address = jsonProperty[XmlElementNames.Entry];
            }
        }
    }
    // ReadAttributesFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("EmailAddressEntry.ts - ReadAttributesFromXml : Not implemented."); }
    // ReadTextValueFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("EmailAddressEntry.ts - ReadTextValueFromXml : Not implemented."); }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        if (writer.Service.RequestedServerVersion > ExchangeVersion.Exchange2007_SP1) {
            writer.WriteAttributeValue(XmlAttributeNames.Name, this.EmailAddress.Name);
            writer.WriteAttributeValue(XmlAttributeNames.RoutingType, this.EmailAddress.RoutingType);
            if (this.EmailAddress.MailboxType != MailboxType.Unknown) {
                writer.WriteAttributeValue(XmlAttributeNames.MailboxType, MailboxType.ToEwsEnumString(this.EmailAddress.MailboxType));
            }
        }
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { writer.WriteValue(this.EmailAddress.Address, XmlElementNames.EmailAddress); }
}
export class ImAddressEntry extends DictionaryEntryProperty<ImAddressKey> {
    private imAddress: string = null;
    get ImAddress(): string {
        return this.imAddress;
    }
    set ImAddress(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.imAddress, setValue: (address: string) => { this.imAddress = address } }, value);
    }
    constructor();
    constructor(key: ImAddressKey, imAddress: string);
    constructor(key: ImAddressKey = ImAddressKey.ImAddress1, imAddress: string = null) {
        super(key);
        this.keyType = ImAddressKey;
        this.imAddress = imAddress;
    }

    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        this.Key = <ImAddressKey><any>ImAddressKey[jsonProperty[XmlAttributeNames.Key]];
        this.ImAddress = jsonProperty[XmlElementNames.Entry];// ImAddress];//ElementValue becomes Same ElementName when it has attribute. 
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { writer.WriteValue(this.ImAddress, XmlElementNames.ImAddress); }
}
export class PhoneNumberEntry extends DictionaryEntryProperty<PhoneNumberKey> {
    private phoneNumber: string = null;
    get PhoneNumber(): string {
        return this.phoneNumber;
    }
    set PhoneNumber(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.phoneNumber, setValue: (address: string) => { this.phoneNumber = address } }, value);
    }
    constructor();
    constructor(key: PhoneNumberKey, imAddress: string);
    constructor(key: PhoneNumberKey = PhoneNumberKey.AssistantPhone, phoneNumber: string = null) {
        super(key);
        this.keyType= PhoneNumberKey;
        this.phoneNumber = phoneNumber;
    }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        this.Key = <PhoneNumberKey><any>PhoneNumberKey[jsonProperty[XmlAttributeNames.Key]];
        this.phoneNumber = jsonProperty[XmlElementNames.Entry];//PhoneNumber
    } 
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { writer.WriteValue(this.PhoneNumber, XmlElementNames.PhoneNumber); }
}


class PhysicalAddressSchema {
	static Street: string = "Street";
	static City: string = "City";
	static State: string = "State";
	static CountryOrRegion: string = "CountryOrRegion";
	static PostalCode: string = "PostalCode";
	private static xmlElementNames: LazyMember<string[]> = new LazyMember<string[]>(() => {
		var list: string[] = [];
		list.push("Street");
		list.push("City");
		list.push("State");
		list.push("CountryOrRegion");
		list.push("PostalCode");
		return list;
	});

	static get XmlElementNames(): string[] {
		return PhysicalAddressSchema.xmlElementNames.Member;
	}
}

/**
 * PhysicalAddressEntry class
 */
export class PhysicalAddressEntry extends DictionaryEntryProperty<PhysicalAddressKey> {

	private propertyBag: SimplePropertyBag<string> = null;
	get Street(): string {
		return <string>this.propertyBag._getItem("Street");
	}
	set Street(value: string) {
		this.propertyBag._setItem("Street", value);
	}
	get City(): string {
		return <string>this.propertyBag._getItem("City");
	}
	set City(value: string) {
		this.propertyBag._setItem("City", value);
	}
	get State(): string {
		return <string>this.propertyBag._getItem("State");
	}
	set State(value: string) {
		this.propertyBag._setItem("State", value);
	}
	get CountryOrRegion(): string {
		return <string>this.propertyBag._getItem("CountryOrRegion");
	}
	set CountryOrRegion(value: string) {
		this.propertyBag._setItem("CountryOrRegion", value);
	}
	get PostalCode(): string {
		return <string>this.propertyBag._getItem("PostalCode");
	}
	set PostalCode(value: string) {
		this.propertyBag._setItem("PostalCode", value);
	}

	constructor() {
		super();
		this.keyType = PhysicalAddressKey;
		this.propertyBag = new SimplePropertyBag<string>((key: string) => key);
		this.propertyBag.OnChange.push(this.PropertyBagChanged.bind(this));
	}
	ClearChangeLog(): void { this.propertyBag.ClearChangeLog(); }
	private GetFieldUri(xmlElementName: string): string { return "contacts:PhysicalAddress:" + xmlElementName; }
	InternalToJson(service: ExchangeService): any { throw new Error("PhysicalAddressEntry.ts - InternalToJson : Not implemented."); }
	/**@internal */
    InternalWriteDeleteFieldToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject, fieldXmlElementName: string): void {
		writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetDeleteFieldXmlElementName());
		writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.IndexedFieldURI);
		writer.WriteAttributeValue(XmlAttributeNames.FieldURI, this.GetFieldUri(fieldXmlElementName));
		writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, PhysicalAddressKey[this.Key]);
		writer.WriteEndElement(); // IndexedFieldURI
		writer.WriteEndElement(); // ewsObject.GetDeleteFieldXmlElementName()
	}
	InternalWriteDeleteUpdateToJson(ewsObject: ServiceObject, propertyName: string, updates: any[] /*System.Collections.Generic.List<any>*/): void { throw new Error("PhysicalAddressEntry.ts - InternalWriteDeleteUpdateToJson : Not implemented."); }
	LoadFromJson(jsonProperty: any, service: ExchangeService): void { throw new Error("PhysicalAddressEntry.ts - LoadFromJson : Not implemented."); }
	PropertyBagChanged(): void { this.Changed(); }
	LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
		this.Key = <PhysicalAddressKey><any>PhysicalAddressKey[jsonProperty[XmlAttributeNames.Key]];
		this.Street = jsonProperty[XmlElementNames.Street];
		this.City = jsonProperty[XmlElementNames.City];
		this.State = jsonProperty[XmlElementNames.State];
		this.Street = jsonProperty[XmlElementNames.Street];
		this.CountryOrRegion = jsonProperty[XmlElementNames.CountryOrRegion];
		this.PostalCode = jsonProperty[XmlElementNames.PostalCode];
	}
	WriteDeleteUpdateToJson(service: ExchangeService, ewsObject: ServiceObject, updates: any[] /*System.Collections.Generic.List<any>*/): boolean { throw new Error("PhysicalAddressEntry.ts - WriteDeleteUpdateToJson : Not implemented."); }
	/**@internal */
    WriteDeleteUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject): boolean {
		for (var xmlElementName of PhysicalAddressSchema.XmlElementNames) {
			this.InternalWriteDeleteFieldToXml(
				writer,
				ewsObject,
				xmlElementName);
		}
		return true;
	}
	/**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		for (var xmlElementName of PhysicalAddressSchema.XmlElementNames) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				xmlElementName,
				this.propertyBag._getItem(xmlElementName));
		}
	}
	WriteSetUpdateToJson(service: ExchangeService, ewsObject: ServiceObject, propertyDefinition: PropertyDefinition, updates: any[] /*System.Collections.Generic.List<JsonObject>*/): boolean { throw new Error("PhysicalAddressEntry.ts - WriteSetUpdateToJson : Not implemented."); }
	/**@internal */
    WriteSetUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject, ownerDictionaryXmlElementName: string): boolean {
		var fieldsToSet: string[] = [];

		for (var xmlElementName of this.propertyBag.AddedItems) {
			fieldsToSet.push(xmlElementName);
		}

		for (var xmlElementName of this.propertyBag.ModifiedItems) {
			fieldsToSet.push(xmlElementName);
		}

		for (var xmlElementName of fieldsToSet) {
			writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetSetFieldXmlElementName());

			writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.IndexedFieldURI);
			writer.WriteAttributeValue(XmlAttributeNames.FieldURI, this.GetFieldUri(xmlElementName));
			writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, PhysicalAddressKey[this.Key]);
			writer.WriteEndElement(); // IndexedFieldURI

			writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetXmlElementName());
			writer.WriteStartElement(XmlNamespace.Types, ownerDictionaryXmlElementName);
			writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Entry);
			this.WriteAttributesToXml(writer);
			writer.WriteElementValue(
				XmlNamespace.Types,
				xmlElementName,
				this.propertyBag._getItem(xmlElementName));
			writer.WriteEndElement(); // Entry
			writer.WriteEndElement(); // ownerDictionaryXmlElementName
			writer.WriteEndElement(); // ewsObject.GetXmlElementName()

			writer.WriteEndElement(); // ewsObject.GetSetFieldXmlElementName()
		}

		for (var xmlElementName of this.propertyBag.RemovedItems) {
			this.InternalWriteDeleteFieldToXml(
				writer,
				ewsObject,
				xmlElementName);
		}

		return true;
	}
}

/**
 * Represents a generic dictionary that can be sent to or retrieved from EWS.
 * 
 * @typeparam   <TKey>      The type of key.
 * @typeparam   <TEntry>    The type of entry.
 */
export abstract class DictionaryProperty<TKey, TEntry extends DictionaryEntryProperty<TKey>> extends ComplexProperty implements ICustomUpdateSerializer {

    private dictionaryKeyType: DictionaryKeyType = DictionaryKeyType.EmailAddressKey;
    private dictionaryKeyTypeEnum: any;
    private dictionaryKeyDelegate: StringKeyPicker<TKey> = (key) => { return this.dictionaryKeyTypeEnum[<any>key] };
    private entries: Dictionary<TKey, TEntry> = new Dictionary<TKey, TEntry>(this.dictionaryKeyDelegate);
    private removedEntries: Dictionary<TKey, TEntry> = new Dictionary<TKey, TEntry>(this.dictionaryKeyDelegate);
    private addedEntries: TKey[] = [];
    private modifiedEntries: TKey[] = [];

    /**
     * Gets the entries.
     * 
     * @value   The entries.
     */
    get Entries(): Dictionary<TKey, TEntry> {
        return this.entries;
    }

    /**
     * @internal Initializes a new instance of the **DictionaryProperty** class.
     *
     * @param   {DictionaryKeyType}	dictionaryKeyType	Dictionary Key type, needed to workaround c# type checking of generics.    
     */
    constructor(dictionaryKeyType: DictionaryKeyType) {
        super();
        this.dictionaryKeyType = dictionaryKeyType;

        this.dictionaryKeyTypeEnum = EwsUtilities.GetDictionaryKeyTypeEnum(this.dictionaryKeyType);
    }

    /**
     * @internal Clears the change log.
     */
    ClearChangeLog(): void {
        this.addedEntries.splice(0);
        this.removedEntries.clear();
        this.modifiedEntries.splice(0);

        for (var entry of this.entries.Values) {
            entry.ClearChangeLog();
        }
    }

    /**
     * Determines whether this instance contains the specified key.
     *
     * @param   {TKey}      key   The key.
     * @return  {boolean}   true if this instance contains the specified key; otherwise, false.
     */
    Contains(key: TKey): boolean {
        return this.Entries.containsKey(key);
    }

    /**
     * @internal Creates the entry.
     *
     * @return  {TEntry}  Dictionary entry.
     */
    CreateEntry(): TEntry {
        return this.CreateEntryInstance();
    }

    /**
     * @internal Creates instance of dictionary entry.
     *
     * @return  {TEntry}      New instance.
     */
    abstract CreateEntryInstance(): TEntry;

    /**
     * Entry was changed.
     *
     * @param   {}   complexProperty   The complex property.
     */
    private EntryChanged(complexProperty: ComplexProperty): void {
        var key: TKey = (<DictionaryEntryProperty<any>>complexProperty).Key;

        if (this.addedEntries.indexOf(key) === -1 && this.modifiedEntries.indexOf(key) === -1) {
            this.modifiedEntries.push(key);
            this.Changed();
        }
    }

    /**
     * @internal Gets the name of the entry XML element.
     *
     * @param   {TEntry}    entry   The entry.
     * @return  {string}    XML element name.
     */
    GetEntryXmlElementName(entry: TEntry): string {
        return XmlElementNames.Entry;
    }

    /**
     * @internal Gets the index of the field.
     *
     * @param   {TKey}      key   The key.
     * @return  {string}    Key index.
     */
    GetFieldIndex(key: TKey): string {
        return this.dictionaryKeyTypeEnum[<any>key];
    }

    /**
     * @internal Gets the field URI.
     *
     * @return  {string}      Field URI.
     */
    GetFieldURI(): string {
        return null;
    }

    /**
     * @internal Add entry.
     *
     * @param   {TEntry}   entry   The entry.
     */
    InternalAdd(entry: TEntry): void {
        entry.OnChange.push(this.EntryChanged.bind(this));

        this.entries.Add(entry.Key, entry);
        this.addedEntries.push(entry.Key);
        this.removedEntries.remove(entry.Key);
        this.Changed();
    }

    /**
     * @internal Add or replace entry.
     *
     * @param   {TEntry}   entry   The entry.
     */
    InternalAddOrReplace(entry: TEntry): void {
        var oldEntry: IOutParam<TEntry> = { outValue: null };

        if (this.entries.tryGetValue(entry.Key, oldEntry)) {
            ArrayHelper.RemoveEntry(oldEntry.outValue.OnChange, this.EntryChanged);

            entry.OnChange.push(this.EntryChanged.bind(this));

            if (this.addedEntries.indexOf(entry.Key) === -1) {
                if (this.modifiedEntries.indexOf(entry.Key) === -1) {
                    this.modifiedEntries.push(entry.Key);
                }
            }

            this.Changed();
        }
        else {
            this.InternalAdd(entry);
        }
    }

    /**
     * Remove entry based on key.
     *
     * @param   {TKey}   key   The key.
     */
    InternalRemove(key: TKey): void {
        var entry: IOutParam<TEntry> = { outValue: null };

        if (this.entries.tryGetValue(key, entry)) {
            ArrayHelper.RemoveEntry(entry.outValue.OnChange, this.EntryChanged);

            this.entries.remove(key);
            this.removedEntries.Add(key, entry.outValue);
            this.Changed();
        }

        ArrayHelper.RemoveEntry(this.addedEntries, key);
        ArrayHelper.RemoveEntry(this.modifiedEntries, key);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        if (jsonProperty[XmlElementNames.Entry]) {
            var entries: any[] = EwsServiceJsonReader.ReadAsArray(jsonProperty, XmlElementNames.Entry);
            for (var jsonEntry of entries) {
                var entry: TEntry = this.CreateEntryInstance();
                entry.LoadFromXmlJsObject(jsonEntry, service);
                this.InternalAdd(entry);
            }
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        for (var keyValuePair of this.entries.Items) {
            keyValuePair.value.WriteToXml(writer, this.GetEntryXmlElementName(keyValuePair.value));
        }
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          xmlNamespace     The XML namespace.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string, xmlNamespace?: XmlNamespace): void {
        // Only write collection if it has at least one element.
        if (this.entries.Count > 0) {
            super.WriteToXml(
                writer,
                xmlElementName,
                xmlNamespace)
        }
    }

    /**
     * Writes the URI to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     * @param   {TKey}                  key      The key.
     */
    private WriteUriToXml(writer: EwsServiceXmlWriter, key: TKey): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.IndexedFieldURI);
        writer.WriteAttributeValue(XmlAttributeNames.FieldURI, this.GetFieldURI());
        writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, this.GetFieldIndex(key));
        writer.WriteEndElement();
    }

    /**
     * @internal Writes the update to XML.
     * ICustomUpdateSerializer.WriteSetUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer.
     * @param   {ServiceObject}         ewsObject            The ews object.
     * @param   {PropertyDefinition}    propertyDefinition   Property definition.
     * @return  {boolean}               True if property generated serialization.
     */
    WriteSetUpdateToXml(
        writer: EwsServiceXmlWriter,
        ewsObject: ServiceObject,
        propertyDefinition: PropertyDefinition): boolean {

        let tempEntries: TEntry[] = [];

        for (let key of this.addedEntries) {
            tempEntries.push(this.entries.get(key));
        }
        for (let key of this.modifiedEntries) {
            tempEntries.push(this.entries.get(key));
        }

        for (let entry of tempEntries) {
            if (!entry.WriteSetUpdateToXml(
                writer,
                ewsObject,
                propertyDefinition.XmlElementName)) {
                writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetSetFieldXmlElementName());
                this.WriteUriToXml(writer, entry.Key);

                writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetXmlElementName());
                writer.WriteStartElement(XmlNamespace.Types, propertyDefinition.XmlElementName);
                entry.WriteToXml(writer, this.GetEntryXmlElementName(entry));
                writer.WriteEndElement();
                writer.WriteEndElement();

                writer.WriteEndElement();
            }
        }

        for (let entry of this.removedEntries.Values) {
            if (!entry.WriteDeleteUpdateToXml(writer, ewsObject)) {
                writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetDeleteFieldXmlElementName());
                this.WriteUriToXml(writer, entry.Key);
                writer.WriteEndElement();
            }
        }

        return true;
    }

    /**
     * @internal Writes the deletion update to XML.
     * ICustomUpdateSerializer.WriteDeleteUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer      The writer.
     * @param   {ServiceObject}         ewsObject   The ews object.
     * @return  {boolean}               True if property generated serialization.
     */
    WriteDeleteUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject): boolean {
        // Use the default XML serializer.
        return false;
    }
}
export class EmailAddressDictionary extends DictionaryProperty<EmailAddressKey, EmailAddressEntry> {

    constructor() {
        super(DictionaryKeyType.EmailAddressKey);
    }

    /**
     * Gets or sets the e-mail address at the specified key.
     *
     * @param   {EmailAddressKey}   key   The key of the e-mail address to get or set.
     * @return  {EmailAddress}         The e-mail address at the specified key.
     */
    _getItem(key: EmailAddressKey): EmailAddress {
        return this.Entries.get(key).EmailAddress;
    }

    /**
     * Gets or sets the e-mail address at the specified key.
     *
     * @param   {EmailAddressKey}   key   The key of the e-mail address to get or set.
     * @return  {EmailAddress}         The e-mail address at the specified key.
     */
    _setItem(key: EmailAddressKey, value: EmailAddress) {
        if (value == null) {
            this.InternalRemove(key);
        }
        else {
            var entry: IOutParam<EmailAddressEntry> = { outValue: null };

            if (this.Entries.tryGetValue(key, entry)) {
                entry.outValue.EmailAddress = value;
                this.Changed();
            }
            else {
                let newEntry = new EmailAddressEntry(key, value);
                this.InternalAdd(newEntry);
            }
        }
    }

    /**
     * @internal Creates instance of dictionary entry.
     *
     * @return  {EmailAddressEntry}      New instance.
     */
    CreateEntryInstance(): EmailAddressEntry { return new EmailAddressEntry(); }

    /**
     * @internal Gets the field URI.
     *
     * @return  {string}      Field URI.
     */
    GetFieldURI(): string { return "contacts:EmailAddress"; }

    /**
     * Tries to get the e-mail address associated with the specified key.
     *
     * @param   {EmailAddressKey}   key            The key.
     * @param   {IOutParam<EmailAddress>}   emailAddress   When this method returns, contains the e-mail address associated with the specified key, if the key is found; otherwise, null. This parameter is passed uninitialized.
     * @return  {boolean}                  true if the Dictionary contains an e-mail address associated with the specified key; otherwise, false.
     */
    TryGetValue(key: EmailAddressKey, emailAddress: IOutParam<EmailAddress>): boolean {
        let entry: IOutParam<EmailAddressEntry> = { outValue: null };

        if (this.Entries.tryGetValue(key, entry)) {
            emailAddress.outValue = entry.outValue.EmailAddress;

            return true;
        }
        else {
            emailAddress = null;

            return false;
        }
    }
}
export class ImAddressDictionary extends DictionaryProperty<ImAddressKey, ImAddressEntry> {
    constructor() {
        super(DictionaryKeyType.ImAddressKey);
    }
    _getItem(key: ImAddressKey): string {
        return this.Entries.get(key).ImAddress;
    }

    _setItem(key: ImAddressKey, value: string) {
        if (value == null) {
            this.InternalRemove(key);
        }
        else {
            var entry: IOutParam<ImAddressEntry> = { outValue: null };

            if (this.Entries.tryGetValue(key, entry)) {
                entry.outValue.ImAddress = value;
                this.Changed();
            }
            else {
                let newEntry = new ImAddressEntry(key, value);
                this.InternalAdd(newEntry);
            }
        }
    }
    CreateEntryInstance(): ImAddressEntry { return new ImAddressEntry(); }
    GetFieldURI(): string { return "contacts:ImAddress"; }
    TryGetValue(key: ImAddressKey, imAddress: IOutParam<string>): boolean {
        var entry: IOutParam<ImAddressEntry> = { outValue: null };

        if (this.Entries.tryGetValue(key, entry)) {
            imAddress.outValue = entry.outValue.ImAddress;
            return true;
        }
        else {
            imAddress.outValue = null;
            return false;
        }
    }
}
export class PhoneNumberDictionary extends DictionaryProperty<PhoneNumberKey, PhoneNumberEntry> {
    constructor() {
        super(DictionaryKeyType.PhoneNumberKey);
    }
    _getItem(key: PhoneNumberKey): string {
        return this.Entries.get(key).PhoneNumber;
    }

    _setItem(key: PhoneNumberKey, value: string) {
        if (value == null) {
            this.InternalRemove(key);
        }
        else {
            var entry: IOutParam<PhoneNumberEntry> = { outValue: null };

            if (this.Entries.tryGetValue(key, entry)) {
                entry.outValue.PhoneNumber = value;
                this.Changed();
            }
            else {
                let newEntry = new PhoneNumberEntry(key, value);
                this.InternalAdd(newEntry);
            }
        }
    }

    CreateEntryInstance(): PhoneNumberEntry {return new PhoneNumberEntry(); }
    GetFieldURI(): string { return "contacts:PhoneNumber"; }
    TryGetValue(key: PhoneNumberKey, phoneNumber: IOutParam<string>): boolean {
        var entry: IOutParam<PhoneNumberEntry> = { outValue: null };

        if (this.Entries.tryGetValue(key, entry)) {
            phoneNumber.outValue = entry.outValue.PhoneNumber;

            return true;
        }
        else {
            phoneNumber = null;

            return false;
        }
    }
}
export class PhysicalAddressDictionary extends DictionaryProperty<PhysicalAddressKey, PhysicalAddressEntry> {
    constructor() {
        super(DictionaryKeyType.PhysicalAddressKey);
    }
    _getItem(key: PhysicalAddressKey): PhysicalAddressEntry {
        return this.Entries.get(key);
    }

    _setItem(key: PhysicalAddressKey, value: PhysicalAddressEntry) {
        if (value == null) {
            this.InternalRemove(key);
        }
        else {
            value.Key = key;
            this.InternalAddOrReplace(value);
        }
    }
    CreateEntryInstance(): PhysicalAddressEntry { return new PhysicalAddressEntry(); }
    TryGetValue(key: PhysicalAddressKey, physicalAddress: IOutParam<PhysicalAddressEntry>): boolean { return this.Entries.tryGetValue(key, physicalAddress); }
}

/**
 * Represents an e-mail address.
 */
export class EmailAddress extends ComplexProperty implements ISearchStringProvider {

    /**
     * SMTP routing type.
     */
    static SmtpRoutingType: string = "SMTP";

    /**
     * Display name.
     */
    private name: string = null;

    /**
     * Email address.
     */
    private address: string = null;

    /**
     * Routing type.
     */
    private routingType: string = null;

    /**
     * Mailbox type. 
     */
    private mailboxType: MailboxType = null;

    /**
     * ItemId - Contact or PDL.
     */
    private id: ItemId = null;

    /**
     * Gets or sets the name associated with the e-mail address.
     */
    get Name(): string {
        return this.name;
    }
    set Name(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.name, setValue: (updateValue) => { this.name = updateValue } }, value);
    }

    /**
     * Gets or sets the actual address associated with the e-mail address. The type of the Address property must match the specified routing type. If RoutingType is not set, Address is assumed to be an SMTP address.
     */
    get Address(): string {
        return this.address;
    }
    set Address(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.address, setValue: (updateValue) => { this.address = updateValue } }, value);
    }

    /**
     * Gets or sets the routing type associated with the e-mail address. If RoutingType is not set, Address is assumed to be an SMTP address.
     */
    get RoutingType(): string {
        return this.routingType;
    }
    set RoutingType(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.routingType, setValue: (updateValue) => { this.routingType = updateValue } }, value);
    }

    /**
     * Gets or sets the type of the e-mail address.
     */
    get MailboxType(): MailboxType {
        return this.mailboxType;
    }
    set MailboxType(value: MailboxType) {
        this.SetFieldValue<MailboxType>({ getValue: () => this.mailboxType, setValue: (updateValue) => { this.mailboxType = updateValue } }, value);
    }

    /**
     * Gets or sets the Id of the contact the e-mail address represents. When Id is specified, Address should be set to null.
     */
    get Id(): ItemId {
        return this.id;
    }
    set Id(value: ItemId) {
        this.SetFieldValue<ItemId>({ getValue: () => this.id, setValue: (updateValue) => { this.id = updateValue } }, value);
    }

    /**
     * Initializes a new instance of the **EmailAddress** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **EmailAddress** class.
     *
     * @param   {string}        name          The name used to initialize the EmailAddress.
     */
    constructor(smtpAddress: string);
    /**
     * Initializes a new instance of the **EmailAddress** class.
     *
     * @param   {string}        name          The name used to initialize the EmailAddress.
     * @param   {string}        address       The address used to initialize the EmailAddress.
     */
    constructor(name: string, smtpAddress: string);
    /**
     * Initializes a new instance of the **EmailAddress** class.
     *
     * @param   {string}        name          The name used to initialize the EmailAddress.
     * @param   {string}        address       The address used to initialize the EmailAddress.
     * @param   {string}        routingType   The routing type used to initialize the EmailAddress.
     */
    constructor(name: string, address: string, routingType: string);
    /**
     * Initializes a new instance of the **EmailAddress** class.
     *
     * @param   {string}        name          The name used to initialize the EmailAddress.
     * @param   {string}        address       The address used to initialize the EmailAddress.
     * @param   {string}        routingType   The routing type used to initialize the EmailAddress.
     * @param   {MailboxType}   mailboxType   Mailbox type of the participant.
     */
    constructor(name: string, address: string, routingType: string, mailboxType: MailboxType);
    /**
     * Initializes a new instance of the **EmailAddress** class.
     *
     * @param   {string}        name          The name used to initialize the EmailAddress.
     * @param   {string}        address       The address used to initialize the EmailAddress.
     * @param   {string}        routingType   The routing type used to initialize the EmailAddress.
     * @param   {MailboxType}   mailboxType   Mailbox type of the participant.
     * @param   {ItemId}        itemId        ItemId of a Contact or PDL.
     */
    constructor(name: string, address: string, routingType: string, mailboxType: MailboxType, itemId: ItemId);
    /**
     * Initializes a new instance of the **EmailAddress** class from another EmailAddress instance.
     *
     * @param   {EmailAddress}   mailbox   EMailAddress instance to copy.
     */
    constructor(mailbox: EmailAddress);
    constructor(smtpAddressOrMailbox: string | EmailAddress); //for Attendee to call super() easily
    constructor(smtpAddressOrNameOrMailbox?: EmailAddress | string, smtpAddressOrAddress?: string, routingType?: string, mailboxType?: MailboxType, itemId?: ItemId) {
        super();
        if (smtpAddressOrNameOrMailbox instanceof EmailAddress) {
            EwsUtilities.ValidateParam(smtpAddressOrNameOrMailbox, "mailbox");

            this.Name = smtpAddressOrNameOrMailbox.Name;
            this.Address = smtpAddressOrNameOrMailbox.Address;
            this.RoutingType = smtpAddressOrNameOrMailbox.RoutingType;
            this.MailboxType = smtpAddressOrNameOrMailbox.MailboxType;
            this.Id = smtpAddressOrNameOrMailbox.Id;
        }
        else {
            let argsLength = arguments.length;
            if (argsLength === 1) {
                this.address = <string>smtpAddressOrNameOrMailbox;
            }
            else if (argsLength > 1) {
                this.name = <string>smtpAddressOrNameOrMailbox;
                this.address = smtpAddressOrAddress;
                if (argsLength >= 3) {
                    this.routingType = routingType;
                }
                if (argsLength >= 4) {
                    this.mailboxType = mailboxType;
                }
                if (argsLength === 5) {
                    this.id = itemId;
                }
            }
        }
    }

    /**
     * Get a string representation for using this instance in a search filter. 
     * ISearchStringProvider.GetSearchString
     *
     * @return  {string}      String representation of instance.
     */
    GetSearchString(): string {
        return this.Address;
    }

    ReadElementsFromXmlJsObject(reader: any): boolean { throw new Error("EmailAddress.ts - TryReadElementFromXmlJsObject : Not implemented."); }
    //todo: implement UpdateFromXmlJsObject

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.Name:
                    this.name = jsObject[key];
                    break;
                case XmlElementNames.EmailAddress:
                    this.address = jsObject[key];
                    break;
                case XmlElementNames.RoutingType:
                    this.routingType = jsObject[key];
                    break;
                case XmlElementNames.MailboxType:
                    this.mailboxType = MailboxType.FromEwsEnumString(jsObject[key])
                    break;
                case XmlElementNames.ItemId:
                    this.id = new ItemId();
                    this.id.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Returns a **string** that represents the current **object**.
     *
     * @return  {string}      A **string** that represents the current **object**.
     */
    ToString(): string {
        let addressPart: string = null;

        if (StringHelper.IsNullOrEmpty(this.Address)) {
            return StringHelper.Empty;
        }

        if (!StringHelper.IsNullOrEmpty(this.RoutingType)) {
            addressPart = this.RoutingType + ":" + this.Address;
        }
        else {
            addressPart = this.Address;
        }

        if (!StringHelper.IsNullOrEmpty(this.Name)) {
            return this.Name + " <" + addressPart + ">";
        }
        else {
            return addressPart;
        }
    }
    toString(): string {
        return this.ToString();
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Name, this.Name);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EmailAddress, this.Address);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RoutingType, this.RoutingType);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MailboxType, MailboxType.ToEwsEnumString(this.MailboxType));

        if (this.Id != null) {
            this.Id.WriteToXml(writer);//, XmlElementNames.ItemId);
        }
    }
}

/**
 * Represents an attendee to a meeting.
 */
export class Attendee extends EmailAddress {

    private responseType: MeetingResponseType;
    private lastResponseTime: DateTime;

    /**
     * Gets the type of response the attendee gave to the meeting invitation it received.
     */
    get ResponseType(): MeetingResponseType {
        return this.responseType;
    }

    /**
     * Gets the date and time when the attendee last responded to a meeting invitation or update.
     */
    get LastResponseTime(): DateTime {
        return this.lastResponseTime;
    }

    /**
     * Initializes a new instance of the **Attendee** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **Attendee** class.
     *
     * @param   {string}   name          The name used to initialize the Attendee.
     */
    constructor(smtpAddress: string);
    /**
     * Initializes a new instance of the **Attendee** class.
     *
     * @param   {string}   name          The name used to initialize the Attendee.
     * @param   {string}   smtpAddress   The SMTP address used to initialize the Attendee.
     */
    constructor(name: string, smtpAddress: string);
    /**
     * Initializes a new instance of the **Attendee** class.
     *
     * @param   {string}   name          The name used to initialize the Attendee.
     * @param   {string}   smtpAddress   The SMTP address used to initialize the Attendee.
     * @param   {string}   routingType   The routing type used to initialize the Attendee.
     */
    constructor(name: string, smtpAddress: string, routingType: string);
    /**
     * Initializes a new instance of the **Attendee** class from an EmailAddress.
     *
     * @param   {EmailAddress}   mailbox   The mailbox used to initialize the Attendee.
     */
    constructor(mailbox: EmailAddress);
    constructor(smtpAddressOrNameOrMailbox?: string | EmailAddress, smtpAddress?: string, routingType?: string) {
        switch (arguments.length) {
            case 1:
                super(smtpAddressOrNameOrMailbox);
                if (typeof smtpAddressOrNameOrMailbox === 'string') {
                    EwsUtilities.ValidateParam(smtpAddressOrNameOrMailbox, "smtpAddress");
                }
                break;
            case 2:
                super(<string>smtpAddressOrNameOrMailbox, smtpAddress);
                break;
            case 3:
                super(<string>smtpAddressOrNameOrMailbox, smtpAddress, routingType);
                break;
            default:
                super();
                break;
        }
        this.responseType = null;
        this.lastResponseTime = null;

    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }
            switch (key) {
                case XmlElementNames.Mailbox:
                    super.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ResponseType:
                    this.responseType = MeetingResponseType[<string>jsObject[key]];
                    break;
                case XmlElementNames.LastResponseTime:
                    this.lastResponseTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(this.Namespace, XmlElementNames.Mailbox);
        super.WriteElementsToXml(writer);
        writer.WriteEndElement();
    }
}



/**
 * Represents an ExtractedEntity object.
 */
export abstract class ExtractedEntity extends ComplexProperty {

    /**
     * Gets the Position.
     */
    Position: EmailPosition = EmailPosition.LatestReply;

    /**
     * Initializes a new instance of the **ExtractedEntity** class.
     */
    constructor() {
        super();
        this.Namespace = XmlNamespace.Types;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        if (jsObject[XmlElementNames.NlgEmailPosition]) {
            this.Position = EmailPosition[<string>jsObject[XmlElementNames.NlgEmailPosition]] || this.Position;
        }
        // for (let key in jsObject) {
        //     switch (key) {
        //         case XmlElementNames.NlgEmailPosition:
        //             this.Position = EmailPosition[<string>jsObject[key]] || this.Position;
        //             break;
        //         default:
        //             break;
        //     }
        // }
    }
}

/**
 * Represents an AddressEntity object.
 */
export class AddressEntity extends ExtractedEntity {

    /**
     * Gets the meeting suggestion Location.
     */
    Address: string;

    /**
     * Initializes a new instance of the **AddressEntity** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgAddress:
                    this.Address = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents an ContactEntity object.
 */
export class ContactEntity extends ExtractedEntity {

    /**
     * Gets the contact entity PersonName.
     */
    PersonName: string = null;

    /**
     * Gets the contact entity BusinessName.
     */
    BusinessName: string = null;

    /**
     * Gets the contact entity PhoneNumbers.
     */
    PhoneNumbers: ContactPhoneEntityCollection = null;

    /**
     * Gets the contact entity Urls.
     */
    Urls: StringList = null;

    /**
     * Gets the contact entity EmailAddresses.
     */
    EmailAddresses: StringList = null;

    /**
     * Gets the contact entity Addresses.
     */
    Addresses: StringList = null;

    /**
     * Gets the contact entity ContactString.
     */
    ContactString: string = null;

    /**
     * Initializes a new instance of the **ContactEntity** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgPersonName:
                    this.PersonName = jsObject[key];
                    break;
                case XmlElementNames.NlgBusinessName:
                    this.BusinessName = jsObject[key];
                    break;
                case XmlElementNames.NlgPhoneNumbers:
                    this.PhoneNumbers = new ContactPhoneEntityCollection();
                    this.PhoneNumbers.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgUrls:
                    this.Urls = new StringList(XmlElementNames.NlgUrl);
                    this.Urls.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgEmailAddresses:
                    this.EmailAddresses = new StringList(XmlElementNames.NlgEmailAddress);
                    this.EmailAddresses.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgAddresses:
                    this.EmailAddresses = new StringList(XmlElementNames.NlgEmailAddress);
                    this.Addresses.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgContactString:
                    this.ContactString = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents an EmailAddressEntity object.
 */
export class EmailAddressEntity extends ExtractedEntity {
    
    /**
     * Gets the meeting suggestion Location.
     */
    EmailAddress: string;

    /**
     * @internal Initializes a new instance of the **EmailAddressEntity** class.
     */
    constructor() {
        super();
    }
    
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgEmailAddress:
                    this.EmailAddress = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents an MeetingSuggestion object.
 */
export class MeetingSuggestion extends ExtractedEntity {

    /**
     * Gets the meeting suggestion Attendees.
     */
    Attendees: EmailUserEntityCollection = null;

    /**
     * Gets the meeting suggestion Location.
     */
    Location: string = null;

    /**
     * Gets the meeting suggestion Subject.
     */
    Subject: string = null;

    /**
     * Gets the meeting suggestion MeetingString.
     */
    MeetingString: string = null;

    /**
     * Gets the meeting suggestion StartTime.
     */
    StartTime: DateTime = null;

    /**
     * Gets the meeting suggestion EndTime.
     */
    EndTime: DateTime = null;

    /**
     * @internal Initializes a new instance of the **MeetingSuggestion** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgAttendees:
                    this.Attendees = new EmailUserEntityCollection();
                    this.Attendees.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgLocation:
                    this.Location = jsObject[key];
                    break;
                case XmlElementNames.NlgSubject:
                    this.Subject = jsObject[key];
                    break;
                case XmlElementNames.NlgMeetingString:
                    this.MeetingString = jsObject[key];
                    break;
                case XmlElementNames.NlgStartTime:
                    this.StartTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.NlgEndTime:
                    this.EndTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents an PhoneEntity object.
 */
export class PhoneEntity extends ExtractedEntity {

    /**
     * Gets the phone entity OriginalPhoneString.
     */
    OriginalPhoneString: string;

    /**
     * Gets the phone entity PhoneString.
     */
    PhoneString: string;

    /**
     * Gets the phone entity Type.
     */
    Type: string;

    /**
     * @internal Initializes a new instance of the **PhoneEntity** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgOriginalPhoneString:
                    this.OriginalPhoneString = jsObject[key];
                    break;
                case XmlElementNames.NlgPhoneString:
                    this.PhoneString = jsObject[key];
                    break;
                case XmlElementNames.NlgType:
                    this.Type = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents an TaskSuggestion object.
 */
export class TaskSuggestion extends ExtractedEntity {

    /**
     * Gets the meeting suggestion TaskString.
     */
    TaskString: string;

    /**
     * Gets the meeting suggestion Assignees.
     */
    Assignees: EmailUserEntityCollection;

    /**
     * @internal Initializes a new instance of the **TaskSuggestion** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgTaskString:
                    this.TaskString = jsObject[key];
                    break;
                case XmlElementNames.NlgAssignees:
                    this.Assignees = new EmailUserEntityCollection();
                    this.Assignees.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents an UrlEntity object.
 */
export class UrlEntity extends ExtractedEntity {

    Url: string;

    /**
     * Initializes a new instance of the **UrlEntity** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgUrl:
                    this.Url = jsObject[key]
                    break;
                default:
                    break;
            }
        }
    }
}

export class MessageBody extends ComplexProperty {
    private bodyType: BodyType = 0;
    private text: string = null;
    get BodyType(): BodyType {
        return this.bodyType;
    }
    set BodyType(value: BodyType) {
        this.SetFieldValue({ getValue: () => this.bodyType, setValue: (bodytype) => this.bodyType = bodytype }, value)
    }
    get Text(): string {
        return this.text;
    }
    set Text(value: string) {
        this.SetFieldValue({ getValue: () => this.text, setValue: (txt) => this.text = txt }, value)
    }
    constructor();
    constructor(text: string);
    constructor(bodyType: BodyType, text: string);
    constructor(bodyTypeOrText?: BodyType | string, text?: string) {
        super();
        var argslength = arguments.length
        if (argslength === 0) {
            return;
        }
        var bodyType = BodyType.HTML;
        var strText = text;
        if (argslength === 1 && typeof bodyTypeOrText === "string") {
            strText = bodyTypeOrText;
        }
        if (argslength === 2 && typeof bodyTypeOrText === "number") {
            bodyType = bodyTypeOrText;
        }
        this.bodyType = bodyType;
        this.text = strText;
    }
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (var key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }
            switch (key) {
                case XmlAttributeNames.BodyType:
                    this.bodyType = BodyType[<string>jsObject[key]];
                    break;
                case XmlElementNames.Body: //info - Body Element text - custom parser in ews-javascript-api. 
                case XmlElementNames.TextBody: //info - TextBody Element text - custom parser in ews-javascript-api. 
                    this.text = jsObject[key];
                    break;
                case XmlAttributeNames.IsTruncated:
                    //ref: IsTruncated not captured 
                    break;
                default:
                    //debugger;//check exact name of body element
                    EwsLogging.Log(`MessageBody->LoadFromXmlJsObject : element ${key} is skipped, open issue to fix this. `, true)
                    break;
            }
        }
    }
    /**@internal */
    ReadAttributesFromXmlJsObject(reader: EwsServiceXmlReader): void { throw new Error("MessageBody.ts - ReadAttributesFromXml : Not implemented. - should not be called"); }
    /**@internal */
    ReadTextValueFromXmlJsObject(reader: EwsServiceXmlReader): void { throw new Error("MessageBody.ts - ReadTextValueFromXml : Not implemented. - should not be called"); }
    ToString(): string { return (this.Text == null) ? StringHelper.Empty : this.Text; }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void { writer.WriteAttributeValue(XmlAttributeNames.BodyType, BodyType[this.BodyType]); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (!StringHelper.IsNullOrEmpty(this.Text)) {
            writer.WriteValue(this.Text, XmlElementNames.Body);
        }
    }
}

/**
 * Represents the body of a message.
 */
export class TextBody extends MessageBody {

    /**
     * Initializes a new instance of the **TextBody** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **TextBody** class.
     *
     * @param   {string}   text   The text of the message body.
     */
    constructor(text: string);
    constructor(text: string = null) {
        arguments.length === 0 ? super() : super(BodyType.Text, text);
    }
}

/**
 * Represents the MIME content of an item.
 */
export abstract class MimeContentBase extends ComplexProperty {

    /**
     * characterSet returned 
     */
    private characterSet: string;

    /**
     * content received
     */
    private content: string;//byte[]

    /**
     * to set XMLElementName when reading XML JsObject value.
     */
    protected xmlElementName: string = XmlElementNames.MimeContent;

    /**
     * Gets or sets the character set of the content.
     */
    get CharacterSet(): string {
        return this.characterSet;
    }
    set CharacterSet(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.characterSet, setValue: (updateValue) => { this.characterSet = updateValue } }, value);
    }

    /**
     * Gets or sets the content.  - ews-javascript-api this is base64 value without encoding applied.
     */
    get Content(): string {
        return this.content;
    }
    set Content(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.content, setValue: (updateValue) => { this.content = updateValue } }, value);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any/*JsonObject*/, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlAttributeNames.CharacterSet:
                    this.characterSet = jsObject[key];
                    break;
                case this.xmlElementName: //ref: text value in xml2jsobject
                    this.content = jsObject[key];;
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Writes attributes to XML.
     * 
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.CharacterSet, this.CharacterSet);
    }

    /**
     * @internal Writes elements to XML.
     * 
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (!StringHelper.IsNullOrEmpty(this.Content)) {
            writer.WriteValue(this.Content, this.xmlElementName);
            //writer.WriteBase64ElementValue(this.Content);
        }
    }
}

/**
 * Represents the MIME content of an item.
 */
export class MimeContent extends MimeContentBase {

    /**
     * Initializes a new instance of the **MimeContent** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **MimeContent** class.
     *
     * @param   {string}   characterSet   The character set of the content.
     * @param   {string}   content        The content.
     */
    constructor(characterSet: string, content: string);
    constructor(characterSet: string = null, content: string = null) {
        super();
        this.CharacterSet = characterSet;
        this.Content = content;
        this.xmlElementName = XmlElementNames.MimeContent;
    }

    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    ToString(): string {
        return this.Content || StringHelper.Empty;
        //ref: //info: 
        //todo: implement arraybuffer and encoding using TextDecoder or some other tech

        // if (this.Content == null) {
        //     return StringHelper.Empty;
        // }
        // else {
        //     try {
        //         // Try to convert to original MIME content using specified charset. If this fails, 
        //         // return the Base64 representation of the content.
        //         // Note: Encoding.GetString can throw DecoderFallbackException which is a subclass
        //         // of ArgumentException.
        //         string charSet = string.IsNullOrEmpty(this.CharacterSet)
        //             ? Encoding.UTF8.EncodingName
        //             : this.CharacterSet;
        //         Encoding encoding = Encoding.GetEncoding(charSet);
        //         return encoding.GetString(this.Content);
        //     }
        //     catch (ArgumentException) {
        //         return Convert.ToBase64String(this.Content);
        //     }
        // }
    }
    toString(): string { return this.ToString(); }
}

/**
 * Represents the MIME content of an item.
 */
export class MimeContentUTF8 extends MimeContentBase {

    /**
     * Initializes a new instance of the **MimeContentUTF8** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **MimeContentUTF8** class.
     *
     * @param   {string}   characterSet   The character set of the content.
     * @param   {string}   content        The content.
     */
    constructor(characterSet: string);
    constructor(characterSet: string = null) {
        super();
        this.CharacterSet = characterSet;
        this.Content = "utf-8";//c# - Encoding.UTF8.BodyName, nodejs - utf8 not utf-8
        this.xmlElementName = XmlElementNames.MimeContentUTF8;
    }

    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    ToString(): string {
        return this.Content || StringHelper.Empty;
        //ref: //info: 
        //todo: implement arraybuffer and encoding using TextDecoder or some other tech

        //            if (this.Content == null)
        //            {
        //                return string.Empty;
        //            }
        //            else
        //            {
        //                try
        //                {
        //                    // Try to convert to original MIME content using specified charset. If this fails, 
        //                    // return the Base64 representation of the content.
        //                    // Note: Encoding.GetString can throw DecoderFallbackException which is a subclass
        //                    // of ArgumentException.
        //                    // it should always be UTF8 encoding for MimeContentUTF8
        //                    return Encoding.UTF8.GetString(this.Content);
        //                }
        //                catch (ArgumentException)
        //                {
        //                    return Convert.ToBase64String(this.Content);
        //                }
        //            }
    }
    toString(): string { return this.ToString(); }
}




/**
 * Represents the retention tag of an item.
 */
export class RetentionTagBase extends ComplexProperty {

    /**
     * Xml element name.
     */
    private xmlElementName: string = null;

    /**
     * Is explicit.
     */
    private isExplicit: boolean = false;

    /**
     * Retention id.
     */
    private retentionId: Guid = null;

    /**
     * Gets or sets if the tag is explicit.
     */
    get IsExplicit(): boolean {
        return this.isExplicit;
    }
    set IsExplicit(value: boolean) {
        this.SetFieldValue<boolean>({ getValue: () => this.isExplicit, setValue: (updateValue) => { this.isExplicit = updateValue } }, value);
    }

    /**
     * Gets or sets the retention id.
     */
    get RetentionId(): Guid {
        return this.retentionId;
    }
    set RetentionId(value: Guid) {
        this.SetFieldValue<Guid>({ getValue: () => this.retentionId, setValue: (updateValue) => { this.retentionId = updateValue } }, value);
    }

    /**
     * Initializes a new instance of the **RetentionTagBase** class.
     * 
     * @param {string}  xmlElementName   Xml element name.
     */
    constructor(xmlElementName: string) {
        super();
        this.xmlElementName = xmlElementName;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlAttributeNames.IsExplicit:
                    this.isExplicit = Convert.toBool(jsObject[key]);
                    break;
                case this.xmlElementName:
                    this.retentionId = new Guid(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    ToString(): string {
        if (this.retentionId == null || this.retentionId == Guid.Empty) {
            return StringHelper.Empty;
        }
        else {
            return this.retentionId.ToString();
        }
    }
    toString(): string { return this.ToString(); }

    /**
     * @internal Writes attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.IsExplicit, this.isExplicit);
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (this.retentionId != null && this.retentionId != Guid.Empty) {
            writer.WriteValue(this.retentionId.ToString(), this.xmlElementName);
        }
    }
}

/**
 * Represents the archive tag of an item or folder.
 */
export class ArchiveTag extends RetentionTagBase {

    /**
     * Initializes a new instance of the **ArchiveTag** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **ArchiveTag** class.
     *
     * @param   {boolean}   isExplicit    Is explicit.
     * @param   {Guid}      retentionId   Retention id.
     */
    constructor(isExplicit: boolean, retentionId: Guid);
    constructor(isExplicit: boolean = false, retentionId: Guid = null) {
        super(XmlElementNames.ArchiveTag);
        this.IsExplicit = isExplicit;
        this.RetentionId = retentionId;
    }
}

/**
 * Represents the policy tag of an item or folder.
 */
export class PolicyTag extends RetentionTagBase {

    /**
     * Initializes a new instance of the **PolicyTag** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **PolicyTag** class.
     *
     * @param   {boolean}   isExplicit    Is explicit.
     * @param   {Guid}      retentionId   Retention id.
     */
    constructor(isExplicit: boolean, retentionId: Guid);
    constructor(isExplicit: boolean = false, retentionId: Guid = null) {
        super(XmlElementNames.PolicyTag);
        this.IsExplicit = isExplicit;
        this.RetentionId = retentionId;
    }
}
/**
 * Represents an operation to be performed on a rule.
 */
export abstract class RuleOperation extends ComplexProperty {

	/**
	 * @internal Gets the XML element name of the rule operation.
	 */
	get XmlElementName(): string {
		throw new Error("abstract - must implement");
	}

	/**
	 * @internal Initializes a new instance of the **RuleOperation** class.
	 */
	constructor() {
		super();
	}
}

/**
 * Represents an operation to create a new rule.
 * 
 * @sealed
 */
export class CreateRuleOperation extends RuleOperation {

    /**
     * Inbox rule to be created.
     */
    private rule: Rule;

    /**
     * Gets or sets the rule to be created.
     */
    get Rule(): Rule {
        return this.rule;
    }
    set Rule(value: Rule) {
        this.SetFieldValue<Rule>({ getValue: () => this.rule, setValue: (updateValue) => { this.rule = updateValue } }, value);
    }

    /**
     * @internal Gets the Xml element name of the CreateRuleOperation object.
     */
    get XmlElementName(): string {
        return XmlElementNames.CreateRuleOperation;
    }

    /**
     * Initializes a new instance of the **CreateRuleOperation** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **CreateRuleOperation** class.
     *
     * @param   {Rule}   rule   The inbox rule to create.
     */
    constructor(rule: Rule);
    constructor(rule: Rule = null) {
        super();
        this.rule = rule;
    }

    /**
	 * @internal Validates this instance.
	 */
    InternalValidate(): void {
        EwsUtilities.ValidateParam(this.rule, "Rule");
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.Rule.WriteToXml(writer, XmlElementNames.Rule);
    }
}

/**
 * Represents an operation to delete an existing rule.
 * 
 * @sealed
 */
export class DeleteRuleOperation extends RuleOperation {

    /**
     * Id of the inbox rule to delete.
     */
    private ruleId: string;

    /**
     * Gets or sets the Id of the rule to delete.
     */
    get RuleId(): string {
        return this.ruleId;
    }
    set RuleId(value: string) {
        this.SetFieldValue<string>({ getValue: () => this.ruleId, setValue: (updateValue) => { this.ruleId = updateValue } }, value);
    }

    /**
     * @internal Gets the Xml element name of the DeleteRuleOperation object.
     */
    get XmlElementName(): string {
        return XmlElementNames.DeleteRuleOperation;
    }

    /**
     * Initializes a new instance of the **DeleteRuleOperation** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **DeleteRuleOperation** class.
     *
     * @param   {string}   ruleId   The Id of the inbox rule to delete.
     */
    constructor(ruleId: string);
    constructor(ruleId: string = null) {
        super();
        this.ruleId = ruleId;
    }

    /**
	 * @internal Validates this instance.
	 */
    InternalValidate(): void {
        EwsUtilities.ValidateParam(this.ruleId, "RuleId");
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RuleId, this.RuleId);
    }
}

/**
 * Represents an operation to update an existing rule.
 * 
 * @sealed
 */
export class SetRuleOperation extends RuleOperation {

    /**
     * Inbox rule to be updated.
     */
    private rule: Rule;

    /**
     * Gets or sets the rule to be updated.
     */
    get Rule(): Rule {
        return this.rule;
    }
    set Rule(value: Rule) {
        this.SetFieldValue<Rule>({ getValue: () => this.rule, setValue: (updateValue) => { this.rule = updateValue } }, value);
    }

    /**
     * @internal Gets the Xml element name of the SetRuleOperation object.
     */
    get XmlElementName(): string {
        return XmlElementNames.SetRuleOperation;
    }

    /**
     * Initializes a new instance of the **SetRuleOperation** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **SetRuleOperation** class.
     *
     * @param   {Rule}   rule   The inbox rule to update.
     */
    constructor(rule: Rule);
    constructor(rule: Rule = null) {
        super();
        this.rule = rule;
    }

    /**
	 * @internal Validates this instance.
	 */
    InternalValidate(): void {
        EwsUtilities.ValidateParam(this.rule, "Rule");
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.Rule:
                    this.rule = new Rule();
                    this.rule.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.Rule.WriteToXml(writer, XmlElementNames.Rule);
    }
}

/**
 * Represents the Id of an Exchange object.
 *
 * @abstract
 * @class ServiceId
 * @extends {ComplexProperty}
 */
export abstract class ServiceId extends ComplexProperty {
    /**
     *Gets the unique Id of the Exchange object.
     *
     * @type {string}
     */
    UniqueId: string;

    /**
     *Gets the change key associated with the Exchange object. The change key represents the the version of the associated item or folder.
     *
     * @type {string}
     */
    ChangeKey: string;

    /**
     * True if this instance is valid, false otherthise.
     * 
     * @value   *true* if this instance is valid; otherwise, *false*.
     */
    public get IsValid(): boolean {
        return this.IsValidProxy();
    }

    /** @internal IsValid proxy to be able to call super. from inherited child */
    protected IsValidProxy(): boolean {
        return !StringHelper.IsNullOrEmpty(this.UniqueId);
    }

    /**
     * Initializes a new instance of the **ServiceId** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **ServiceId** class.
     *
     * @param   {string}   uniqueId   The unique id.
     */
    constructor(uniqueId: string);
    constructor(uniqueId?: string) {
        super();
        if (!StringHelper.IsNullOrEmpty(uniqueId)) {
            EwsUtilities.ValidateParam(uniqueId, "uniqueId");
            this.UniqueId = uniqueId;
        }
    }

    /**
     * @internal Assigns from existing id.
     *
     * @param   {ServiceId}   source   The source.
     */
    Assign(source: ServiceId): void {
        this.UniqueId = source.UniqueId;
        this.ChangeKey = source.ChangeKey;
    }

    /**
     * Determines whether the specified *ServiceId* is equal to the current *ServiceId*.
     * We do not consider the ChangeKey for ServiceId.Equals.
     *
     * @param   {any}       obj   The  to compare with the current .
     * @return  {boolean}   true if the specified  is equal to the current ; otherwise, false.
     */
    Equals(obj: any): boolean {
        if (this === obj) {//object.ReferenceEquals(this, obj)) {
            return true;
        }
        else {
            var other: ServiceId = obj;

            if (!(other instanceof ServiceId)) {// == null) {
                return false;
            }
            else if (!(this.IsValid && other.IsValid)) {
                return false;
            }
            else {
                return this.UniqueId === other.UniqueId;//.Equals(other.UniqueId);
            }
        }
    }

    //GetHashCode(): number { return this.IsValid ? this.UniqueId.GetHashCode() : super.GetHashCode();}

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string { throw new Error("abstract method must implement."); }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.Id:
                    this.UniqueId = jsObject[key];
                    break;
                case XmlAttributeNames.ChangeKey:
                    this.ChangeKey = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Determines whether two ServiceId instances are equal (including ChangeKeys)
     *
     * @param   {ServiceId}   other   The ServiceId to compare with the current ServiceId.
     */
    SameIdAndChangeKey(other: ServiceId): boolean {
        if (this.Equals(other)) {
            return ((this.ChangeKey == null) && (other.ChangeKey == null)) ||
                this.ChangeKey === other.ChangeKey;
        }
        else {
            return false;
        }
    }

    /**
     * Returns a *String* that represents the current *ServiceId*.
     *
     * @return  {string}      A *String* that represents the current *ServiceId*.
     */
    ToString(): string {
        return (this.UniqueId == null) ? "" : this.UniqueId;
    }

    /**
     * @internal Writes attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.UniqueId);
        writer.WriteAttributeValue(XmlAttributeNames.ChangeKey, this.ChangeKey);
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     * @param   {XmlNamespace}          xmlNamespace     The XML namespace.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName?: string, xmlNamespace?: XmlNamespace): void {
        if (arguments.length > 2) {
            super.WriteToXml(writer, xmlElementName, xmlNamespace);
        }
        else if (arguments.length > 1) {
            super.WriteToXml(writer, xmlElementName);
        }
        else {
            super.WriteToXml(writer, this.GetXmlElementName());
        }
    }
}

/**
 * Represents the Id of a Conversation.
 */
export class ConversationId extends ServiceId {

    /**
     * Initializes a new instance of **ConversationId**.
     */
    constructor();
    /**
     * Initializes a new instance of **ConversationId**.
     *
     * @param   {string}   uniqueId   The unique Id used to initialize the **ConversationId**.
     */
    constructor(uniqueId: string);
    constructor(uniqueId?: string) {
        arguments.length === 0 ? super() : super(uniqueId);
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.ConversationId;
    }

    /**
     * Gets a string representation of the Conversation Id.
     *
     * @return  {string}      The string representation of the conversation id.
     */
    ToString(): string {
        // We have ignored the change key portion
        return this.UniqueId;
    }
    toString(): string {
        return this.ToString();
    }
}

/**
 * Represents the Id of a folder.
 *
 * @class FolderId
 * @extends {ServiceId}
 */
export class FolderId extends ServiceId {
    private folderName: WellKnownFolderName;
    private mailbox: Mailbox;

    /**
     * Gets the name of the folder associated with the folder Id. Name and Id are mutually exclusive; if one is set, the other is null.
     *
     * @readonly
     * @type {WellKnownFolderName}
     */
    get FolderName(): WellKnownFolderName {
        return this.folderName;
    }

    /**
     * Gets the mailbox of the folder. Mailbox is only set when FolderName is set.
     *
     * @readonly
     * @type {Mailbox}
     */
    get Mailbox(): Mailbox {
        return this.mailbox;
    }

    /**
     * True if this instance is valid, false otherthise.
     * 
     * @value   *true* if this instance is valid; otherwise, *false*.
     */
    public get IsValid(): boolean {

        if (hasValue(this.FolderName)) {
            return (this.Mailbox == null) || this.Mailbox.IsValid;
        }
        else {
            return super.IsValidProxy();
        }
    }

    /**
     * @internal Initializes a new instance of the **FolderId** class.
    *
    */
    constructor();
    /**
     * Initializes a new instance of the **FolderId** class. Use this constructor to link this FolderId to an existing folder that you have the unique Id of.
    *
    * @param   {String} uniqueId The unique Id used to initialize the FolderId.
    */
    constructor(uniqueId: string);
    /**
     * Initializes a new instance of the **FolderId** class. Use this constructor to link this FolderId to a well known folder (e.g. Inbox, Calendar or Contacts).
    *
    * @param   {WellKnownFolderName}    folderName  The folder name used to initialize the FolderId.
    */
    constructor(folderName: WellKnownFolderName);
    /**
     * Initializes a new instance of the **FolderId** class. Use this constructor to link this FolderId to a well known folder (e.g. Inbox, Calendar or Contacts) in a specific mailbox.
    *
    * @param   {WellKnownFolderName}    folderName   The folder name used to initialize the FolderId.
    * @param   {Mailbox}                mailbox      The mailbox used to initialize the FolderId.
    */
    constructor(folderName: WellKnownFolderName, mailbox: Mailbox);
    constructor(uniqueIdOrFolderName?: string | WellKnownFolderName, mailbox?: Mailbox) {
        arguments.length === 1 && typeof uniqueIdOrFolderName === 'string' ? super(uniqueIdOrFolderName) : super();

        if (arguments.length > 0 && typeof uniqueIdOrFolderName === 'number') {

            this.folderName = uniqueIdOrFolderName;
        }
        if (arguments.length > 1) {
            this.mailbox = mailbox;
        }
    }

    /**
     * Determines whether the specified *FolderId* is equal to the current *FolderId*.
     * We do not consider the ChangeKey for FolderId.Equals.
     *
     * @param   {any}       obj   The  to compare with the current .
     * @return  {boolean}   true if the specified  is equal to the current ; otherwise, false.
     */
    Equals(obj: any): boolean {
        if (this === obj) {
            return true;
        }
        else {
            var other: FolderId = obj;

            if (!(other instanceof FolderId)) {
                return false;
            }
            else if (this.FolderName) {
                if (other.FolderName && this.FolderName === other.FolderName) {
                    if (this.Mailbox != null) {
                        return this.Mailbox.Equals(other.Mailbox);
                    }
                    else if (other.Mailbox == null) {
                        return true;
                    }
                }
            }
            else if (super.Equals(other)) {
                return true;
            }

            return false;
        }
    }

    //GetHashCode(): number { throw new Error("FolderId.ts - GetHashCode : Not implemented."); }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return typeof this.folderName !== 'undefined' && this.FolderName >= 0 ? XmlElementNames.DistinguishedFolderId : XmlElementNames.FolderId;
    }

    /**
     * Returns a *String* that represents the current *FolderId*.
     *
     * @return  {string}      A *String* that represents the current *FolderId*.
     */
    ToString(): string {
        if (this.IsValid) {
            if (hasValue(this.FolderName)) {
                if ((this.mailbox != null) && this.mailbox.IsValid) {
                    return StringHelper.Format("{0} ({1})", WellKnownFolderName[this.folderName], this.Mailbox.ToString());
                }
                else {
                    return WellKnownFolderName[this.FolderName];
                }
            }
            else {
                return super.ToString();
            }
        }
        else {
            return "";
        }
    }

    /**
     * @internal Validates FolderId against a specified request version.
     *
     * @param   {ExchangeVersion}   version   The version.
     */
    Validate(version?: ExchangeVersion): void {
        if (hasValue(version)) {
            // The FolderName property is a WellKnownFolderName, an enumeration type. If the property
            // is set, make sure that the value is valid for the request version.
            if (hasValue(this.FolderName)) {
                EwsUtilities.ValidateEnumVersionValue(WellKnownFolderName, this.FolderName, version, "WellKnownFolderName");
            }
        }
        else {
            super.Validate();
        }
    }

    /**
     * @internal Writes attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        if (typeof this.folderName !== 'undefined' && this.FolderName >= 0) {
            writer.WriteAttributeValue(XmlAttributeNames.Id, WellKnownFolderName[this.FolderName].toLowerCase());

            if (this.Mailbox != null) {
                this.Mailbox.WriteToXml(writer, XmlElementNames.Mailbox);
            }
        }
        else {
            super.WriteAttributesToXml(writer);
        }
    }
}

/**
 * Represents the Id of an Exchange item.
 *
 * @class ItemId
 * @extends {ServiceId}
 */
export class ItemId extends ServiceId {

    /**
     * Initializes a new instance of the **ItemId**.
     */
    constructor();
    /**
     * Initializes a new instance of the **ItemId**.
     *
     * @param   {String} uniqueId   The unique Id used to initialize the ItemId
     */
    constructor(uniqueId: string);
    constructor(uniqueId?: string) {
        if (arguments.length === 0) {
            super();
            return;
        }
        super(uniqueId);
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.ItemId;
    }
}

export class AppointmentOccurrenceId extends ItemId {
    private occurrenceIndex: number;
    get OccurrenceIndex(): number {
        return this.occurrenceIndex;
    }
    set OccurrenceIndex(value: number) {
        if (value < 1) {
            throw new ArgumentException(Strings.OccurrenceIndexMustBeGreaterThanZero);
        }
        this.occurrenceIndex = value;
    }
    constructor(recurringMasterUniqueId: string, occurrenceIndex: number) {
        super(recurringMasterUniqueId);
        this.OccurrenceIndex = occurrenceIndex;
    }

    GetXmlElementName(): string { return XmlElementNames.OccurrenceItemId; }
    InternalToJson(service: ExchangeService): any { throw new Error("AppointmentOccurrenceId.ts - InternalToJson : Not implemented."); }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.RecurringMasterId, this.UniqueId);
        writer.WriteAttributeValue(XmlAttributeNames.InstanceIndex, this.OccurrenceIndex);
    }
}

export class RecurringAppointmentMasterId extends ItemId {
    constructor(occurrenceId: string) {
        super(occurrenceId);
    }
    GetXmlElementName(): string { return XmlElementNames.RecurringMasterItemId; }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.OccurrenceId, this.UniqueId);
        writer.WriteAttributeValue(XmlAttributeNames.ChangeKey, this.ChangeKey);
    }
}

/**
 * Represents a collection of properties that can be sent to and retrieved from EWS.
 * 
 * @type <TComplexProperty>   ComplexProperty type.
 */
export abstract class ComplexPropertyCollection<TComplexProperty extends ComplexProperty> extends ComplexProperty implements IEnumerable<TComplexProperty>, ICustomUpdateSerializer {

    ___typeGenerics: string[] = ["ComplexProperty"];

    private items: TComplexProperty[] = [];
    private addedItems: TComplexProperty[] = [];
    private modifiedItems: TComplexProperty[] = [];
    private removedItems: TComplexProperty[] = [];

    /**
     * @internal Gets the items. (workaround for GetEnumerator)
     * 
     * @return The items.
     */
    get Items(): TComplexProperty[] { return this.items; }

    /**
     * @internal Gets the added items.
     *
     * @return The added items.
     */
    get AddedItems(): TComplexProperty[] { return this.addedItems; }

    /**
     * @internal Gets the modified items.
     *
     * @return The modified items
     */
    get ModifiedItems(): TComplexProperty[] { return this.modifiedItems; }

    /**
     * @internal Gets the removed items.
     * 
     * @return The removed items.
     */
    get RemovedItems(): TComplexProperty[] { return this.removedItems; }

    /**
     * Gets the total number of properties in the collection.
     */
    get Count(): number { return this.items.length; }

    /**
     * Gets the property at the specified index.
     *
     * @param   {number}   index   The zero-based index of the property to get.
     * @return  {TComplexProperty}           The property at the specified index.
     */
    _getItem(index: number): TComplexProperty {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        return this.items[index];
    }

    /**
     * @internal Initializes a new instance of the **ComplexPropertyCollection** class.
     *
     */
    constructor() {
        super();
    }

    /**
     * @internal Clears the change log.
     */
    ClearChangeLog(): void {
        this.removedItems.splice(0);
        this.addedItems.splice(0);
        this.modifiedItems.splice(0);
    }

    /**
     * Determines whether a specific property is in the collection.
     *
     * @param   {TComplexProperty}   complexProperty   The property to locate in the collection.
     * @return  {boolean}           True if the property was found in the collection, false otherwise.
     */
    Contains(complexProperty: TComplexProperty): boolean { return this.items.indexOf(complexProperty) >= 0; }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {TComplexProperty}          Complex property instance.
     */
    abstract CreateComplexProperty(xmlElementName: string): TComplexProperty;

    /**
     * @internal Creates the default complex property.
     *
     * @return  {TComplexProperty}      Complex property instance.
     */
    abstract CreateDefaultComplexProperty(): TComplexProperty;

    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    CreateFromXmlJsObjectCollection(jsObjectCollection: any, service: ExchangeService): void {
        let collection: TComplexProperty[] = jsObjectCollection;
        if (!ArrayHelper.isArray(collection)) {
            collection = [];
            let collectionElement = this.GetCollectionItemXmlElementName(null);
            let typeName = TypeSystem.GetJsObjectTypeName(jsObjectCollection)
            if (collectionElement === null || (typeName && collectionElement === typeName)) {
                collection = [jsObjectCollection];
            }
            else {

                for (let key in jsObjectCollection) {
                    if (key.indexOf("__") === 0) //skip xmljsobject conversion entries like __type and __prefix
                        continue;

                    let collectionObj: TComplexProperty[] = jsObjectCollection[key];
                    if (!ArrayHelper.isArray(collectionObj)) {
                        collectionObj = EwsServiceJsonReader.ReadAsArray(jsObjectCollection, key);
                    }

                    ArrayHelper.AddRange(collection, collectionObj);
                }
            }
        }

        for (let jsonObject of collection) {
            let jsonProperty = jsonObject;

            if (jsonProperty != null) {
                let complexProperty: TComplexProperty = null;

                // If type property is present, use it. Otherwise create default property instance.
                // Note: polymorphic collections (such as Attachments) need a type property so
                // the CreateDefaultComplexProperty call will fail.
                if (TypeSystem.GetJsObjectTypeName(jsonProperty)) {
                    complexProperty = this.CreateComplexProperty(TypeSystem.GetJsObjectTypeName(jsonProperty));
                }
                else {
                    complexProperty = this.CreateDefaultComplexProperty();
                }

                if (complexProperty != null) {
                    complexProperty.LoadFromXmlJsObject(jsonProperty, service);
                    this.InternalAdd(complexProperty, true);
                }
            }
        }
    }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {TComplexProperty}   complexProperty   The complex property.
     * @return  {string}            XML element name.
     */
    abstract GetCollectionItemXmlElementName(complexProperty: TComplexProperty): string;

	/**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    GetEnumerator(): TComplexProperty[] {
        return this.items;
    }

    /**
     * Searches for a specific property and return its zero-based index within the collection.
     *
     * @param   {TComplexProperty}   complexProperty   The property to locate in the collection.
     * @return  {number}                     The zero-based index of the property within the collection.
     */
    IndexOf(complexProperty: TComplexProperty): number {
        return this.items.indexOf(complexProperty);
    }

    /**
     * @internal Add complex property.
     *
     * @param   {TComplexProperty}   complexProperty   The complex property.
     */
    InternalAdd(complexProperty: TComplexProperty): void;
    /**
     * @private Add complex property.
     *
     * @param   {TComplexProperty}   complexProperty   The complex property.
     * @param   {boolean}   loading           If true, collection is being loaded.
     */
    InternalAdd(complexProperty: TComplexProperty, loading: boolean): void;
    InternalAdd(complexProperty: TComplexProperty, loading: boolean = false): void {
        EwsLogging.Assert(
            complexProperty != null,
            "ComplexPropertyCollection.InternalAdd",
            "complexProperty is null");

        if (this.items.indexOf(complexProperty) < 0) {
            this.items.push(complexProperty);
            if (!loading) {
                ArrayHelper.RemoveEntry(this.removedItems, complexProperty);// this.removedItems.Remove(complexProperty);
                this.addedItems.push(complexProperty);
            }
            complexProperty.OnChange.push(this.ItemChanged.bind(this));
            this.Changed();
        }
    }

    /**
     * @internal Clear collection.
     */
    InternalClear(): void {
        while (this.Count > 0) {
            this.InternalRemoveAt(0);
        }
    }

    /**
     * @internal Remove specified complex property.
     *
     * @param   {TComplexProperty}   complexProperty   The complex property.
     * @return  {boolean}           True if the complex property was successfully removed from the collection, false otherwise.
     */
    InternalRemove(complexProperty: TComplexProperty): boolean {
        EwsLogging.Assert(
            complexProperty != null,
            "ComplexPropertyCollection.InternalRemove",
            "complexProperty is null");

        if (ArrayHelper.RemoveEntry(this.items, complexProperty)) { // this.items.Remove(complexProperty))

            ArrayHelper.RemoveEntry(complexProperty.OnChange, this.ItemChanged);// complexProperty.OnChange -= this.ItemChanged;

            if (this.addedItems.indexOf(complexProperty) < 0) {
                this.removedItems.push(complexProperty);
            }
            else {
                ArrayHelper.RemoveEntry(this.addedItems, complexProperty);// this.addedItems.Remove(complexProperty);
            }
            ArrayHelper.RemoveEntry(this.modifiedItems, complexProperty);// this.modifiedItems.Remove(complexProperty);
            this.Changed();
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * @internal Remote entry at index.
     *
     * @param   {number}   index   The index.
     */
    InternalRemoveAt(index: number): void {
        EwsLogging.Assert(
            index >= 0 && index < this.Count,
            "ComplexPropertyCollection.InternalRemoveAt",
            "index is out of range.");

        this.InternalRemove(this.items[index]);
    }

    /**
     * @internal Item changed.
     *
     * @param   {ComplexProperty}   complexProperty   The complex property.
     */
    ItemChanged(complexProperty: ComplexProperty): void {
        //TComplexProperty property = complexProperty as TComplexProperty;
        let property = complexProperty;
        // EwsLogging.Assert(
        //     property != null,
        //     "ComplexPropertyCollection.ItemChanged",
        //     StringHelper.Format("ComplexPropertyCollection.ItemChanged: the type of the complexProperty argument ({0}) is not supported.", complexProperty.___typeName));

        if (this.addedItems.indexOf(<TComplexProperty>property) < 0) {
            if (this.modifiedItems.indexOf(<TComplexProperty>property) < 0) {
                this.modifiedItems.push(<TComplexProperty>property);
                this.Changed();
            }
        }
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
	LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        EwsLogging.Assert(false, "ComplexPropertyCollection.LoadFromXmlJsObject", "LoadFromXmlJsObject was called, should not be calling. Fix it to direct to Create or Update call instad.")
        this.CreateFromXmlJsObjectCollection(jsObject, service);
    }

    /**
     * @internal Removes from change log.
     *
     * @param   {TComplexProperty}   complexProperty   The complex property.
     */
    RemoveFromChangeLog(complexProperty: TComplexProperty): void {
        ArrayHelper.RemoveEntry(this.removedItems, complexProperty);     //this.removedItems.Remove(complexProperty);
        ArrayHelper.RemoveEntry(this.modifiedItems, complexProperty);    //this.modifiedItems.Remove(complexProperty);
        ArrayHelper.RemoveEntry(this.addedItems, complexProperty);       //this.addedItems.Remove(complexProperty);
    }

    /**
     * @internal Determine whether we should write collection to XML or not.
     *
     * @return  {boolean}      True if collection contains at least one element.
     */
    ShouldWriteToRequest(): boolean {
        // Only write collection if it has at least one element.
        return this.Count > 0;
    }

    /**
     * @internal Loads from XMLJsObject collection to update collection Items.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The XMLJsObject collection.
     * @param   {ExchangeService}   service          The service.
     */
    UpdateFromXmlJsObjectCollection(jsObjectCollection: any, service: ExchangeService): void {
        let collection: TComplexProperty[] = jsObjectCollection;
        if (!ArrayHelper.isArray(collection)) {
            collection = [];
            let collectionElement = this.GetCollectionItemXmlElementName(null);
            let typeName = TypeSystem.GetJsObjectTypeName(jsObjectCollection)
            if (collectionElement === null || (typeName && collectionElement === typeName)) {
                collection = [jsObjectCollection];
            }
            else {

                for (let key in jsObjectCollection) {
                    if (key.indexOf("__") === 0) //skip xmljsobject conversion entries like __type and __prefix
                        continue;

                    let collectionObj: TComplexProperty[] = jsObjectCollection[key];
                    if (!ArrayHelper.isArray(collectionObj)) {
                        collectionObj = EwsServiceJsonReader.ReadAsArray(jsObjectCollection, key);
                    }

                    ArrayHelper.AddRange(collection, collectionObj);
                }
            }
        }

        if (this.Count != collection.length) {
            throw new ServiceLocalException(Strings.PropertyCollectionSizeMismatch);
        }

        let index: number = 0;
        for (let jsonObject of collection) {
            let jsonProperty = jsonObject;

            if (jsonProperty != null) {
                let expectedComplexProperty: TComplexProperty = null;

                if (TypeSystem.GetJsObjectTypeName(jsonProperty)) {
                    expectedComplexProperty = this.CreateComplexProperty(TypeSystem.GetJsObjectTypeName(jsonProperty));
                }
                else {
                    expectedComplexProperty = this.CreateDefaultComplexProperty();
                }

                let actualComplexProperty: TComplexProperty = this._getItem(index++);

                if (expectedComplexProperty == null || !(actualComplexProperty instanceof expectedComplexProperty.constructor)) {
                    throw new ServiceLocalException(Strings.PropertyTypeIncompatibleWhenUpdatingCollection);
                }
                actualComplexProperty.LoadFromXmlJsObject(jsonProperty, service);
            }
            else {
                throw new ServiceLocalException();
            }
        }
    }

    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        for (let complexProperty of this.items) {
            complexProperty.WriteToXml(writer, this.GetCollectionItemXmlElementName(complexProperty));
        }
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          xmlNamespace     The XML namespace.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string, xmlNamespace: XmlNamespace = XmlNamespace.Types): void {
        if (this.ShouldWriteToRequest()) {
            super.WriteToXml(
                writer,
                xmlElementName,
                xmlNamespace);
        }
    }

    /**
     * @internal Writes the update to XML.
     * ICustomUpdateSerializer.WriteSetUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer.
     * @param   {ServiceObject}         ewsObject            The ews object.
     * @param   {PropertyDefinition}    propertyDefinition   Property definition.
     * @return  {boolean}               True if property generated serialization.
     */
    WriteSetUpdateToXml(
        writer: EwsServiceXmlWriter,
        ewsObject: ServiceObject,
        propertyDefinition: PropertyDefinition): boolean {
        // If the collection is empty, delete the property.
        if (this.Count == 0) {
            writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetDeleteFieldXmlElementName());
            propertyDefinition.WriteToXml(writer);
            writer.WriteEndElement();
            return true;
        }
        // Otherwise, use the default XML serializer.
        else {
            return false;
        }
    }

    /**
     * @internal Writes the deletion update to XML.
     * ICustomUpdateSerializer.WriteDeleteUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer      The writer.
     * @param   {ServiceObject}         ewsObject   The ews object.
     * @return  {boolean}               True if property generated serialization.
     */
    WriteDeleteUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject): boolean {
        // Use the default XML serializer.
        return false;
    }
}

/**
 * Represents a collection of AddressEntity objects.
 */
export class AddressEntityCollection extends ComplexPropertyCollection<AddressEntity> {

    /**
     * @internal Initializes a new instance of the **AddressEntityCollection** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **AddressEntityCollection** class.
     *
     * @param   {AddressEntity[]}   collection   The collection of objects to include.
     */
    constructor(collection: AddressEntity[]);
    constructor(collection: AddressEntity[] = null) {
        super();
        if (collection != null) {
            collection.forEach((address) => { this.InternalAdd(address); });
        }
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}            xmlElementName   Name of the XML element.
     * @return  {AddressEntity}     AddressEntity.
     */
    CreateComplexProperty(xmlElementName: string): AddressEntity { return new AddressEntity(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {AddressEntity}      AddressEntity.
     */
    CreateDefaultComplexProperty(): AddressEntity { return new AddressEntity(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {AddressEntity}     complexProperty   The complex property.
     * @return  {string}            XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: AddressEntity): string { return XmlElementNames.NlgAddress; }
}

/**
 * Represents an item's attachment collection.
 */
export class AttachmentCollection extends ComplexPropertyCollection<Attachment> implements IOwnedProperty {

    ___typeGenerics: string[] = ["ComplexProperty"];

	/**
	 * The item owner that owns this attachment collection
	 */
    private owner: Item = null;
    /**
     * @interface:IOwnedProperty The owner of this attachment collection.
     */
    get Owner(): ServiceObject { return this.owner; };
    set Owner(value) {
        EwsLogging.Assert(
            value != null && (value instanceof TypeContainer.Item), // instanceof Item), //info: can not check instanceof to avoid circular dependency in js. TypeContainer is workaround
            "AttachmentCollection.IOwnedProperty.set_Owner",
            "value is not a descendant of ItemBase");
        this.owner = <Item>value;
    }

	/**
	 * @internal Initializes a new instance of AttachmentCollection.
	 */
    constructor() {
        super();
    }

	/**
	 * Adds a file attachment to the collection.
	 *
	 * @param   {string}	fileName   The name of the file representing the content of the attachment.
	 * @return  {FileAttachment} 		A FileAttachment instance.
	 */
    private AddFileAttachmentXXXXX(fileName: string): FileAttachment;
    /**
     * Adds a file attachment to the collection.
     *
     * @param   {string}   name       The display name of the new attachment.
     * @param   {string}   fileName   The name of the file representing the content of the attachment.
     * @return  {FileAttachment}      A FileAttachment instance.
     */
    private AddFileAttachmentXXXXX(name: string, fileName: string): FileAttachment;

    //AddFileAttachmentXXXXX(name: string, contentStream: TextStreamBase /*System.IO.Stream*/): FileAttachment;	
    //AddFileAttachmentXXXXX(name: string, content: number[] /* Byte[]  */): FileAttachment;
    /**
     * Adds a file attachment to the collection. - isContent parameter is required to be true to be able to use bas64 content directly
     *
     * @param   {string}    name       The display name of the new attachment.
     * @param   {string}    fileContent   base64 ontent of the file representing the content of the attachment.
     * @param   {boolean}   isContent   if true used as base64 content of file.
     * @return  {FileAttachment}      A FileAttachment instance.
     */
    private AddFileAttachmentXXXXX(name: string, fileContent: string, isContent: boolean): FileAttachment;
    private AddFileAttachmentXXXXX(nameOrFileName: string, fileNameOrContent?: string, isContent: boolean = false): FileAttachment {
        let argsLength = arguments.length;
        if (argsLength == 1) {
            let name = nameOrFileName.split('\\').pop().split('/').pop();
            return this.AddFileAttachment(name, fileNameOrContent);
        }
        if (argsLength === 2) {
            throw new Error("AttachmentCollection.ts - Can only use this method with base64 content");
            let fileAttachment: FileAttachment = new FileAttachment(this.owner);
            fileAttachment.Name = name;
            fileAttachment.FileName = fileNameOrContent;
            this.InternalAdd(fileAttachment);
            return fileAttachment;
        }
        if (argsLength == 3) {
            if (isContent === true) {
                let fileAttachment: FileAttachment = new FileAttachment(this.owner);
                fileAttachment.Name = name;
                fileAttachment.Base64Content = fileNameOrContent;
                this.InternalAdd(fileAttachment);
                return fileAttachment;
            }
            else {
                return this.AddFileAttachment(nameOrFileName, fileNameOrContent);
            }
        }
        new Error("AttachmentCollection.ts - AddFileAttachment - incorrect count of parameters");
    }
    /**
     * Adds a file attachment to the collection. - isContent parameter is required to be true to be able to use bas64 content directly
     *
     * @param   {string}    name       The display name of the new attachment.
     * @param   {string}    fileContent   base64 ontent of the file representing the content of the attachment.
     * @return  {FileAttachment}      A FileAttachment instance.
     */
    AddFileAttachment(name: string, content: string): FileAttachment {
        let fileAttachment: FileAttachment = new FileAttachment(this.owner);
        fileAttachment.Name = name;
        fileAttachment.Base64Content = content;
        this.InternalAdd(fileAttachment);
        return fileAttachment;
    }

    /**
     * Adds an item attachment to the collection
     *
     * @type <TItem>    The type of the item to attach.
     * 
     * @param   {any*}      TItem    Item type, not instance
     * @param   {string}    TItemElementName    XML Element Name of the Item class
     * @return  {ItemAttachmentOf<TItem>}      An ItemAttachment instance.
     */
    AddItemAttachment<TItem extends Item>(TItem: typeof Item, TItemElementName: string): ItemAttachmentOf<TItem> {

        if (typeof TItem.Attachable === 'undefined' || TItem.Attachable === false) {
            throw new Error(
                StringHelper.Format(
                    "Items of type {0} are not supported as attachments.",
                    TItem["name"])); //InvalidOperationException
        }

        let itemAttachment: ItemAttachmentOf<TItem> = new ItemAttachmentOf<TItem>(this.owner); //ref: //info: ItemAttachment can not be generic when same name non generic version exhist. TypeScript limitation
        itemAttachment.Item = <TItem>(new ItemInfo()).CreateItemFromItemClass(itemAttachment, TItemElementName, true); //todo: needs to implement Reflector metadata for Type to class creation map

        this.InternalAdd(<any><any>itemAttachment);

        return itemAttachment;

    }

    /**
     * Removes all attachments from this collection.
     */
    Clear(): void { this.InternalClear(); }

    /**
     * @internal Disables the change log clearing mechanism. Attachment collections are saved separately from the items they belong to.
     */
    ClearChangeLog(): void { /** Do nothing */ }

    /**
     * @internal Instantiate the appropriate attachment type depending on the current XML element name.
     *
     * @param   {string}   xmlElementName   The XML element name from which to determine the type of attachment to create.
     * @return  {Attachment}        An Attachment instance.
     */
    CreateComplexProperty(xmlElementName: string): Attachment {
        switch (xmlElementName) {
            case XmlElementNames.FileAttachment:
                return new FileAttachment(this.owner);
            case XmlElementNames.ItemAttachment:
                return <any><any>new ItemAttachment(this.owner);
            default:
                return null;
        }
    }

    //JsonDeserializationNotImplementedException
    CreateDefaultComplexProperty(): Attachment { EwsLogging.DebugLog("AttachmentCollection.ts - CreateDefaultComplexProperty : Not implemented."); return null; }

    /**
     * @internal Determines the name of the XML element associated with the complexProperty parameter.
     *
     * @param   {Attachment}   complexProperty   The attachment object for which to determine the XML element name with.
     * @return  {string}        The XML element name associated with the complexProperty parameter.
     */
    GetCollectionItemXmlElementName(complexProperty: Attachment): string {
        if (complexProperty instanceof FileAttachment) {
            return XmlElementNames.FileAttachment;
        }
        else {
            return XmlElementNames.ItemAttachment;
        }
    }

    /**
     * @internal Determines whether there are any unsaved attachment collection changes.
     *
     * @return  {boolean}      True if attachment adds or deletes haven't been processed yet.
     */
    HasUnprocessedChanges(): boolean {
        for (let attachment of this.Items) {
            if (attachment.IsNew) {
                return true;
            }
        }

        // Any pending deletions?
        for (let attachment of this.RemovedItems) {
            if (!attachment.IsNew) {
                return true;
            }
        }

        // Recurse: process item attachments to check for new or deleted sub-attachments.
        for (let itemAttachment of ArrayHelper.OfType<Attachment, ItemAttachment>(this.Items, (attach) => { return attach instanceof ItemAttachment; })) {
            if (itemAttachment.Item != null) {
                if (itemAttachment.Item.Attachments.HasUnprocessedChanges()) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Calls the CreateAttachment web method to create a list of attachments.
     *
     * @param   {string}        parentItemId   The Id of the parent item of the new attachments.
     * @param   {Attachment[]}  attachments    The attachments to create.
     */
    private InternalCreateAttachments(parentItemId: string, attachments: Attachment[]): Promise<void> {
        return this.owner.Service.CreateAttachments(parentItemId, attachments)
            .then((responses: ServiceResponseCollection<CreateAttachmentResponse>) => {
                for (let response of responses.Responses) {
                    // We remove all attachments that were successfully deleted from the change log. We should never
                    // receive a warning from EWS, so we ignore them.
                    if (response.Result != ServiceResult.Error) {
                        this.RemoveFromChangeLog(response.Attachment);
                    }
                }

                // TODO : Should we throw for warnings as well?
                if (responses.OverallResult == ServiceResult.Error) {
                    throw new CreateAttachmentException(responses, Strings.AttachmentCreationFailed);
                }
            });
    }

    /**
     * Calls the DeleteAttachment web method to delete a list of attachments.
     *
     * @param   {Attachment[]}   attachments   The attachments to delete.
     */
    private InternalDeleteAttachments(attachments: Attachment[]): Promise<void> {
        return this.owner.Service.DeleteAttachments(attachments)
            .then((responses: ServiceResponseCollection<DeleteAttachmentResponse>) => {
                for (let response of responses.Responses) {
                    // We remove all attachments that were successfully deleted from the change log. We should never
                    // receive a warning from EWS, so we ignore them.
                    if (response.Result != ServiceResult.Error) {
                        this.RemoveFromChangeLog(response.Attachment);
                    }
                }

                // TODO : Should we throw for warnings as well?
                if (responses.OverallResult == ServiceResult.Error) {
                    throw new DeleteAttachmentException(responses, Strings.AtLeastOneAttachmentCouldNotBeDeleted);
                }
            });
    }

    /**
     * Removes the specified attachment.
     *
     * @param   {Attachment}    attachment   The attachment to remove.
     * @return  {boolean}       True if the attachment was successfully removed from the collection, false otherwise.
     */
    Remove(attachment: Attachment): boolean {
        EwsUtilities.ValidateParam(attachment, "attachment");

        return this.InternalRemove(attachment);
    }

    /**
     * Removes the attachment at the specified index.
     *
     * @param   {number}   index   Index of the attachment to remove.
     */
    RemoveAt(index: number): void {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        this.InternalRemoveAt(index);
    }

    /**
     * @internal Saves this collection by creating new attachment and deleting removed ones.
     */
    Save(): Promise<void> {

        let attachments = [];

        // Retrieve a list of attachments that have to be deleted.
        for (let attachment of this.RemovedItems) {
            if (!attachment.IsNew) {
                attachments.push(attachment);
            }
        }

        // If any, delete them by calling the DeleteAttachment web method.
        //promise resolves with null to keep chaining
        return Promise.resolve(attachments.length > 0 ? this.InternalDeleteAttachments(attachments) : void 0)
            .then<void>(() => {
                attachments.splice(0);
            })
            .then(() => {
                // Retrieve a list of attachments that have to be created.
                for (let attachment of this.Items) {
                    if (attachment.IsNew) {
                        attachments.push(attachment);
                    }
                }
                // If there are any, create them by calling the CreateAttachment web method.
                if (attachments.length > 0) {
                    let parentId = this.owner.IsAttachment ? this.owner.ParentAttachment.Id : this.owner.Id.UniqueId;
                    return this.InternalCreateAttachments(parentId, attachments);
                } else {
                    return Promise.resolve();
                }
            }).then(() => {
                // Process all of the item attachments in this collection.
                let itemAttachments = ArrayHelper.OfType<Attachment, ItemAttachment>(attachments, (attachment) => attachment instanceof ItemAttachment);
                return itemAttachments.reduce((prev, curr, index) => {
                    return prev.then<void>(() => {
                        return curr.Item.Attachments.Save().then(() => {
                            curr.Item.ClearChangeLog();
                        });
                    });
                }, Promise.resolve());

            }).then(() => {
                super.ClearChangeLog();
            });
    }

    /**
     * @internal Validates this instance.
     */
    Validate(): void {
        // Validate all added attachments
        let contactPhotoFound: boolean = false;

        for (let attachmentIndex = 0; attachmentIndex < this.AddedItems.length; attachmentIndex++) {
            let attachment: Attachment = this.AddedItems[attachmentIndex];
            if (attachment.IsNew) {
                // At the server side, only the last attachment with IsContactPhoto is kept, all other IsContactPhoto
                // attachments are removed. CreateAttachment will generate AttachmentId for each of such attachments (although
                // only the last one is valid).
                // 
                // With E14 SP2 CreateItemWithAttachment, such request will only return 1 AttachmentId; but the client
                // expects to see all, so let us prevent such "invalid" request in the first place. 
                // 
                // The IsNew check is to still let CreateAttachmentRequest allow multiple IsContactPhoto attachments.
                // 
                if (this.owner.IsNew && this.owner.Service.RequestedServerVersion >= ExchangeVersion.Exchange2010_SP2) {
                    let fileAttachment: FileAttachment = <FileAttachment>attachment;

                    if (fileAttachment instanceof Attachment && fileAttachment.IsContactPhoto) {
                        if (contactPhotoFound) {
                            throw new ServiceValidationException(Strings.MultipleContactPhotosInAttachment);
                        }

                        contactPhotoFound = true;
                    }
                }
                attachment.Validate(attachmentIndex);
            }
        }
    }

    /**
     * @internal Validates and saves this instance. **Not in official EWS source, to workaround some promise errors with validate and save**
     */
    ValidateAndSave(): Promise<void> {
        this.Validate();
        return this.Save();
    }
}

/**
 * Represents a collection of attendees.
 */
export class AttendeeCollection extends ComplexPropertyCollection<Attendee> {

    /**
     * @internal Initializes a new instance of the **AttendeeCollection** class.
     */
    constructor() {
        super();
    }

    /**
     * Adds an attendee to the collection.
     *
     * @param   {Attendee}   attendee   The attendee to add.
     */
    Add(attendee: Attendee): void;
    /**
     * Adds a attendee to the collection.
     *
     * @param   {string}   smtpAddress   The SMTP address of the attendee.
     * @return  {Attendee}      An Attendee instance initialized with the provided name and SMTP address.
     */
    Add(smtpAddress: string): Attendee;
    /**
     * Adds a attendee to the collection.
     *
     * @param   {string}   name          The name of the attendee.
     * @param   {string}   smtpAddress   The SMTP address of the attendee.
     * @return  {Attendee}      An Attendee instance initialized with the provided name and SMTP address.
     */
    Add(name: string, smtpAddress: string): Attendee;
    Add(nameOrSmtpAddressOrAttendee: string | Attendee, smtpAddress?: string): any | Attendee {
        let argsLength = arguments.length;
        let attendee: Attendee = <Attendee>nameOrSmtpAddressOrAttendee;
        if (argsLength == 1) {
            if (typeof nameOrSmtpAddressOrAttendee === 'string') {
                attendee = new Attendee(nameOrSmtpAddressOrAttendee);
            }
            else {
                attendee = nameOrSmtpAddressOrAttendee;
            }
        }
        if (argsLength === 2) {
            attendee = new Attendee(<string>nameOrSmtpAddressOrAttendee, smtpAddress);
        }
        this.InternalAdd(attendee);
        return attendee;
    }

    /**
     * Clears the collection.
     */
    Clear(): void {
        this.InternalClear();
    }

    /**
     * @internal Creates an Attendee object from an XML element name.
     *
     * @param   {string}   xmlElementName   The XML element name from which to create the attendee.
     * @return  {Attendee}      An Attendee object.
     */
    CreateComplexProperty(xmlElementName: string): Attendee {
        if (xmlElementName == XmlElementNames.Attendee) {
            return new Attendee();
        }
        else {
            return null;
        }
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {Attendee}      [description]
     */
    CreateDefaultComplexProperty(): Attendee { return new Attendee(); }

    /**
     * @internal Retrieves the XML element name corresponding to the provided Attendee object.
     *
     * @param   {Attendee}   attendee   The Attendee object from which to determine the XML element name.
     * @return  {string}        The XML element name corresponding to the provided Attendee object.
     */
    GetCollectionItemXmlElementName(attendee: Attendee): string { return XmlElementNames.Attendee; }

    /**
     * Removes an attendee from the collection.
     *
     * @param   {Attendee}   attendee   The attendee to remove.
     * @return  {boolean}              True if the attendee was successfully removed from the collection, false otherwise.
     */
    Remove(attendee: Attendee): boolean {
        EwsUtilities.ValidateParam(attendee, "attendee");
        return this.InternalRemove(attendee);
    }

    /**
     * Removes an attendee from the collection.
     *
     * @param   {number}   index   The index of the attendee to remove.
     */
    RemoveAt(index: number): void {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }

        this.InternalRemoveAt(index);
    }
}


/**
 * Represents a collection of ContactEntity objects.
 */
export class ContactEntityCollection extends ComplexPropertyCollection<ContactEntity> {

    /**
     * @internal Initializes a new instance of the **ContactEntityCollection** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **ContactEntityCollection** class.
     *
     * @param   {ContactEntity[]}   collection   The collection of objects to include.
     */
    constructor(collection: ContactEntity[]);
    constructor(collection: ContactEntity[] = null) {
        super();
        if (collection != null) {
            collection.forEach((entity) => { this.InternalAdd(entity); });
        }
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}                xmlElementName   Name of the XML element.
     * @return  {ContactEntity}     ContactEntity.
     */
    CreateComplexProperty(xmlElementName: string): ContactEntity { return new ContactEntity(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {ContactEntity}      ContactEntity.
     */
    CreateDefaultComplexProperty(): ContactEntity { return new ContactEntity(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {ContactEntity}     complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: ContactEntity): string { return XmlElementNames.NlgContact; }
}

/**
 * Represents a collection of ContactPhoneEntity objects.
 */
export class ContactPhoneEntityCollection extends ComplexPropertyCollection<ContactPhoneEntity> {

    /**
     * @internal Initializes a new instance of the **ContactPhoneEntityCollection** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **ContactPhoneEntityCollection** class.
     *
     * @param   {ContactPhoneEntity[]}   collection   The collection of objects to include.
     */
    constructor(collection: ContactPhoneEntity[]);
    constructor(collection: ContactPhoneEntity[] = null) {
        super();
        if (collection != null) {
            collection.forEach((phone) => { this.InternalAdd(phone); });
        }
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}                xmlElementName   Name of the XML element.
     * @return  {ContactPhoneEntity}    ContactPhoneEntity.
     */
    CreateComplexProperty(xmlElementName: string): ContactPhoneEntity { return new ContactPhoneEntity(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {ContactPhoneEntity}    ContactPhoneEntity.
     */
    CreateDefaultComplexProperty(): ContactPhoneEntity { return new ContactPhoneEntity(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {ContactPhoneEntity}    complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: ContactPhoneEntity): string { return XmlElementNames.NlgPhone; }
}

/**
 * Represents a collection of conversation items.
 * 
 * @sealed
 */
export class ConversationNodeCollection extends ComplexPropertyCollection<ConversationNode> {

    private propertySet: PropertySet = null;

    /**
     * @internal Initializes a new instance of the **ConversationNodeCollection** class.
     *
     * @param   {PropertySet}   propertySet   The property set.
     */
    constructor(propertySet: PropertySet) {
        super();
        this.propertySet = propertySet;
    }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {string}   complexProperty   The complex property.
     * @return  {ConversationNode}           XML element name.
     */
    CreateComplexProperty(xmlElementName: string): ConversationNode {
        return new ConversationNode(this.propertySet);
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {ConversationNode}      ConversationItem.
     */
    CreateDefaultComplexProperty(): ConversationNode {
        return new ConversationNode(this.propertySet);
    }

    /**
     * @internal Loads from XMLjsObject.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    LoadFromXmlJsObject(jsObjectCollection: any, service: ExchangeService): void {
        let jsCollection: any[] = jsObjectCollection;
        if (!ArrayHelper.isArray(jsCollection)) {
            jsCollection = [jsObjectCollection];
        }

        for (let jsObject of jsCollection) {
            let jsEntry = jsObject;

            if (jsEntry != null) {
                let node: ConversationNode = new ConversationNode(this.propertySet);
                node.LoadFromXmlJsObject(jsEntry, service);
                this.InternalAdd(node);
            }
        }
    }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {ConversationNode}  complexProperty   The complex property.
     * @return  {string}            XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: ConversationNode): string {
        return complexProperty.GetXmlElementName();
    }
}

/**
 * Represents a collection of deleted occurrence objects.
 */
export class DeletedOccurrenceInfoCollection extends ComplexPropertyCollection<DeletedOccurrenceInfo> {

    /**
     * @internal Initializes a new instance of the **OccurrenceInfoCollection** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {DeletedOccurrenceInfo}     OccurenceInfo instance.
     */
    CreateComplexProperty(xmlElementName: string): DeletedOccurrenceInfo {
        if (xmlElementName == XmlElementNames.DeletedOccurrence) {
            return new DeletedOccurrenceInfo();
        }
        else {
            return null;
        }
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {DeletedOccurrenceInfo}     Default OccurenceInfo instance.
     */
    CreateDefaultComplexProperty(): DeletedOccurrenceInfo { return new DeletedOccurrenceInfo(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {DeletedOccurrenceInfo}   complexProperty   The complex property.
     * @return  {string}        XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: DeletedOccurrenceInfo): string { return XmlElementNames.Occurrence; }
}

/**
 * Represents a collection of e-mail addresses.
 */
export class EmailAddressCollection extends ComplexPropertyCollection<EmailAddress> {

    /**
     * XML element name
     */
    private collectionItemXmlElementName: string = null;

    /**
     * @internal Initializes a new instance of the **EmailAddressCollection** class.
     *
     * /remarks/    Note that XmlElementNames.Mailbox is the collection element name for ArrayOfRecipientsType, not ArrayOfEmailAddressesType.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **EmailAddressCollection** class.
     *
     * @param   {string}   collectionItemXmlElementName   Name of the collection item XML element.
     */
    constructor(collectionItemXmlElementName: string);
    constructor(collectionItemXmlElementName?: string) {
        super();
        this.collectionItemXmlElementName = collectionItemXmlElementName || XmlElementNames.Mailbox;
    }

    /**
     * Adds an e-mail address to the collection.
     *
     * @param   {EmailAddress}   emailAddress   The e-mail address to add.
     */
    Add(emailAddress: EmailAddress): void;
    /**
     * Adds an e-mail address to the collection.
     *
     * @param   {string}   smtpAddress   The SMTP address used to initialize the e-mail address.
     * @return  {EmailAddress}                 An EmailAddress object initialized with the provided SMTP address.
     */
    Add(smtpAddress: string): EmailAddress;
    /**
     * Adds an e-mail address to the collection.
     *
     * @param   {string}   name          The name used to initialize the e-mail address.
     * @param   {string}   smtpAddress   The SMTP address used to initialize the e-mail address.
     * @return  {EmailAddress}           An EmailAddress object initialized with the provided SMTP address.
     */
    Add(name: string, smtpAddress: string): EmailAddress;
    Add(nameOrSmtpAddressOrEmailAddress: string | EmailAddress, smtpAddress?: string): any | EmailAddress {
        let argsLength = arguments.length;
        let emailAddress: EmailAddress = <EmailAddress>nameOrSmtpAddressOrEmailAddress;
        if (argsLength == 1) {
            if (typeof nameOrSmtpAddressOrEmailAddress === 'string') {
                emailAddress = new EmailAddress(nameOrSmtpAddressOrEmailAddress);
            }
            else {
                emailAddress = nameOrSmtpAddressOrEmailAddress;
            }
        }
        if (argsLength === 2) {
            emailAddress = new EmailAddress(<string>nameOrSmtpAddressOrEmailAddress, smtpAddress);
        }
        this.InternalAdd(emailAddress);
        return emailAddress;
    }

    /**
     * Adds multiple e-mail addresses to the collection.
     *
     * @param   {EmailAddress[]}   emailAddresses   The e-mail addresses to add.
     */
    AddRange(emailAddresses: EmailAddress[]): void;
    /**
     * Adds multiple e-mail addresses to the collection.
     *
     * @param   {string[]}   smtpAddresses   The SMTP addresses used to initialize the e-mail addresses.
     */
    AddRange(smtpAddresses: string[]): void;
    AddRange(emailOrSmtpAddresses: EmailAddress[] | string[]): void {
        for (let address of emailOrSmtpAddresses) {
            let emailAddress = <EmailAddress>address;
            if (typeof emailAddress === 'string') {
                emailAddress = new EmailAddress(<string>address);
            }
            this.InternalAdd(emailAddress);
        }
    }

    /**
     * Clears the collection.
     */
    Clear(): void { this.InternalClear(); }

    /**
     * @internal Creates an EmailAddress object from an XML element name.
     *
     * @param   {string}   xmlElementName   The XML element name from which to create the e-mail address.
     * @return  {EmailAddress}              An EmailAddress object.
     */
    CreateComplexProperty(xmlElementName: string): EmailAddress {
        if (xmlElementName == this.collectionItemXmlElementName) {
            return new EmailAddress();
        }
        else {
            return null;
        }
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {EmailAddress}      default instance of EmailAddress
     */
    CreateDefaultComplexProperty(): EmailAddress { return new EmailAddress(); }

    /**
     * @internal Retrieves the XML element name corresponding to the provided EmailAddress object.
     *
     * @param   {EmailAddress}   emailAddress   The EmailAddress object from which to determine the XML element name.
     * @return  {string}        The XML element name corresponding to the provided EmailAddress object.
     */
    GetCollectionItemXmlElementName(emailAddress: EmailAddress): string { return this.collectionItemXmlElementName; }

    /**
     * Removes an e-mail address from the collection.
     *
     * @param   {EmailAddress}  emailAddress   The e-mail address to remove.
     * @return  {boolean}       True if the email address was successfully removed from the collection, false otherwise.
     */
    Remove(emailAddress: EmailAddress): boolean {
        EwsUtilities.ValidateParam(emailAddress, "emailAddress");
        return this.InternalRemove(emailAddress);
    }

    /**
     * Removes an e-mail address from the collection.
     *
     * @param   {number}   index   The index of the e-mail address to remove.
     */
    RemoveAt(index: number): void {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        this.InternalRemoveAt(index);
    }

    /**
     * @internal Determine whether we should write collection to XML or not.
     *
     * @return  {true}      Always true, even if the collection is empty.
     */
    ShouldWriteToRequest(): boolean { return true; }
}

/**
 * Represents a collection of EmailAddressEntity objects.
 */
export class EmailAddressEntityCollection extends ComplexPropertyCollection<EmailAddressEntity> {

    /**
     * @internal Initializes a new instance of the **EmailAddressEntityCollection** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **EmailAddressEntityCollection** class.
     *
     * @param   {EmailAddressEntity[]}   collection   The collection of objects to include.
     */
    constructor(collection: EmailAddressEntity[]);
    constructor(collection: EmailAddressEntity[] = null) {
        super();
        if (collection != null) {
            collection.forEach((entity) => { this.InternalAdd(entity); });
        }
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}                xmlElementName   Name of the XML element.
     * @return  {EmailAddressEntity}    EmailAddressEntity.
     */
    CreateComplexProperty(xmlElementName: string): EmailAddressEntity { return new EmailAddressEntity(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {EmailAddressEntity}      EmailAddressEntity.
     */
    CreateDefaultComplexProperty(): EmailAddressEntity { return new EmailAddressEntity(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {EmailAddressEntity}    complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: EmailAddressEntity): string { return XmlElementNames.NlgEmailAddress; }
}

/**
 * Represents a collection of EmailUserEntity objects.
 */
export class EmailUserEntityCollection extends ComplexPropertyCollection<EmailUserEntity> {

    /**
     * @internal Initializes a new instance of the **EmailUserEntityCollection** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **EmailUserEntityCollection** class.
     *
     * @param   {EmailUserEntity[]}   collection   The collection of objects to include.
     */
    constructor(collection: EmailUserEntity[]);
    constructor(collection: EmailUserEntity[] = null) {
        super();
        if (collection != null) {
            collection.forEach((entity) => { this.InternalAdd(entity); });
        }
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}              xmlElementName   Name of the XML element.
     * @return  {EmailUserEntity}     EmailUserEntity.
     */
    CreateComplexProperty(xmlElementName: string): EmailUserEntity { return new EmailUserEntity(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {EmailUserEntity}      EmailUserEntity.
     */
    CreateDefaultComplexProperty(): EmailUserEntity { return new EmailUserEntity(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {EmailUserEntity}       complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: EmailUserEntity): string { return XmlElementNames.NlgEmailUser; }
}

export class ExtendedPropertyCollection extends ComplexPropertyCollection<ExtendedProperty> implements ICustomUpdateSerializer {
    CreateComplexProperty(xmlElementName: string): ExtendedProperty { return new ExtendedProperty(); }
    CreateDefaultComplexProperty(): ExtendedProperty { return new ExtendedProperty(); }
    GetCollectionItemXmlElementName(complexProperty: ExtendedProperty): string { return null; }
    GetOrAddExtendedProperty(propertyDefinition: ExtendedPropertyDefinition): ExtendedProperty {
        var extendedProperty: IOutParam<ExtendedProperty> = { outValue: null };
        if (!this.TryGetProperty(propertyDefinition, extendedProperty)) {
            extendedProperty.outValue = new ExtendedProperty(propertyDefinition);
            this.InternalAdd(extendedProperty.outValue);
        }
        return extendedProperty.outValue;
    }
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {//localElementName: string
        var extendedProperty = new ExtendedProperty();
        //debugger; //debug: //todo: check for need of local element -not tested
        extendedProperty.LoadFromXmlJsObject(jsObject, service);
        this.InternalAdd(extendedProperty);
    }
    RemoveExtendedProperty(propertyDefinition: ExtendedPropertyDefinition): boolean {
        //EwsUtilities.ValidateParam(propertyDefinition, "propertyDefinition");

        var extendedProperty: IOutParam<ExtendedProperty> = { outValue: null };
        if (this.TryGetProperty(propertyDefinition, extendedProperty)) {
            return this.InternalRemove(extendedProperty.outValue);
        }
        else {
            return false;
        }
    }
    SetExtendedProperty(propertyDefinition: ExtendedPropertyDefinition, value: any): void {
        var extendedProperty = this.GetOrAddExtendedProperty(propertyDefinition);
        extendedProperty.Value = value;
    }
    TryGetProperty(propertyDefinition: ExtendedPropertyDefinition, extendedProperty: IOutParam<ExtendedProperty>): boolean {
        extendedProperty.outValue = ArrayHelper.Find(this.Items, (prop) => prop.PropertyDefinition.Equals(propertyDefinition));
        return extendedProperty.outValue != null;
    }
    TryGetValue<T>(propertyDefinition: ExtendedPropertyDefinition, propertyValue: IOutParam<T>): boolean {
        var extendedProperty: IOutParam<ExtendedProperty> = { outValue: null };
        if (this.TryGetProperty(propertyDefinition, extendedProperty)) {
            //debug: Verify that the type parameter and property definition's type are compatible.
            //if (!typeof (T).IsAssignableFrom(propertyDefinition.Type)) {
            // var errorMessage = StringHelper.Format(
            //     Strings.PropertyDefinitionTypeMismatch,
            //     EwsUtilities.GetPrintableTypeName(propertyDefinition.Type),
            //     EwsUtilities.GetPrintableTypeName("Y"));
            // throw new ArgumentException(errorMessage +  " - propertyDefinition");
            //}
            propertyValue.outValue = <T>extendedProperty.outValue.Value;
            return true
        }
        else {
            propertyValue.outValue = null;// default(T);
            return false;
        }
    }

    /**
     * @internal Writes the deletion update to XML.
     * ICustomUpdateSerializer.WriteDeleteUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer      The writer.
     * @param   {ServiceObject}         ewsObject   The ews object.
     * @return  {boolean}               True if property generated serialization.
     */
    WriteDeleteUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject): boolean {
        // Use the default XML serializer.
        for (let extendedProperty of this.Items) {
            writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetDeleteFieldXmlElementName());
            extendedProperty.PropertyDefinition.WriteToXml(writer);
            writer.WriteEndElement();
        }

        return true;
    }

    /**
     * @internal Writes the update to XML.
     * ICustomUpdateSerializer.WriteSetUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer.
     * @param   {ServiceObject}         ewsObject            The ews object.
     * @param   {PropertyDefinition}    propertyDefinition   Property definition.
     * @return  {boolean}               True if property generated serialization.
     */
    WriteSetUpdateToXml(
        writer: EwsServiceXmlWriter,
        ewsObject: ServiceObject,
        propertyDefinition: PropertyDefinition): boolean {
        let propertiesToSet: ExtendedProperty[] = [];

        ArrayHelper.AddRange(propertiesToSet, this.AddedItems);
        ArrayHelper.AddRange(propertiesToSet, this.ModifiedItems);

        for (let extendedProperty of propertiesToSet) {
            writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetSetFieldXmlElementName());
            extendedProperty.PropertyDefinition.WriteToXml(writer);

            writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetXmlElementName());
            extendedProperty.WriteToXml(writer, XmlElementNames.ExtendedProperty);
            writer.WriteEndElement();

            writer.WriteEndElement();
        }

        for (let extendedProperty of this.RemovedItems) {
            writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetDeleteFieldXmlElementName());
            extendedProperty.PropertyDefinition.WriteToXml(writer);
            writer.WriteEndElement();
        }

        return true;
    }

    /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void {
        for (var extendedProperty of this.Items) {
            extendedProperty.WriteToXml(writer, XmlElementNames.ExtendedProperty);
        }
    }
}


/**
 * Represents a collection of folder Ids.
 * 
 * @sealed
 */
export class FolderIdCollection extends ComplexPropertyCollection<FolderId> {

    /**
	 * @internal Initializes a new instance of the **FolderIdCollection** class.
	 */
    constructor();
    /**
     * @internal Initializes a new instance of the **FolderIdCollection** class.
     *
     * @param   {FolderId[]}   folderIds   The folder ids to include.
     */
    constructor(folderIds: FolderId[]);
    constructor(folderIds: FolderId[] = null) {
        super();
        if (folderIds != null) {
            folderIds.forEach((folderId) => this.InternalAdd(folderId));
        }
    }

    /**
     * Adds a folder Id to the collection.
     *
     * @param   {FolderId}   folderId   The folder Id to add.
     */
    Add(folderId: FolderId): void;
    /**
     * Adds a well-known folder to the collection.
     *
     * @param   {WellKnownFolderName}   folderName   The well known folder to add.
     * @return  {FolderId}      A FolderId encapsulating the specified Id.
     */
    Add(folderName: WellKnownFolderName): FolderId;
    Add(folderIdOrName: FolderId | WellKnownFolderName): void | FolderId {

        let folderId: FolderId = null;
        if (typeof folderIdOrName === 'number') {
            folderId = new FolderId(folderIdOrName);
            if (ArrayHelper.Find(this.Items, (item) => item.FolderName === folderIdOrName)) { //if (this.Contains(folderIdOrName)) { // can not use in JavaScript
                throw new ArgumentException(Strings.IdAlreadyInList, "folderName");
            }
        }
        else {

            EwsUtilities.ValidateParam(folderId, "folderId");
            folderId = folderIdOrName;
            if (this.Contains(folderId)) {
                throw new ArgumentException(Strings.IdAlreadyInList, "folderId");
            }
        }

        this.InternalAdd(folderId);

        return folderId;
    }

    /**
     * Clears the collection.
     */
    Clear(): void {
        this.InternalClear();
    }

    /**
     * @internal Instantiate the appropriate attachment type depending on the current XML element name.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {FolderId}        FolderId.
     */
    CreateComplexProperty(xmlElementName: string): FolderId {
        return new FolderId();
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {FolderId}      FolderId.
     */
    CreateDefaultComplexProperty(): FolderId {
        return new FolderId();
    }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {FolderId}  complexProperty   The complex property.
     * @return  {string}    XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: FolderId): string {
        return complexProperty.GetXmlElementName();
    }

    /**
     * Removes the specified folder Id from the collection.
     *
     * @param   {FolderId}   folderId   The folder Id to remove from the collection.
     * @return  {boolean}    True if the folder id was successfully removed from the collection, false otherwise.
     */
    Remove(folderId: FolderId): boolean;
    /**
     * Removes the specified well-known folder from the collection.
     *
     * @param   {WellKnownFolderName}   folderName   The well-knwon folder to remove from the collection.
     * @return  {boolean}               True if the well-known folder was successfully removed from the collection, false otherwise.
     */
    Remove(folderName: WellKnownFolderName): boolean;
    Remove(folderIdOrName: FolderId | WellKnownFolderName): boolean {
        if (typeof folderIdOrName === 'number') {
            // can not simply use InternalRemove as javascript does not have c# List functionality
            let index = ArrayHelper.IndexOf(this.Items, (item) => item.FolderName === folderIdOrName);
            if (index >= 0) {
                this.InternalRemoveAt(index);
                return true;
            }
        }
        else {
            EwsUtilities.ValidateParam(folderIdOrName, "folderId");

            return this.InternalRemove(folderIdOrName);
        }
        return false;
    }

    /**
     * Removes the folder Id at the specified index.
     *
     * @param   {number}   index   The zero-based index of the folder Id to remove.
     */
    RemoveAt(index: number): void {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }

        this.InternalRemoveAt(index);
    }
}

/**
 * Represents a collection of folder permissions.
 * 
 * @sealed
 */
export class FolderPermissionCollection extends ComplexPropertyCollection<FolderPermission> {

    private isCalendarFolder: boolean;
    private unknownEntries: string[] = [];

    /**
     * Gets the name of the inner collection XML element.
     *
     * @value   XML element name.
     */
    private get InnerCollectionXmlElementName(): string {
        return this.isCalendarFolder ? XmlElementNames.CalendarPermissions : XmlElementNames.Permissions;
    }

    /**
     * Gets the name of the collection item XML element.
     *
     * @value   XML element name.
     */
    private get CollectionItemXmlElementName(): string {
        return this.isCalendarFolder ? XmlElementNames.CalendarPermission : XmlElementNames.Permission;
    }

    /**
     * Gets a list of unknown user Ids in the collection.
     */
    get UnknownEntries(): string[] {
        return this.unknownEntries;
    }

    /**
     * Initializes a new instance of the **FolderPermissionCollection** class.
     *
     * @param   {Folder}   owner   The folder owner.
     */
    constructor(owner: Folder) {
        super();
        this.isCalendarFolder = owner instanceof TypeContainer.CalendarFolder;// owner instanceof CalendarFolder;

    }

    /**
     * Adds a permission to the collection.
     *
     * @param   {FolderPermission}   permission   The permission to add.
     */
    Add(permission: FolderPermission): void {
        this.InternalAdd(permission);
    }

    /**
     * Adds the specified permissions to the collection.
     *
     * @param   {FolderPermission[]}   permissions   The permissions to add.
     */
    AddRange(permissions: FolderPermission[]): void {
        EwsUtilities.ValidateParam(permissions, "permissions");
        for (let permission of permissions) {
            this.Add(permission);
        }
    }

    /**
     * Clears this collection.
     */
    Clear(): void {
        this.InternalClear();
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {FolderPermission}          FolderPermission instance.
     */
    CreateComplexProperty(xmlElementName: string): FolderPermission {
        return new FolderPermission();
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {FolderPermission}  FolderPermission instance.
     */
    CreateDefaultComplexProperty(): FolderPermission {
        return new FolderPermission();
    }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {FolderPermission}      complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: FolderPermission): string {
        return this.CollectionItemXmlElementName;
    }

    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    CreateFromXmlJsObjectCollection(jsObjectCollection: any, service: ExchangeService): void {
        let jsonFolderPermissions: any[] = jsObjectCollection[this.InnerCollectionXmlElementName];
        if (jsonFolderPermissions && jsonFolderPermissions[this.CollectionItemXmlElementName])
            jsonFolderPermissions = jsonFolderPermissions[this.CollectionItemXmlElementName];
        if (!Array.isArray(jsonFolderPermissions)) {
            //debugger;
            throw new Error("FolderPermissionCollection.ts - LoadFromXmlJsObject - Invalid xml parsing, jsonproperty must contain collectionxmlelementname and collectionitemelementname underneeth");
        }
        for (let jsonFolderPermission of jsonFolderPermissions) {
            let permission: FolderPermission = new FolderPermission();
            permission.LoadFromXmlJsObject(jsonFolderPermission, service);
            this.InternalAdd(permission);
        }
        if (jsObjectCollection[XmlElementNames.UnknownEntries]) {
            let jsonUnknownEntries: any[] = jsObjectCollection[XmlElementNames.UnknownEntries];
            if (typeof jsonUnknownEntries !== 'object' && !Array.isArray(jsonFolderPermissions)) {
                //debugger;
                throw new Error("FolderPermissionCollection.ts - LoadFromXmlJsObject - Invalid xml returned - check for consistency, UnknownEntries must be array type");
            }

            for (let jsonUnknownEntry of jsonUnknownEntries) {
                this.unknownEntries.push(jsonUnknownEntry);
            }
        }
    }

    /**
     * Removes a permission from the collection.
     *
     * @param   {FolderPermission}  permission   The permission to remove.
     * @return  {boolean}           True if the folder permission was successfully removed from the collection, false otherwise.
     */
    Remove(permission: FolderPermission): boolean {
        return this.InternalRemove(permission);
    }

    /**
     * Removes a permission from the collection.
     *
     * @param   {number}   index   The zero-based index of the permission to remove.
     */
    RemoveAt(index: number): void {
        this.InternalRemoveAt(index);
    }

    /**
     * @internal Validates this instance.
     */
    Validate(): void {
        for (let permissionIndex = 0; permissionIndex < this.Items.length; permissionIndex++) {
            let permission: FolderPermission = this.Items[permissionIndex];
            permission.Validate(this.isCalendarFolder, permissionIndex);
        }
    }

    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, this.InnerCollectionXmlElementName);
        for (let folderPermission of this.Items) {
            folderPermission.WriteToXml(
                writer,
                this.GetCollectionItemXmlElementName(folderPermission),
                undefined,//XmlNamespace - incorrect inheritance error with typesctipt in folderpermission class if removed xmlnamespace parameter
                this.isCalendarFolder);
        }
        writer.WriteEndElement(); // this.InnerCollectionXmlElementName
    }
}



/**
 * Represents a collection of members of GroupMember type.
 * @sealed
 */
export class GroupMemberCollection extends ComplexPropertyCollection<GroupMember> implements ICustomUpdateSerializer {

    /**
     * If the collection is cleared, then store PDL members collection is updated with "SetItemField". If the collection is not cleared, then store PDL members collection is updated with "AppendToItemField".
     *
     */
    private collectionIsCleared: boolean = false;

    /**
     * Initializes a new instance of the  class.
     *
     */
    constructor() {
        super();
    }

    /**
     * Adds a member to the collection.
     *
     * @param   {GroupMember}   member   The member to add.
     */
    Add(member: GroupMember): void {
        EwsUtilities.ValidateParam(member, "member");

        EwsLogging.Assert(
            member.Key == null,
            "GroupMemberCollection.Add",
            "member.Key is not null.");

        EwsLogging.Assert(
            !this.Contains(member),
            "GroupMemberCollection.Add",
            "The member is already in the collection");

        this.InternalAdd(member);
    }

    /**
     * Adds a member that is linked to a specific e-mail address of a contact.
     *
     * @param   {Contact}   contact           The contact to link to.
     * @param   {EmailAddressKey}   emailAddressKey   The contact's e-mail address to link to.
     */
    AddContactEmailAddress(contact: Contact, emailAddressKey: EmailAddressKey): void {
        this.Add(new GroupMember(contact, emailAddressKey));
    }

    /**
     * Adds a member linked to a Contact Group.
     *
     * @param   {ItemId}   contactGroupId   The Id of the contact group.
     */
    AddContactGroup(contactGroupId: ItemId): void {
        this.Add(new GroupMember(contactGroupId));
    }

    /**
     * Adds a member linked to an Active Directory contact.
     *
     * @param   {string}   smtpAddress   The SMTP address of the Active Directory contact.
     */
    AddDirectoryContact(smtpAddress: string): void;
    /**
     * Adds a member linked to an Active Directory contact.
     *
     * @param   {string}   address       The address of the Active Directory contact.
     * @param   {string}   routingType   The routing type of the address.
     */
    AddDirectoryContact(address: string, routingType: string): void;
    AddDirectoryContact(address: string, routingType: string = EmailAddress.SmtpRoutingType): void {
        this.Add(new GroupMember(address, routingType, MailboxType.Contact));
    }

    /**
     * Adds a member linked to a mail-enabled Public Folder.
     *
     * @param   {string}   smtpAddress   The SMTP address of the mail-enabled Public Folder.
     */
    AddDirectoryPublicFolder(smtpAddress: string): void {
        this.Add(new GroupMember(smtpAddress, EmailAddress.SmtpRoutingType, MailboxType.PublicFolder));
    }

    /**
     * Adds a member linked to an Active Directory user.
     *
     * @param   {string}   smtpAddress   The SMTP address of the member.
     */
    AddDirectoryUser(smtpAddress: string): void;
    /**
     * Adds a member linked to an Active Directory user.
     *
     * @param   {string}   address       The address of the member.
     * @param   {string}   routingType   The routing type of the address.
     */
    AddDirectoryUser(address: string, routingType: string): void;
    AddDirectoryUser(address: string, routingType: string = EmailAddress.SmtpRoutingType): void {
        this.Add(new GroupMember(address, routingType, MailboxType.Mailbox));
    }

    /**
     * Adds a one-off member.
     *
     * @param   {string}   displayName   The display name of the member.
     * @param   {string}   smtpAddress   The SMTP address of the member.
     */
    AddOneOff(displayName: string, smtpAddress: string): void;
    /**
     * Adds a one-off member.
     *
     * @param   {string}   displayName   The display name of the member.
     * @param   {string}   address       The address of the member.
     * @param   {string}   routingType   The routing type of the address.
     */
    AddOneOff(displayName: string, address: string, routingType: string): void;
    AddOneOff(displayName: string, address: string, routingType: string = EmailAddress.SmtpRoutingType): void {
        this.Add(new GroupMember(displayName, address, routingType));
    }

    /**
     * Adds a member linked to a contact's first available e-mail address.
     *
     * @param   {ItemId}   contactId   The Id of the contact.
     */
    AddPersonalContact(contactId: ItemId): void;
    /**
     * Adds a member linked to a specific contact's e-mail address.
     *
     * @param   {ItemId}   contactId       The Id of the contact.
     * @param   {string}   addressToLink   The contact's address to link to.
     */
    AddPersonalContact(contactId: ItemId, addressToLink: string): void;
    AddPersonalContact(contactId: ItemId, addressToLink: string = null): void {
        this.Add(new GroupMember(contactId, addressToLink));
    }

    /**
     * Adds a member linked to a Public Group.
     *
     * @param   {string}   smtpAddress   The SMTP address of the Public Group.
     */
    AddPublicGroup(smtpAddress: string): void {
        this.Add(new GroupMember(smtpAddress, EmailAddress.SmtpRoutingType, MailboxType.PublicGroup));
    }

    /**
     * Adds multiple members to the collection.
     *
     * @param   {GroupMember[]}   members   The members to add.
     */
    AddRange(members: GroupMember[] /*IEnumerable<T>*/): void {
        EwsUtilities.ValidateParam(members, "members");

        for (let member of members) {
            this.Add(member);
        }
    }

    /**
     * Clears the collection.
     */
    Clear(): void {
        // mark the whole collection for deletion
        this.InternalClear();
        this.collectionIsCleared = true;
    }

    /**
     * @internal Clears the change log.
     *
     */
    ClearChangeLog(): void {
        super.ClearChangeLog();
        this.collectionIsCleared = false;
    }

    /**
     * @internal Creates a GroupMember object from an XML element name.
     *
     * @param   {string}        xmlElementName   The XML element name from which to create the e-mail address.
     * @return  {GroupMember}   An GroupMember object.
     */
    CreateComplexProperty(xmlElementName: string): GroupMember {
        return new GroupMember();
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {GroupMember}      An GroupMember object.
     */
    CreateDefaultComplexProperty(): GroupMember {
        return new GroupMember();
    }

    /**
     * Finds the member with the specified key in the collection. 
     * Members that have not yet been saved do not have a key.
     *
     * @param   {}   key   The key of the member to find.
     * @return  {}         The member with the specified key.
     */
    Find(key: string): GroupMember {
        EwsUtilities.ValidateParam(key, "key");

        for (let item of this.Items) {
            if (item.Key == key) {
                return item;
            }
        }

        return null;
    }

    /**
     * @internal Retrieves the XML element name corresponding to the provided GroupMember object.
     *
     * @param   {GroupMember}   member   The GroupMember object from which to determine the XML element name.
     * @return  {string}            The XML element name corresponding to the provided GroupMember object.
     */
    GetCollectionItemXmlElementName(member: GroupMember): string {
        return XmlElementNames.Member;
    }

    /**
     * @internal Validates this instance.
     */
    InternalValidate(): void {
        super.InternalValidate();

        for (let groupMember of this.ModifiedItems) {
            if (StringHelper.IsNullOrEmpty(groupMember.Key)) {
                throw new ServiceValidationException(Strings.ContactGroupMemberCannotBeUpdatedWithoutBeingLoadedFirst);
            }
        }
    }

    /**
     * Removes a member from the collection.
     *
     * @param   {GroupMember}   member   The member to remove.
     * @return  {boolean}       True if the group member was successfully removed from the collection, false otherwise.
     */
    Remove(member: GroupMember): boolean {
        return this.InternalRemove(member);
    }

    /**
     * Removes a member at the specified index.
     *
     * @param   {number}   index   The index of the member to remove.
     */
    RemoveAt(index: number): void {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }

        this.InternalRemoveAt(index);
    }

    /**
     * Delete the whole members collection.
     *
     * @param   {EwsServiceXmlWriter}   writer   Xml writer.
     */
    private WriteDeleteMembersCollectionToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.DeleteItemField);
        ContactGroupSchema.Members.WriteToXml(writer);
        writer.WriteEndElement();
    }

    /**
     * Generate XML to delete individual members.
     *
     * @param   {EwsServiceXmlWriter}   writer    Xml writer.
     * @param   {GroupMember[]}         members   Members to delete.
     */
    private WriteDeleteMembersToXml(writer: EwsServiceXmlWriter, members: GroupMember[] /* List<GroupMember>*/): void {
        if (members.length != 0) {
            let memberPropDef: GroupMemberPropertyDefinition = new GroupMemberPropertyDefinition();

            for (let member of members) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.DeleteItemField);

                memberPropDef.Key = member.Key;
                memberPropDef.WriteToXml(writer);

                writer.WriteEndElement();   // DeleteItemField
            }
        }
    }

    /**
     * Generate XML to Set or Append members. When members are set, the existing PDL member collection is cleared On append members are added to the PDL existing members collection.
     *
     * @param   {EwsServiceXmlWriter}   writer    Xml writer.
     * @param   {GroupMember[]}         members   Members to set or append.
     * @param   {boolean}               setMode   True - set members, false - append members.
     */
    private WriteSetOrAppendMembersToXml(writer: EwsServiceXmlWriter, members: GroupMember[] /*List<GroupMember>*/, setMode: boolean): void {
        if (members.length != 0) {
            writer.WriteStartElement(XmlNamespace.Types, setMode ? XmlElementNames.SetItemField : XmlElementNames.AppendToItemField);

            ContactGroupSchema.Members.WriteToXml(writer);

            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.DistributionList);
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Members);

            for (let member of members) {
                member.WriteToXml(writer, XmlElementNames.Member);
            }

            writer.WriteEndElement();   // Members
            writer.WriteEndElement();   // Group
            writer.WriteEndElement();   // setMode ? SetItemField : AppendItemField
        }
    }

    //#region ICustomUpdateSerializer

    /**
     * @internal Writes the deletion update to XML.
     * ICustomUpdateSerializer.WriteDeleteUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer      The writer.
     * @param   {ServiceObject}         ewsObject   The ews object.
     * @return  {boolean}               True if property generated serialization.
     */
    WriteDeleteUpdateToXml(writer: EwsServiceXmlWriter, ewsObject: ServiceObject): boolean {
        return false;
    }

    /**
     * @internal Writes the update to XML.
     * ICustomUpdateSerializer.WriteSetUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer.
     * @param   {ServiceObject}         ewsObject            The ews object.
     * @param   {PropertyDefinition}    propertyDefinition   Property definition.
     * @return  {boolean}               True if property generated serialization.
     */
    WriteSetUpdateToXml(
        writer: EwsServiceXmlWriter,
        ewsObject: ServiceObject,
        propertyDefinition: PropertyDefinition): boolean {

        if (this.collectionIsCleared) {
            if (this.AddedItems.length == 0) {
                // Delete the whole members collection
                this.WriteDeleteMembersCollectionToXml(writer);
            }
            else {
                // The collection is cleared, so Set
                this.WriteSetOrAppendMembersToXml(writer, this.AddedItems, true);
            }
        }
        else {
            // The collection is not cleared, i.e. dl.Members.Clear() is not called.
            // Append AddedItems.
            this.WriteSetOrAppendMembersToXml(writer, this.AddedItems, false);

            // Since member replacement is not supported by server
            // Delete old ModifiedItems, then recreate new instead.
            this.WriteDeleteMembersToXml(writer, this.ModifiedItems);
            this.WriteSetOrAppendMembersToXml(writer, this.ModifiedItems, false);

            // Delete RemovedItems.
            this.WriteDeleteMembersToXml(writer, this.RemovedItems);
        }

        return true;
    }
    //#endregion
}

/**
 * Represents a collection of Internet message headers.
 */
export class InternetMessageHeaderCollection extends ComplexPropertyCollection<InternetMessageHeader> {

    /**
     * @internal Initializes a new instance of the **InternetMessageHeaderCollection** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {InternetMessageHeader}     InternetMessageHeader instance.
     */
    CreateComplexProperty(xmlElementName: string): InternetMessageHeader { return new InternetMessageHeader(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {InternetMessageHeader}      InternetMessageHeader instance.
     */
    CreateDefaultComplexProperty(): InternetMessageHeader { return new InternetMessageHeader(); }

    /**
     * Find a specific header in the collection.
     *
     * @param   {string}   name   The name of the header to locate.
     * @return  {InternetMessageHeader}     An InternetMessageHeader representing the header with the specified name; null if no header with the specified name was found.
     */
    Find(name: string): InternetMessageHeader {
        for (let internetMessageHeader of this.Items) {
            if (name.toUpperCase() === internetMessageHeader.Name.toUpperCase()) {
                return internetMessageHeader;
            }
        }

        return null;
    }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {InternetMessageHeader}     complexProperty   The complex property.
     * @return  {string}                    XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: InternetMessageHeader): string { return XmlElementNames.InternetMessageHeader; }
}

/**
 * Represents a collection of item Ids.
 * 
 * @sealed
 */
export class ItemIdCollection extends ComplexPropertyCollection<ItemId> {

    /**
     * @internal Initializes a new instance of the **ItemIdCollection** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}    xmlElementName   Name of the XML element.
     * @return  {ItemId}    ItemId.
     */
    CreateComplexProperty(xmlElementName: string): ItemId {
        return new ItemId();
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {ItemId}      ItemId.
     */
    CreateDefaultComplexProperty(): ItemId {
        return new ItemId();
    }

    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    CreateFromXmlJsObjectCollection(jsObjectCollection: any, service: ExchangeService): void {
        let collection: ItemId[] = jsObjectCollection;
        if (!ArrayHelper.isArray(collection)) {
            if(jsObjectCollection[XmlElementNames.OccurrenceItemId]){
                EwsLogging.Log("Fix needed for ItemIdCollection for element OccurrenceItemId",true,true);
                EwsLogging.Log(jsObjectCollection[XmlElementNames.OccurrenceItemId],true,true);
            }
            if(jsObjectCollection[XmlElementNames.RecurringMasterItemId]){
                EwsLogging.Log("Fix needed for ItemIdCollection for element RecurringMasterItemId",true,true);
                EwsLogging.Log(jsObjectCollection[XmlElementNames.RecurringMasterItemId],true,true);
            }
            collection = EwsServiceJsonReader.ReadAsArray(collection, XmlElementNames.ItemId);
        }

        super.CreateFromXmlJsObjectCollection(collection, service);
    }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {ItemId}   complexProperty   The complex property.
     * @return  {string}                     XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: ItemId): string {
        return complexProperty.GetXmlElementName();
    }

    /**
     * @internal Loads from XMLJsObject collection to update collection Items.
     *
     * @interface   IJsonCollectionDeserializer
     * 
     * @param   {any}               jsObjectCollection   The XMLJsObject collection.
     * @param   {ExchangeService}   service          The service.
     */
    UpdateFromXmlJsObjectCollection(jsObjectCollection: any, service: ExchangeService): void {
        let collection: ItemId[] = jsObjectCollection;
        if (!ArrayHelper.isArray(collection)) {
            collection = EwsServiceJsonReader.ReadAsArray(collection, XmlElementNames.ItemId);
        }

        super.UpdateFromXmlJsObjectCollection(collection, service);
    }
}

/**
 * Represents a collection of MeetingSuggestion objects.
 */
export class MeetingSuggestionCollection extends ComplexPropertyCollection<MeetingSuggestion> {

    /**
     * @internal Initializes a new instance of the **MeetingSuggestionCollection** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **MeetingSuggestionCollection** class.
     *
     * @param   {MeetingSuggestion[]}   collection   The collection of objects to include.
     */
    constructor(collection: MeetingSuggestion[]);
    constructor(collection: MeetingSuggestion[] = null) {
        super();
        if (collection != null) {
            collection.forEach((suggestion) => { this.InternalAdd(suggestion); });
        }
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}                xmlElementName   Name of the XML element.
     * @return  {MeetingSuggestion}     MeetingSuggestion.
     */
    CreateComplexProperty(xmlElementName: string): MeetingSuggestion { return new MeetingSuggestion(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {MeetingSuggestion}      MeetingSuggestion.
     */
    CreateDefaultComplexProperty(): MeetingSuggestion { return new MeetingSuggestion(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {MeetingSuggestion}     complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: MeetingSuggestion): string { return XmlElementNames.NlgMeetingSuggestion; }
}

/**
 * Represents a collection of OccurrenceInfo objects.
 */
export class OccurrenceInfoCollection extends ComplexPropertyCollection<OccurrenceInfo> {

    /**
     * @internal Initializes a new instance of the **OccurrenceInfoCollection** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {OccurrenceInfo}        OccurenceInfo instance.
     */
    CreateComplexProperty(xmlElementName: string): OccurrenceInfo {
        if (xmlElementName == XmlElementNames.Occurrence) {
            return new OccurrenceInfo();
        }
        else {
            return null;
        }
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {OccurrenceInfo}      OccurenceInfo instance.
     */
    CreateDefaultComplexProperty(): OccurrenceInfo { return new OccurrenceInfo(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {OccurrenceInfo}    complexProperty   The complex property.
     * @return  {string}            XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: OccurrenceInfo): string { return XmlElementNames.Occurrence; }
}

/**
 * Represents a collection of PhoneEntity objects.
 */
export class PhoneEntityCollection extends ComplexPropertyCollection<PhoneEntity> {

    /**
     * @internal Initializes a new instance of the **PhoneEntityCollection** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **PhoneEntityCollection** class.
     *
     * @param   {PhoneEntity[]}   collection   The collection of objects to include.
     */
    constructor(collection: PhoneEntity[]);
    constructor(collection: PhoneEntity[] = null) {
        super();
        if (collection != null) {
            collection.forEach((suggestion) => { this.InternalAdd(suggestion); });
        }
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}        xmlElementName   Name of the XML element.
     * @return  {PhoneEntity}   PhoneEntity.
     */
    CreateComplexProperty(xmlElementName: string): PhoneEntity { return new PhoneEntity(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {PhoneEntity}      PhoneEntity.
     */
    CreateDefaultComplexProperty(): PhoneEntity { return new PhoneEntity(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {PhoneEntity}   complexProperty   The complex property.
     * @return  {string}        XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: PhoneEntity): string { return XmlElementNames.NlgPhone; }
}

/**
 * @internal Represents a collection of rule validation errors.
 * 
 * @sealed
 */
export class RuleErrorCollection extends ComplexPropertyCollection<RuleError> {

	/**
     * @internal Initializes a new instance of the **RuleErrorCollection** class.
     */
  constructor() {
    super();
  }

  /**
   * @internal Creates an RuleError object from an XML element name.
   *
   * @param   {string}   xmlElementName   The XML element name from which to create the RuleError object.
   * @return  {RuleError}        A RuleError object.
   */
  CreateComplexProperty(xmlElementName: string): RuleError {
    if (xmlElementName == XmlElementNames.Error) {
      return new RuleError();
    }
    else {
      return null;
    }
  }

	/**
     * @internal Creates the default complex property.
     *
     * @return  {RuleError}      A RuleError object.
     */
  CreateDefaultComplexProperty(): RuleError {
    return new RuleError();
  }

	/**
     * @internal Retrieves the XML element name corresponding to the provided RuleError object.
     *
     * @param   {RuleError}		ruleValidationError   The RuleError object from which to determine the XML element name.
     * @return  {string}		The XML element name corresponding to the provided RuleError object.
     */
  GetCollectionItemXmlElementName(ruleValidationError: RuleError): string {
    return XmlElementNames.Error;
  }
}

/**
 * Represents a collection of rule operation errors.
 * 
 * @sealed
 */
export class RuleOperationErrorCollection extends ComplexPropertyCollection<RuleOperationError> {

    /**
     * @internal Initializes a new instance of the **RuleOperationErrorCollection** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Creates an RuleOperationError object from an XML element name.
     *
     * @param   {string}   xmlElementName   The XML element name from which to create the RuleOperationError object.
     * @return  {RuleOperationError}        A RuleOperationError object.
     */
    CreateComplexProperty(xmlElementName: string): RuleOperationError {
        if (xmlElementName == XmlElementNames.RuleOperationError) {
            return new RuleOperationError();
        }
        else {
            return null;
        }
    }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {RuleOperationError}      A RuleOperationError object.
     */
    CreateDefaultComplexProperty(): RuleOperationError {
        return new RuleOperationError();
    }

    /**
     * @internal Retrieves the XML element name corresponding to the provided RuleOperationError object.
     *
     * @param   {RuleOperationError}    operationError   The RuleOperationError object from which to determine the XML element name.
     * @return  {string}                The XML element name corresponding to the provided RuleOperationError object.
     */
    GetCollectionItemXmlElementName(operationError: RuleOperationError): string {
        return XmlElementNames.RuleOperationError;
    }
}

/**
 * Represents a collection of TaskSuggestion objects.
 */
export class TaskSuggestionCollection extends ComplexPropertyCollection<TaskSuggestion> {

    /**
     * @internal Initializes a new instance of the **TaskSuggestionCollection** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **TaskSuggestionCollection** class.
     *
     * @param   {TaskSuggestion[]}   collection   The collection of objects to include.
     */
    constructor(collection: TaskSuggestion[]);
    constructor(collection: TaskSuggestion[] = null) {
        super();
        if (collection != null) {
            collection.forEach((suggestion) => { this.InternalAdd(suggestion); });
        }
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}            xmlElementName   Name of the XML element.
     * @return  {TaskSuggestion}    TaskSuggestion.
     */
    CreateComplexProperty(xmlElementName: string): TaskSuggestion { return new TaskSuggestion(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {TaskSuggestion}      TaskSuggestion.
     */
    CreateDefaultComplexProperty(): TaskSuggestion { return new TaskSuggestion(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {TaskSuggestion}    complexProperty   The complex property.
     * @return  {string}            XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: TaskSuggestion): string { return XmlElementNames.NlgTaskSuggestion; }
}

/**
 * Represents a collection of UrlEntity objects.
 */
export class UrlEntityCollection extends ComplexPropertyCollection<UrlEntity> {

    /**
     * @internal Initializes a new instance of the **UrlEntityCollection** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **UrlEntityCollection** class.
     *
     * @param   {UrlEntity[]}   collection   The collection of objects to include.
     */
    constructor(collection: UrlEntity[]);
    constructor(collection: UrlEntity[] = null) {
        super();
        if (collection != null) {
            collection.forEach((entity) => { this.InternalAdd(entity); });
        }
    }

    /**
     * @internal Creates the complex property.
     *
     * @param   {string}        xmlElementName   Name of the XML element.
     * @return  {UrlEntity}     UrlEntity.
     */
    CreateComplexProperty(xmlElementName: string): UrlEntity { return new UrlEntity(); }

    /**
     * @internal Creates the default complex property.
     *
     * @return  {UrlEntity}      UrlEntity.
     */
    CreateDefaultComplexProperty(): UrlEntity { return new UrlEntity(); }

    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {UrlEntity}     complexProperty   The complex property.
     * @return  {string}        XML element name.
     */
    GetCollectionItemXmlElementName(complexProperty: UrlEntity): string { return XmlElementNames.NlgUrl; }
}


/**
 * Represents the base class for all property definitions.
 */
export abstract class PropertyDefinitionBase {

    /**
     * Gets the minimum Exchange version that supports this property.
     *
     * @value {ExchangeVersion} The version.
     */
    Version: ExchangeVersion;

    /**
     * Gets the type of the property.
     */
    get Type(): any { return PropertyDefinitionBase } //System.Type;

    /**
     * @internal Initializes a new instance of the **PropertyDefinitionBase** class.
     */
    constructor() { }

    /**
     * @internal Gets the property definition's printable name.
     *
     * @return  {string}      The property definition's printable name.
     */
    abstract GetPrintableName(): string;

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    abstract GetXmlElementName(): string;
    ToString(): string { return this.GetPrintableName(); }
    //TryLoadFromJson(jsonObject: JsonObject): PropertyDefinitionBase{ throw new Error("PropertyDefinitionBase.ts - TryLoadFromJson : Not implemented.");}

    /**
     * @internal load from XMLJsObject.
     *
     * @param   {any}   jsonObject   The json object.
     * @return  {PropertyDefinitionBase}        True if property was loaded.
     */
    static LoadFromXmlJsObject(jsObject: any): PropertyDefinitionBase {
        for (var key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }
            switch (key) {
                case XmlElementNames.FieldURI:
                    return TypeContainer.ServiceObjectSchema.FindPropertyDefinition(XmlAttributeNames.FieldURI);
                case XmlElementNames.IndexedFieldURI:
                    return new TypeContainer.IndexedPropertyDefinition(
                        jsObject[XmlAttributeNames.FieldURI],
                        jsObject[XmlAttributeNames.FieldIndex])
                case XmlElementNames.ExtendedFieldURI:
                    let propertyDefiniton: ExtendedPropertyDefinition = new TypeContainer.ExtendedPropertyDefinition();
                    propertyDefiniton.LoadPropertyValueFromXmlJsObject(jsObject);
                    return propertyDefiniton;
                default:
                    break;
            }
        }
        return null;
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    abstract WriteAttributesToXml(writer: EwsServiceXmlWriter): void;

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, this.GetXmlElementName());
        this.WriteAttributesToXml(writer);
        writer.WriteEndElement();
    }
}

/**
 * Represents the definition of an extended property.
 */
export class ExtendedPropertyDefinition extends PropertyDefinitionBase {

    private static FieldFormat: string = "{0}: {1} ";
    private static PropertySetFieldName: string = "PropertySet";
    private static PropertySetIdFieldName: string = "PropertySetId";
    private static TagFieldName: string = "Tag";
    private static NameFieldName: string = "Name";
    private static IdFieldName: string = "Id";
    private static MapiTypeFieldName: string = "MapiType";

    private propertySet: DefaultExtendedPropertySet;
    private propertySetId: Guid;
    private tag: number;
    private name: string;
    private id: number;
    private mapiType: MapiPropertyType;

    /**
     * @Nullable Gets the Id of the extended property.
     */
    get Id(): number { return this.id; }

    /**
     * Gets the MAPI type of the extended property.
     */
    get MapiType(): MapiPropertyType { return this.mapiType; }

    /**
     * Gets the name of the extended property.
     */
    get Name(): string { return this.name || ((typeof this.tag === 'undefined') ? null : this.tag.toString()); }

    /**
     * @Nullable Gets the property set of the extended property.
     */
    get PropertySet(): DefaultExtendedPropertySet { return this.propertySet; }

    /**
     * @Nullable Gets the property set Id or the extended property.
     * */
    get PropertySetId(): Guid { return this.propertySetId; }

    /**
     * @Nullable Gets the extended property's tag.
     */
    get Tag(): number { return this.tag; }

    /**
     * Gets the minimum Exchange version that supports this extended property.
     *
     * @value {ExchangeVersion} The version.     
     */
    get Version(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * Gets the property type.
     */
    Type: any;// System.Type;

    /**
     * @internal Initializes a new instance of the **ExtendedPropertyDefinition** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **ExtendedPropertyDefinition** class.
     *
     * @param   {MapiPropertyType}  mapiType      The MAPI type of the extended property.
     */
    constructor(mapiType: MapiPropertyType);
    /**
     * Initializes a new instance of the **ExtendedPropertyDefinition** class.
     *
     * @param   {number}            tag        The tag of the extended property.
     * @param   {MapiPropertyType}  mapiType      The MAPI type of the extended property.
     */
    constructor(tag: number, mapiType: MapiPropertyType);
    /**
     * Initializes a new instance of the **ExtendedPropertyDefinition** class.
     *
     * @param   {DefaultExtendedPropertySet}    propertySet   The extended property set of the extended property.
     * @param   {string}                        name          The name of the extended property.
     * @param   {MapiPropertyType}              mapiType      The MAPI type of the extended property.
     */
    constructor(propertySet: DefaultExtendedPropertySet, name: string, mapiType: MapiPropertyType);
    /**
     * Initializes a new instance of the **ExtendedPropertyDefinition** class.
     *
     * @param   {DefaultExtendedPropertySet}    propertySet   The extended property set of the extended property.
     * @param   {number}                        id            The Id of the extended property.
     * @param   {MapiPropertyType}              mapiType      The MAPI type of the extended property.
     */
    constructor(propertySet: DefaultExtendedPropertySet, id: number, mapiType: MapiPropertyType);
    /**
     * Initializes a new instance of the **ExtendedPropertyDefinition** class.
     *
     * @param   {Guid}              propertySetId   The property set Id of the extended property.
     * @param   {string}            name          The name of the extended property.
     * @param   {MapiPropertyType}  mapiType      The MAPI type of the extended property.
     */
    constructor(propertySetId: Guid, name: string, mapiType: MapiPropertyType);
    /**
     * Initializes a new instance of the **ExtendedPropertyDefinition** class.
     *
     * @param   {Guid}              propertySetId   The property set Id of the extended property.
     * @param   {number}            id            The Id of the extended property.
     * @param   {MapiPropertyType}  mapiType      The MAPI type of the extended property.
     */
    constructor(propertySetId: Guid, id: number, mapiType: MapiPropertyType);
    constructor(
        mapiTypeTagPropertySetOrPropertySetId?: MapiPropertyType | number | DefaultExtendedPropertySet | Guid,
        mapiTypeNameOrId?: MapiPropertyType | string | number,
        mapiType?: MapiPropertyType) {
        super();
        var argsLength = arguments.length;
        this.mapiType = MapiPropertyType.String;
        switch (argsLength) {
            case 1:
                this.mapiType = <MapiPropertyType>mapiTypeTagPropertySetOrPropertySetId;
                break;
            case 2:
                this.mapiType = <MapiPropertyType>mapiTypeNameOrId;
                if (<number>mapiTypeTagPropertySetOrPropertySetId < 0 || <number>mapiTypeTagPropertySetOrPropertySetId > 65535 /*UInt16.MaxValue*/) {
                    throw new ArgumentOutOfRangeException("tag", Strings.TagValueIsOutOfRange);
                }
                this.tag = <number>mapiTypeTagPropertySetOrPropertySetId;
                break;
            case 3:
                this.mapiType = mapiType;

                typeof mapiTypeNameOrId === 'string' ? this.name = mapiTypeNameOrId : this.id = mapiTypeNameOrId;
                typeof mapiTypeTagPropertySetOrPropertySetId === 'number' ? this.propertySet = <DefaultExtendedPropertySet>mapiTypeTagPropertySetOrPropertySetId : this.propertySetId = <Guid>mapiTypeTagPropertySetOrPropertySetId;
                break;
            default:
                break;
        }
    }

    /**
     * Determines whether a given extended property definition is equal to this extended property definition.
     *
     * @param   {any}   obj   The object to check for equality.
     * @return  {boolean}         True if the properties definitions define the same extended property.
     */
    Equals(obj: any): boolean {
        var propertyDefinition = <ExtendedPropertyDefinition>obj;
        return ExtendedPropertyDefinition.IsEqualTo(propertyDefinition, this);
    }

    /**
     * @internal Formats the field.
     *
     * @type    <T>        Type of field value. 
     * @param   {string}   name         The name.
     * @param   {string}   fieldValue   The field value.
     * @return  {string}                Formatted value.
     */
    FormatField(name: string, fieldValue: string): string {
        //debugger;
        return (fieldValue != null)
            ? StringHelper.Format(ExtendedPropertyDefinition.FieldFormat, name, fieldValue)
            : "";
    }

    /**
     * Serves as a hash function for a particular type.
     *
     * @return  {number}      A hash code for the current System.Object.
     */
    GetHashCode(): number { throw new Error("ExtendedPropertyDefinition.ts - GetHashCode : Not implemented."); }

    /**
     * @internal Gets the property definition's printable name.
     *
     * @return  {string}      The property definition's printable name.
     */
    GetPrintableName(): string {
        var sb = "";
        sb += "{";
        sb += this.FormatField(ExtendedPropertyDefinition.NameFieldName, this.Name);
        sb += this.FormatField(ExtendedPropertyDefinition.MapiTypeFieldName, MapiPropertyType[this.MapiType]);
        sb += this.FormatField(ExtendedPropertyDefinition.IdFieldName, this.Id.toString());
        sb += this.FormatField(ExtendedPropertyDefinition.PropertySetFieldName, DefaultExtendedPropertySet[this.PropertySet]);
        sb += this.FormatField(ExtendedPropertyDefinition.PropertySetIdFieldName, this.PropertySetId != null ? this.PropertySetId.ToString() : "");
        sb += this.FormatField(ExtendedPropertyDefinition.TagFieldName, this.Tag.toString());
        sb += "}";
        return sb;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string { return XmlElementNames.ExtendedFieldURI; }

    /**
     * @internal Determines whether two specified instances of ExtendedPropertyDefinition are equal.
     *
     * @param   {ExtendedPropertyDefinition}    extPropDef1   First extended property definition.
     * @param   {ExtendedPropertyDefinition}    extPropDef2   Second extended property definition.
     * @return  {boolean}                       True if extended property definitions are equal.
     */
    static IsEqualTo(extPropDef1: ExtendedPropertyDefinition, extPropDef2: ExtendedPropertyDefinition): boolean {
        return (extPropDef1 === extPropDef2) ||
            (extPropDef1 && extPropDef2 &&
                (extPropDef1.Id === extPropDef2.Id) &&
                (extPropDef1.MapiType === extPropDef2.MapiType) &&
                (extPropDef1.Tag === extPropDef2.Tag) &&
                (extPropDef1.Name === extPropDef2.Name) &&
                (extPropDef1.PropertySet === extPropDef2.PropertySet) &&
                (String(extPropDef1.propertySetId) === String(extPropDef2.propertySetId)));
    }

    /**
     * @internal Loads from XMLJsObject.
     *
     * @param   {any}   jsObject   The json object.
     */
    LoadPropertyValueFromXmlJsObject(jsObject: any): void {

        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.DistinguishedPropertySetId:
                    //debugger;
                    this.propertySet = isNaN(jsObject[key]) ? DefaultExtendedPropertySet[jsObject[key]] : <any><DefaultExtendedPropertySet>+(jsObject[key]);// jsObject.ReadEnumValue<DefaultExtendedPropertySet>(key);
                    break;
                case XmlAttributeNames.PropertySetId:
                    //debugger;
                    this.propertySetId = new Guid(jsObject[key]);// new Guid(jsObject.ReadAsString(key));
                    break;
                case XmlAttributeNames.PropertyTag:
                    this.tag = Convert.toNumber(jsObject[key]);//Convert.ToUInt16(jsObject.ReadAsString(key), 16);
                    break;
                case XmlAttributeNames.PropertyName:
                    this.name = jsObject[key];//jsObject.ReadAsString(key);
                    break;
                case XmlAttributeNames.PropertyId:
                    this.id = Convert.toInt(jsObject[key]);//jsObject.ReadAsInt(key);
                    break;
                case XmlAttributeNames.PropertyType:
                    this.mapiType = isNaN(jsObject[key]) ? MapiPropertyType[jsObject[key]] : <any><MapiPropertyType>+(jsObject[key]);// jsObject.ReadEnumValue<MapiPropertyType>(key);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        if (!isNullOrUndefined(this.propertySet)) {
            writer.WriteAttributeValue(XmlAttributeNames.DistinguishedPropertySetId, DefaultExtendedPropertySet[this.propertySet]);
        }
        if (this.propertySetId) {
            writer.WriteAttributeValue(XmlAttributeNames.PropertySetId, this.propertySetId.ToString());
        }
        if (this.tag) {
            writer.WriteAttributeValue(XmlAttributeNames.PropertyTag, this.tag);
        }
        if (!StringHelper.IsNullOrEmpty(this.name)) {
            writer.WriteAttributeValue(XmlAttributeNames.PropertyName, this.name);
        }
        if (this.id) {
            writer.WriteAttributeValue(XmlAttributeNames.PropertyId, this.id);
        }

        writer.WriteAttributeValue(XmlAttributeNames.PropertyType, MapiPropertyType[this.mapiType]);
    }
}

/**
 * ExtendedPropertyDefinition interface to be used with TypeContainer - removes circular dependency
 */
export interface IExtendedPropertyDefinition {
    new(): ExtendedPropertyDefinition;
    new(mapiType: MapiPropertyType): ExtendedPropertyDefinition;
    new(tag: number, mapiType: MapiPropertyType): ExtendedPropertyDefinition;
    new(propertySet: DefaultExtendedPropertySet, name: string, mapiType: MapiPropertyType): ExtendedPropertyDefinition;
    new(propertySet: DefaultExtendedPropertySet, id: number, mapiType: MapiPropertyType): ExtendedPropertyDefinition;
    new(propertySetId: Guid, name: string, mapiType: MapiPropertyType): ExtendedPropertyDefinition;
    new(propertySetId: Guid, id: number, mapiType: MapiPropertyType): ExtendedPropertyDefinition;
}


/**
 * Represents a property definition for a service object.
 */
export abstract class ServiceObjectPropertyDefinition extends PropertyDefinitionBase {

    private uri: string = null;

    /**
     * Gets the minimum Exchange version that supports this property.
     *
     * @value {ExchangeVersion} The version.
     */
    get Version(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Gets the URI of the property definition.
     */
    get Uri(): string { return this.uri; }

    /**
     * @internal Initializes a new instance of the **ServiceObjectPropertyDefinition** class.
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **ServiceObjectPropertyDefinition** class.
     *
     * @param   {string}   uri   The URI.
     */
    constructor(uri: string);
    constructor(uri: string = null) {
        super();
        if (arguments.length == 1) {
            EwsLogging.Assert(
                !StringHelper.IsNullOrEmpty(uri),
                "ServiceObjectPropertyDefinition.ctor",
                "uri is null or empty");

            this.uri = uri;
        }
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string { return XmlElementNames.FieldURI; }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.FieldURI, this.Uri);
    }
}



/**
 * @internal Represents the definition of the GroupMember property.
 */
export class GroupMemberPropertyDefinition extends ServiceObjectPropertyDefinition {

    /**
     * FieldUri of IndexedFieldURI for a group member.
     */
    private static FieldUri: string = "distributionlist:Members:Member";

    /**
     * Member key. Maps to the Index attribute of IndexedFieldURI element.
     */
    private key: string = null;

    /**
     * Gets or sets the member's key. 
     */
    get Key(): string {
        return this.key;
    }
    set Key(value: string) {
        this.key = value;
    }

    /**
     * Gets the property type.
     */
    get Type(): any {
        return "String";
    }

    /**
     * Initializes a new instance of the **GroupMemberPropertyDefinition** class without key.
     */
    constructor();
    /**
     * Initializes a new instance of the **GroupMemberPropertyDefinition** class.
     *
     * @param   {string}   key   The member's key.
     */
    constructor(key: string);
    constructor(key?: string) {
        super(GroupMemberPropertyDefinition.FieldUri);
        if (arguments.length === 1) {
            this.key = key;
        }
    }

    /**
     * @internal Gets the property definition's printable name.
     *
     * @return  {string}      The property definition's printable name.
     */
    GetPrintableName(): string { return StringHelper.Format("{0}:{1}", GroupMemberPropertyDefinition.FieldUri, this.Key); }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string { return XmlElementNames.IndexedFieldURI; }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);
        writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, this.Key);
    }
}


/**
 * Represents an indexed property definition.
 */
export class IndexedPropertyDefinition extends ServiceObjectPropertyDefinition {

    /**
     * Index attribute of IndexedFieldURI element.
     */
    private index: string;

    /**
     * Gets the index of the property.
     */
    get Index(): string { return this.index; }

    get Type(): string { return 'string'; /*return typeof string;*/ } //System.Type;

    /**
     * @internal Initializes a new instance of the **IndexedPropertyDefinition** class.
     *
     * @param   {string}   uri     The FieldURI attribute of the IndexedFieldURI element.
     * @param   {string}   index   The Index attribute of the IndexedFieldURI element.
     */
    constructor(uri: string, index: string) {
        super(uri);
        this.index = index;
    }

    /**
     * Determines whether a given indexed property definition is equal to this indexed property definition.
     *
     * @param   {any}   obj   The object to check for equality.
     * @return  {boolean}         True if the properties definitions define the same indexed property.
     */
    Equals(obj: any): boolean {
        var propertyDefinition = <IndexedPropertyDefinition>obj;
        return IndexedPropertyDefinition.IsEqualTo(propertyDefinition, this);
    }

    /**
     * Serves as a hash function for a particular type.
     *
     * @return  {number}      A hash code for the current System.Object.
     */
    GetHashCode(): number { throw new Error("IndexedPropertyDefinition.ts - GetHashCode : Not implemented."); }

    /**
     * @internal Gets the property definition's printable name.
     *
     * @return  {string}      The property definition's printable name.
     */
    GetPrintableName(): string { return StringHelper.Format("{0}:{1}", this.Uri, this.Index); }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string { return XmlElementNames.IndexedFieldURI; }

    /**
     * @internal Determines whether two specified instances of IndexedPropertyDefinition are equal.
     *
     * @param   {IndexedPropertyDefinition}    extPropDef1   First extended property definition.
     * @param   {IndexedPropertyDefinition}    extPropDef2   Second extended property definition.
     * @return  {boolean}                      True if extended property definitions are equal.
     */
    static IsEqualTo(idxPropDef1: IndexedPropertyDefinition, idxPropDef2: IndexedPropertyDefinition): boolean {
        return idxPropDef1 === idxPropDef2 ||
            (idxPropDef1.Uri == idxPropDef2.Uri &&
                idxPropDef1.Index == idxPropDef2.Index);
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);
        writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, this.Index);
    }
}

/**
 * IndexedPropertyDefinition interface to be used with TypeContainer - removes circular dependency
 */
export interface IIndexedPropertyDefinition {
    new (uri: string, index: string): IndexedPropertyDefinition;
}

/**
 * Represents the definition of a folder or item property.
 */
export abstract class PropertyDefinition extends ServiceObjectPropertyDefinition {

    private xmlElementName: string;
    private flags: PropertyDefinitionFlags;
    private name: string;
    private version: ExchangeVersion;

    /**
     * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
     */
    get IsNullable(): boolean { return true; }

    /**
     * Gets the name of the property.
     */
    get Name(): string {
        if (StringHelper.IsNullOrEmpty(this.name)) {
            throw new Error("PropertyDefinition.Name - incorrectly registered propertynames - info: fixed by initializing names in respective serviceobjectschema static properties. fix if receive this error");
            //todo:fix: can not use this to initialize names, ServiceObjectSchema creates circular loops in modules.
            //ServiceObjectSchema.InitializeSchemaPropertyNames(); //info: fixed by initializing names in respective serviceobjectschema static properties. fix if receive this error
            //fix - did not work , shifted to statically initialize by constructer in this class ServiceObjectSchemaExtension.InitializeSchemaPropertyNames(); //info: fixed by initializing names in respective serviceobjectschema static properties. fix if receive this error
        }
        return this.name;
    }
    set Name(value: string) { this.name = value; }

    /**
     * Gets the minimum Exchange version that supports this property.
     *
     * @value {ExchangeVersion} The version.
     */
    get Version(): ExchangeVersion { return this.version; }

    /**
     * @internal Gets the name of the XML element.
     * 
     * @value {string}  The name of the XML element.
     */
    get XmlElementName(): string { return this.xmlElementName; }

    /**
     * @internal Initializes a new instance of the **PropertyDefinition** class.
     *
     * @param   {string}            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}            xmlElementName   Name of the XML element.
     * @param   {string}            uri              The URI.
     * @param   {ExchangeVersion}   version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **PropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, flags: PropertyDefinitionFlags, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **PropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion);
    constructor(propertyName: string, xmlElementName: string, uriOrFlags: string | PropertyDefinitionFlags, versionOrFlags: PropertyDefinitionFlags | ExchangeVersion, version?: ExchangeVersion) {
        typeof uriOrFlags === 'string' ? super(uriOrFlags) : super();

        this.name = propertyName;
        this.xmlElementName = xmlElementName;
        this.flags = typeof uriOrFlags === 'string' ? PropertyDefinitionFlags.None : uriOrFlags;

        switch (arguments.length) {
            case 4:
                this.version = <ExchangeVersion>versionOrFlags;
                break;
            case 5:
                this.version = version;
                this.flags = <PropertyDefinitionFlags>versionOrFlags;
                break;
            default:
                break;
        }
    }

    /**
     * @internal Gets a list of associated internal properties.
     *
     * /remarks/    This is a hack. It is here (currently) solely to help the API register the MeetingTimeZone property definition that is internal.
     * @return  {PropertyDefinition[]}      A list of PropertyDefinition objects.
     */
    GetAssociatedInternalProperties(): PropertyDefinition[] /*System.Collections.Generic.List<PropertyDefinition>*/ {
        var properties: PropertyDefinition[] = [];

        this.RegisterAssociatedInternalProperties(properties);

        return properties;
    }

    /**
     * @internal Gets the property definition's printable name.
     *
     * @return  {string}      The property definition's printable name.
     */
    GetPrintableName(): string { return this.Name; }

    /**
     * @internal Determines whether the specified flag is set.
     *
     * @param   {PropertyDefinitionFlags}   flag   The flag.
     * @return  {boolean}   true if the specified flag is set; otherwise, false.
     */
    HasFlag(flag: PropertyDefinitionFlags): boolean;
    /**
     * @internal Determines whether the specified flag is set.
     *
     * @param   {PropertyDefinitionFlags}   flag      The flag.
     * @param   {ExchangeVersion}           version   Requested version.
     * @return  {boolean}                   true if the specified flag is set; otherwise, false.
     */
    HasFlag(flag: PropertyDefinitionFlags, version: ExchangeVersion): boolean;
    HasFlag(flag: PropertyDefinitionFlags, version?: ExchangeVersion): boolean {
        return (this.flags & flag) == flag;
    }

    /**
     * @internal Loads the property value from json.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    abstract LoadPropertyValueFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void;

    /**
     * @internal Registers associated internal properties.
     *
     * @param   {PropertyDefinition[]}   properties   The list in which to add the associated properties.
     */
    RegisterAssociatedInternalProperties(properties: PropertyDefinition[]): void {
    }

    /**
     * @internal Writes the property value to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    abstract WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void;
}

/**
 * @internal Represents effective rights property definition.
 */
export class EffectiveRightsPropertyDefinition extends PropertyDefinition {

    /**
     * Gets the property type.
     */
    Type: any;//System.Type;

    /**
     * @internal Initializes a new instance of the **EffectiveRightsPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version);
    }


    /**
     * @internal Loads the property value from XMLJsObject.
     *
     * @param   {any}               value         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    LoadPropertyValueFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {
        var effectiveRightsValue: EffectiveRights = EffectiveRights.None;
        if (jsObject != null) {
            for (var key in jsObject) {
                switch (key) {
                    case XmlElementNames.CreateAssociated:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.CreateAssociated;
                        }
                        break;
                    case XmlElementNames.CreateContents:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.CreateContents;
                        }
                        break;
                    case XmlElementNames.CreateHierarchy:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.CreateHierarchy;
                        }
                        break;
                    case XmlElementNames.Delete:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.Delete;
                        }
                        break;
                    case XmlElementNames.Modify:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.Modify;
                        }
                        break;
                    case XmlElementNames.Read:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.Read;
                        }
                        break;
                    case XmlElementNames.ViewPrivateItems:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.ViewPrivateItems;
                        }
                        break;
                }
            }
        }
        propertyBag._setItem(this, effectiveRightsValue);
    }

    /**
     * @internal Writes the property value to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void {
        // EffectiveRights is a read-only property, no need to implement this.
    }
}

/**
 * @internal Represents the definition for the meeting time zone property.
 */
export class MeetingTimeZonePropertyDefinition extends PropertyDefinition {

    /**
     * Gets the property type.
     */
    Type: any;//System.Type;

    /**
     * @internal Initializes a new instance of the **MeetingTimeZonePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version);
    }

    /**
     * @internal Loads the property value from json.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    LoadPropertyValueFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {
        EwsLogging.Assert(false, "MeetingTimeZonePropertyDefinition.LoadPropertyValueFromXmlJsObject", "This is not properly validate, need to validate with example");
        if (jsObject != null) {
            var meetingTimeZone: MeetingTimeZone = new MeetingTimeZone();
            meetingTimeZone.LoadFromXmlJsObject(jsObject, service);

            propertyBag._setItem(Schemas.AppointmentSchema.StartTimeZone, meetingTimeZone.ToTimeZoneInfo());
        }
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void {
        var value: MeetingTimeZone = <MeetingTimeZone>propertyBag._getItem(this);

        if (value) {
            value.WriteToXml(writer, this.XmlElementName);
        }
    }
}

/**
 * @internal Represenrs recurrence property definition.
 */
export class RecurrencePropertyDefinition extends PropertyDefinition {

    /**
     * not in ews-managed-api - use to find which recurrence is being used. 
     */
    private static recurrences: string[] = [XmlElementNames.AbsoluteMonthlyRecurrence, XmlElementNames.AbsoluteYearlyRecurrence, XmlElementNames.DailyRecurrence, XmlElementNames.DailyRegeneration, XmlElementNames.MonthlyRegeneration, XmlElementNames.RelativeMonthlyRecurrence, XmlElementNames.RelativeYearlyRecurrence, XmlElementNames.WeeklyRecurrence, XmlElementNames.WeeklyRegeneration, XmlElementNames.YearlyRegeneration];

    /**
     * not in ews-managed-api - use to find which recurrence range is being used. 
     */
    private static recurrenceRanges: string[] = [XmlElementNames.NoEndRecurrence, XmlElementNames.EndDateRecurrence, XmlElementNames.NumberedRecurrence];

    /**
     * Gets the property type.
     */
    Type: any;//System.Type;

    /**
     * @internal Initializes a new instance of the **RecurrencePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version);
    }

    /**
     * Gets the recurrence from string.
     *
     * @param   {string}   recurranceString   The recurrance string.
     * @return  {Recurrence}    Recurrence
     */
    private static GetRecurrenceFromString(recurranceString: string): Recurrence {
        let recurrence: Recurrence;

        switch (recurranceString) {
            case XmlElementNames.RelativeYearlyRecurrence:
                recurrence = new Recurrence.RelativeYearlyPattern();
                break;
            case XmlElementNames.AbsoluteYearlyRecurrence:
                recurrence = new Recurrence.YearlyPattern();
                break;
            case XmlElementNames.RelativeMonthlyRecurrence:
                recurrence = new Recurrence.RelativeMonthlyPattern();
                break;
            case XmlElementNames.AbsoluteMonthlyRecurrence:
                recurrence = new Recurrence.MonthlyPattern();
                break;
            case XmlElementNames.DailyRecurrence:
                recurrence = new Recurrence.DailyPattern();
                break;
            case XmlElementNames.DailyRegeneration:
                recurrence = new Recurrence.DailyRegenerationPattern();
                break;
            case XmlElementNames.WeeklyRecurrence:
                recurrence = new Recurrence.WeeklyPattern();
                break;
            case XmlElementNames.WeeklyRegeneration:
                recurrence = new Recurrence.WeeklyRegenerationPattern();
                break;
            case XmlElementNames.MonthlyRegeneration:
                recurrence = new Recurrence.MonthlyRegenerationPattern();
                break;
            case XmlElementNames.YearlyRegeneration:
                recurrence = new Recurrence.YearlyRegenerationPattern();
                break;
            default:
                //info: //ref: cannot throw, need to keep null/undefined to successfully parse XMLJsObject
                //throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.InvalidRecurrencePattern, recurranceString));
                break;
        }
        return recurrence;
    }

    /**
     * Gets the recurrence range.
     *
     * @param   {string}            recurrenceRangeString   The recurrence range string.
     * @return  {RecurrenceRange}   RecurrenceRange
     */
    private static GetRecurrenceRange(recurrenceRangeString: string): RecurrenceRange {
        let range: RecurrenceRange;

        switch (recurrenceRangeString) {
            case XmlElementNames.NoEndRecurrence:
                range = new NoEndRecurrenceRange();
                break;
            case XmlElementNames.EndDateRecurrence:
                range = new EndDateRecurrenceRange();
                break;
            case XmlElementNames.NumberedRecurrence:
                range = new NumberedRecurrenceRange();
                break;
            default:
                //info: //ref: cannot throw, need to keep null/undefined to successfully parse XMLJsObject
                //throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.InvalidRecurrenceRange, recurrenceRangeString)); 
                break;
        }
        return range;
    }

    /**
     * @internal Loads the property value from json.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    LoadPropertyValueFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {
        let recurrence: Recurrence;
        let range: RecurrenceRange;
        let props = "";

        for (let key in jsObject) {
            if (key.indexOf("__") === 0) //skip xmljsobject conversion entries like __type and __prefix
                continue;
            if (RecurrencePropertyDefinition.recurrences.indexOf(key) >= 0) {
                recurrence = RecurrencePropertyDefinition.GetRecurrenceFromString(key);
                recurrence.LoadFromXmlJsObject(jsObject[key], service);
            }
            if (RecurrencePropertyDefinition.recurrenceRanges.indexOf(key) >= 0) {
                range = RecurrencePropertyDefinition.GetRecurrenceRange(key);
                range.LoadFromXmlJsObject(jsObject[key], service);
            }
            props += key + ",";

        }
        if (props.length > 1 && props.lastIndexOf(",") === props.length - 1) {
            props = props.substr(0, props.length - 1);
        }

        if (!recurrence) {
            throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.InvalidRecurrencePattern, props));
        }
        if (!range) {
            throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.InvalidRecurrenceRange, props));
        }

        range.SetupRecurrence(recurrence);
        propertyBag._setItem(this, recurrence);

    }

    /**
     * @internal Writes the property value to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void {
        let value: Recurrence = <Recurrence>propertyBag._getItem(this);
        if (value) {
            value.WriteToXml(writer, XmlElementNames.Recurrence);
        }
    }
}
export class ResponseObjectsPropertyDefinition extends PropertyDefinition {

    /**
     * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
     */
    get IsNullable(): boolean { return false; }

    /**
     * Gets the property type.
     */
    Type: any;//System.Type;

    /**
     * Gets the response action.
     *
     * @param   {string}   responseActionString   The response action string.
     * @return  {ResponseActions}       ResponseActions
     */
    private static GetResponseAction(responseActionString: string): ResponseActions {
        var value: ResponseActions = ResponseActions.None;

        switch (responseActionString) {
            case XmlElementNames.AcceptItem:
                value = ResponseActions.Accept;
                break;
            case XmlElementNames.TentativelyAcceptItem:
                value = ResponseActions.TentativelyAccept;
                break;
            case XmlElementNames.DeclineItem:
                value = ResponseActions.Decline;
                break;
            case XmlElementNames.ReplyToItem:
                value = ResponseActions.Reply;
                break;
            case XmlElementNames.ForwardItem:
                value = ResponseActions.Forward;
                break;
            case XmlElementNames.ReplyAllToItem:
                value = ResponseActions.ReplyAll;
                break;
            case XmlElementNames.CancelCalendarItem:
                value = ResponseActions.Cancel;
                break;
            case XmlElementNames.RemoveItem:
                value = ResponseActions.RemoveFromCalendar;
                break;
            case XmlElementNames.SuppressReadReceipt:
                value = ResponseActions.SuppressReadReceipt;
                break;
            case XmlElementNames.PostReplyItem:
                value = ResponseActions.PostReply;
                break;
        }
        return value;
    }

    /**
     * @internal Loads the property value from json.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    LoadPropertyValueFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {
        let responseActionValue: ResponseActions = ResponseActions.None;
        for (let key in jsObject) {
            if (key.indexOf("__") === 0) //skip xmljsobject conversion entries like __type and __prefix
                continue;

            if (jsObject.hasOwnProperty(key)) {
                responseActionValue |= ResponseObjectsPropertyDefinition.GetResponseAction(key);
            }
        }
        propertyBag._setItem(this, responseActionValue);
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void { /* ResponseObjects is a read-only property, no need to implement this.*/ }
}

/**
 * @internal Represents DateTime property definition.
 */
export class DateTimePropertyDefinition extends PropertyDefinition {

    private isNullable: boolean;
    /**
     * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
     */
    get IsNullable(): boolean { return this.isNullable; }

    /**
     * Gets the property type.
     */
    Type: any;//System.Type;

    /**
     * @internal Initializes a new instance of the **DateTimePropertyDefinition** class.
     *
     * @param   {string}            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}            xmlElementName   Name of the XML element.
     * @param   {string}            uri              The URI.
     * @param   {ExchangeVersion}   version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **DateTimePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **DateTimePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     * @param   {boolean}                   isNullable       Indicates that this property definition is for a nullable property.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion, isNullable: boolean);
    constructor(propertyName: string, xmlElementName: string, uri: string, versionOrFlags: ExchangeVersion | PropertyDefinitionFlags, version?: ExchangeVersion, isNullable?: boolean) {
        switch (arguments.length) {
            case 4:
                super(propertyName, xmlElementName, uri, <ExchangeVersion>versionOrFlags);
                break;
            case 5:
            case 6:
                super(propertyName, xmlElementName, uri, <PropertyDefinitionFlags>versionOrFlags, version);
                break;
            default:
                break;
        }
        this.isNullable = isNullable || false;
    }

    /**
     * Gets the converted date time.
     *
     * @param   {ExchangeServiceBase}   service             The service.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   if set to true [is update operation].
     * @param   {any}                   value               The value.
     * @return  {DateTime}      Converted DateTime value
     */
    private GetConvertedDateTime(service: ExchangeServiceBase, propertyBag: PropertyBag, isUpdateOperation: boolean, value: any): DateTime {
        EwsLogging.Assert(false, "DateTimePropertyDefinition.GetConvertedDateTime", "TimeZone info could be misleading, It should be used as UTC in all cases until fixed");

        var dateTime = DateTime.Parse(value);
        var convertedDateTime: DateTime;
        //debug: //todo: find datetimekind
        // If the date/time is unspecified, we may need to scope it to time zone.
        if (dateTime.Kind == DateTimeKind.Unspecified) {
            convertedDateTime = this.ScopeToTimeZone(
                service,
                value,
                propertyBag,
                isUpdateOperation);
        }
        else {
            convertedDateTime = dateTime;
        }
        return convertedDateTime;
    }

    /**
     * @internal Loads the property value from XMLJsObject.
     *
     * @param   {any}               value         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    LoadPropertyValueFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {
        var stringValue: string = jsObject;//.toString();
        //debug: //ref: check for datetime value
        if (!StringHelper.IsNullOrEmpty(stringValue)) {
            var value = service.ConvertUniversalDateTimeStringToLocalDateTime(stringValue);
            propertyBag._setItem(this, service.ConvertUniversalDateTimeStringToLocalDateTime(stringValue));
        }
    }

    /**
     * @internal Scopes the date time property to the appropriate time zone, if necessary.
     *
     * @param   {ExchangeServiceBase}   service             The service emitting the request.
     * @param   {DateTime}              dateTime            The date time.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the scoping is to be performed in the context of an update operation.
     * @return  {DateTime}              The converted DateTime.
     */
    ScopeToTimeZone(service: ExchangeServiceBase, dateTime: DateTime, propertyBag: PropertyBag, isUpdateOperation: boolean): DateTime {
        EwsLogging.Assert(false, "DateTimePropertyDefinition.ScopeToTimeZone", "TimeZone info could be misleading, It should be used as UTC in all cases until fixed");
        try {
            var convertedDateTime: DateTime = EwsUtilities.ConvertTime(
                dateTime,
                service.TimeZone,
                TimeZoneInfo.Utc);

            return new DateTime(convertedDateTime.TotalMilliSeconds, DateTimeKind.Utc);
        }
        catch (e)//TimeZoneConversionException
        {
            throw new PropertyException(
                StringHelper.Format(Strings.InvalidDateTime, dateTime),
                this.Name,
                e);
        }
    }

    /**
     * @internal Writes the property value to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void {
        var value = propertyBag._getItem(this);
        if (value != null) {
            writer.WriteStartElement(XmlNamespace.Types, this.XmlElementName);

            var convertedDateTime: DateTime = this.GetConvertedDateTime(writer.Service, propertyBag, isUpdateOperation, value);

            writer.WriteValue(EwsUtilities.DateTimeToXSDateTime(convertedDateTime), this.Name);

            writer.WriteEndElement();
        }
    }
}


/**
 * @internal Represents a property definition for DateTime values scoped to a specific time zone property.
 */
export class ScopedDateTimePropertyDefinition extends DateTimePropertyDefinition {

    private getPropertyDefinitionCallback: GetPropertyDefinitionCallback;

    /**
     * @internal Initializes a new instance of the **ScopedDateTimePropertyDefinition** class.
     *
     * @param   {string}                            propertyName                    Name of the property.
     * @param   {string}                            xmlElementName                  Name of the XML element.
     * @param   {ExchangeVersion}                   version                         The version.
     * @param   {string}                            uri                             The URI.
     * @param   {PropertyDefinitionFlags}           flags                           The flags.
     * @param   {GetPropertyDefinitionCallback}     getPropertyDefinitionCallback   The callback that will be used to retrieve the time zone property.
     */
    constructor(
        propertyName: string,
        xmlElementName: string,
        uri: string,
        flags: PropertyDefinitionFlags,
        version: ExchangeVersion,
        getPropertyDefinitionCallback: GetPropertyDefinitionCallback) {
        super(propertyName, xmlElementName, uri, flags, version);
        EwsLogging.Assert(
            getPropertyDefinitionCallback != null,
            "ScopedDateTimePropertyDefinition.ctor",
            "getPropertyDefinitionCallback is null.");
        this.getPropertyDefinitionCallback = getPropertyDefinitionCallback;

    }

    /**
     * Gets the time zone property to which to scope times.
     *
     * @param   {ExchangeVersion}   version   The EWS version for which the property is to be retrieved.
     * @return  {PropertyDefinition}             The PropertyDefinition of the scoping time zone property.
     */
    private GetTimeZoneProperty(version: ExchangeVersion): PropertyDefinition {
        var timeZoneProperty: PropertyDefinition = this.getPropertyDefinitionCallback(version);

        EwsLogging.Assert(
            timeZoneProperty != null,
            "ScopedDateTimePropertyDefinition.GetTimeZoneProperty",
            "timeZoneProperty is null.");

        return timeZoneProperty;
    }

    /**
     * @internal Scopes the date time property to the appropriate time zone, if necessary.
     *
     * @param   {ExchangeServiceBase}   service             The service emitting the request.
     * @param   {DateTime}              dateTime            The date time.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the scoping is to be performed in the context of an update operation.
     * @return  {DateTime}              The converted DateTime.
     */
    ScopeToTimeZone(service: ExchangeServiceBase, dateTime: DateTime, propertyBag: PropertyBag, isUpdateOperation: boolean): DateTime {
        EwsLogging.DebugLog("[ScopedDateTimePropertyDefinition.ScopeToTimeZone]: TimeZone info has been updated, Please report any bugs to github");
        if (!propertyBag.Owner.GetIsCustomDateTimeScopingRequired()) {
            // Most item types do not require a custom scoping mechanism. For those item types,
            // use the default scoping mechanism.
            return super.ScopeToTimeZone(
                service,
                dateTime,
                propertyBag,
                isUpdateOperation);
        }
        else {
            // Appointment, however, requires a custom scoping mechanism which is based on an
            // associated time zone property.
            var timeZoneProperty: PropertyDefinition = this.GetTimeZoneProperty(service.RequestedServerVersion);
            var timeZonePropertyValue: IOutParam<any> = { outValue: null };

            var timeZonePropertyIsSet: boolean = propertyBag.TryGetProperty(timeZoneProperty, timeZonePropertyValue);

            if (timeZonePropertyValue.outValue != null && propertyBag.IsPropertyUpdated(timeZoneProperty)) {
                // If we have the associated time zone property handy and if it has been updated locally,
                // then we scope the date time to that time zone.
                try {
                    var convertedDateTime: DateTime = EwsUtilities.ConvertTime(
                        dateTime,
                        <TimeZoneInfo>timeZonePropertyValue.outValue,
                        TimeZoneInfo.Utc);

                    // This is necessary to stamp the date/time with the Local kind.
                    return new DateTime(convertedDateTime.TotalMilliSeconds, DateTimeKind.Utc);
                }
                catch (e) {
                    throw new PropertyException(
                        StringHelper.Format(Strings.InvalidDateTime, dateTime),
                        this.Name,
                        <TimeZoneConversionException>e);
                }
            }
            else {
                if (isUpdateOperation) {
                    // In an update operation, what we do depends on what version of EWS
                    // we are targeting.
                    if (service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
                        // For Exchange 2007 SP1, we still need to scope to the service's time zone.
                        return super.ScopeToTimeZone(
                            service,
                            dateTime,
                            propertyBag,
                            isUpdateOperation);
                    }
                    else {
                        // Otherwise, we let the server scope to the appropriate time zone.
                        return dateTime;
                    }
                }
                else {
                    // In a Create operation, always scope to the service's time zone.
                    return super.ScopeToTimeZone(
                        service,
                        dateTime,
                        propertyBag,
                        isUpdateOperation);
                }
            }
        }
    }
}

/**
 * @internal Defines a callback method used to get a reference to a property definition.
 *
 * @param   {ExchangeVersion}   version   The EWS version for which the property is to be retrieved.
 */
export interface GetPropertyDefinitionCallback {
    (version: ExchangeVersion): PropertyDefinition
}

/**
 * @internal Represents typed property definition.
 */
export abstract class TypedPropertyDefinition extends PropertyDefinition {

    private isNullable: boolean;

    /**
     * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
     *
     */
    get IsNullable(): boolean { return this.isNullable; };

    /**
     * @internal Initializes a new instance of the **TypedPropertyDefinition** class.
     *
     * @param   {string}            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}            xmlElementName   Name of the XML element.
     * @param   {string}            uri              The URI.
     * @param   {ExchangeVersion}   version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **TypedPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **TypedPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     * @param   {boolean}                   isNullable       Indicates that this property definition is for a nullable property.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion, isNullable: boolean);
    constructor(propertyName: string, xmlElementName: string, uri: string, versionOrFlags: ExchangeVersion | PropertyDefinitionFlags, version?: ExchangeVersion, isNullable?: boolean) {
        switch (arguments.length) {
            case 4:
                super(propertyName, xmlElementName, uri, <ExchangeVersion>versionOrFlags);
                break;
            case 5:
            case 6:
                super(propertyName, xmlElementName, uri, <PropertyDefinitionFlags>versionOrFlags, version);
                break;
            default:
                break;
        }
        this.isNullable = isNullable || false;
    }

    /**
     * @internal Loads the property value from XMLJsObject.
     *
     * @param   {any}               value         The JsObject value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    LoadPropertyValueFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {

        if (jsObject) {
            propertyBag._setItem(this, this.Parse(jsObject));
        }

        // if (typeof jsObject === 'string' || jsObject instanceof String) {
        //     propertyBag._setItem(this, this.Parse(jsObject));
        // }
        // else if (jsObject != null) { //undefined == null returns true, false for === comparison.
        //     propertyBag._setItem(this, this.Parse(jsObject));
        // }
    }

    /**
     * @internal Parses the specified value.
     *
     * @param   {string}   value   The value.
     * @return  {any}       Typed value.
     */
    abstract Parse(value: string): any;

    /**
     * @internal Convert instance to string.
     *
     * @param   {any}   value   The value.
     * @return  {string}        String representation of property value.
     */
    ToString(value?: any): string {
        if (value !== null && typeof value !== 'undefined')
            return value.toString();
        throw new Error("TypedPropertydefinition: incorrect call of ToString(value): value is undefined");
    }
    toString(value?: any) {
        if (arguments.length > 0) {
            return this.ToString(value);
        }
        else {
            return this.ToString();
        }
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void {
        var value = propertyBag._getItem(this);
        if (typeof value !== 'undefined') {
            writer.WriteElementValue(XmlNamespace.Types, this.XmlElementName, this.Name, this.ToString(value));
        }
    }
}

/**
 * @internal Represents byte array property definition.
 */
export class ByteArrayPropertyDefinition extends TypedPropertyDefinition {

    /**
     * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
     */
    get IsNullable(): boolean { return true; }

    /**
     * @internal Gets the property type.
     */
    get Type(): any { return ByteArrayPropertyDefinition; }//System.Type;

    /**
     * @internal Initializes a new instance of the **ByteArrayPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version);
    }

    /**
     * @internal Parses the specified value.
     *
     * @param   {string}   value   The value.
     * @return  {any}           Byte array value.
     */
    Parse(value: string): any {
        //ref: storing original base64 data base64Helper.atob(value); }
        EwsLogging.Assert(false, "ByteArrayPropertyDefinition.Parse", "ByteArrayPropertyDefinition needs to be improved");
        return value;
    }

    /**
     * @internal Converts byte array property to a string.
     *
     * @param   {any}       value   The value.
     * @return  {string}    Byte array value.
     */
    ToString(value?: any): string {
        EwsLogging.Assert(false, "ByteArrayPropertyDefinition.Parse", "ByteArrayPropertyDefinition needs to be improved");
        if (value)
            return value;//ref: using original value. base64Helper.btoa(value);

        throw new Error("ByteArrayPropertyDefinition: incorrect call of ToString(value): value is undefined");
    }
}

/**
 * @internal Represents String property definition.
 */
export class StringPropertyDefinition extends TypedPropertyDefinition {
    
    /**
     * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...). 
     */
    get IsNullable(): boolean { return true; }

    /**
     * @internal Gets the property type.
     */
    get Type(): any { return StringPropertyDefinition; }//System.Type;

    /**
     * @internal Initializes a new instance of the **StringPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version);
    }

    /**
     * @internal Parses the specified value.
     *
     * @param   {string}   value   The value.
     * @return  {any}           String value.
     */
    Parse(value: string): any { return value; }
}



/**@internal  */
export type GenericEnumType = typeof AppointmentType | typeof ContactSource | typeof ConversationFlagStatus | typeof FileAsMapping | typeof IconIndex | typeof Importance | typeof LegacyFreeBusyStatus | typeof MeetingRequestType | typeof MeetingResponseType | typeof PhysicalAddressIndex | typeof Sensitivity | typeof TaskMode | typeof TaskStatus | typeof WellKnownFolderName;

/**
 * @internal Represents generic property definition.
 */
export class GenericPropertyDefinition<TPropertyValue> extends TypedPropertyDefinition {

    Type: any;//System.Type;
    /** ews-javascript-api specific - need to capture Enum type based on constructor */
    enumType: GenericEnumType;

    /**
     * @internal Initializes a new instance of the **GenericPropertyDefinition<TPropertyValue>** class.
     *
     * @param   {string}            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}            xmlElementName   Name of the XML element.
     * @param   {string}            uri              The URI.
     * @param   {ExchangeVersion}   version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **GenericPropertyDefinition<TPropertyValue>** class.
     * Added enumType parameter to 
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     * @param   {GenericEnumType}           enumType         Enum type parameter to Parse EwsEnum Attribute using EwsUtility.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion, enumType: GenericEnumType);
    /**
     * @internal Initializes a new instance of the **GenericPropertyDefinition<TPropertyValue>** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     * @param   {boolean}                   isNullable       Indicates that this property definition is for a nullable property.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion, isNullable: boolean);
    constructor(propertyName: string, xmlElementName: string, uri: string, versionOrFlags: ExchangeVersion | PropertyDefinitionFlags, version?: ExchangeVersion, isNullableOrEnumType: boolean | GenericEnumType = false) {
        switch (arguments.length) {
            case 4:
                super(propertyName, xmlElementName, uri, <ExchangeVersion>versionOrFlags);
                break;
            case 6:
                if (typeof isNullableOrEnumType === 'boolean') {
                    super(propertyName, xmlElementName, uri, <PropertyDefinitionFlags>versionOrFlags, version, isNullableOrEnumType);
                }
                else {
                    super(propertyName, xmlElementName, uri, <PropertyDefinitionFlags>versionOrFlags, version);
                    this.enumType = isNullableOrEnumType;
                }
                break;
            default:
                break;
        }
    }

    /**
     * @internal Parses the specified value.
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    Parse(value: string): any {
        //todo: fix converting generictype
        if (TypeGuards.hasEwsEnumAttribute(this.enumType)) {
            return this.enumType.FromEwsEnumString(value);
        }

        // if enum type is set, use this to get enum number instead of string
        if(this.enumType && typeof value === 'string') {
            return this.enumType[value];
        }

        EwsLogging.Assert(false, "GenericPropertyDefinition<TPropertyValue>.Parse", "GenericPropertyDefinition<TPropertyValue> needs to be improved");
        return value;
    }

    /**
     * @internal Convert instance to string.
     *
     * @param   {any}   value   The value.
     * @return  {string}        String representation of property value.
     */
    ToString(value?: any): string {
        if (value === void 0 || value === null) {
            throw new Error("GenericPropertyDefinition: incorrect call of ToString(value): value is undefined/null");
        }

        if (TypeGuards.hasEwsEnumAttribute(this.enumType)) {
            return this.enumType.ToEwsEnumString(value);
        }

        if(this.enumType && typeof value === "number") {
            return this.enumType[value];
        }

        return value.toString();
    }
    toString(value?: any): string {
        return this.ToString(value);
    }
}

/**
 * @internal Represents Boolean property definition
 */
export class BoolPropertyDefinition extends GenericPropertyDefinition<boolean> {

    /**
     * @internal Initializes a new instance of the **BoolPropertyDefinition** class.
     *
     * @param   {string}            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}            xmlElementName   Name of the XML element.
     * @param   {string}            uri              The URI.
     * @param   {ExchangeVersion}   version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **BoolPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **BoolPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     * @param   {boolean}                   isNullable       Indicates that this property definition is for a nullable property.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion, isNullable: boolean);
    constructor(propertyName: string, xmlElementName: string, uri: string, versionOrFlags: ExchangeVersion | PropertyDefinitionFlags, version?: ExchangeVersion, isNullable?: boolean) {
        switch (arguments.length) {
            case 4:
                super(propertyName, xmlElementName, uri, <ExchangeVersion>versionOrFlags);
                break;
            case 5:
                super(propertyName, xmlElementName, uri, <PropertyDefinitionFlags>versionOrFlags, version, false);
                break;
            case 6:
                super(propertyName, xmlElementName, uri, <PropertyDefinitionFlags>versionOrFlags, version, isNullable);
                break;
            default:
                break;
        }
    }

    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    Parse(value: string): any {
        return Convert.toBool(value);
    }

    /**
     * Convert instance to string.
     *
     * @param   {any}       value   The value.
     * @return  {string}    String representation of Boolean property.
     */
    ToString(value?: any): string {
        if (typeof value !== 'undefined')
            return EwsUtilities.BoolToXSBool(value);
        throw new Error("BoolPropertyDefinition: incorrect call of ToString(value): value is undefined");
    }
}

/**
 * @internal Represents double-precision floating point property definition.
 */
export class DoublePropertyDefinition extends GenericPropertyDefinition<number> {

    /**
     * @internal Initializes a new instance of the **DoublePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version, false);
    }

    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    Parse(value: string): any {
        return Convert.toNumber(value);
    }
}

/**
 * @internal Represents Integer property defintion.
 */
export class IntPropertyDefinition extends GenericPropertyDefinition<number> {

    /**
     * @internal Initializes a new instance of the **IntPropertyDefinition** class.
     *
     * @param   {string}            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}            xmlElementName   Name of the XML element.
     * @param   {string}            uri              The URI.
     * @param   {ExchangeVersion}   version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **IntPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **IntPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     * @param   {boolean}                   isNullable       Indicates that this property definition is for a nullable property.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion, isNullable: boolean);
    constructor(propertyName: string, xmlElementName: string, uri: string, versionOrFlags: ExchangeVersion | PropertyDefinitionFlags, version?: ExchangeVersion, isNullable?: boolean) {
        switch (arguments.length) {
            case 4:
                super(propertyName, xmlElementName, uri, <ExchangeVersion>versionOrFlags);
                break;
            case 5:
                super(propertyName, xmlElementName, uri, <PropertyDefinitionFlags>versionOrFlags, version, false);
                break;
            case 6:
                super(propertyName, xmlElementName, uri, <PropertyDefinitionFlags>versionOrFlags, version, isNullable);
                break;
            default:
                break;
        }
    }

    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    Parse(value: string): any {
        return Convert.toNumber(value);
    }
}
/** @internal */
export class ListValuePropertyDefinition<TPropertyValue> extends GenericPropertyDefinition<TPropertyValue> {
    Parse(value: string): any {

        throw new Error("ListValuePropertyDefinition - Parse: Not implemented.");
        
        // xs:list values are sent as a space-separated list; convert to comma-separated for EwsUtilities.Parse.
        var commaSeparatedValue: string = value ? value : value.replace(' ', ',');
        //return EwsUtilities.Parse<TPropertyValue>(commaSeparatedValue);
            
    }
}

/**
 * @internal Represents a task delegation property definition.
 */
export class TaskDelegationStatePropertyDefinition extends GenericPropertyDefinition<TaskDelegationState> {
    private static NoMatch: string = "NoMatch";
    private static OwnNew: string = "OwnNew";
    private static Owned: string = "Owned";
    private static Accepted: string = "Accepted";

    /**
     * @internal Initializes a new instance of the **TaskDelegationStatePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version, false); //ref: not setting enumType as this.ToString Method covers for the string conversion
    }

    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    Parse(value: string): any {
        switch (value) {
            case TaskDelegationStatePropertyDefinition.NoMatch:
                return TaskDelegationState.NoDelegation;
            case TaskDelegationStatePropertyDefinition.OwnNew:
                return TaskDelegationState.Unknown;
            case TaskDelegationStatePropertyDefinition.Owned:
                return TaskDelegationState.Accepted;
            case TaskDelegationStatePropertyDefinition.Accepted:
                return TaskDelegationState.Declined;
            default:
                EwsLogging.Assert(
                    false,
                    "TaskDelegationStatePropertyDefinition.Parse",
                    StringHelper.Format("TaskDelegationStatePropertyDefinition.Parse(): value {0} cannot be handled.", value));
                return null; // To keep the compiler happy
        }
    }

    /**
     * Convert instance to string.
     *
     * @param   {any}       value   The value.
     * @return  {string}    TaskDelegationState value.
     */
    ToString(value?: any): string {
        let taskDelegationState: TaskDelegationState = <TaskDelegationState>value;

        switch (taskDelegationState) {
            case TaskDelegationState.NoDelegation:
                return TaskDelegationStatePropertyDefinition.NoMatch;
            case TaskDelegationState.Unknown:
                return TaskDelegationStatePropertyDefinition.OwnNew;
            case TaskDelegationState.Accepted:
                return TaskDelegationStatePropertyDefinition.Owned;
            case TaskDelegationState.Declined:
                return TaskDelegationStatePropertyDefinition.Accepted;
            default:
                EwsLogging.Assert(
                    false,
                    "TaskDelegationStatePropertyDefinition.ToString",
                    "Invalid TaskDelegationState value.");
                return null; // To keep the compiler happy
        }
    }
}

/**
 * @internal Represents TimeSpan property definition. based on moment Duration
 */
export class TimeSpanPropertyDefinition extends GenericPropertyDefinition<TimeSpan> {

    /**
     * @internal Initializes a new instance of the **TimeSpanPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version, false);
    }

    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    Parse(value: string): any {
        return EwsUtilities.XSDurationToTimeSpan(value);
    }

    /**
     * Convert instance to string.
     *
     * @param   {any}       value   The value.
     * @return  {string}    TimeSpan value.
     */
    ToString(value?: any): string {
        if (value)
            return EwsUtilities.TimeSpanToXSDuration(value);
        throw new Error("TimeSpanPropertyDefinition: incorrect call of ToString(value): value is undefined");
    }
}

/**
 * @internal Represents abstract complex property definition.
 */
export abstract class ComplexPropertyDefinitionBase extends PropertyDefinition {

    /**
     * @internal Initializes a new instance of the **ComplexPropertyDefinitionBase** class.
     *
     * @param   {string}            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}            xmlElementName   Name of the XML element.
     * @param   {string}            uri              The URI.
     * @param   {ExchangeVersion}   version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **ComplexPropertyDefinitionBase** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, flags: PropertyDefinitionFlags, version: ExchangeVersion);
    /**
     * @internal Initializes a new instance of the **ComplexPropertyDefinitionBase** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion);
    constructor(propertyName: string, xmlElementName: string, uriOrFlags: string | PropertyDefinitionFlags, versionOrFlags: PropertyDefinitionFlags | ExchangeVersion, version?: ExchangeVersion) {
        switch (arguments.length) {
            case 4:
                super(propertyName, xmlElementName, <any>uriOrFlags, <ExchangeVersion>versionOrFlags);
                break;
            case 5:
                super(propertyName, xmlElementName, <string>uriOrFlags, <PropertyDefinitionFlags>versionOrFlags, version);
                break;
            default:
                break;
        }
    }

    /**
     * @internal Creates the property instance.
     *
     * @param   {ServiceObject}     owner   The owner.
     * @return  {ComplexProperty}   ComplexProperty.
     */
    abstract CreatePropertyInstance(owner: ServiceObject): ComplexProperty;

    /**
     * Gets the property instance.
     *
     * @param   {PropertyBag}       propertyBag       The property bag.
     * @param   {complexProperty}   complexProperty   The property instance.
     * @return  {boolean}    True if the instance is newly created.
     */
    private GetPropertyInstance(propertyBag: PropertyBag, complexProperty: IOutParam<ComplexProperty>): boolean {
        complexProperty.outValue = null;
        if (!propertyBag.TryGetValue(this, complexProperty) || !this.HasFlag(PropertyDefinitionFlags.ReuseInstance, propertyBag.Owner.Service.RequestedServerVersion)) {
            complexProperty.outValue = this.CreatePropertyInstance(propertyBag.Owner);
            return true;
        }

        return false;
    }

    /**
     * @internal Internals the load from XMlJsObject.
     *
     * @param   {any}               jsObject    The json object.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    InternalLoadFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {

        var outComplexproperty: IOutParam<ComplexProperty> = { outValue: null };
        var justCreated: boolean = this.GetPropertyInstance(propertyBag, outComplexproperty);

        //assume collection type
        var complexPropertyCollection: ComplexPropertyCollection<any> = <ComplexPropertyCollection<any>>outComplexproperty.outValue
        //check for collection type //todo: implement better ComplexPropertyCollection detection
        if (complexPropertyCollection.Items) { //false if ths is not collection
            if (!justCreated && this.HasFlag(PropertyDefinitionFlags.UpdateCollectionItems, propertyBag.Owner.Service.RequestedServerVersion)) {
                complexPropertyCollection.UpdateFromXmlJsObjectCollection(jsObject, service);
            }
            else {
                complexPropertyCollection.CreateFromXmlJsObjectCollection(jsObject, service);
            }
        }
        else {
            //var typename = TypeSystem.GetJsObjectTypeName(jsObject);
            outComplexproperty.outValue.LoadFromXmlJsObject(jsObject, service);
        }

        propertyBag._setItem(this, outComplexproperty.outValue);
    }

    /**
     * @internal Loads the property value from XMLJsObject.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    LoadPropertyValueFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {
        // check for null value from empty element
        if (jsObject) {
            //debugger;//update: array type detection in next call, can not call GetPropertyInstance multiple time
            this.InternalLoadFromXmlJsObject(jsObject, service, propertyBag);
        }
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void {
        var complexProperty: ComplexProperty = <ComplexProperty>propertyBag._getItem(this);
        //debugger;
        if (complexProperty) {
            complexProperty.WriteToXml(writer, this.XmlElementName);
        }
    }
}


/**
 * @internal Represents base complex property type.
 * 
 * @type <TComplexProperty> The type of the complex property.
 */
export class ComplexPropertyDefinition<TComplexProperty extends ComplexProperty> extends ComplexPropertyDefinitionBase {
    
    Type: any;// System.Type; //todo: implement Type using typeof type
    
    private propertyCreationDelegate: CreateComplexPropertyDelegate<TComplexProperty>;


    /**
     * @internal Initializes a new instance of the **ComplexPropertyDefinition<TComplexProperty>** class.
     *
     * @param   {string}                                            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                                            xmlElementName   Name of the XML element.
     * @param   {string}                                            uri              The URI.
     * @param   {ExchangeVersion}                                   version          The version.
     * @param   {CreateComplexPropertyDelegate<TComplexProperty>}   propertyCreationDelegate   Delegate used to create instances of ComplexProperty. 
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, version: ExchangeVersion, propertyCreationDelegate: CreateComplexPropertyDelegate<TComplexProperty>);
    /**
     * @internal Initializes a new instance of the **ComplexPropertyDefinition<TComplexProperty>** class.
     *
     * @param   {string}                                            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                                            xmlElementName   Name of the XML element.
     * @param   {PropertyDefinitionFlags}                           flags            The flags.
     * @param   {ExchangeVersion}                                   version          The version.
     * @param   {CreateComplexPropertyDelegate<TComplexProperty>}   propertyCreationDelegate   Delegate used to create instances of ComplexProperty. 
     */
    constructor(propertyName: string, xmlElementName: string, flags: PropertyDefinitionFlags, version: ExchangeVersion, propertyCreationDelegate: CreateComplexPropertyDelegate<TComplexProperty>);
    /**
     * @internal Initializes a new instance of the **ComplexPropertyDefinition<TComplexProperty>** class.
     *
     * @param   {string}                                            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                                            xmlElementName   Name of the XML element.
     * @param   {string}                                            uri              The URI.
     * @param   {PropertyDefinitionFlags}                           flags            The flags.
     * @param   {ExchangeVersion}                                   version          The version.
     * @param   {CreateComplexPropertyDelegate<TComplexProperty>}   propertyCreationDelegate   Delegate used to create instances of ComplexProperty.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion, propertyCreationDelegate: CreateComplexPropertyDelegate<TComplexProperty>);
    constructor(propertyName: string, xmlElementName: string, uriOrFlags: string | PropertyDefinitionFlags, versionOrFlags: PropertyDefinitionFlags | ExchangeVersion, versionOrDelegate?: ExchangeVersion | CreateComplexPropertyDelegate<TComplexProperty>, propertyCreationDelegate?: CreateComplexPropertyDelegate<TComplexProperty>) {
        switch (arguments.length) {
            case 5:
                super(propertyName, xmlElementName, <any>uriOrFlags, <ExchangeVersion>versionOrFlags);
                this.propertyCreationDelegate = <CreateComplexPropertyDelegate<TComplexProperty>>versionOrDelegate;
                EwsLogging.Assert(
                    this.propertyCreationDelegate != null,
                    "ComplexPropertyDefinition ctor",
                    "CreateComplexPropertyDelegate cannot be null");
                break;
            case 6:
                super(propertyName, xmlElementName, <string>uriOrFlags, <PropertyDefinitionFlags>versionOrFlags, <ExchangeVersion>versionOrDelegate);
                this.propertyCreationDelegate = propertyCreationDelegate;
                break;
            default:
                break;
        }
    }

    /**
     * @internal Creates the property instance.
     *
     * @param   {ServiceObject}   owner   The owner.
     * @return  {ComplexProperty}       ComplexProperty instance.
     */
    CreatePropertyInstance(owner: ServiceObject): ComplexProperty {

        var complexProperty: TComplexProperty = this.propertyCreationDelegate();

        if (TypeGuards.isIOwnedProperty(complexProperty)) { //IOwnedProperty ownedProperty = complexProperty as IOwnedProperty;
            complexProperty.Owner = owner;
        }

        if (complexProperty)
            return complexProperty;
    }
}

/**
 * @internal Represents base Attachments property type.
 */
export class AttachmentsPropertyDefinition extends ComplexPropertyDefinition<AttachmentCollection> {
    
    private static Exchange2010SP2PropertyDefinitionFlags: PropertyDefinitionFlags = PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.ReuseInstance | PropertyDefinitionFlags.UpdateCollectionItems;

    /**
     * Initializes a new instance of the **AttachmentsPropertyDefinition** class.
     * 
     * @param   {string}    propertyName     Name of the property (added to workaround reflection based initialization of Names). 
     */
    constructor(propertyName: string) {
        super(
            propertyName,
            XmlElementNames.Attachments,
            "item:Attachments",
            PropertyDefinitionFlags.AutoInstantiateOnRead,
            ExchangeVersion.Exchange2007_SP1,
            () => { return new AttachmentCollection(); })
    }

    /**
     * @internal Determines whether the specified flag is set.
     *
     * @param   {PropertyDefinitionFlags}   flag      The flag.
     * @param   {ExchangeVersion}           version   Requested version.
     * @return  {boolean}                   true if the specified flag is set; otherwise, false.
     */
    HasFlag(flag: PropertyDefinitionFlags, version?: ExchangeVersion): boolean {
        if (version && version >= ExchangeVersion.Exchange2010_SP2) {
            return (flag & AttachmentsPropertyDefinition.Exchange2010SP2PropertyDefinitionFlags) == flag;
        }
        return super.HasFlag(flag, version);
    }
}

/**
 * @internal Represents contained property definition.
 * 
 * @type    <TComplexProperty>  ComplexProperty
 */
export class ContainedPropertyDefinition<TComplexProperty extends ComplexProperty> extends ComplexPropertyDefinition<TComplexProperty> {

    private containedXmlElementName: string;

    /**
     * @internal Initializes a new instance of the **ContainedPropertyDefinition<TComplexProperty>** class.
     * 
     * @param   {string}                                            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                                            xmlElementName             Name of the XML element.
     * @param   {string}                                            uri                        The URI.
     * @param   {string}                                            containedXmlElementName    Name of the contained XML element.
     * @param   {PropertyDefinitionFlags}                           flags                      The flags.
     * @param   {ExchangeVersion}                                   version                    The version.
     * @param   {CreateComplexPropertyDelegate<TComplexProperty>}   propertyCreationDelegate   Delegate used to create instances of ComplexProperty.
     */
    constructor(
        propertyName: string,
        xmlElementName: string,
        uri: string,
        containedXmlElementName: string,
        flags: PropertyDefinitionFlags,
        version: ExchangeVersion,
        propertyCreationDelegate: CreateComplexPropertyDelegate<TComplexProperty>) {

        super(propertyName, xmlElementName, uri, flags, version, propertyCreationDelegate);
        this.containedXmlElementName = containedXmlElementName;
    }

    /**
     * @internal Load from XMLJsObject.
     *
     * @param   {any}               reader        The reader.
     * @param   {ExchangeService}   service        The Service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    InternalLoadFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {
        //debug: //check for correct contained element name
        if (jsObject[this.containedXmlElementName]) {
            jsObject = jsObject[this.containedXmlElementName];
        }
        super.InternalLoadFromXmlJsObject(jsObject, service, propertyBag);
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void {
        var complexProperty: ComplexProperty = <ComplexProperty>propertyBag._getItem(this);
        if (complexProperty) {
            writer.WriteStartElement(XmlNamespace.Types, this.XmlElementName);

            complexProperty.WriteToXml(writer, this.containedXmlElementName);

            writer.WriteEndElement(); // this.XmlElementName
        }
    }
}

// /**
//  * @internal Represents permission set property definition.
//  */
// export class PermissionSetPropertyDefinition extends ComplexPropertyDefinitionBase {
    
//     /**
//      * Gets the property type.
//      */
//     get Type(): any {//} Type {
//         return undefined;// new Type("FolderPermissionCollection");
//     }

//     /**
//      * @internal Initializes a new instance of the **PermissionSetPropertyDefinition** class.
//      *
//      * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
//      * @param   {string}                    xmlElementName   Name of the XML element.
//      * @param   {string}                    uri              The URI.
//      * @param   {PropertyDefinitionFlags}   flags            The flags.
//      * @param   {ExchangeVersion}           version          The version.
//      */
//     constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion){
//         super(propertyName, xmlElementName, uri, flags, version);
//     }

//     /**
//      * @internal Creates the property instance.
//      *
//      * @param   {ServiceObject}   owner   The owner.
//      * @return  {ComplexProperty}       ComplexProperty.
//      */
//     CreatePropertyInstance(owner: ServiceObject): ComplexProperty {
//         var folder: Folder = owner instanceof TypeContainer.Folder ? <Folder>owner : null;
//         EwsLogging.Assert(folder !== null, "PermissionCollectionPropertyDefinition.CreatePropertyInstance", "The owner parameter is not of type Folder or a derived class.");
//         return new FolderPermissionCollection(folder);
//     }
// }

/**
 * @internal Represents permission set property definition.
 */
export class PermissionSetPropertyDefinition extends ComplexPropertyDefinitionBase {

    /**
     * Gets the property type.
     */
    get Type(): any {//} Type {
        return undefined;// new Type("FolderPermissionCollection");
    }

    /**
     * @internal Initializes a new instance of the **PermissionSetPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version);
    }

    /**
     * @internal Creates the property instance.
     *
     * @param   {ServiceObject}   owner   The owner.
     * @return  {ComplexProperty}       ComplexProperty.
     */
    CreatePropertyInstance(owner: ServiceObject): ComplexProperty {
        var folder: Folder = owner instanceof TypeContainer.Folder ? <Folder>owner : null;
        EwsLogging.Assert(folder !== null, "PermissionCollectionPropertyDefinition.CreatePropertyInstance", "The owner parameter is not of type Folder or a derived class.");
        return new FolderPermissionCollection(folder);
    }
}

/**
 * @internal Represents a property definition for properties of type TimeZoneInfo.
 */
export class TimeZonePropertyDefinition extends PropertyDefinition {

    /**
     * Gets the property type.
     */
    Type: any;//System.Type;

    /**
     * @internal Initializes a new instance of the **TimeZonePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version);
    }

    /**
     * @internal Loads the property value from json.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    LoadPropertyValueFromXmlJsObject(jsObject: any, service: ExchangeService, propertyBag: PropertyBag): void {
        EwsLogging.DebugLog("[TimeZonePropertyDefinition.LoadPropertyValueFromXmlJsObject]: TimeZone info has been updated, Please report any bugs to github");
        let timeZoneDefinition: TimeZoneDefinition = new TimeZoneDefinition();

        if (jsObject) {
            timeZoneDefinition.LoadFromXmlJsObject(jsObject, service);
        }

        propertyBag._setItem(this, timeZoneDefinition.ToTimeZoneInfo(service));
    }

    /**
     * @internal Writes the property value to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void {
        EwsLogging.DebugLog("[TimeZonePropertyDefinition.WritePropertyValueToXml]: TimeZone info has been updated, Please report any bugs to github");        
        let value = <TimeZoneInfo>propertyBag._getItem(this);

        if (value != null) {
            // We emit time zone properties only if we have not emitted the time zone SOAP header
            // or if this time zone is different from that of the service through which the request
            // is being emitted.
            if (!writer.IsTimeZoneHeaderEmitted || value != writer.Service.TimeZone) {
                let timeZoneDefinition: TimeZoneDefinition = new TimeZoneDefinition(value);
                timeZoneDefinition.WriteToXml(writer, this.XmlElementName);
            }
        }
    }
}

/**
 * @internal Represents a property definition for properties of type TimeZoneInfo.
 */
export class StartTimeZonePropertyDefinition extends TimeZonePropertyDefinition {

    /**
     * @internal Initializes a new instance of the **StartTimeZonePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion) {
        super(propertyName, xmlElementName, uri, flags, version);
    }

    /**
     * @internal Determines whether the specified flag is set.
     *
     * @param   {PropertyDefinitionFlags}   flag      The flag.
     * @param   {ExchangeVersion}           version   Requested version.
     * @return  {boolean}                   true if the specified flag is set; otherwise, false.
     */
    HasFlag(flag: PropertyDefinitionFlags, version?: ExchangeVersion): boolean {
        if (version && (version as ExchangeVersion === ExchangeVersion.Exchange2007_SP1)) {
            return Schemas.AppointmentSchema.MeetingTimeZone.HasFlag(flag, version);
        }
        else {
            return super.HasFlag(flag, version);
        }
    }

    /**
     * @internal Registers associated internal properties.
     *
     * @param   {PropertyDefinition[]}   properties   The list in which to add the associated properties.
     */
    RegisterAssociatedInternalProperties(properties: PropertyDefinition[]): void {
        super.RegisterAssociatedInternalProperties(properties);

        properties.push(Schemas.AppointmentSchema.MeetingTimeZone);
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    WritePropertyValueToXml(writer: EwsServiceXmlWriter, propertyBag: PropertyBag, isUpdateOperation: boolean): void {
        var value = propertyBag._getItem(this);

        if (value != null) {
            if (writer.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
                var service = <ExchangeService>writer.Service;
                if (service != null && service.Exchange2007CompatibilityMode == false) {
                    var meetingTimeZone: MeetingTimeZone = new MeetingTimeZone(<TimeZoneInfo>value);
                    meetingTimeZone.WriteToXml(writer, XmlElementNames.MeetingTimeZone);
                }
            }
            else {
                super.WritePropertyValueToXml(
                    writer,
                    propertyBag,
                    isUpdateOperation);
            }
        }
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        if (writer.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
            Schemas.AppointmentSchema.MeetingTimeZone.WriteToXml(writer);
        }
        else {
            super.WriteToXml(writer);
        }
    }
}
// export class EwsHttpWebRequest implements  IEwsHttpWebRequest{
// 	private Accept: string;
// 	private AllowAutoRedirect: boolean;
// 	private ClientCertificates: any /*System.Security.Cryptography.X509Certificates.X509CertificateCollection*/;
// 	private ContentType: string;
// 	private CookieContainer: any /*System.Net.CookieContainer*/;
// 	private Credentials: any /*System.Net.ICredentials*/;
// 	private Headers: any /*System.Net.WebHeaderCollection*/;
// 	private Method: string;
// 	private Proxy: any /*System.Net.IWebProxy*/;
// 	private PreAuthenticate: boolean;
// 	private RequestUri: string /*Uri*/;
// 	private Timeout: number;
// 	private UseDefaultCredentials: boolean;
// 	private UserAgent: string;
// 	KeepAlive: boolean;
// 	ConnectionGroupName: string;
// 	private request: any /*System.Net.HttpWebRequest*/;
// }






			

			
//  class EwsHttpWebRequestFactory {
// }
// export = EwsHttpWebRequestFactory;


//------------modulename->Microsoft.Exchange.WebServices.Data------------


			
// export class EwsHttpWebResponse implements IEwsHttpWebResponse{
// 	private ContentEncoding: string;
// 	private ContentType: string;
// 	private Headers: any /*System.Net.WebHeaderCollection*/;
// 	private ResponseUri: string /*Uri*/;
// 	private StatusCode: any /*System.Net.HttpStatusCode*/;
// 	private StatusDescription: string;
// 	private ProtocolVersion: any /*System.Version*/;
// 	private response: any /*System.Net.HttpWebResponse*/;
// }






			

declare var window: any;
var isNode = (typeof window === 'undefined')
var util: any = undefined;

declare var require: any;

// if (isNode) {
//     util = require('util');
// }
// else {
    util = {
        inspect: (obj: any, option: any) => { return obj; }
    }
// }


export class EwsLogging {
    static DebugLogEnabled: boolean = false;
    static Assert(condition: boolean, caller: string, message: string, always: boolean = false): void {
        if ((this.DebugLogEnabled || always) && !condition)
            console.log(StringHelper.Format("[{0}] {1}", caller, message));
    }

    static Log(message: any, always: boolean = false, expandObject: boolean = false): void {
        if (this.DebugLogEnabled || always) {
            if (expandObject)
                console.log(util.inspect(message, { showHidden: false, depth: null, colors: true }));
            else
                console.log(message);
        }
    }

    static DebugLog(message: any, expandObject: boolean = false): void {
        if (this.DebugLogEnabled) {
            if (expandObject)
                console.log(util.inspect(message, { showHidden: false, depth: null, colors: true }));
            else
                console.log(message);
        }
    }
}
export class EwsServiceJsonReader {
    //Service: ExchangeService;
    // constructor(service: ExchangeService){
    // 	this.Service = service;
    // }
    static ReadAsArray(jsObject: any, xmlElementName: string):any[] {
        if (!jsObject || !jsObject[xmlElementName]) {
            return [];
            //throw new Error("EwsServiceJsonReader - ReadAsArray - json property not found");
        }
        var collectionItems: any[] = jsObject[xmlElementName];
        if (!Array.isArray(collectionItems)) {
            collectionItems = [collectionItems];
        }
        return collectionItems;
    }
    static ReadBase64ElementValue(obj:any):string{
        return base64Helper.atob(obj);
    }
    static ReadServiceObjectsCollectionFromJson<TServiceObject extends ServiceObject>(jsonResponse: any/*JsonObject*/, service: ExchangeService, collectionJsonElementName: string, getObjectInstanceDelegate: GetObjectInstanceDelegate<TServiceObject>, clearPropertyBag: boolean, requestedPropertySet: PropertySet, summaryPropertiesOnly: boolean): TServiceObject[] /*System.Collections.Generic.List<TServiceObject>*/ {

        var serviceObjects: TServiceObject[] = [];
        var serviceObject: TServiceObject = null;

        var collectionItems: any[] = jsonResponse[collectionJsonElementName];

        for (var key in collectionItems) {
            if ((<string>key).indexOf("__") === 0)
                continue;
            var jsonServiceObjects: any[] = collectionItems[key];
            if (!Array.isArray(jsonServiceObjects)) {
                jsonServiceObjects = [jsonServiceObjects];
            }
            for (var jsonServiceObject of jsonServiceObjects) {
                if (jsonServiceObject != null) {
                    var typeName = TypeSystem.GetJsObjectTypeName(jsonServiceObject);
                    if (StringHelper.IsNullOrEmpty(typeName)) debugger;//check why typeName is empty - may be invalid xml parsing by xml2js
                    serviceObject = getObjectInstanceDelegate(service, typeName || key);
                    if (serviceObject != null) {
                        if ((typeName || key) !== serviceObject.GetXmlElementName()) { //string.Compare(jsonServiceObject.ReadTypeString(), serviceObject.GetXmlElementName(), StringComparison.Ordinal) != 0)                        
                            throw new ServiceLocalException(
                                StringHelper.Format(
                                    "The type of the object in the store ({0}) does not match that of the local object ({1}).",
                                    typeName,
                                    serviceObject.GetXmlElementName()));
                        }
                        serviceObject.LoadFromXmlJsObject(
                            jsonServiceObject,
                            service,
                            clearPropertyBag,
                            requestedPropertySet,
                            summaryPropertiesOnly);
                        serviceObjects.push(serviceObject);
                    }
                    // else
                    //     debugger;
                }
            }

        }

        return serviceObjects;
    }
}






			

//todo: ix this - import Xml = require("System.Xml");

/** @internal */
export class EwsXmlReader {
    private static ReadWriteBufferSize: number = 4096;

    get HasAttributes(): boolean { return this.currentNode ? this.currentNode.hasAttributes() : false; }
    get IsEmptyElement(): boolean { return this.currentNode.nodeType == Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/ && !this.currentNode.hasChildNodes(); }
    get LocalName(): string { return this.currentNode ? this.currentNode.localName : undefined; }
    get NamespacePrefix(): string { return this.currentNode ? (<any>this.currentNode).prefix : undefined; }
    get NamespaceUri(): string { return this.currentNode ? this.currentNode.namespaceURI : undefined; }
    get NodeType(): number /*Xml.XmlNodeType*/ { return this.currentNode ? this.currentNode.nodeType : undefined; }
    //get PrevNodeType(): System.Xml.XmlNodeType { return this.prevNodeType; }
    get IsRoot(): boolean { return this.currentNode == this.treeWalker.root; }
    get ParentNode(): Node { return this.currentNode ? this.currentNode.parentNode : undefined; }
    get CurrentNode(): Node { return this.currentNode; }
    private prevNodeType: number /*Xml.XmlNodeType*/;
    private xmlReader: any;
    get Eof(): boolean { return this.eof; }
    private eof: boolean = false;
    protected xmlDoc: XMLDocument;
    protected currentNode: Node;
    protected treeWalker: TreeWalker;


    //#region xml2JS logic
    get JsObject(): any { return this.jsObject; }
    private jsObject: any;
    //#endregion


    //#region Constructor
    constructor(rawXML: string) {
        var parser = new DOMParser();
        this.xmlDoc = parser.parseFromString(rawXML, "text/xml");
        //this.treeWalker = this.xmlDoc.createTreeWalker(this.xmlDoc, NodeFilter.SHOW_ELEMENT, null, false);
        //this.currentNode = this.treeWalker.root;
        var xml2js = new xml2JsObject();
        this.jsObject = xml2js.parseXMLNode(this.xmlDoc.documentElement, true);
        EwsLogging.DebugLog(this.JsObject, true);

    }
    //#endregion


    EnsureCurrentNodeIsEndElement(xmlNamespace: XmlNamespace, localName: string): any { throw new Error("EwsXmlReader.ts - EnsureCurrentNodeIsEndElement : Not implemented."); }
    //EnsureCurrentNodeIsStartElement(xmlNamespace: XmlNamespace, localName: string): any { throw new Error("EwsXmlReader.ts - EnsureCurrentNodeIsStartElement : Not implemented."); }
    //EnsureCurrentNodeIsStartElement(): any { throw new Error("EwsXmlReader.ts - EnsureCurrentNodeIsStartElement : Not implemented."); }
    FormatElementName(namespacePrefix: string, localElementName: string): string { throw new Error("EwsXmlReader.ts - FormatElementName : Not implemented."); }
    GetXmlReaderForNode(): any { throw new Error("EwsXmlReader.ts - GetXmlReaderForNode : Not implemented."); }
    InitializeXmlReader(stream: any /*System.IO.Stream*/): any { throw new Error("EwsXmlReader.ts - InitializeXmlReader : Not implemented."); }
    //InternalReadElement(namespacePrefix: string, localName: string, nodeType: System.Xml.XmlNodeType): any;// { throw new Error("EwsXmlReader.ts - InternalReadElement : Not implemented."); }
    InternalReadElement(xmlNamespace: XmlNamespace, localName: string, nodeType: number /*Xml.XmlNodeType*/): any {

        if (this.LocalName === localName && this.NamespaceUri == EwsUtilities.GetNamespaceUri(xmlNamespace)) return;
        this.Read(nodeType);

        if (localName && nodeType)
            if ((this.LocalName != localName) || (this.NamespaceUri != EwsUtilities.GetNamespaceUri(xmlNamespace))) {
                throw new Error(StringHelper.Format(
                    "unexpected element, {0}:{1}, {2}, {3}, {4}",
                    EwsUtilities.GetNamespacePrefix(xmlNamespace),
                    localName,
                    nodeType,
                    this.xmlReader.Name,
                    this.NodeType));
            }


    }
    HasRecursiveParent(localName: string, node: Node = this.currentNode): boolean {
        if (node === null || node.parentNode === null) return false;
        if (node.parentNode.localName == localName) return true;
        else
            return this.HasRecursiveParent(localName, node.parentNode);
    }
    HasRecursiveParentNode(parentNode: Node, parentName: string, node: Node = this.currentNode): boolean {
        if (node === null || node.parentNode === null) return false;
        if (node.parentNode.localName == parentName && node.parentNode != parentNode) return false;

        if (node.parentNode == parentNode) return true;
        else
            return this.HasRecursiveParentNode(parentNode, parentName, node.parentNode);
    }
    //IsEndElement(xmlNamespace: XmlNamespace, localName: string): boolean { throw new Error("EwsXmlReader.ts - IsEndElement : Not implemented."); }
    //IsEndElement(namespacePrefix: string, localName: string): boolean { throw new Error("EwsXmlReader.ts - IsEndElement : Not implemented."); }
    //IsStartElement(namespacePrefix: string, localName: string): boolean { throw new Error("EwsXmlReader.ts - IsStartElement : Not implemented."); }
    //IsStartElement(): boolean { throw new Error("EwsXmlReader.ts - IsStartElement : Not implemented."); }
    //IsStartElement(xmlNamespace: XmlNamespace, localName: string): boolean { throw new Error("EwsXmlReader.ts - IsStartElement : Not implemented."); }
    IsElement(xmlNamespace: XmlNamespace, localName: string): boolean {
        return (this.LocalName == localName) &&
            ((this.NamespacePrefix == EwsUtilities.GetNamespacePrefix(xmlNamespace)) ||
                (this.NamespaceUri == EwsUtilities.GetNamespaceUri(xmlNamespace)));
    }

    //Read(): any { throw new Error("EwsXmlReader.ts - Read : Not implemented."); }
    Read(nodeType?: number /*Xml.XmlNodeType*/): boolean {
        this.currentNode = this.treeWalker.nextNode();
        if (this.currentNode == null) this.eof = true;
        if (nodeType) {
            if (this.NodeType !== nodeType) throw new Error("unexpected element type");
        }

        return this.currentNode != null;
    }


    //ReadAttributeValue(attributeName: string): string;// { throw new Error("EwsXmlReader.ts - ReadAttributeValue : Not implemented."); }
    //ReadAttributeValue(attributeName: string): any { throw new Error("EwsXmlReader.ts - ReadAttributeValue : Not implemented."); }
    ReadAttributeValue(xmlNamespace: XmlNamespace, attributeName: string): string {
        if (this.currentNode == null || this.currentNode.nodeType != this.currentNode.ELEMENT_NODE || !this.currentNode.hasAttributes()) return null;
        var elem = <Element>this.currentNode;

        var val = elem.getAttributeNS(EwsUtilities.GetNamespaceUri(xmlNamespace), attributeName);
        return val;
    }

    //ReadBase64ElementValue(outputStream: System.IO.Stream): any { throw new Error("EwsXmlReader.ts - ReadBase64ElementValue : Not implemented."); }
    ReadBase64ElementValue(): any[] /*System.Byte[]*/ { throw new Error("EwsXmlReader.ts - ReadBase64ElementValue : Not implemented."); }

    ReadElementValue(): string {
        return this.currentNode.textContent;
    }
    //ReadElementValue(): any { throw new Error("EwsXmlReader.ts - ReadElementValue : Not implemented."); }
    //ReadElementValue(xmlNamespace: XmlNamespace, localName: string): any { throw new Error("EwsXmlReader.ts - ReadElementValue : Not implemented."); }
    //ReadElementValue(namespacePrefix: string, localName: string): string { throw new Error("EwsXmlReader.ts - ReadElementValue : Not implemented."); }
    //ReadElementValue(xmlNamespace: XmlNamespace, localName: string): string { throw new Error("EwsXmlReader.ts - ReadElementValue : Not implemented."); }

    //ReadEndElement(namespacePrefix: string, elementName: string): any { throw new Error("EwsXmlReader.ts - ReadEndElement : Not implemented."); }
    ReadEndElement(xmlNamespace: XmlNamespace, localName: string): void {
        this.InternalReadElement(xmlNamespace, localName, Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/);

    }

    ReadEndElementIfNecessary(xmlNamespace: XmlNamespace, localName: string): void {
        if (!(this.IsElement(xmlNamespace, localName) && this.IsEmptyElement)) {
            //if (!this.IsEndElement(xmlNamespace, localName)) {
            this.ReadEndElement(xmlNamespace, localName);
            //}
        }
    }

    ReadInnerXml(): string { throw new Error("EwsXmlReader.ts - ReadInnerXml : Not implemented."); }

    ReadNullableAttributeValue(attributeName: string): any { throw new Error("EwsXmlReader.ts - ReadNullableAttributeValue : Not implemented."); }
    ReadOuterXml(): string { throw new Error("EwsXmlReader.ts - ReadOuterXml : Not implemented."); }
    //ReadStartElement(namespacePrefix: string, localName: string): any { throw new Error("EwsXmlReader.ts - ReadStartElement : Not implemented."); }
    ReadStartElement(xmlNamespace: XmlNamespace, localName: string): void {
        this.InternalReadElement(xmlNamespace, localName, Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/);
    }
    ReadToDescendant(xmlNamespace: XmlNamespace, localName: string): any { throw new Error("EwsXmlReader.ts - ReadToDescendant : Not implemented."); }
    ReadValue(): string { throw new Error("EwsXmlReader.ts - ReadValue : Not implemented."); }
    //ReadValue(): any { throw new Error("EwsXmlReader.ts - ReadValue : Not implemented."); }
    SeekLast(): void {
        if (!this.eof) this.currentNode = this.treeWalker.previousNode();
    }
    SkipCurrentElement(): void {
        //debug:
        var parentNode = this.CurrentNode;
        do {
            this.Read();
        }
        while (this.HasRecursiveParentNode(parentNode, parentNode.localName));
        this.SeekLast();
    }
    SkipElement(xmlNamespace: XmlNamespace, localName: string): any { throw new Error("EwsXmlReader.ts - SkipElement : Not implemented."); }
    //SkipElement(namespacePrefix: string, localName: string): any { throw new Error("EwsXmlReader.ts - SkipElement : Not implemented."); }
    TryReadValue(value: any): boolean { throw new Error("EwsXmlReader.ts - TryReadValue : Not implemented."); }
}




/**@internal */
export class EwsServiceXmlReader extends EwsXmlReader {
    get Service(): ExchangeService { return this.service; }
    private service: ExchangeService;
    //#region Constructor
    constructor(rawXML: string, service: ExchangeService) {
        super(rawXML);
        this.service = service;
    }
    //#endregion
    ConvertStringToDateTime(dateTimeString: string): Date { throw new Error("EwsServiceXmlReader.ts - ConvertStringToDateTime : Not implemented."); }
    ConvertStringToUnspecifiedDate(dateTimeString: string): Date { throw new Error("EwsServiceXmlReader.ts - ConvertStringToUnspecifiedDate : Not implemented."); }
    ReadElementValueAsDateTime(): Date { throw new Error("EwsServiceXmlReader.ts - ReadElementValueAsDateTime : Not implemented."); }
    //ReadElementValueAsDateTime(xmlNamespace: XmlNamespace, localName: string): Date { throw new Error("EwsServiceXmlReader.ts - ReadElementValueAsDateTime : Not implemented."); }
    ReadElementValueAsUnbiasedDateTimeScopedToServiceTimeZone(): Date { throw new Error("EwsServiceXmlReader.ts - ReadElementValueAsUnbiasedDateTimeScopedToServiceTimeZone : Not implemented."); }
    ReadElementValueAsUnspecifiedDate(): Date { throw new Error("EwsServiceXmlReader.ts - ReadElementValueAsUnspecifiedDate : Not implemented."); }
    //ReadServiceObjectsCollectionFromXml(collectionXmlNamespace: XmlNamespace, collectionXmlElementName: string, getObjectInstanceDelegate: GetObjectInstanceDelegate<T>, clearPropertyBag: boolean, requestedPropertySet: PropertySet, summaryPropertiesOnly: boolean): System.Collections.Generic.List<T> { throw new Error("EwsServiceXmlReader.ts - ReadServiceObjectsCollectionFromXml : Not implemented."); }
    //ReadServiceObjectsCollectionFromXml(collectionXmlElementName: string, getObjectInstanceDelegate: GetObjectInstanceDelegate<T>, clearPropertyBag: boolean, requestedPropertySet: PropertySet, summaryPropertiesOnly: boolean): System.Collections.Generic.List<T> { throw new Error("EwsServiceXmlReader.ts - ReadServiceObjectsCollectionFromXml : Not implemented."); }
    // ReadServiceObjectsCollectionFromXml<TServiceObject extends ServiceObject>(collectionXmlElementName: string,
    //     getObjectInstanceDelegate: GetObjectInstanceDelegate<TServiceObject>,
    //     clearPropertyBag: boolean, requestedPropertySet: PropertySet, summaryPropertiesOnly: boolean,
    //     collectionXmlNamespace: XmlNamespace = XmlNamespace.Messages): TServiceObject[] /*System.Collections.Generic.List<T>*/ {

    //     // condensed both overload in one.

    //     //return this.ReadServiceObjectsCollectionFromXml<TServiceObject>(
    //     //    XmlNamespace.Messages,
    //     //    collectionXmlElementName,
    //     //    getObjectInstanceDelegate,
    //     //    clearPropertyBag,
    //     //    requestedPropertySet,
    //     //    summaryPropertiesOnly);

    //     var serviceObjects: TServiceObject[] = [];//new List<TServiceObject>();
    //     var serviceObject: TServiceObject = null;

    //     if (!this.IsElement(collectionXmlNamespace, collectionXmlElementName)) {
    //         this.ReadStartElement(collectionXmlNamespace, collectionXmlElementName);
    //     }

    //     if (!this.IsEmptyElement) {
    //         do {
    //             this.Read();

    //             //if (this.IsStartElement()) { //todo: test for specific startElement if possible - cant check that with javascript XML Node Walker
    //             serviceObject = getObjectInstanceDelegate(this.Service, this.LocalName);

    //             if (serviceObject == null) {
    //                 this.SkipCurrentElement();
    //             }
    //             else {
    //                 if (this.LocalName.toLowerCase() !== serviceObject.GetXmlElementName().toLowerCase()) {
    //                     throw new ServiceLocalException(
    //                         StringHelper.Format(
    //                             "The type of the object in the store ({0}) does not match that of the local object ({1}).",
    //                             this.LocalName,
    //                             serviceObject.GetXmlElementName()));
    //                 }

    //                 serviceObject.LoadFromXmlJsObject(
    //                     this,
    //                     clearPropertyBag,
    //                     requestedPropertySet,
    //                     summaryPropertiesOnly);

    //                 serviceObjects.push(serviceObject);
    //             }
    //             //}
    //         }
    //         while (!this.HasRecursiveParent(/*collectionXmlNamespace, */collectionXmlElementName));
    //         this.SeekLast(); // to let next Read() parse right node.
    //     }

    //     return serviceObjects;

    // }
}


/**@internal */
    export class EwsServiceMultiResponseXmlReader extends EwsServiceXmlReader {
	Create(stream: any /*System.IO.Stream*/, service: ExchangeService): EwsServiceMultiResponseXmlReader{ throw new Error("EwsServiceMultiResponseXmlReader.ts - Create : Not implemented.");}
	CreateXmlReader(stream: any /*System.IO.Stream*/): any /*System.Xml.XmlReader*/{ throw new Error("EwsServiceMultiResponseXmlReader.ts - CreateXmlReader : Not implemented.");}
	InitializeXmlReader(stream: any /*System.IO.Stream*/): any /*System.Xml.XmlReader*/{ throw new Error("EwsServiceMultiResponseXmlReader.ts - InitializeXmlReader : Not implemented.");}
}






			


/**
 * @internal XML writer
 */
export class EwsServiceXmlWriter {
    
    //get InternalWriter(): System.Xml.XmlWriter;
    get Service(): ExchangeServiceBase { return this.service }
    /**
     * Buffer size for writing Base64 encoded content.
     *
     */
    static BufferSize: number = 4096;

    IsTimeZoneHeaderEmitted: boolean;
    RequireWSSecurityUtilityNamespace: boolean;
    private isDisposed: boolean;
    private service: ExchangeServiceBase;
    private xmlWriter: any;// System.Xml.XmlWriter;
    private isTimeZoneHeaderEmitted: boolean;
    private requireWSSecurityUtilityNamespace: boolean;
    
    /**
     * UTF-8 encoding that does not create leading Byte order marks
     *
     */
    private static utf8Encoding: any;// System.Text.Encoding;
    
    Dispose(): any { throw new Error("EwsServiceXmlWriter.ts - Dispose : Not implemented."); }
    
    Flush(): void { //throw new Error("Not implemented.");
    }

    //#region custome XML writer data;
    private xmlElements: string[] = [];
    private pendingElementData = "";
    private pendingXMLTagClosure = false;
    private soapData: string = "";

    private rootUris: string[] = [];
    private rootLevel: boolean = false;
    private currentLevel: number = 0;
    private uriCache: string[][];

    /**
     * Gets the xml created by EWS XMl Writer.
     * 
     * @param   {boolean}   keep   removes internal cache of XML data if false, otherwise keep the data. 
     */
    GetXML(keep: boolean = false): string {
        var returnVal = this.soapData.trim();
        if (!keep) this.soapData = "";
        return returnVal;
    }

    /**
     * Closes XMl tag
     */
    private CloseTag(): void {
        if (this.pendingXMLTagClosure) {
            this.soapData += ">";
            this.pendingXMLTagClosure = false;
            this.rootLevel = false;
        }

    }

    /**
     * Pushes xml uri to internal tracker of used xml uris
     * 
     * @param   {string}   prefix     Prefix of uri.
     * @param   {string}   uri        uri itself.
     */
    private PushUris(prefix: string, uri: string): void {

        if (this.rootLevel) {
            this.rootUris.push(prefix + ":" + uri);
        }

    }

    /**
     * check if an uri exist in internal tracker
     * 
     * @param   {string}   prefix     Prefix of uri.
     * @param   {string}   uri        uri itself.
     */
    private CheckRootUri(prefix: string, uri: string): boolean {
        return this.rootUris.indexOf(prefix + ":" + uri) >= 0;
    }

    //#endregion

    /**
     * Initializes a new instance of the **EwsServiceXmlWriter** class.
     *
     * @param   {ExchangeServiceBase}   service   The service.
     */
    constructor(service: ExchangeServiceBase) {
        this.service = service;
    }

    //TryConvertObjectToString(value: any, strValue: any): boolean { throw new Error("EwsServiceXmlWriter.ts - TryConvertObjectToString : Not implemented."); }

    /**
     * convert object to a string. transformed TryConvertObjectToString metho from c#
     *
     * @param   {any}     value      The value.
     * @return  {string}  The string representation of value.
     */
    ConvertObjectToString(value: any): string {
        var strValue: string = null;

        if (value === null) return null;

        if (value != null) {
            switch (typeof (value)) {
                case "boolean":
                    strValue = EwsUtilities.BoolToXSBool(<boolean>value);
                    break;
                case "number":
                    strValue = value.toString();
                    //todo check for datetime
                    //strValue = this.Service.ConvertDateTimeToUniversalDateTimeString((DateTime) value);
                    break;
                case "string":
                    return value;
                default:
                    if (value instanceof DateTime) {
                        return this.service.ConvertDateTimeToUniversalDateTimeString(value as DateTime);
                        //return EwsUtilities.DateTimeToXSDateTime(value as DateTime);
                    }
                    try {
                        if (TypeGuards.isISearchStringProvider(value)) // ISearchStringProvider searchStringProvider = value as ISearchStringProvider;
                            return value.GetSearchString();
                        else
                            throw new Error("value can not be of type object");
                    }
                    catch (e) {
                        throw e;
                    }

                    break;
            }
            return strValue;
        }

        //return converted;
        return undefined;
    }

    /**
     * Writes the attribute value.
     *
     * @param   {string}   localName     The local name of the attribute.
     * @param   {string}   stringValue   The string value.
     */
    WriteAttributeString(localName: string, stringValue: string): void;
    /**
     * Writes the attribute value.
     *
     * @param   {string}   namespacePrefix   The namespace prefix.
     * @param   {string}   localName         The local name of the attribute.
     * @param   {string}   stringValue       The string value.
     */
    WriteAttributeString(namespacePrefix: string, localName: string, stringValue: string): void;
    WriteAttributeString(
        localNameOrNamespacePrefix: string,
        localNameOrStringValue: string,
        stringValueToWrite?: string): void {
        var namespacePrefix: string = "";
        var localName: string = localNameOrNamespacePrefix;
        var stringValue: string = localNameOrStringValue;
        if (arguments.length === 3) {
            namespacePrefix = localNameOrNamespacePrefix;
            localName = localNameOrStringValue;
            stringValue = stringValueToWrite;
        }

        if (namespacePrefix !== "") namespacePrefix += ":";
        this.soapData += " " + namespacePrefix + localName + "=\"" + stringValue + "\"";
        if (namespacePrefix == "xmlns:") // push to rootUris cache
            this.PushUris(localName, stringValue);
        //try {
        //    this.xmlWriter.WriteAttributeString(
        //        namespacePrefix,
        //        localName,
        //        null,
        //        stringValue);
        //}
        //catch (ex) {
        //    // XmlTextWriter will throw ArgumentException if string includes invalid characters.
        //    //throw new ServiceXmlSerializationException(
        //    //    string.Format(Strings.InvalidAttributeValue, stringValue, localName),
        //    //    ex);
        //}
    }

    /**
     * Writes the attribute value.  Does not emit empty string values.
     *
     * @param   {string}  localName   The local name of the attribute.
     * @param   {any}     value       The value.
     */
    WriteAttributeValue(localName: string, value: any): void;
    /**
     * Writes the attribute value.  Optionally emits empty string values.
     *
     * @param   {string}      localName                The local name of the attribute.
     * @param   {boolean}     alwaysWriteEmptyString   Always emit the empty string as the value.
     * @param   {any}         value                    The value.
     */
    WriteAttributeValue(localName: string, alwaysWriteEmptyString: boolean, value: any): void;
    /**
     * Writes the attribute value.
     *
     * @param   {string}  namespacePrefix   The namespace prefix.
     * @param   {string}  localName         The local name of the attribute.
     * @param   {any}     value             The value.
     */
    WriteAttributeValue(namespacePrefix: string, localName: string, value: any): void;
    WriteAttributeValue(
        localNameOrNamespacePrefix: string,
        localNameOrAlwaysWriteEmptyStringOrValue: string | boolean | any,
        valueToWrite?: any): void {
        var argsLength = arguments.length;
        var localName: string = localNameOrNamespacePrefix;
        var value: any = valueToWrite;
        var alwaysWriteEmptyString: boolean = false;
        var namespacePrefix: string = null;
        var callWithNameSpacePrifix: boolean = false;

        if (argsLength === 2) {
            value = localNameOrAlwaysWriteEmptyStringOrValue;
        }
        if (argsLength === 3) {
            if (typeof localNameOrAlwaysWriteEmptyStringOrValue === "boolean") {
                localName = localNameOrNamespacePrefix;
                alwaysWriteEmptyString = localNameOrAlwaysWriteEmptyStringOrValue;
            }
            else {
                namespacePrefix = localNameOrNamespacePrefix;
                localName = localNameOrAlwaysWriteEmptyStringOrValue;
                callWithNameSpacePrifix = true;
            }
        }

        var stringValue: string = this.ConvertObjectToString(value);
        if (!StringHelper.IsNullOrEmpty(stringValue) || alwaysWriteEmptyString) {
            this.WriteAttributeString(
                callWithNameSpacePrifix ? namespacePrefix : "",
                localName,
                stringValue);
        }
    }

    //WriteBase64ElementValue(buffer: System.Byte[]): any{ throw new Error("EwsServiceXmlWriter.ts - WriteBase64ElementValue : Not implemented.");}
    //WriteBase64ElementValue(stream: System.IO.Stream): any{ throw new Error("EwsServiceXmlWriter.ts - WriteBase64ElementValue : Not implemented.");}

    /**
     * Writes the base64-encoded element value.
     *
     * @param   {any}   buffer   The buffer.
     */
    WriteBase64ElementValue(buffer: any): void {
        this.WriteValue(base64Helper.btoa(buffer), null);
    }

    /**
     * Writes the element value.
     *
     * @param   {XmlNamespace}    xmlNamespace   The XML namespace.
     * @param   {string}          localName      The local name of the element.
     * @param   {string}          displayName    The name that should appear in the exception message when the value can not be serialized.
     * @param   {any}             value          The value.
     */
    WriteElementValue(xmlNamespace: XmlNamespace, localName: string, value: any): void;
    /**
     * Writes the element value.
     *
     * @param   {XmlNamespace}    xmlNamespace   The XML namespace.
     * @param   {string}          localName      The local name of the element.
     * @param   {any}             value          The value.
     */
    WriteElementValue(xmlNamespace: XmlNamespace, localName: string, displayName: string, value: any): void;
    WriteElementValue(
        xmlNamespace: XmlNamespace,
        localName: string,
        displayNameOrValue: string | any,
        valueToWrite?: any): void {

        var value: any = displayNameOrValue;
        var displayName: string = localName;
        if (arguments.length === 4) {
            value = valueToWrite;
            displayName = displayNameOrValue;
        }
        var stringValue: string = this.ConvertObjectToString(value);
        if (stringValue != undefined) {
            this.WriteStartElement(xmlNamespace, localName);
            this.WriteValue(stringValue, displayName);
            this.WriteEndElement();
        }
        else {
            EwsLogging.Assert(stringValue !== 'undefined', 'WriteElementValue', StringHelper.Format(
                Strings.ElementValueCannotBeSerialized,
                typeof (value), localName));

            // throw new Error(StringHelper.Format(
            //     Strings.ElementValueCannotBeSerialized,
            //     typeof (value), localName));
        }
    }

    /**
     * Writes the end element.
     */
    WriteEndElement(): void {
        //this.xmlWriter.WriteEndElement();
        var element = "</" + this.xmlElements.pop() + ">";
        this.CloseTag();
        this.soapData += element;
    }

    //WriteNode(xmlNode: System.Xml.XmlNode): any{ throw new Error("EwsServiceXmlWriter.ts - WriteNode : Not implemented.");}

    /**
     * Writes the start element.
     *
     * @param   {XmlNamespace}    xmlNamespace   The XML namespace.
     * @param   {string}          localName      The local name of the element.
     */
    WriteStartElement(xmlNamespace: XmlNamespace, localName: string): void {
        this.CloseTag();
        if (this.soapData == "")
            this.rootLevel = true;
        else
            this.soapData += "";//\r\n";
        var prefix = EwsUtilities.GetNamespacePrefix(xmlNamespace);
        this.soapData += "<" + prefix + ":" + localName;

        var uri = EwsUtilities.GetNamespaceUri(xmlNamespace);
        if (!this.CheckRootUri(prefix, uri)) {
            this.soapData += " xmlns:" + prefix + "=\"" + uri + "\"";
        }
        this.PushUris(prefix, uri);

        this.xmlElements.push(prefix + ":" + localName);

        this.pendingXMLTagClosure = true;
        //this.xmlWriter.WriteStartElement(
        //    EwsUtilities.GetNamespacePrefix(xmlNamespace),
        //    localName,
        //    EwsUtilities.GetNamespaceUri(xmlNamespace));
    }

    /**
     * Writes string value.
     *
     * @param   {string}   value   The value.
     * @param   {string}   name    Element name (used for error handling)
     */
    WriteValue(value: string, name: string): any {
        //var closeElement = this.soapData.charAt(this.soapData.length - 1) !== ">";
        //if (closeElement) this.soapData += ">";
        this.CloseTag();
        this.soapData += value;

        //todo: validate invalid characters
        // name is used for exception with invalid characters
    }
}

export type RequiredServerVersionEnums = typeof ConversationQueryTraversal | typeof EventType | typeof FileAsMapping | typeof ItemTraversal | typeof MailboxType | typeof MeetingRequestsDeliveryScope | typeof ViewFilter | typeof WellKnownFolderName

/**
 * @internal EWS utilities
 *
 * @static
 */
export class EwsUtilities {

    //#region constants in c# - typescript static
    static XSFalse: string = "false";
    static XSTrue: string = "true";
    static EwsTypesNamespacePrefix: string = "t";
    static EwsMessagesNamespacePrefix: string = "m";
    static EwsErrorsNamespacePrefix: string = "e";
    static EwsSoapNamespacePrefix: string = "soap";
    static EwsXmlSchemaInstanceNamespacePrefix: string = "xsi";
    static PassportSoapFaultNamespacePrefix: string = "psf";
    static WSTrustFebruary2005NamespacePrefix: string = "wst";
    static WSAddressingNamespacePrefix: string = "wsa";
    static AutodiscoverSoapNamespacePrefix: string = "a";
    static WSSecurityUtilityNamespacePrefix: string = "wsu";
    static WSSecuritySecExtNamespacePrefix: string = "wsse";
    static EwsTypesNamespace: string = "http://schemas.microsoft.com/exchange/services/2006/types";
    static EwsMessagesNamespace: string = "http://schemas.microsoft.com/exchange/services/2006/messages";
    static EwsErrorsNamespace: string = "http://schemas.microsoft.com/exchange/services/2006/errors";
    static EwsSoapNamespace: string = "http://schemas.xmlsoap.org/soap/envelope/";
    static EwsSoap12Namespace: string = "http://www.w3.org/2003/05/soap-envelope";
    static EwsXmlSchemaInstanceNamespace: string = "http://www.w3.org/2001/XMLSchema-instance";
    static PassportSoapFaultNamespace: string = "http://schemas.microsoft.com/Passport/SoapServices/SOAPFault";
    static WSTrustFebruary2005Namespace: string = "http://schemas.xmlsoap.org/ws/2005/02/trust";
    static WSAddressingNamespace: string = "http://www.w3.org/2005/08/addressing";
    static AutodiscoverSoapNamespace: string = "http://schemas.microsoft.com/exchange/2010/Autodiscover";
    static WSSecurityUtilityNamespace: string = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";
    static WSSecuritySecExtNamespace: string = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";

    /// <summary>
    /// Regular expression for legal domain names.
    /// </summary>
    static DomainRegex: string = "^[-a-zA-Z0-9_.]+$";
    //#endregion


    static BuildVersion: string;
    // private static serviceObjectInfo: LazyMember<ServiceObjectInfo> = new LazyMember<ServiceObjectInfo>(
    //     () => {
    //         //return new ServiceObjectInfo();
    //     });
    //private static buildVersion: LazyMember<T>;
    // private static enumVersionDictionaries: LazyMember<EnumToExhcangeVersionDelegateDictionary> = new LazyMember<EnumToExhcangeVersionDelegateDictionary>(
    //     () => {
    //         var e2evmh = EnumToExchangeVersionMappingHelper;
    //         var dict: EnumToExhcangeVersionDelegateDictionary = {};
    //         dict[e2evmh[e2evmh.WellKnownFolderName]] = EwsUtilities.BuildEnumDict(e2evmh.WellKnownFolderName);
    //         dict[e2evmh[e2evmh.ItemTraversal]] = EwsUtilities.BuildEnumDict(e2evmh.ItemTraversal);
    //         dict[e2evmh[e2evmh.ConversationQueryTraversal]] = EwsUtilities.BuildEnumDict(e2evmh.ConversationQueryTraversal);
    //         dict[e2evmh[e2evmh.FileAsMapping]] = EwsUtilities.BuildEnumDict(e2evmh.FileAsMapping);
    //         dict[e2evmh[e2evmh.EventType]] = EwsUtilities.BuildEnumDict(e2evmh.EventType);
    //         dict[e2evmh[e2evmh.MeetingRequestsDeliveryScope]] = EwsUtilities.BuildEnumDict(e2evmh.MeetingRequestsDeliveryScope);
    //         dict[e2evmh[e2evmh.ViewFilter]] = EwsUtilities.BuildEnumDict(e2evmh.ViewFilter);
    //         dict[e2evmh[e2evmh.MailboxType]] = EwsUtilities.BuildEnumDict(e2evmh.MailboxType);
    //         return dict;
    //     });
    // private static schemaToEnumDictionaries: LazyMember<DictionaryWithNumericKey<DictionaryWithStringKey<number>>> = new LazyMember<DictionaryWithNumericKey<DictionaryWithStringKey<number>>>(
    //     () => {
    //         var dict = new DictionaryWithNumericKey<DictionaryWithStringKey<number>>();
    //         dict.addUpdate(EnumToSchemaMappingHelper.WellKnownFolderName, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.WellKnownFolderName));
    //         dict.addUpdate(EnumToSchemaMappingHelper.ItemTraversal, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.ItemTraversal));
    //         dict.addUpdate(EnumToSchemaMappingHelper.ConversationQueryTraversal, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.ConversationQueryTraversal));
    //         dict.addUpdate(EnumToSchemaMappingHelper.FileAsMapping, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.FileAsMapping));
    //         dict.addUpdate(EnumToSchemaMappingHelper.EventType, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.EventType));
    //         dict.addUpdate(EnumToSchemaMappingHelper.MeetingRequestsDeliveryScope, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.MeetingRequestsDeliveryScope));
    //         dict.addUpdate(EnumToSchemaMappingHelper.ViewFilter, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.ViewFilter));
    //         dict.addUpdate(EnumToSchemaMappingHelper.MailboxType, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.EventType));
    //         return dict;
    //     });
    // private static enumToSchemaDictionaries: LazyMember<DictionaryWithNumericKey<DictionaryWithNumericKey<string>>>;
    //private static typeNameToShortNameMap: LazyMember<T>;

    static BoolToXSBool(value: boolean): string {
        var boolvalue = Convert.toBool(value)
        return boolvalue ? EwsUtilities.XSTrue : EwsUtilities.XSFalse;
        //throw new Error("EwsUtilities.ts - static BoolToXSBool : Not implemented.");
    }
    //static BuildEnumDict(enumType: System.Type): System.Collections.Generic.Dictionary<TKey, TValue>{ throw new Error("EwsUtilities.ts - static BuildEnumDict : Not implemented.");}
    //deviation - need to work with static data for enum to exchange version dict, there is no Attribute type system in javascript.
    // static BuildEnumDict(enumType: EnumToExchangeVersionMappingHelper): EnumVersionDelegate {
    //     var enumDelegate = (value: any) => { return ExchangeVersion.Exchange2007_SP1 };
    //     switch (enumType) {
    //         //TODO: fix numbering to named enum value if possible
    //         case EnumToExchangeVersionMappingHelper.WellKnownFolderName:
    //             enumDelegate = (value) => {
    //                 var enumVersion = ExchangeVersion.Exchange2007_SP1;
    //                 if (value <= 15) //<= WellKnownFolderName.VoiceMail
    //                     enumVersion = ExchangeVersion.Exchange2007_SP1;
    //                 else if (value >= 16 && value <= 26) //>= RecoverableItemsRoot && <= ArchiveRecoverableItemsPurges
    //                     enumVersion = ExchangeVersion.Exchange2010_SP1;
    //                 else if (value >= 27 && value <= 34) //>= SyncIssues && <= ToDoSearch
    //                     enumVersion = ExchangeVersion.Exchange2013;
    //                 else
    //                     enumVersion = ExchangeVersion.Exchange_Version_Not_Updated;

    //                 return enumVersion;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.ItemTraversal:
    //             enumDelegate = (value) => {
    //                 if (value <= 1) //<= ItemTraversal.SoftDeleted
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 else if (value == 2) // === Associated
    //                     return ExchangeVersion.Exchange2010;

    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.ConversationQueryTraversal:
    //             enumDelegate = (value) => {
    //                 if (value <= 1) //<= ConversationQueryTraversal.Deep
    //                     return ExchangeVersion.Exchange2013;
    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.FileAsMapping:
    //             enumDelegate = (value) => {
    //                 if (value <= 12) //<= FileAsMapping.SurnameSpaceGivenName
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 else if (value >= 13 && value <= 17) // >= DisplayName && <=Empty
    //                     return ExchangeVersion.Exchange2010;

    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.EventType:
    //             enumDelegate = (value) => {
    //                 if (value <= 6) //<= EventType.Created
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 else if (value == 7) // == FreeBusyChanged
    //                     return ExchangeVersion.Exchange2010_SP1;

    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.MeetingRequestsDeliveryScope:
    //             enumDelegate = (value) => {
    //                 if (value <= 2) //<= MeetingRequestsDeliveryScope.DelegatesAndSendInformationToMe
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 else if (value == 3) // == NoForward
    //                     return ExchangeVersion.Exchange2010_SP1;

    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.ViewFilter:
    //             enumDelegate = (value) => {
    //                 if (value <= 10) //<=ViewFilter.SuggestionsDelete
    //                     return ExchangeVersion.Exchange2013;

    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.MailboxType:
    //             enumDelegate = (value) => {
    //                 if (value <= 1) //<=MailboxType.OneOff
    //                     return ExchangeVersion.Exchange2010;
    //                 if (value <= 6) //<=MailboxType.Contact
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 if (value <= 7) //<=MailboxType.GroupMailbox
    //                     return ExchangeVersion.Exchange2015;

    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         default:
    //             throw new Error("EwsUtilities.ts - BuildEnumDict - no mapping available for this enumtype" + EnumToExchangeVersionMappingHelper[<number>enumType]);
    //     }

    //     return enumDelegate;
    // }
    /**@internal */
    //deviation - need to work with static data for enum to exchange version dict, there is no Attribute type system in javascript.
    static BuildEnumToSchemaDict(enumType: EnumToSchemaMappingHelper): Dictionary<number, string> { throw new Error("EwsUtilities.ts - static BuildEnumToSchemaDict : Not implemented."); }
    /**@internal */
    //deviation - need to work with static data for enum to exchange version dict, there is no Attribute type system in javascript.
    static BuildSchemaToEnumDict(enumType: EnumToSchemaMappingHelper): Dictionary<string, number> { throw new Error("EwsUtilities.ts - static BuildSchemaToEnumDict : Not implemented."); }

    static GetDictionaryKeyTypeEnum(dictionaryKeyType: DictionaryKeyType): any {
        switch (dictionaryKeyType) {
            case DictionaryKeyType.EmailAddressKey:
                return EmailAddressKey;
            case DictionaryKeyType.ImAddressKey:
                return ImAddressKey;
            case DictionaryKeyType.PhoneNumberKey:
                return PhoneNumberKey;
            case DictionaryKeyType.PhysicalAddressKey:
                return PhysicalAddressKey;
            default:
                throw new Error("EwsUtilities.ts - GetDictionaryKeyTypeEnum - invalid value: " + dictionaryKeyType);
        }
    }
    // private static GetExchangeVersionFromEnumDelegate(enumType: EnumToExchangeVersionMappingHelper, enumValue: number): ExchangeVersion {
    //     var delegate = this.enumVersionDictionaries.Member[EnumToExchangeVersionMappingHelper[enumType]];
    //     if (delegate && typeof delegate === 'function') {
    //         try {
    //             return delegate(enumValue);
    //         }
    //         catch (ex) { }
    //     }

    //     return ExchangeVersion.Exchange2007_SP1;
    // }
    static ConvertTime(dateTime: DateTime, sourceTimeZone: TimeZoneInfo, destinationTimeZone: TimeZoneInfo): DateTime {
        try {
            return TimeZoneInfo.ConvertTime(
                dateTime,
                sourceTimeZone,
                destinationTimeZone);
        }
        catch (ex)//ArgumentException
        {
            throw new TimeZoneConversionException(
                StringHelper.Format(
                    Strings.CannotConvertBetweenTimeZones,
                    EwsUtilities.DateTimeToXSDateTime(dateTime),
                    sourceTimeZone.DisplayName,
                    destinationTimeZone.DisplayName),
                ex);
        }
    }
    //static CopyStream(source: System.IO.Stream, target: System.IO.Stream): any{ throw new Error("EwsUtilities.ts - static CopyStream : Not implemented.");}
    static CountMatchingChars(str: string, charPredicate: any): number { throw new Error("EwsUtilities.ts - static CountMatchingChars : Not implemented."); }
    static CreateEwsObjectFromXmlElementName<TServiceObject extends ServiceObject>(service: ExchangeService, xmlElementName: string): TServiceObject {
        throw new Error("EwsUtilities - CreateEwsObjectFromXmlElementName: - this is moved in folderinfo/iteminfo classes to avoid circular loop caused by serviceobjectinfo class");
        //     //var itemClass = TypeSystem.GetObjectByClassName("Microsoft.Exchange.WebServices.Data." + xmlElementName
        //     debugger;

        //     //        var creationDelegate = EwsUtilities.serviceObjectInfo.Member.ServiceObjectConstructorsWithServiceParam[xmlElementName];
        //     //
        //     //        if (creationDelegate) {
        //     //            return creationDelegate(service);
        //     //        }
        //     //        else return null;

        //     //var itemClass = EwsUtilities.serviceObjectInfo.Member.XmlElementNameToServiceObjectClassMap[xmlElementName];
        //     //if (itemClass) {
        //     //    //return new itemClass(service);

        //     //    creationDelegate: CreateServiceObjectWithServiceParam;


        //     //    //if (EwsUtilities.serviceObjectInfo.Member.ServiceObjectConstructorsWithServiceParam.TryGetValue(itemClass, out creationDelegate)) {
        //     //    //    return (TServiceObject)creationDelegate(service);
        //     //    //}
        //     //    //else {
        //     //    //    throw new ArgumentException(Strings.NoAppropriateConstructorForItemClass);
        //     //    //}
        //     //}
        //     //else {
        //     //    return null; //default(TServiceObject);
        //     //}
    }
    //static CreateItemFromItemClass(itemAttachment: ItemAttachment, itemClass: System.Type, isNew: boolean): Item{ throw new Error("EwsUtilities.ts - static CreateItemFromItemClass : Not implemented.");}
    static CreateItemFromXmlElementName(itemAttachment: ItemAttachment, xmlElementName: string): Item { throw new Error("EwsUtilities.ts - static CreateItemFromXmlElementName : Not implemented."); }
    public static DateTimeToXSDate(date: DateTime): string { return DateTime.DateTimeToXSDate(date); }
    public static DateTimeToXSDateTime(dateTime: DateTime): string { return DateTime.DateTimeToXSDateTime(dateTime); }
    static DomainFromEmailAddress(emailAddress: string): string {
        var emailAddressParts: string[] = emailAddress.split('@');

        if (emailAddressParts.length != 2 || StringHelper.IsNullOrEmpty(emailAddressParts[1])) {
            throw new Error(Strings.InvalidEmailAddress);
        }

        return emailAddressParts[1];
    }
    static EwsToSystemDayOfWeek(dayOfTheWeek: DayOfTheWeek): DayOfWeek {
        if (dayOfTheWeek == DayOfTheWeek.Day ||
            dayOfTheWeek == DayOfTheWeek.Weekday ||
            dayOfTheWeek == DayOfTheWeek.WeekendDay) {
            throw new ArgumentException(
                StringHelper.Format("Cannot convert {0} to System.DayOfWeek enum value", dayOfTheWeek),
                "dayOfTheWeek");
        }
        else {
            return <DayOfWeek><any>dayOfTheWeek;
        }
    }

    static FindFirstItemOfType<T extends Item>(items: Item[], type: any): T {
        for (var item of items) {
            if (item instanceof type) {
                return <T>item;
            }
        }
    }
    //static ForEach(collection: System.Collections.Generic.IEnumerable<T>, action: any): any{ throw new Error("EwsUtilities.ts - static ForEach : Not implemented.");}
    //static FormatHttpHeaders(headers: System.Net.WebHeaderCollection): string{ throw new Error("EwsUtilities.ts - static FormatHttpHeaders : Not implemented.");}
    //static FormatHttpHeaders(sb: any, headers: System.Net.WebHeaderCollection): any{ throw new Error("EwsUtilities.ts - static FormatHttpHeaders : Not implemented.");}
    //static FormatHttpRequestHeaders(request: IEwsHttpWebRequest): string{ throw new Error("EwsUtilities.ts - static FormatHttpRequestHeaders : Not implemented.");}
    //static FormatHttpRequestHeaders(request: any): string{ throw new Error("EwsUtilities.ts - static FormatHttpRequestHeaders : Not implemented.");}
    private static FormatHttpResponseHeaders(response: any /*IEwsHttpWebResponse*/): string { throw new Error("EwsUtilities.ts - static FormatHttpResponseHeaders : Not implemented."); }
    static FormatLogMessage(entryKind: string, logEntry: string): string { throw new Error("EwsUtilities.ts - static FormatLogMessage : Not implemented."); }
    static FormatLogMessageWithXmlContent(entryKind: string, memoryStream: any): string { throw new Error("EwsUtilities.ts - static FormatLogMessageWithXmlContent : Not implemented."); }
    static GetEnumeratedObjectAt(objects: any, index: number): any { throw new Error("EwsUtilities.ts - static GetEnumeratedObjectAt : Not implemented."); }
    static GetEnumeratedObjectCount(objects: any): number { throw new Error("EwsUtilities.ts - static GetEnumeratedObjectCount : Not implemented."); }


    //static GetEnumSchemaName(enumType: System.Type, enumName: string): string{ throw new Error("EwsUtilities.ts - static GetEnumSchemaName : Not implemented.");}
    //static GetEnumVersion(enumType: System.Type, enumName: string): ExchangeVersion{ throw new Error("EwsUtilities.ts - static GetEnumVersion : Not implemented.");}
    //static GetItemTypeFromXmlElementName(xmlElementName: string): System.Type{ throw new Error("EwsUtilities.ts - static GetItemTypeFromXmlElementName : Not implemented.");}

    static GetNamespaceFromUri(namespaceUri: string): XmlNamespace {
        switch (namespaceUri) {
            case this.EwsErrorsNamespace:
                return XmlNamespace.Errors;
            case this.EwsTypesNamespace:
                return XmlNamespace.Types;
            case this.EwsMessagesNamespace:
                return XmlNamespace.Messages;
            case this.EwsSoapNamespace:
                return XmlNamespace.Soap;
            case this.EwsSoap12Namespace:
                return XmlNamespace.Soap12;
            case this.EwsXmlSchemaInstanceNamespace:
                return XmlNamespace.XmlSchemaInstance;
            case this.PassportSoapFaultNamespace:
                return XmlNamespace.PassportSoapFault;
            case this.WSTrustFebruary2005Namespace:
                return XmlNamespace.WSTrustFebruary2005;
            case this.WSAddressingNamespace:
                return XmlNamespace.WSAddressing;
            default:
                return XmlNamespace.NotSpecified;
        }
    }
    static GetNamespacePrefix(xmlNamespace: XmlNamespace): string {
        switch (xmlNamespace) {
            case XmlNamespace.Types:
                return EwsUtilities.EwsTypesNamespacePrefix;
            case XmlNamespace.Messages:
                return EwsUtilities.EwsMessagesNamespacePrefix;
            case XmlNamespace.Errors:
                return EwsUtilities.EwsErrorsNamespacePrefix;
            case XmlNamespace.Soap:
            case XmlNamespace.Soap12:
                return EwsUtilities.EwsSoapNamespacePrefix;
            case XmlNamespace.XmlSchemaInstance:
                return EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix;
            case XmlNamespace.PassportSoapFault:
                return EwsUtilities.PassportSoapFaultNamespacePrefix;
            case XmlNamespace.WSTrustFebruary2005:
                return EwsUtilities.WSTrustFebruary2005NamespacePrefix;
            case XmlNamespace.WSAddressing:
                return EwsUtilities.WSAddressingNamespacePrefix;
            case XmlNamespace.Autodiscover:
                return EwsUtilities.AutodiscoverSoapNamespacePrefix;
            default:
                return "";
        }
    }
    static GetNamespaceUri(xmlNamespace: XmlNamespace): string {
        switch (xmlNamespace) {
            case XmlNamespace.Types:
                return EwsUtilities.EwsTypesNamespace;
            case XmlNamespace.Messages:
                return EwsUtilities.EwsMessagesNamespace;
            case XmlNamespace.Errors:
                return EwsUtilities.EwsErrorsNamespace;
            case XmlNamespace.Soap:
                return EwsUtilities.EwsSoapNamespace;
            case XmlNamespace.Soap12:
                return EwsUtilities.EwsSoap12Namespace;
            case XmlNamespace.XmlSchemaInstance:
                return EwsUtilities.EwsXmlSchemaInstanceNamespace;
            case XmlNamespace.PassportSoapFault:
                return EwsUtilities.PassportSoapFaultNamespace;
            case XmlNamespace.WSTrustFebruary2005:
                return EwsUtilities.WSTrustFebruary2005Namespace;
            case XmlNamespace.WSAddressing:
                return EwsUtilities.WSAddressingNamespace;
            case XmlNamespace.Autodiscover:
                return EwsUtilities.AutodiscoverSoapNamespace;
            default:
                return "";
        }
    }


    public static GetPrintableTypeName(type: any /*instance */): string {
        var typename: string = typeof type;
        if (typename.indexOf("object") >= 0) {
            try {
                typename = type.__proto__.constructor.name;

            } catch (error) {
                typename += " - Error getting name";
            }
        }

        return typename;
        //         if (type.IsGenericType)
        //             {
        //                 // Convert generic type to printable form (e.g. List<Item>)
        //                 string genericPrefix = type.Name.Substring(0, type.Name.IndexOf('`'));
        //                 StringBuilder nameBuilder = new StringBuilder(genericPrefix);
        //
        //                 // Note: building array of generic parameters is done recursively. Each parameter could be any type.
        //                 string[] genericArgs = type.GetGenericArguments().ToList<Type>().ConvertAll<string>(t => GetPrintableTypeName(t)).ToArray<string>();
        //
        //                 nameBuilder.Append("<");
        //                 nameBuilder.Append(string.Join(",", genericArgs));
        //                 nameBuilder.Append(">");
        //                 return nameBuilder.ToString();
        //             }
        //             else if (type.IsArray)
        //             {
        //                 // Convert array type to printable form.
        //                 string arrayPrefix = type.Name.Substring(0, type.Name.IndexOf('['));
        //                 StringBuilder nameBuilder = new StringBuilder(EwsUtilities.GetSimplifiedTypeName(arrayPrefix));
        //                 for (int rank = 0; rank < type.GetArrayRank(); rank++)
        //                 {
        //                     nameBuilder.Append("[]");
        //                 }
        //                 return nameBuilder.ToString();
        //             }
        //             else
        //             {
        //                 return EwsUtilities.GetSimplifiedTypeName(type.Name);
        //             }
    }
    //static GetSimplifiedTypeName(typeName: string): string{ throw new Error("EwsUtilities.ts - static GetSimplifiedTypeName : Not implemented.");}
    static IsLocalTimeZone(timeZone: TimeZoneInfo): boolean {
        return (TimeZoneInfo.Local == timeZone) || (TimeZoneInfo.Local.Id == timeZone.Id && TimeZoneInfo.Local.HasSameRules(timeZone));
    }
    //static Parse(value: string): any{ throw new Error("EwsUtilities.ts - static Parse : Not implemented.");}
    static ParseEnum(value: string, ewsenum): any { throw new Error("EwsUtilities.ts - static Parse : Not implemented."); }
    static ParseAsUnbiasedDatetimescopedToServicetimeZone(dateString: string, service: ExchangeService): DateTime {
        // Convert the element's value to a DateTime with no adjustment.
        //var tempDate: DateTime = DateTime.Parse(dateString + "Z");

        // Set the kind according to the service's time zone
        if (service.TimeZone == TimeZoneInfo.Utc) {
            return DateTime.Parse(dateString, DateTimeKind.Utc);
        }
        else if (EwsUtilities.IsLocalTimeZone(service.TimeZone)) {
            return DateTime.Parse(dateString, DateTimeKind.Local);
        }
        else {
            return DateTime.DateimeStringToTimeZone(dateString, service.TimeZone.IanaId);
            //return DateTime.Parse(dateString, DateTimeKind.Unspecified);
        }
    }
    static ParseEnumValueList<T>(list: any[], value: string, separators: string, enumType: any): void {
        // EwsLogging.Assert(
        //         typeof(T).IsEnum,
        //         "EwsUtilities.ParseEnumValueList",
        //         "T is not an enum type.");

        if (!value) {
            return;
        }

        var enumValues: string[] = value.split(separators);

        for (var enumValue of enumValues) {
            var enumValueParsed = enumType[enumValue];
            if (typeof enumValueParsed !== 'undefined')
                list.push(enumValueParsed);
        }
    }
    //static SerializeEnum(value: any): string{ throw new Error("EwsUtilities.ts - static SerializeEnum : Not implemented.");}

    static SystemToEwsDayOfTheWeek(dayOfWeek: DayOfWeek): DayOfTheWeek {
        return <DayOfTheWeek><any>dayOfWeek;
    }

    static TimeSpanToXSDuration(timeSpan: TimeSpan): string {
        // Optional '-' offset
        var offsetStr: string = (timeSpan.TotalSeconds < 0) ? "-" : StringHelper.Empty;

        // The TimeSpan structure does not have a Year or Month
        // property, therefore we wouldn't be able to return an xs:duration
        // string from a TimeSpan that included the nY or nM components.
        return StringHelper.Format(
            "{0}P{1}DT{2}H{3}M{4}S",
            offsetStr,
            Math.abs(timeSpan.Days),
            Math.abs(timeSpan.Hours),
            Math.abs(timeSpan.Minutes),
            Math.abs(timeSpan.Seconds) + "." + Math.abs(timeSpan.Milliseconds));
    }
    private static numPad(num: number, length: number) {
        var str = num.toString();
        while (str.length < length)
            str = "0" + str;
        return str;
    }
    static TimeSpanToXSTime(timeSpan: TimeSpan): string {
        return StringHelper.Format(
            "{0}:{1}:{2}",
            this.numPad(timeSpan.Hours, 2),
            this.numPad(timeSpan.Minutes, 2),
            this.numPad(timeSpan.Seconds, 2));
    }
    static XSDurationToTimeSpan(xsDuration: string): TimeSpan {
        var regex: RegExp = /(-)?P(([0-9]+)Y)?(([0-9]+)M)?(([0-9]+)D)?(T(([0-9]+)H)?(([0-9]+)M)?(([0-9]+)(\.([0-9]+))?S)?)?/; //ref: info: not using \\, may be a bug in EWS managed api. does not match "-P2Y6M5DT12H35M30.4S" with \\ //old /(-)?P([0-9]+)Y?([0-9]+)M?([0-9]+)D?T([0-9]+)H?([0-9]+)M?([0-9]+\.[0-9]+)?S?/;

        if (xsDuration.match(regex) === null) {
            throw new ArgumentException(Strings.XsDurationCouldNotBeParsed);
        }
        return new TimeSpan(xsDuration);//using moment, it recognize the format.

    }
    //static TrueForAll(collection: System.Collections.Generic.IEnumerable<T>, predicate: any): boolean{ throw new Error("EwsUtilities.ts - static TrueForAll : Not implemented.");}

    static ValidateClassVersion(service: ExchangeService, minimumServerVersion: ExchangeVersion, className: string): void {
        if (service.RequestedServerVersion < minimumServerVersion) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ClassIncompatibleWithRequestVersion,
                    className,
                    ExchangeVersion[minimumServerVersion]));
        }
    }

    static ValidateDomainNameAllowNull(domainName: string, paramName: string): void {

        //todo: validate domain names per ews managed api

        //if (domainName != null) {
        //    Regex regex = new Regex(DomainRegex);

        //    if (!regex.IsMatch(domainName)) {
        //        throw new ArgumentException(string.Format(Strings.InvalidDomainName, domainName), paramName);
        //    }
        //}
    }

    /**
     * Validates the enum value against the request version.
     *
     * @param   {RequiredServerVersionEnums}   enumType        one of Enum type which has RequiredServerVersionAttrubute
     * @param   {number}            enumValue        The enum value.
     * @param   {ExchangeVersion}   requestVersion   The request version.
     * @param   {string}            name   The request version.
     */
    static ValidateEnumVersionValue(enumType: RequiredServerVersionEnums, enumValue: number, requestVersion: ExchangeVersion, name: string): void {
        //default is 2007_SP1
        var enumVersion = ExchangeVersion.Exchange2007_SP1;
        //if it has RequiredServerVersionAttrubute (ews-javascript-api, those enums has static function named 'RequiredServerVersion' )
        if (TypeGuards.hasRequiredServerVersionAttribute(enumType)) {
            enumVersion = enumType.RequiredServerVersion(enumValue);
        }

        if (requestVersion < enumVersion) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.EnumValueIncompatibleWithRequestVersion,
                    enumType[enumValue],
                    name,
                    ExchangeVersion[enumVersion]));
        }

    }
    static ValidateMethodVersion(service: ExchangeService, minimumServerVersion: ExchangeVersion, methodName: string): void {
        if (service.RequestedServerVersion < minimumServerVersion) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.MethodIncompatibleWithRequestVersion,
                    methodName,
                    ExchangeVersion[minimumServerVersion]));
        }
    }

    /**
     * Validates string parameter to be non-empty string (null value not allowed).
     *
     * @param   {string}   param       The string parameter.
     * @param   {string}   paramName   Name of the parameter.
     */
    static ValidateNonBlankStringParam(param: string, paramName: string): void {
        if (param == null) {
            throw new ArgumentNullException(paramName);
        }

        this.ValidateNonBlankStringParamAllowNull(param, paramName);
    }

    /**
     * Validates string parameter to be non-empty string (null value allowed).
     *
     * @param   {string}   param       The string parameter.
     * @param   {string}   paramName   Name of the parameter.
     */
    static ValidateNonBlankStringParamAllowNull(param: string, paramName: string): void {
        if (param) {
            // Non-empty string has at least one character which is *not* a whitespace character
            if (param.replace(/\s*/g, '').length === 0) {
                throw new ArgumentException(Strings.ArgumentIsBlankString, paramName);
            }
        }
    }

    /**
     * Validates parameter (null value not allowed).
     *
     * @param   {any}       param       The param.
     * @param   {string}    paramName   Name of the param.
     */
    static ValidateParam(param: any, paramName: string): void {
        var isValid = false;

        if (typeof (param) == "string") {
            isValid = !StringHelper.IsNullOrEmpty(param);
        }
        else {
            isValid = param != null && typeof (param) !== 'undefined';
        }

        if (!isValid) {
            throw new ArgumentNullException(paramName);
        }

        this.ValidateParamAllowNull(param, paramName);
    }

    /**
     * Validates parameter (and allows null value).
     *
     * @param   {any}       param       The param.
     * @param   {string}    paramName   Name of the param.
     */
    static ValidateParamAllowNull(param: any, paramName: string): void {
        var selfValidate: ISelfValidate = param;
        // look for null/undefined
        if (TypeGuards.isISelfValidate(selfValidate)) {//todo: interface detection for ISelfValidate
            try {
                selfValidate.Validate();
            }
            catch (e) {
                throw new ArgumentException(
                    Strings.ValidationFailed,
                    paramName,
                    e);
            }
        }

        let ewsObject: ServiceObject = param;

        if (ewsObject instanceof TypeContainer.ServiceObject) {
            if (ewsObject.IsNew) {
                throw new ArgumentException(Strings.ObjectDoesNotHaveId, paramName);
            }
        }
    }

    /**
     * Validates parameter collection.
     *
     * @param   {any[]}     collection   The collection.
     * @param   {string}    paramName    Name of the param.
     */
    static ValidateParamCollection(collection: any[], paramName: string): void {
        this.ValidateParam(collection, paramName);

        let count: number = 0;

        for (let obj of collection) {
            try {
                this.ValidateParam(obj, StringHelper.Format("collection[{0}]", count));
            }
            catch (e) {
                throw new ArgumentException(
                    StringHelper.Format("The element at position {0} is invalid", count),
                    paramName,
                    e);
            }

            count++;
        }

        if (count == 0) {
            throw new ArgumentException(Strings.CollectionIsEmpty, paramName);
        }
    }

    /**
     * Validates property version against the request version.
     *
     * @param   {ExchangeService}   service                The Exchange service.
     * @param   {ExchangeVersion}   minimumServerVersion   The minimum server version that supports the property.
     * @param   {string}            propertyName           Name of the property.
     */
    static ValidatePropertyVersion(service: ExchangeService, minimumServerVersion: ExchangeVersion, propertyName: string): void {
        if (service.RequestedServerVersion < minimumServerVersion) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.PropertyIncompatibleWithRequestVersion,
                    propertyName,
                    ExchangeVersion[minimumServerVersion]));
        }
    }
    static ValidateServiceObjectVersion(serviceObject: ServiceObject, requestVersion: ExchangeVersion): any { throw new Error("EwsUtilities.ts - static ValidateServiceObjectVersion : Not implemented."); }
    //static WriteTraceStartElement(writer: System.Xml.XmlWriter, traceTag: string, includeVersion: boolean): any{ throw new Error("EwsUtilities.ts - static WriteTraceStartElement : Not implemented.");}
}


export interface EnumToExhcangeVersionDelegateDictionary {
    [index: string]: EnumVersionDelegate;
}

export interface EnumVersionDelegate {
    (value: number): ExchangeVersion;
}



// todo: should be done
export class ExchangeServerInfo {
    MajorVersion: number;
    MinorVersion: number;
    MajorBuildNumber: number;
    MinorBuildNumber: number;
    VersionString: string;
    //private majorVersion: number;
    //private minorVersion: number;
    //private majorBuildNumber: number;
    //private minorBuildNumber: number;
    //private versionString: string;
    static Parse(jsObject: any /*JsonObject*/): ExchangeServerInfo {
        var exchangeServerInfo: ExchangeServerInfo = new ExchangeServerInfo();
        exchangeServerInfo.MajorVersion = Convert.toInt(jsObject["MajorVersion"]);
        exchangeServerInfo.MinorVersion = Convert.toInt(jsObject["MinorVersion"]);
        exchangeServerInfo.MajorBuildNumber = Convert.toInt(jsObject["MajorBuildNumber"]);
        exchangeServerInfo.MinorBuildNumber = Convert.toInt(jsObject["MinorBuildNumber"]);
        exchangeServerInfo.VersionString = jsObject["Version"];
        return exchangeServerInfo;
    }
    //    static Parse(reader: EwsServiceXmlReader): ExchangeServerInfo {
    //        EwsLogging.Assert(
    //            reader.HasAttributes,
    //            "ExchangeServerVersion.Parse",
    //            "Current element doesn't have attributes");
    //
    //        var info = new ExchangeServerInfo();
    //        info.MajorVersion = +(reader.ReadAttributeValue(XmlNamespace.Types, "MajorVersion"));
    //        info.MinorVersion = +(reader.ReadAttributeValue(XmlNamespace.Types, "MinorVersion"));
    //        info.MajorBuildNumber = +(reader.ReadAttributeValue(XmlNamespace.Types, "MajorBuildNumber"));
    //        info.MinorBuildNumber = +(reader.ReadAttributeValue(XmlNamespace.Types, "MinorBuildNumber"));
    //        info.VersionString = reader.ReadAttributeValue(XmlNamespace.Types, "Version");
    //        return info;
    //    }
    ToString(): string {
        //return string.Format("{0:d}.{1:d2}.{2:d4}.{3:d3}",
        return StringHelper.Format("{0}.{1}.{2}.{3}",
            this.MajorVersion,
            this.MinorVersion,
            this.MajorBuildNumber,
            this.MinorBuildNumber);
    }
}


export class ExchangeServiceBase {

    static AccountIsLocked: any /*System.Net.systemnet.HttpStatusCode*/ = 456;

    AcceptGzipEncoding: boolean;
    ClientRequestId: string;
    ConnectionGroupName: string;
    CookieContainer: any;//System.Net.CookieContainer;
    Credentials: ExchangeCredentials;
    HttpHeaders: { [index: string]: string };//System.Collections.Generic.IDictionary<string, string>;
    HttpResponseHeaders: { [index: string]: string };//System.Collections.Generic.IDictionary<string, string>;
    HttpWebRequestFactory: IEwsHttpWebRequestFactory;
    KeepAlive: boolean;
    PreAuthenticate: boolean;
    get RequestedServerVersion(): ExchangeVersion { return this.requestedServerVersion; }
    ReturnClientRequestId: boolean;
    SendClientLatencies: boolean;
    ServerInfo: ExchangeServerInfo;
    static SessionKey: any[];//System.Byte[];
    SuppressXmlVersionHeader: boolean;
    Timeout: number;
    get TimeZone(): TimeZoneInfo {
        return this.timeZone;
    }
    /**@internal */
    get TimeZoneDefinition(): TimeZoneDefinition {
        if (this.timeZoneDefinition == null) {
            this.timeZoneDefinition = new TimeZoneDefinition(this.TimeZone);
        }
        return this.timeZoneDefinition;
    }
    TraceEnabled: boolean;
    TraceFlags: TraceFlags;
    TraceListener: ITraceListener;
    UseDefaultCredentials: boolean;
    UserAgent: string;
    WebProxy: any;//System.Net.IWebProxy;

    //private acceptGzipEncoding: boolean;
    private clientRequestId: string;
    private connectionGroupName: string;
    //private cookieContainer: any;//System.Net.CookieContainer;
    private credentials: ExchangeCredentials;
    private ewsHttpWebRequestFactory: IEwsHttpWebRequestFactory;
    private httpHeaders: { [index: string]: string };//System.Collections.Generic.IDictionary<string, string>;
    private httpResponseHeaders: { [index: string]: string };//System.Collections.Generic.IDictionary<string, string>;
    private keepAlive: boolean;
    private OnResponseHeadersCaptured: Function;// ResponseHeadersCapturedHandler;
    private OnSerializeCustomSoapHeaders: Function;// CustomXmlSerializationDelegate;
    private preAuthenticate: boolean;
    private requestedServerVersion: ExchangeVersion = ExchangeVersion.Exchange2013_SP1;
    private returnClientRequestId: boolean;
    private sendClientLatencies: boolean;
    private serverInfo: ExchangeServerInfo;
    private timeout: number;
    protected timeZone: TimeZoneInfo = TimeZoneInfo.Local;

    private timeZoneDefinition: TimeZoneDefinition;
    private traceEnabled: boolean;
    private traceFlags: TraceFlags;
    private traceListener: ITraceListener;
    private useDefaultCredentials: boolean;
    private userAgent: string;
    private webProxy: any;//System.Net.IWebProxy;

    private static lockObj: any;
    private static binarySecret: any;//System.Byte[];
    private static defaultUserAgent: string;

    private xhrApi: IXHRApi = null;
    get XHRApi(): IXHRApi {
        return this.xhrApi || XHRFactory.XHRApi;
    }
    set XHRApi(xhrApi: IXHRApi) {
        this.xhrApi = xhrApi || XHRFactory.XHRApi;
    }

    constructor();
    constructor(timeZone: TimeZoneInfo);
    constructor(requestedServerVersion: ExchangeVersion);
    constructor(requestedServerVersion: ExchangeVersion, timeZone: TimeZoneInfo);
    constructor(service: ExchangeServiceBase);
    constructor(service: ExchangeServiceBase, requestedServerVersion: ExchangeVersion);

    constructor(
        versionServiceorTZ?: ExchangeVersion | ExchangeServiceBase | TimeZoneInfo,
        versionOrTZ?: ExchangeVersion | TimeZoneInfo
    ) {
        var argsLength = arguments.length;
        if (argsLength > 2) {
            throw new Error("ExchangeServiceBase.ts - ctor with " + argsLength + " parameters, invalid number of arguments, check documentation and try again.");
        }
        var timeZone: TimeZoneInfo = null;
        var requestedServerVersion: ExchangeVersion = ExchangeVersion.Exchange2013_SP1;
        var service: ExchangeServiceBase = null;

        if (argsLength >= 1) {
            if (versionServiceorTZ instanceof TimeZoneInfo) {
                timeZone = versionServiceorTZ;
            }
            else if (versionServiceorTZ instanceof ExchangeServiceBase) {
                service = versionServiceorTZ;
            }
            else if (typeof versionServiceorTZ === 'number') {
                requestedServerVersion = versionServiceorTZ;
            }
        }
        if (argsLength == 2) {
            if (versionOrTZ instanceof TimeZoneInfo) {
                if (typeof versionServiceorTZ !== 'number') {
                    throw new Error("ExchangeServiceBase.ts - ctor with " + argsLength + " parameters - incorrect uses of parameter at 1st position, it must be ExchangeVersion when using TimeZoneInfo at 2nd place");
                }
                timeZone = versionOrTZ;
            }
            else if (typeof versionOrTZ === 'number') {
                if (!(versionServiceorTZ instanceof ExchangeServiceBase)) {
                    throw new Error("ExchangeServiceBase.ts - ctor with " + argsLength + " parameters - incorrect uses of parameter at 1st position, it must be ExchangeServiceBase when using ExchangeVersion at 2nd place");
                }
                requestedServerVersion = versionOrTZ;
            }
        }



        this.requestedServerVersion = requestedServerVersion;

        if (service !== null && typeof service !== 'undefined') {
            this.useDefaultCredentials = service.useDefaultCredentials;
            this.credentials = service.credentials;
            this.traceEnabled = service.traceEnabled;
            this.traceListener = service.traceListener;
            this.traceFlags = service.traceFlags;
            this.timeout = service.timeout;
            this.preAuthenticate = service.preAuthenticate;
            this.userAgent = service.userAgent;
            //this.acceptGzipEncoding = service.acceptGzipEncoding;
            this.keepAlive = service.keepAlive;
            this.connectionGroupName = service.connectionGroupName;
            this.timeZone = service.timeZone;
            this.httpHeaders = service.httpHeaders;
            this.ewsHttpWebRequestFactory = service.ewsHttpWebRequestFactory;
        }

        if (timeZone !== null && typeof timeZone !== 'undefined') {
            this.timeZone = timeZone;
            //this.useDefaultCredentials = true; //ref: no default credential in node.js
        }
    }


    ConvertDateTimeToUniversalDateTimeString(value: DateTime): string {
        var dateTime: DateTime;

        switch (value.Kind) {
            case DateTimeKind.Unspecified:
                dateTime = EwsUtilities.ConvertTime(
                    value,
                    this.TimeZone,
                    TimeZoneInfo.Utc);

                break;
            case DateTimeKind.Local:
                dateTime = EwsUtilities.ConvertTime(
                    value,
                    TimeZoneInfo.Local,
                    TimeZoneInfo.Utc);

                break;
            default:
                // The date is already in UTC, no need to convert it.
                dateTime = value;

                break;
        }
        //debug://todo:iso string should work
        return dateTime.ToISOString();// ISO string should work .ToString("yyyy-MM-ddTHH:mm:ss.fffZ", CultureInfo.InvariantCulture);
    }
    ConvertStartDateToUnspecifiedDateTime(value: string): DateTime {
        //EwsLogging.Log("ExchangeServiceBase.ConvConvertStartDateToUnspecifiedDateTime : DateTimeOffset not implemented, check date values")
        value = value.substring(0, 10); //info: //ref: for DateTimeOffset substitution, this is being called only from recurring datetime StartDate and 
        if (StringHelper.IsNullOrEmpty(value)) {
            return null;
        }
        else {
            return DateTime.Parse(value);

            //let dateTimeOffset:DateTimeOffset = DateTimeOffset.Parse(value, CultureInfo.InvariantCulture);

            // Return only the date part with the kind==Unspecified.
            //return dateTimeOffset.Date;
        }
    }
    ConvertUniversalDateTimeStringToLocalDateTime(value: string): DateTime {
        if (StringHelper.IsNullOrEmpty(value)) {
            return null;
        }
        else {
            // Assume an unbiased date/time is in UTC. Convert to UTC otherwise.
            //ref: //fix: hard convert to UTC date as no request contains TZ information.
            if (value.toLowerCase().indexOf("z") < 0 && ["+", "-"].indexOf(value.substr(19, 1)) < 0) {
                value += "Z";
            }

            var dateTime: DateTime = DateTime.Parse(
                value);
            // CultureInfo.InvariantCulture,
            // DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal);

            if (this.TimeZone == TimeZoneInfo.Utc) {
                // This returns a DateTime with Kind.Utc
                return dateTime;
            }
            else {
                var localTime: DateTime = EwsUtilities.ConvertTime(

                    dateTime,
                    TimeZoneInfo.Utc,
                    this.TimeZone);

                if (EwsUtilities.IsLocalTimeZone(this.TimeZone)) {
                    // This returns a DateTime with Kind.Local
                    return new DateTime(localTime.TotalMilliSeconds, DateTimeKind.Local);
                }
                else {
                    // This returns a DateTime with Kind.Unspecified
                    return localTime;
                }
            }
        }
    }
    DoOnSerializeCustomSoapHeaders(writer: any /*System.Xml.XmlWriter*/): void {
        EwsLogging.Assert(
            writer != null,
            "ExchangeServiceBase.DoOnSerializeCustomSoapHeaders",
            "writer is null");

        if (this.OnSerializeCustomSoapHeaders != null) {
            this.OnSerializeCustomSoapHeaders(writer);
        }
    }

    /**
     * @internal Processes an HTTP error response
     *
     * /remarks/    This method doesn't handle 500 ISE errors. This is handled by the caller since 500 ISE typically indicates that a SOAP fault has occurred and the handling of a SOAP fault is currently service specific.
     * @param   {XMLHttpRequest}    httpWebResponse            The HTTP web response.
     * @param   {SoapFaultDetails}  webException               The web exception.
     * @param   {TraceFlags}        responseHeadersTraceFlag   The trace flag for response headers.
     * @param   {TraceFlags}        responseTraceFlag          The trace flag for responses.
     * 
     */
    InternalProcessHttpErrorResponse(httpWebResponse: XMLHttpRequest, soapFault: SoapFaultDetails, responseHeadersTraceFlag: TraceFlags, responseTraceFlag: TraceFlags): void {
        EwsLogging.Assert(
            httpWebResponse.status != 500, // HttpStatusCode.InternalServerError,
            "ExchangeServiceBase.InternalProcessHttpErrorResponse",
            "InternalProcessHttpErrorResponse does not handle 500 ISE errors, the caller is supposed to handle this.");

        this.ProcessHttpResponseHeaders(responseHeadersTraceFlag, httpWebResponse);

        let exception: Exception = null;
        // Deal with new HTTP error code indicating that account is locked.
        // The "unlock" URL is returned as the status description in the response.
        if (httpWebResponse.status == ExchangeServiceBase.AccountIsLocked) {
            EwsLogging.Assert(false, "ExchangeServiceBase.InternalProcessHttpErrorResponse", "Please report back to ews-javascript-api with example or response XML for future improvements of this code.");

            let location: string = httpWebResponse.getResponseHeader("StatusDescription");

            let accountUnlockUrl: Uri = null;

            //if (Uri.IsWellFormedUriString(location, UriKind.Absolute)) {
            if (Uri.ParseString(location).authority) { //todo: implement better Url parsing in Uri.
                accountUnlockUrl = new Uri(location);
            }

            this.TraceMessage(responseTraceFlag, StringHelper.Format("Account is locked. Unlock URL is {0}", accountUnlockUrl.ToString()));

            exception = new AccountIsLockedException(
                StringHelper.Format(Strings.AccountIsLocked, accountUnlockUrl),
                accountUnlockUrl,
                null);
        }
        else if (httpWebResponse.status === 401 /*Unauthorized*/) {
            exception = new ServiceRequestUnauthorizedException("401 Unauthorized");
        }

        if (exception) {
            if (soapFault !== null) {
                soapFault.Exception = exception;
                if (StringHelper.IsNullOrEmpty(soapFault.message) && !StringHelper.IsNullOrEmpty(exception.message)) {
                    soapFault.message = exception.message;
                }
            }
            else {
                throw exception;
            }
        }
    }

    IsTraceEnabledFor(traceFlags: TraceFlags): boolean { return this.TraceEnabled && ((this.TraceFlags & traceFlags) != 0); }
    PrepareHttpWebRequestForUrl(url: Uri, acceptGzipEncoding: boolean, allowAutoRedirect: boolean): IXHROptions /*IEwsHttpWebRequest*/ {
        // Verify that the protocol is something that we can handle
        if ((url.Scheme != Uri.UriSchemeHttp) && (url.Scheme != Uri.UriSchemeHttps)) {
            throw new ServiceLocalException("unsupported web protocol" + url);//string.Format(Strings.UnsupportedWebProtocol, url.Scheme));
        }
        var request: IXHROptions = { url: url.ToString() };
        request.headers = {};


        //request.PreAuthenticate = this.PreAuthenticate;
        //request.Timeout = this.Timeout; //todo: implement this within IPromise

        this.SetContentType(request);

        request.type = "POST";

        //request.headers["User-Agent"] = this.UserAgent || ExchangeServiceBase.defaultUserAgent; //todo:fix -> Noje.js is refusing to set this unsafe header -//
        //request.AllowAutoRedirect = allowAutoRedirect;

        //todo: figure out next 3 lines
        //request.CookieContainer = this.CookieContainer;
        //request.KeepAlive = this.keepAlive;
        //request.ConnectionGroupName = this.connectionGroupName;

        if (acceptGzipEncoding) {
            request.headers["Accept-Encoding"] = "gzip,deflate";
        }

        if (!StringHelper.IsNullOrEmpty(this.clientRequestId)) {
            request.headers["client-request-id"] = this.clientRequestId;
            if (this.returnClientRequestId) {
                request.headers["return-client-request-id"] = "true";
            }
        }

        //if (this.webProxy != null) {
        //    request.Proxy = this.webProxy;
        //}

        if (this.HttpHeaders) {
            for (var kv in this.HttpHeaders) {
                request.headers[kv] = this.HttpHeaders[kv];
            }
        }

        //request.UseDefaultCredentials = this.UseDefaultCredentials;
        if (!this.UseDefaultCredentials) {
            var serviceCredentials = this.Credentials;
            if (serviceCredentials == null) {
                throw new ServiceLocalException(Strings.CredentialsRequired);
            }

            // Make sure that credentials have been authenticated if required
            //serviceCredentials.PreAuthenticate(); //todo: fix preauthenticate if possible

            // Apply credentials to the request
            serviceCredentials.PrepareWebRequest(request);
        }
        // else
        //     debugger;

        this.httpResponseHeaders = {};

        return request;
    }
    ProcessHttpErrorResponse(httpWebResponse: XMLHttpRequest/*IEwsHttpWebResponse*/, webException: any): any { throw new Error("ExchangeServiceBase.ts - ProcessHttpErrorResponse : Not implemented."); }
    ProcessHttpResponseHeaders(traceType: TraceFlags, response: any): void {
        return;
        //todo: implement tracing
        this.TraceHttpResponseHeaders(traceType, response);

        this.SaveHttpResponseHeaders(response.Headers);
    }
    SaveHttpResponseHeaders(headers: IXHROptions/* System.Net.WebHeaderCollection*/): any {
        //debug:
        this.httpResponseHeaders = {};

        for (var key in headers.headers) {
            this.httpResponseHeaders[key] = headers.headers[key];
        }

        if (this.OnResponseHeadersCaptured != null) {
            this.OnResponseHeadersCaptured(headers);
        }
    }
    SetContentType(request: IXHROptions /*IEwsHttpWebRequest*/): void {
        request.headers["Content-Type"] = "text/xml; charset=utf-8";
        request.headers["Accept"] = "text/xml";
    }
    SetCustomUserAgent(userAgent: string): any { /*this.userAgent = userAgent;*/ }
    TraceHttpRequestHeaders(traceType: TraceFlags, request: any): any { throw new Error("ExchangeServiceBase.ts - TraceHttpRequestHeaders : Not implemented."); }
    TraceHttpResponseHeaders(traceType: TraceFlags, response: any): any { throw new Error("ExchangeServiceBase.ts - TraceHttpResponseHeaders : Not implemented."); }
    TraceMessage(traceType: TraceFlags, logEntry: string): any { EwsLogging.Log(logEntry); /*throw new Error("Not implemented."); */ }
    TraceXml(traceType: TraceFlags, stream: any): any { throw new Error("ExchangeServiceBase.ts - TraceXml : Not implemented."); }
    Validate(): any { }
}


/**
 * Represents a binding to the **Exchange Web Services**.
 *
 */
export class ExchangeService extends ExchangeServiceBase {

    /* #region Constants */
    private static TargetServerVersionHeaderName: string = "X-EWS-TargetVersion";
    /* #endregion Constants */


    /* #region Fields */
    private url: Uri = null;
    //private preferredCulture: any = null;// System.Globalization.CultureInfo;
    //private dateTimePrecision: DateTimePrecision = DateTimePrecision.Default;
    //private impersonatedUserId: ImpersonatedUserId = null;
    //private privilegedUserId: PrivilegedUserId = null;
    //private managementRoles: ManagementRoles = null;
    //private fileAttachmentContentHandler: IFileAttachmentContentHandler = null;
    private unifiedMessaging: UnifiedMessaging = null;
    //private enableScpLookup: boolean = false; //false for javascript, AD Lookup not implemented 
    private renderingMode: RenderingMode = RenderingMode.Xml;
    //private traceEnablePrettyPrinting: boolean = true;
    private targetServerVersion: string = null;
    //private exchange2007CompatibilityMode: boolean = false;
    /* #endregion Fields */


    /* #region Properties */
    Url: Uri;
    ImpersonatedUserId: ImpersonatedUserId = null;
    /**@internal */
    PrivilegedUserId: PrivilegedUserId = null;
    ManagementRoles: ManagementRoles = null;
    PreferredCulture: any = null;//System.Globalization.CultureInfo;
    DateTimePrecision: DateTimePrecision = DateTimePrecision.Default;
    FileAttachmentContentHandler: IFileAttachmentContentHandler = null;
    get TimeZone(): TimeZoneInfo {
        return this.timeZone;
    }
    get UnifiedMessaging(): UnifiedMessaging {
        if (this.unifiedMessaging === null) {
            this.unifiedMessaging = new UnifiedMessaging(this);
        }
        return this.unifiedMessaging;
    }
    get EnableScpLookup(): boolean { return false; } //false for javascript, AD Lookup not implemented
    Exchange2007CompatibilityMode: boolean = false;
    get RenderingMethod(): RenderingMode { return this.renderingMode; }
    TraceEnablePrettyPrinting: boolean = true;
    get TargetServerVersion(): string {
        return this.targetServerVersion;
    }
    set TargetServerVersion(value: string) {
        ExchangeService.ValidateTargetVersion(value);
        this.targetServerVersion = value;
    }
    /* #region Properties */



    /* #region Response object operations */
    /**
     * @internal Create response object.
     * 
     * @param   {ServiceObject}          responseObject       The response object.
     * @param   {FolderId}               parentFolderId       The parent folder id.
     * @param   {MessageDisposition}     messageDisposition   The message disposition.
     * @return  {Promise<Item[]>}        The list of items created or modified as a result of the "creation" of the response object :Promise.
     */
    InternalCreateResponseObject(responseObject: ServiceObject, parentFolderId: FolderId, messageDisposition: MessageDisposition): Promise<Item[]> {
        var request: CreateResponseObjectRequest = new CreateResponseObjectRequest(this, ServiceErrorHandling.ThrowOnError);
        request.ParentFolderId = parentFolderId;
        request.Items = [responseObject];
        request.MessageDisposition = messageDisposition;
        return request.Execute().then((responses) => {
            return responses.__thisIndexer(0).Items;
        });
    }
    /* #endregion Response object operations */


    /* #region Folder operations */

    /**
     * @internal Binds to folder.
     *
     * @param   {FolderId}           folderId      The folder id.
     * @param   {PropertySet}        propertySet   The property set.
     * @return  {Promise<TFolder>}   Folder object :Promise.
     */
    BindToFolder(folderId: FolderId, propertySet: PropertySet): Promise<Folder>;
    /**
     * @internal Binds to folder.
     *
     * @param   {FolderId}           folderId      The folder id.
     * @param   {PropertySet}        propertySet   The property set.
     * @param   {folderType}         propertySet   Type to Cast - pass Folder or subclass itself, not an instance
     * @return  {Promise<TFolder>}   Folder object :Promise.
     */
    BindToFolder<TFolder extends Folder>(folderId: FolderId, propertySet: PropertySet,/** pass Folder or subclass itself, not an instance */ folderType: any): Promise<TFolder>;
    BindToFolder(folderId: FolderId, propertySet: PropertySet, /** pass Folder or subclass itself, not an instance */ folderType: any = null): Promise<Folder> {
        EwsUtilities.ValidateParam(folderId, "folderId");
        EwsUtilities.ValidateParam(propertySet, "propertySet");

        var request: GetFolderRequest = new GetFolderRequest(this, ServiceErrorHandling.ThrowOnError);

        request.FolderIds.Add(folderId);
        request.PropertySet = propertySet;

        return request.Execute().then((responses) => {
            var result = responses.__thisIndexer(0).Folder;
            if (folderType != null && !(result instanceof folderType)) { //todo: validate folderType to be not a constructor
                throw new ServiceLocalException(
                    StringHelper.Format(
                        Strings.FolderTypeNotCompatible,
                        "Type detection not implemented - ExchangeService.ts - BindToFolder<TFolder>",
                        "Type detection not implemented"));
            }
            return result;
        });


    }
    /**
     * @internal Copies a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}           folderId              The folder id.
     * @param   {FolderId}           destinationFolderId   The destination folder id.
     * @return  {Promise<Folder>}    Copy of folder :Promise.
     */
    CopyFolder(folderId: FolderId, destinationFolderId: FolderId): Promise<Folder> {
        var request: CopyFolderRequest = new CopyFolderRequest(this, ServiceErrorHandling.ThrowOnError);

        request.DestinationFolderId = destinationFolderId;
        request.FolderIds.Add(folderId);

        return request.Execute().then((responses) => {
            return responses.__thisIndexer(0).Folder;
        });
    }
    /**
     * @internal Creates a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   folder           The folder.
     * @param   {FolderId}   parentFolderId   The parent folder id.
     */
    CreateFolder(folder: Folder, parentFolderId: FolderId): Promise<void> {
        var request: CreateFolderRequest = new CreateFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.Folders = [folder];
        request.ParentFolderId = parentFolderId;
        return <any>request.Execute();
    }

    /**
     * @internal Deletes a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      folderId     The folder id.
     * @param   {DeleteMode}    deleteMode   The delete mode.
     */
    DeleteFolder(folderId: FolderId, deleteMode: DeleteMode): Promise<void> {
        EwsUtilities.ValidateParam(folderId, "folderId");
        var request: DeleteFolderRequest = new DeleteFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.DeleteMode = deleteMode;
        return <any>request.Execute();
    }
    /**
     * @internal Empties a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      folderId           The folder id.
     * @param   {DeleteMode}    deleteMode         The delete mode.
     * @param   {boolean}       deleteSubFolders   if set to true empty folder should also delete sub folders.
     */
    EmptyFolder(folderId: FolderId, deleteMode: DeleteMode, deleteSubFolders: boolean): Promise<void> {
        EwsUtilities.ValidateParam(folderId, "folderId");
        var request: EmptyFolderRequest = new EmptyFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.DeleteMode = deleteMode;
        request.DeleteSubFolders = deleteSubFolders;
        return <any>request.Execute();
    }

    /**
     * Obtains a list of folders by searching the sub-folders of the specified folder.
     *
     * @param   {FolderId}                       parentFolderId   The Id of the folder in which to search for folders.
     * @param   {FolderView}                     view             The view controlling the number of folders returned.
     * @return  {Promise<FindFoldersResults>}    An object representing the results of the search operation :Promise.
     */
    FindFolders(parentFolderId: FolderId, view: FolderView): Promise<FindFoldersResults>;
    /**
     * Obtains a list of folders by searching the sub-folders of the specified folder.
     *
     * @param   {WellKnownFolderName}            parentFolderName   The name of the folder in which to search for folders.
     * @param   {FolderView}                     view               The view controlling the number of folders returned.
     * @return  {Promise<FindFoldersResults>}    An object representing the results of the search operation :Promise.
     */
    FindFolders(parentFolderName: WellKnownFolderName, view: FolderView): Promise<FindFoldersResults>;
    /**
     * Obtains a list of folders by searching the sub-folders of the specified folder.
     *
     * @param   {FolderId}                       parentFolderId   The Id of the folder in which to search for folders.
     * @param   {SearchFilter}                   searchFilter     The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {FolderView}                     view             The view controlling the number of folders returned.
     * @return  {Promise<FindFoldersResults>}    An object representing the results of the search operation :Promise.
     */
    FindFolders(parentFolderId: FolderId, searchFilter: SearchFilter, view: FolderView): Promise<FindFoldersResults>;
    /**
     * Obtains a list of folders by searching the sub-folders of the specified folder.
     *
     * @param   {WellKnownFolderName}            parentFolderName   The name of the folder in which to search for folders.
     * @param   {SearchFilter}                   searchFilter       The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {FolderView}                     view               The view controlling the number of folders returned.
     * @return  {Promise<FindFoldersResults>}    An object representing the results of the search operation :Promise.
     */
    FindFolders(parentFolderName: WellKnownFolderName, searchFilter: SearchFilter, view: FolderView): Promise<FindFoldersResults>;

    FindFolders(
        parentFolderIdOrName: FolderId | WellKnownFolderName,
        viewOrSearchFilter: FolderView | SearchFilter,
        folderView?: FolderView): Promise<FindFoldersResults> {
        //todo: better argument check with ewsutilities
        //EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");
        //EwsUtilities.ValidateParam(view, "view");
        //EwsUtilities.ValidateParamAllowNull(searchFilter, "searchFilter");
        var argsLength = arguments.length;
        if (argsLength < 2 && argsLength > 3) {
            throw new Error("ExchangeService.ts - FindFolders - invalid number of arguments, check documentation and try again.");
        }

        //position 1 - parentFolderIdOrName
        var parentFolderIds: FolderId[] = []
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderIds.push(new FolderId(parentFolderIdOrName));
        }
        else if (parentFolderIdOrName instanceof FolderId) {
            parentFolderIds.push(parentFolderIdOrName);
        }
        else {
            throw new Error("ExchangeService.ts - FindFolders - incorrect use of parameters, 1st argument must be Folder ID or WellKnownFolderName");
        }

        var searchFilter: SearchFilter = null;
        var view: FolderView = null;

        //position 2 - viewOrSearchFilter
        if (viewOrSearchFilter instanceof SearchFilter) {
            if (!(folderView instanceof FolderView)) {
                throw new Error("ExchangeService.ts - FindFolders with " + argsLength + " parameters - incorrect uses of parameter at 3nd position, it must be FolderView when using SearchFilter at 2nd place");
            }
            searchFilter = viewOrSearchFilter;
        }
        else if (viewOrSearchFilter instanceof FolderView) {
            view = viewOrSearchFilter;
        }
        else {
            throw new Error("ExchangeService.ts - FindFolders - incorrect uses of parameters at 2nd position, must be FolderView or SearchFilter");
        }

        //position 3 - folderView
        if (argsLength == 3) {
            view = folderView;
        }

        return this.InternalFindFolders(
            parentFolderIds,
            searchFilter, /* searchFilter */
            view,
            ServiceErrorHandling.ThrowOnError).then((responses) => {
                return responses.__thisIndexer(0).Results;
            });
    }
    /**
     * Finds folders.
     *
     * @param   {FolderId[]}             parentFolderIds     The parent folder ids.
     * @param   {SearchFilter}           searchFilter        The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {FolderView}             view                The view controlling the number of folders returned.
     * @param   {ServiceErrorHandling}   errorHandlingMode   Indicates the type of error handling should be done.
     * @return  {Promise<ServiceResponseCollection<FindFolderResponse>>}     Collection of service responses :Promise.
     */
    private InternalFindFolders(parentFolderIds: FolderId[], searchFilter: SearchFilter, view: FolderView, errorHandlingMode: ServiceErrorHandling): Promise<ServiceResponseCollection<FindFolderResponse>> {

        var request: FindFolderRequest = new FindFolderRequest(this, errorHandlingMode);

        request.ParentFolderIds.AddRange(parentFolderIds);
        request.SearchFilter = searchFilter;
        request.View = view;

        return request.Execute();
    }
    /**
     * @internal Load specified properties for a folder.
     *
     * @param   {Folder}         folder        The folder.
     * @param   {PropertySet}    propertySet   The property set.
     */
    LoadPropertiesForFolder(folder: Folder, propertySet: PropertySet): Promise<void> {
        EwsUtilities.ValidateParam(folder, "folder");
        EwsUtilities.ValidateParam(propertySet, "propertySet");

        var request: GetFolderRequestForLoad = new GetFolderRequestForLoad(this, ServiceErrorHandling.ThrowOnError);

        request.FolderIds.Add(folder);
        request.PropertySet = propertySet;

        return <any>request.Execute();
    }
    /**
     * @internal Marks all items in folder as read/unread. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      folderId               The folder id.
     * @param   {boolean}       readFlag               If true, items marked as read, otherwise unread.
     * @param   {boolean}       suppressReadReceipts   If true, suppress read receipts for items.
     */
    MarkAllItemsAsRead(folderId: FolderId, readFlag: boolean, suppressReadReceipts: boolean): Promise<void> {
        EwsUtilities.ValidateParam(folderId, "folderId");
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "MarkAllItemsAsRead");
        var request: MarkAllItemsAsReadRequest = new MarkAllItemsAsReadRequest(this, ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.ReadFlag = readFlag;
        request.SuppressReadReceipts = suppressReadReceipts;
        return <any>request.Execute();
    }
    /**
     * @internal Move a folder.
     *
     * @param   {FolderId}           folderId              The folder id.
     * @param   {FolderId}           destinationFolderId   The destination folder id.
     * @return  {Promise<Folder>}    Moved folder :Promise.
     */
    MoveFolder(folderId: FolderId, destinationFolderId: FolderId): Promise<Folder> {
        var request: MoveFolderRequest = new MoveFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.DestinationFolderId = destinationFolderId;
        request.FolderIds.Add(folderId);
        return request.Execute().then((responses) => {
            return responses.__thisIndexer(0).Folder;
        });
    }
    /**
     * @internal Updates a folder.
     *
     * @param   {Folder}   folder   The folder.
     */
    UpdateFolder(folder: Folder): Promise<void> {
        var request: UpdateFolderRequest = new UpdateFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.Folders.push(folder);
        return request.Execute().then((value) => {
            return null;
        });
    }
    /* #endregion Folder operations */


    /* #region Item operations */

    /**
     * Archives multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}   itemIds          The Ids of the items to move.
     * @param   {FolderId}   sourceFolderId   The Id of the folder in primary corresponding to which items are being archived to.
     * @return  {Promise<ServiceResponseCollection<ArchiveItemResponse>>}                     A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    ArchiveItems<TResponse extends ServiceResponse>(itemIds: ItemId[], sourceFolderId: FolderId): Promise<ServiceResponseCollection<ArchiveItemResponse>> {
        var request: ArchiveItemRequest = new ArchiveItemRequest(this, ServiceErrorHandling.ReturnErrors);
        request.Ids.AddRange(itemIds);
        request.SourceFolderId = sourceFolderId;
        return request.Execute();
    }
    /* //ref: new method, //todo: implement other newer code from ews managed api repo  */
    /**
     * Binds to multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}      itemIds         The Ids of the items to bind to.
     * @param   {PropertySet}   propertySet     The set of properties to load.
     * @param   {string}        anchorMailbox   The SmtpAddress of mailbox that hosts all items we need to bind to
     * @return  {Promise<ServiceResponseCollection<GetItemResponse>>}                    A ServiceResponseCollection providing results for each of the specified item Ids :Promise.
     */
    BindToGroupItems(itemIds: ItemId[], propertySet: PropertySet, anchorMailbox: string): Promise<ServiceResponseCollection<GetItemResponse>> {
        EwsUtilities.ValidateParamCollection(itemIds, "itemIds");
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        EwsUtilities.ValidateParam(propertySet, "anchorMailbox");

        return this.InternalBindToItems(
            itemIds,
            propertySet,
            anchorMailbox,
            ServiceErrorHandling.ReturnErrors);
    }
    /**
     * @internal Binds to item.
     *
     * @param   {ItemId}            itemId        The item id.
     * @param   {PropertySet}       propertySet   The property set.
     * @return  {Promise<Item>}     Item :Promise.
     */
    BindToItem(itemId: ItemId, propertySet: PropertySet): Promise<Item>;
    /**
     * @internal Binds to item.
     *
     * @param   {ItemId}            itemId        The item id.
     * @param   {PropertySet}       propertySet   The property set.
     * @param   {<TItem>}           itemType      Item type class ex: Item, EmailMessage etc..
     * @return  {Promise<Item>}     Item :Promise.
     */
    BindToItem<TItem extends Item>(itemId: ItemId, propertySet: PropertySet, itemType: typeof Item /* pass Item or subclass itself, not instance */): Promise<TItem>;
    BindToItem(itemId: ItemId, propertySet: PropertySet,/** pass Item or subclass itself, not an instance */ itemType: typeof Item = null): Promise<Item> {

        EwsUtilities.ValidateParam(itemId, "itemId");
        EwsUtilities.ValidateParam(propertySet, "propertySet");

        return this.InternalBindToItems(
            [itemId],
            propertySet,
            null, /* anchorMailbox */
            ServiceErrorHandling.ThrowOnError).then((response) => {
                var result = response.__thisIndexer(0).Item;
                if (itemType != null && !(result instanceof itemType)) { //todo: validate itemType to be not a constructor
                    throw new ServiceLocalException(
                        StringHelper.Format(
                            Strings.ItemTypeNotCompatible,
                            "Type detection not implemented - ExchangeService.ts - BindToItem<TItem>",
                            "Type detection not implemented"));
                }

                return result;
            });
    }
    /**
     * Binds to multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}      itemIds       The Ids of the items to bind to.
     * @param   {PropertySet}   propertySet   The set of properties to load.
     * @return  {Promise<ServiceResponseCollection<GetItemResponse>>}                  A ServiceResponseCollection providing results for each of the specified item Ids :Promise.
     */
    BindToItems(itemIds: ItemId[], propertySet: PropertySet): Promise<ServiceResponseCollection<GetItemResponse>> {
        EwsUtilities.ValidateParamCollection(itemIds, "itemIds");
        EwsUtilities.ValidateParam(propertySet, "propertySet");

        return this.InternalBindToItems(
            itemIds,
            propertySet,
            null, /* anchorMailbox */
            ServiceErrorHandling.ReturnErrors);
    }
    /**
     * @internal Copies an item. Calling this method results in a call to EWS.
     *
     * @param   {ItemId}        itemId                The Id of the item to copy.
     * @param   {FolderId}      destinationFolderId   The Id of the folder to copy the item to.
     * @return  {Promise<Item>}     The copy of the item :Promise.
     */
    CopyItem(itemId: ItemId, destinationFolderId: FolderId): Promise<Item> {
        return this.InternalCopyItems(
            [itemId],
            destinationFolderId,
            null,
            ServiceErrorHandling.ThrowOnError).then((response) => {
                return response.__thisIndexer(0).Item;
            });
    }
    /**
     * Copies multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}      itemIds               The Ids of the items to copy.
     * @param   {FolderId}      destinationFolderId   The Id of the folder to copy the items to.
     * @return  {Promise<ServiceResponseCollection<MoveCopyItemResponse>>}                          A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    CopyItems(itemIds: ItemId[], destinationFolderId: FolderId): Promise<ServiceResponseCollection<MoveCopyItemResponse>>;
    /**
     * Copies multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}      itemIds               The Ids of the items to copy.
     * @param   {FolderId}      destinationFolderId   The Id of the folder to copy the items to.
     * @param   {boolean}       returnNewItemIds      Flag indicating whether service should return new ItemIds or not.
     * @return  {Promise<ServiceResponseCollection<MoveCopyItemResponse>>}                          A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    CopyItems(itemIds: ItemId[], destinationFolderId: FolderId, returnNewItemIds: boolean): Promise<ServiceResponseCollection<MoveCopyItemResponse>>;
    CopyItems(itemIds: ItemId[], destinationFolderId: FolderId, returnNewItemIds: boolean = null): Promise<ServiceResponseCollection<MoveCopyItemResponse>> {
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2010_SP1,
            "CopyItems");

        return this.InternalCopyItems(
            itemIds,
            destinationFolderId,
            returnNewItemIds,
            ServiceErrorHandling.ReturnErrors);
    }
    /**
     * @internal Creates an item. Calling this method results in a call to EWS.
     *
     * @param   {Item}                  item                  The item to create.
     * @param   {FolderId}              parentFolderId        The Id of the folder in which to place the newly created item. If null, the item is created in its default folders.
     * @param   {MessageDisposition}    messageDisposition    Indicates the disposition mode for items of type EmailMessage. Required if item is an EmailMessage instance.
     * @param   {SendInvitationsMode}   sendInvitationsMode   Indicates if and how invitations should be sent for item of type Appointment. Required if item is an Appointment instance.
     */
    CreateItem(item: Item, parentFolderId: FolderId, messageDisposition: MessageDisposition, sendInvitationsMode: SendInvitationsMode): Promise<void> {
        return <any>this.InternalCreateItems(
            [item],
            parentFolderId,
            messageDisposition,
            sendInvitationsMode,
            ServiceErrorHandling.ThrowOnError);
    }
    /**
     * Creates multiple items in a single EWS call. Supported item classes are EmailMessage, Appointment, Contact, PostItem, Task and Item. CreateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                items                 The items to create.
     * @param   {FolderId}              parentFolderId        The Id of the folder in which to place the newly created items. If null, items are created in their default folders.
     * @param   {MessageDisposition}    messageDisposition    Indicates the disposition mode for items of type EmailMessage. Required if items contains at least one EmailMessage instance.
     * @param   {SendInvitationsMode}   sendInvitationsMode   Indicates if and how invitations should be sent for items of type Appointment. Required if items contains at least one Appointment instance.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}                          A ServiceResponseCollection providing creation results for each of the specified items :Promise.
     */
    CreateItems(items: Item[], parentFolderId: FolderId, messageDisposition: MessageDisposition, sendInvitationsMode: SendInvitationsMode): Promise<ServiceResponseCollection<ServiceResponse>> {
        // All items have to be new.
        if (!items.every((item) => item.IsNew)) {
            throw new ServiceValidationException(Strings.CreateItemsDoesNotHandleExistingItems);
        }

        // Make sure that all items do *not* have unprocessed attachments.
        if (!items.every((item) => !item.HasUnprocessedAttachmentChanges())) {
            throw new ServiceValidationException(Strings.CreateItemsDoesNotAllowAttachments);
        }

        return this.InternalCreateItems(
            items,
            parentFolderId,
            messageDisposition,
            sendInvitationsMode,
            ServiceErrorHandling.ReturnErrors);
    }
    /**
     * @internal Deletes an item. Calling this method results in a call to EWS.
     *
     * @param   {ItemId}                    itemId                    The Id of the item to delete.
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether cancellation messages should be sent. Required if the item Id represents an Appointment.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicates which instance of a recurring task should be deleted. Required if item Id represents a Task.
     */
    DeleteItem(itemId: ItemId, deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence): Promise<void>;
    /**
     * @internal Deletes an item. Calling this method results in a call to EWS.
     *
     * @param   {ItemId}                    itemId                    The Id of the item to delete.
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether cancellation messages should be sent. Required if the item Id represents an Appointment.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicates which instance of a recurring task should be deleted. Required if item Id represents a Task.
     * @param   {boolean}                   suppressReadReceipts      Whether to suppress read receipts
     */
    DeleteItem(itemId: ItemId, deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence, suppressReadReceipts: boolean): Promise<void>;
    DeleteItem(itemId: ItemId, deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence, suppressReadReceipts: boolean = false): Promise<void> {
        EwsUtilities.ValidateParam(itemId, "itemId");

        return <any>this.InternalDeleteItems(
            [itemId],
            deleteMode,
            sendCancellationsMode,
            affectedTaskOccurrences,
            ServiceErrorHandling.ThrowOnError,
            suppressReadReceipts);
    }
    /**
     * Deletes multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}                  itemIds                   The Ids of the items to delete.
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether cancellation messages should be sent. Required if the item Id represents an Appointment.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicates which instance of a recurring task should be deleted. Required if item Id represents a Task.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing deletion results for each of the specified item Ids :Promise.
     */
    DeleteItems(itemIds: ItemId[], deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence): Promise<ServiceResponseCollection<ServiceResponse>>;
    /**
     * Deletes multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}                  itemIds                   The Ids of the items to delete.
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether cancellation messages should be sent. Required if the item Id represents an Appointment.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicates which instance of a recurring task should be deleted. Required if item Id represents a Task.
     * @param   {boolean}                   suppressReadReceipts      Whether to suppress read receipts
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing deletion results for each of the specified item Ids :Promise.
     */
    DeleteItems(itemIds: ItemId[], deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence, suppressReadReceipt: boolean): Promise<ServiceResponseCollection<ServiceResponse>>;
    DeleteItems(itemIds: ItemId[], deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence, suppressReadReceipt: boolean = false): Promise<ServiceResponseCollection<ServiceResponse>> {
        EwsUtilities.ValidateParamCollection(itemIds, "itemIds");
        return this.InternalDeleteItems(
            itemIds,
            deleteMode,
            sendCancellationsMode,
            affectedTaskOccurrences,
            ServiceErrorHandling.ReturnErrors,
            suppressReadReceipt);
    }
    /**
     * Obtains a list of appointments by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   parentFolderName   The name of the calendar folder in which to search for items.
     * @param   {CalendarView}          calendarView     The calendar view controlling the number of appointments returned.
     * @return  {Promise<FindItemsResults<Appointment>>}                     A collection of appointments representing the contents of the specified folder :Promise.
     */
    FindAppointments(parentFolderName: WellKnownFolderName, calendarView: CalendarView): Promise<FindItemsResults<Appointment>>;
    /**
     * Obtains a list of appointments by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      parentFolderId   The id of the calendar folder in which to search for items.
     * @param   {CalendarView}  calendarView     The calendar view controlling the number of appointments returned.
     * @return  {Promise<FindItemsResults<Appointment>>}                     A collection of appointments representing the contents of the specified folder :Promise.
     */
    FindAppointments(parentFolderId: FolderId, calendarView: CalendarView): Promise<FindItemsResults<Appointment>>;
    FindAppointments(parentFolderIdOrName: FolderId | WellKnownFolderName, calendarView: CalendarView): Promise<FindItemsResults<Appointment>> {
        var parentFolderId: FolderId = <FolderId>parentFolderIdOrName;
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderId = new FolderId(parentFolderIdOrName);
        }
        return this.FindItems<Appointment>(
            [parentFolderId],
            null, /* searchFilter */
            null, /* queryString */
            calendarView,
            null, /* groupBy */
            ServiceErrorHandling.ThrowOnError).then((response) => {
                return response.__thisIndexer(0).Results;
            });
    }

    /**
     * Obtains a list of items by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   parentFolderName        The name of the folder in which to search for items.
     * @param   {ViewBase}              view                    The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}               An object representing the results of the search operation :Promise.
     */
    FindItems(parentFolderName: WellKnownFolderName, view: ViewBase): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a list of items by searching the contents of a specific folder. Along with conversations, a list of highlight terms are returned. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}  parentFolderId         The Id of the folder in which to search for items.
     * @param   {ViewBase}  view                   The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}       An object representing the results of the search operation :Promise.
     */
    FindItems(parentFolderId: FolderId, view: ViewBase): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a grouped list of items by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      parentFolderId          The Id of the folder in which to search for items.
     * @param   {ViewBase}      view                    The view controlling the number of items returned.
     * @param   {Grouping}      groupBy                 The group by clause.
     * @return  {Promise<GroupedFindItemsResults<Item>>}        A collection of grouped items representing the contents of the specified :Promise.
     */
    FindItems(parentFolderId: FolderId, view: ViewBase, groupBy: Grouping): Promise<GroupedFindItemsResults<Item>>;
    /**
     * Obtains a list of items by searching the contents of a specific folder. Along with conversations, a list of highlight terms are returned. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}  parentFolderId         The Id of the folder in which to search for items.
     * @param   {string}    queryString            The search string to be used for indexed search, if any.
     * @param   {ViewBase}  view                   The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}       An object representing the results of the search operation :Promise.
     */
    FindItems(parentFolderId: FolderId, queryString: string, view: ViewBase): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a list of items by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   parentFolderName        The name of the folder in which to search for items.
     * @param   {string}                queryString             The search string to be used for indexed search, if any.
     * @param   {ViewBase}              view                    The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}               An object representing the results of the search operation :Promise.
     */
    FindItems(parentFolderName: WellKnownFolderName, queryString: string, view: ViewBase): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a list of items by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   parentFolderName        The name of the folder in which to search for items.
     * @param   {searchFilter}          searchFilter            The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {ViewBase}              view                    The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}               An object representing the results of the search operation :Promise.
     */
    FindItems(parentFolderName: WellKnownFolderName, searchFilter: SearchFilter, view: ViewBase): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a list of items by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      parentFolderId          The Id of the folder in which to search for items.
     * @param   {searchFilter}  searchFilter            The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {ViewBase}      view                    The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}       An object representing the results of the search operation :Promise.
     */
    FindItems(parentFolderId: FolderId, searchFilter: SearchFilter, view: ViewBase): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a grouped list of items by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      parentFolderId          The Id of the folder in which to search for items.
     * @param   {searchFilter}  searchFilter            The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {ViewBase}      view                    The view controlling the number of items returned.
     * @param   {Grouping}      groupBy                 The group by clause.
     * @return  {Promise<GroupedFindItemsResults<Item>>}        A collection of grouped items representing the contents of the specified :Promise.
     */
    FindItems(parentFolderId: FolderId, searchFilter: SearchFilter, view: ViewBase, groupBy: Grouping): Promise<GroupedFindItemsResults<Item>>;
    /**
     * Obtains a grouped list of items by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      parentFolderId          The Id of the folder in which to search for items.
     * @param   {string}        queryString             The search string to be used for indexed search, if any.
     * @param   {ViewBase}      view                    The view controlling the number of items returned.
     * @param   {Grouping}      groupBy                 The group by clause.
     * @return  {Promise<GroupedFindItemsResults<Item>>}        A collection of grouped items representing the contents of the specified :Promise.
     */
    FindItems(parentFolderId: FolderId, queryString: string, view: ViewBase, groupBy: Grouping): Promise<GroupedFindItemsResults<Item>>;
    /**
     * Obtains a grouped list of items by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   parentFolderName        The name of the folder in which to search for items.
     * @param   {searchFilter}          searchFilter            The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {ViewBase}              view                    The view controlling the number of items returned.
     * @param   {Grouping}              groupBy                 The group by clause.
     * @return  {Promise<GroupedFindItemsResults<Item>>}        A collection of grouped items representing the contents of the specified :Promise.
     */
    FindItems(parentFolderName: WellKnownFolderName, searchFilter: SearchFilter, view: ViewBase, groupBy: Grouping): Promise<GroupedFindItemsResults<Item>>;
    /**
     * Obtains a grouped list of items by searching the contents of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   parentFolderName        The name of the folder in which to search for items.
     * @param   {string}                queryString             The search string to be used for indexed search, if any.
     * @param   {ViewBase}              view                    The view controlling the number of items returned.
     * @param   {Grouping}              groupBy                 The group by clause.
     * @return  {Promise<GroupedFindItemsResults<Item>>}        A collection of grouped items representing the contents of the specified :Promise.
     */
    FindItems(parentFolderName: WellKnownFolderName, queryString: string, view: ViewBase, groupBy: Grouping): Promise<GroupedFindItemsResults<Item>>;
    /**
     * Obtains a list of items by searching the contents of a specific folder. Along with conversations, a list of highlight terms are returned. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}  parentFolderId         The Id of the folder in which to search for items.
     * @param   {string}    queryString            the search string to be used for indexed search, if any.
     * @param   {boolean}   returnHighlightTerms   Flag indicating if highlight terms should be returned in the response
     * @param   {ViewBase}  view                   The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}       An object representing the results of the search operation :Promise.
     */
    FindItems(parentFolderId: FolderId, queryString: string, returnHighlightTerms: boolean, view: ViewBase): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a list of items by searching the contents of a specific folder. Along with conversations, a list of highlight terms are returned. Calling this method results in a call to EWS.     
     *
     * @param   {FolderId}  parentFolderId         The Id of the folder in which to search for items.
     * @param   {string}    queryString            the search string to be used for indexed search, if any.
     * @param   {boolean}   returnHighlightTerms   Flag indicating if highlight terms should be returned in the response
     * @param   {ViewBase}  view                   The view controlling the number of items returned.
     * @param   {Grouping}  groupBy                The group by clause.
     * @return  {Promise<GroupedFindItemsResults<Item>>}        An object representing the results of the search operation :Promise.
     */
    FindItems(parentFolderId: FolderId, queryString: string, returnHighlightTerms: boolean, view: ViewBase, groupBy: Grouping): Promise<GroupedFindItemsResults<Item>>;
    /**
     * @internal Finds items.
     *
     * @param   {FolderId[]}                parentFolderIds     The parent folder ids.
     * @param   {SearchFilter}              searchFilter        The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {string}                    queryString         query string to be used for indexed search.
     * @param   {ViewBase}                  view                The view controlling the number of items returned.
     * @param   {Grouping}                  groupBy             The group by.
     * @param   {ServiceErrorHandling}      errorHandlingMode   Indicates the type of error handling should be done.
     * @return  {Promise<ServiceResponseCollection<FindItemResponse<TItem>>>}       Service response collection :Promise.
     */
    FindItems<TItem extends Item>(parentFolderIds: FolderId[], searchFilter: SearchFilter, queryString: string, view: ViewBase, groupBy: Grouping, errorHandlingMode: ServiceErrorHandling): Promise<ServiceResponseCollection<FindItemResponse<TItem>>>;
    //skipped: not needed, no calls coming in to this internal function in ews managed api, future use possible until them keep it muted   - 
    //FindItems<TItem extends Item>(parentFolderId: FolderId, searchFilter: SearchFilter, view: ViewBase, groupBy: Grouping): Promise<ServiceResponseCollection<FindItemResponse<TItem>>>;

    FindItems<TItem extends Item>(
        nameIdOrIds: WellKnownFolderName | FolderId | FolderId[],
        viewQueryStringOrSearchFilter: ViewBase | string | SearchFilter,
        groupByViewRHTOrQueryString?: Grouping | ViewBase | boolean | string,
        groupByOrView?: Grouping | ViewBase,
        groupBy?: Grouping,
        errorHandlingMode: ServiceErrorHandling = ServiceErrorHandling.ThrowOnError
    ): Promise<FindItemsResults<Item> | GroupedFindItemsResults<Item> | ServiceResponseCollection<FindItemResponse<TItem>>> {

        //todo: better argument check with ewsutilities

        //EwsUtilities.ValidateParamAllowNull(searchFilter, "searchFilter");
        //EwsUtilities.ValidateParam(groupBy, "groupBy");
        //EwsUtilities.ValidateParamAllowNull(queryString, "queryString");
        //EwsUtilities.ValidateParamCollection(parentFolderIds, "parentFolderIds");
        //EwsUtilities.ValidateParam(view, "view");
        //EwsUtilities.ValidateParam(groupBy, "groupBy");
        //EwsUtilities.ValidateParamAllowNull(queryString, "queryString");
        //EwsUtilities.ValidateParamAllowNull(returnHighlightTerms, "returnHighlightTerms");
        //EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "FindItems");

        var argsLength = arguments.length;
        if (argsLength < 2 && argsLength > 6) {
            throw new Error("ExchangeService.ts - FindItems - invalid number of arguments, check documentation and try again.");
        }

        //position 1 - nameIdOrIds
        var parentIds: FolderId[] = []
        if (typeof nameIdOrIds === 'number') {
            parentIds.push(new FolderId(nameIdOrIds));
        }
        else if (nameIdOrIds instanceof FolderId) {
            parentIds.push(nameIdOrIds);
        }
        else if (Array.isArray(nameIdOrIds)) {
            parentIds = <FolderId[]>nameIdOrIds;
        }

        var queryString: string = null;
        var searchFilter: SearchFilter = null;
        var view: ViewBase = null;

        //position 2 - viewQueryStringOrSearchFilter
        if (argsLength >= 2)
            if (typeof viewQueryStringOrSearchFilter === 'string') {
                queryString = viewQueryStringOrSearchFilter;
            }
            else if (viewQueryStringOrSearchFilter instanceof SearchFilter) {
                searchFilter = viewQueryStringOrSearchFilter;
            }
            else if (viewQueryStringOrSearchFilter instanceof ViewBase) {
                view = viewQueryStringOrSearchFilter;
            }
            else if (viewQueryStringOrSearchFilter) { //error if not null
                throw new Error("ExchangeService.ts - FindItems - incorrect uses of parameters at 2nd position, must be string, ViewBase or SearchFilter");
            }

        var groupResultBy: Grouping = null;
        var returnHighlightTerms: boolean = false;
        var isGroupped: boolean = false; // to resturn GroupedFindItemsResults<Item>

        //position 3 - groupByViewRHTOrQueryString
        if (argsLength >= 3) {
            if (groupByViewRHTOrQueryString instanceof Grouping) {
                if (!(viewQueryStringOrSearchFilter instanceof ViewBase)) {
                    throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 3nd position, it must be ViewBase when using Grouping at 4th place");
                }
                groupResultBy = groupByViewRHTOrQueryString;
                isGroupped = true;
            }
            else if (groupByViewRHTOrQueryString instanceof ViewBase) {
                view = groupByViewRHTOrQueryString;
            }
            else if (typeof groupByViewRHTOrQueryString === 'string') {
                queryString = groupByViewRHTOrQueryString;
            }
            else if (typeof groupByViewRHTOrQueryString === 'boolean') {
                returnHighlightTerms = groupByViewRHTOrQueryString;
                EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "FindItems");
            }
            else if (groupByViewRHTOrQueryString) {//error if not null
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, must be string, boolean, ViewBase or Grouping");
            }
        }

        //position 4 - groupByOrView
        if (argsLength >= 4) {
            if (groupByOrView instanceof Grouping) {
                if (!(groupByViewRHTOrQueryString instanceof ViewBase)) {
                    throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, it must be ViewBase when using Grouping at 3rd place");
                }
                groupResultBy = groupByOrView;
                isGroupped = true;
            }
            else if (groupByOrView instanceof ViewBase) {
                view = groupByOrView;
            }
            else if (groupByOrView) {//error if not null
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 4th  position, must be  ViewBase or Grouping");
            }
        }

        //position 5 - groupBy
        if (argsLength >= 5) {
            if (groupByOrView && !(groupByOrView instanceof ViewBase)) {//error if not null
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 4th position, it must be ViewBase when using Grouping at 5th place");
            }
            groupResultBy = groupBy;
            isGroupped = true;
        }
        var isRaw: boolean = false; // to return ServiceResponseCollection<FindItemResponse<TItem>>
        //position 6 - errorHandlingMode
        if (argsLength === 6) {
            isRaw = true;
        }

        var request: FindItemRequest<TItem> = new FindItemRequest<TItem>(this, errorHandlingMode | ServiceErrorHandling.ThrowOnError);

        request.ParentFolderIds.AddRange(parentIds);

        request.SearchFilter = searchFilter;

        request.QueryString = queryString;

        request.View = view;

        request.GroupBy = groupResultBy;

        return request.Execute().then((responses) => {
            if (isRaw) {
                return responses;
            }
            if (isGroupped) {
                return responses.__thisIndexer(0).GroupedFindResults;
            }
            return responses.__thisIndexer(0).Results;
        });

    }
    /**
     * Binds to multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}              itemIds         The Ids of the items to bind to.
     * @param   {PropertySet}           propertySet     The set of properties to load.
     * @param   {string}                anchorMailbox   The SmtpAddress of mailbox that hosts all items we need to bind to
     * @param   {ServiceErrorHandling}  errorHandling   Type of error handling to perform.
     * @return  {Promise<ServiceResponseCollection<GetItemResponse>>}       A ServiceResponseCollection providing results for each of the specified item Ids :Promise.
     */
    private InternalBindToItems(itemIds: ItemId[], propertySet: PropertySet, anchorMailbox: string, errorHandling: ServiceErrorHandling): Promise<ServiceResponseCollection<GetItemResponse>> {
        var request: GetItemRequest = new GetItemRequest(this, errorHandling);

        request.ItemIds.AddRange(itemIds);
        request.PropertySet = propertySet;
        request.AnchorMailbox = anchorMailbox;

        return request.Execute();
    }
    /**
     * Copies multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}              itemIds                 The Ids of the items to bind to.
     * @param   {FolderId}              destinationFolderId     The Id of the folder to copy the items to.
     * @param   {boolean}               returnNewItemIds        Flag indicating whether service should return new ItemIds or not.
     * @param   {ServiceErrorHandling}  errorHandling           What type of error handling should be performed.
     * @return  {Promise<ServiceResponseCollection<MoveCopyItemResponse>>}      A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    private InternalCopyItems(itemIds: ItemId[], destinationFolderId: FolderId, returnNewItemIds: boolean, errorHandling: ServiceErrorHandling): Promise<ServiceResponseCollection<MoveCopyItemResponse>> {
        var request: CopyItemRequest = new CopyItemRequest(this, errorHandling);
        request.ItemIds.AddRange(itemIds);
        request.DestinationFolderId = destinationFolderId;
        request.ReturnNewItemIds = returnNewItemIds;

        return request.Execute();
    }
    /**
     * Creates multiple items in a single EWS call. Supported item classes are EmailMessage, Appointment, Contact, PostItem, Task and Item. CreateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                items                 The items to create.
     * @param   {FolderId}              parentFolderId        The Id of the folder in which to place the newly created items. If null, items are created in their default folders.
     * @param   {MessageDisposition}    messageDisposition    Indicates the disposition mode for items of type EmailMessage. Required if items contains at least one EmailMessage instance.
     * @param   {SendInvitationsMode}   sendInvitationsMode   Indicates if and how invitations should be sent for items of type Appointment. Required if items contains at least one Appointment instance.
     * @param   {ServiceErrorHandling}  errorHandling         What type of error handling should be performed.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing creation results for each of the specified items :Promise.
     */
    private InternalCreateItems(items: Item[], parentFolderId: FolderId, messageDisposition: MessageDisposition, sendInvitationsMode: SendInvitationsMode, errorHandling: ServiceErrorHandling): Promise<ServiceResponseCollection<ServiceResponse>> {
        var request: CreateItemRequest = new CreateItemRequest(this, errorHandling);

        request.ParentFolderId = parentFolderId;
        request.Items = items;
        request.MessageDisposition = messageDisposition;
        request.SendInvitationsMode = sendInvitationsMode;

        return request.Execute();
    }
    /**
     * Deletes multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}                  itemIds                   The Ids of the items to delete.
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether cancellation messages should be sent. Required if any of the item Ids represents an Appointment.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicates which instance of a recurring task should be deleted. Required if any of the item Ids represents a Task.
     * @param   {ServiceErrorHandling}      errorHandling             Type of error handling to perform.
     * @param   {boolean}                   suppressReadReceipts      Whether to suppress read receipts
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing deletion results for each of the specified item Ids :Promise.
     */
    private InternalDeleteItems(itemIds: ItemId[], deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence, errorHandling: ServiceErrorHandling, suppressReadReceipts: boolean): Promise<ServiceResponseCollection<ServiceResponse>> {
        var request: DeleteItemRequest = new DeleteItemRequest(this, errorHandling);

        request.ItemIds.AddRange(itemIds);
        request.DeleteMode = deleteMode;
        request.SendCancellationsMode = sendCancellationsMode;
        request.AffectedTaskOccurrences = affectedTaskOccurrences;
        request.SuppressReadReceipts = suppressReadReceipts;

        return request.Execute();
    }
    /**
     * @internal Loads the properties of multiple items in a single call to EWS.
     *
     * @param   {Item[]}                items           The items to load the properties of.
     * @param   {PropertySet}           propertySet     The set of properties to load.
     * @param   {ServiceErrorHandling}  errorHandling   Indicates the type of error handling should be done.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing results for each of the specified items :Promise.
     */
    InternalLoadPropertiesForItems(items: Item[], propertySet: PropertySet, errorHandling: ServiceErrorHandling): Promise<ServiceResponseCollection<ServiceResponse>> {
        var request: GetItemRequestForLoad = new GetItemRequestForLoad(this, errorHandling);
        request.ItemIds.AddRange(items);
        request.PropertySet = propertySet;

        return request.Execute();
    }
    /**
     * Moves multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}              itemIds               The Ids of the items to move.
     * @param   {FolderId}              destinationFolderId   The Id of the folder to move the items to.
     * @param   {boolean}               returnNewItemIds      Flag indicating whether service should return new ItemIds or not.
     * @param   {ServiceErrorHandling}  errorHandling         What type of error handling should be performed.
     * @return  {Promise<ServiceResponseCollection<MoveCopyItemResponse>>}      A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    private InternalMoveItems(itemIds: ItemId[], destinationFolderId: FolderId, returnNewItemIds: boolean, errorHandling: ServiceErrorHandling): Promise<ServiceResponseCollection<MoveCopyItemResponse>> {
        var request: MoveItemRequest = new MoveItemRequest(this, errorHandling);

        request.ItemIds.AddRange(itemIds);
        request.DestinationFolderId = destinationFolderId;
        request.ReturnNewItemIds = returnNewItemIds;

        return request.Execute();
    }
    /**
     * Updates multiple items in a single EWS call. UpdateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                                items                                The items to update.
     * @param   {FolderId}                              savedItemsDestinationFolderId        The folder in which to save sent messages, meeting invitations or cancellations. If null, the messages, meeting invitation or cancellations are saved in the Sent Items folder.
     * @param   {ConflictResolutionMode}                conflictResolution                   The conflict resolution mode.
     * @param   {MessageDisposition}                    messageDisposition                   Indicates the disposition mode for items of type EmailMessage. Required if items contains at least one EmailMessage instance.
     * @param   {SendInvitationsOrCancellationsMode}    sendInvitationsOrCancellationsMode   Indicates if and how invitations and/or cancellations should be sent for items of type Appointment. Required if items contains at least one Appointment instance.
     * @param   {ServiceErrorHandling}                  errorHandling                        What type of error handling should be performed.
     * @param   {boolean}                               suppressReadReceipt                  Whether to suppress read receipts
     * @return  {Promise<ServiceResponseCollection<UpdateItemResponse>>}                     A ServiceResponseCollection providing update results for each of the specified items :Promise.
     */
    private InternalUpdateItems(items: Item[], savedItemsDestinationFolderId: FolderId, conflictResolution: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode, errorHandling: ServiceErrorHandling, suppressReadReceipt: boolean): Promise<ServiceResponseCollection<UpdateItemResponse>> {
        var request: UpdateItemRequest = new UpdateItemRequest(this, errorHandling);


        //request.Items.AddRange(items);
        ArrayHelper.AddRange(request.Items, items);

        request.SavedItemsDestinationFolder = savedItemsDestinationFolderId;
        request.MessageDisposition = messageDisposition;
        request.ConflictResolutionMode = conflictResolution;
        request.SendInvitationsOrCancellationsMode = sendInvitationsOrCancellationsMode;
        request.SuppressReadReceipts = suppressReadReceipt;

        return request.Execute();
    }
    /**
     * Loads the properties of multiple items in a single call to EWS. **Unstable for Extended Properties**
     *
     * @param   {Item[]}        items         The items to load the properties of.
     * @param   {PropertySet}   propertySet   The set of properties to load.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing results for each of the specified items :Promise.
     */
    LoadPropertiesForItems(items: Item[], propertySet: PropertySet): Promise<ServiceResponseCollection<ServiceResponse>> {
        EwsUtilities.ValidateParamCollection(items, "items");
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        return this.InternalLoadPropertiesForItems(
            items,
            propertySet,
            ServiceErrorHandling.ReturnErrors);
    }
    /**
     * Mark items as junk.
     *
     * @param   {ItemId[]}      itemIds    ItemIds for the items to mark
     * @param   {boolean}       isJunk     Whether the items are junk.  If true, senders are add to blocked sender list. If false, senders are removed.
     * @param   {boolean}       moveItem   Whether to move the item.  Items are moved to junk folder if isJunk is true, inbox if isJunk is false.
     * @return  {Promise<ServiceResponseCollection<MarkAsJunkResponse>>}        A ServiceResponseCollection providing itemIds for each of the moved items :Promise.
     */
    MarkAsJunk(itemIds: ItemId[], isJunk: boolean, moveItem: boolean): Promise<ServiceResponseCollection<MarkAsJunkResponse>> {
        var request: MarkAsJunkRequest = new MarkAsJunkRequest(this, ServiceErrorHandling.ReturnErrors);
        request.ItemIds.AddRange(itemIds);
        request.IsJunk = isJunk;
        request.MoveItem = moveItem;
        return request.Execute();
    }
    /**
     * @internal Move an item.
     *
     * @param   {ItemId}    itemId                The Id of the item to move.
     * @param   {FolderId}  destinationFolderId   The Id of the folder to move the item to.
     * @return  {Promise<Item>}                   The moved item :Promise.
     */
    MoveItem(itemId: ItemId, destinationFolderId: FolderId): Promise<Item> {
        return this.InternalMoveItems(
            [itemId],
            destinationFolderId,
            null,
            ServiceErrorHandling.ThrowOnError).then((responses) => {
                return responses.__thisIndexer(0).Item;
            });
    }
    /**
     * Moves multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}   itemIds               The Ids of the items to move.
     * @param   {FolderId}   destinationFolderId   The Id of the folder to move the items to.
     * @return  {Promise<ServiceResponseCollection<MoveCopyItemResponse>>}      A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    MoveItems(itemIds: ItemId[], destinationFolderId: FolderId): Promise<ServiceResponseCollection<MoveCopyItemResponse>>;
    /**
     * Moves multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}   itemIds               The Ids of the items to move.
     * @param   {FolderId}   destinationFolderId   The Id of the folder to move the items to.
     * @param   {boolean}    returnNewItemIds      Flag indicating whether service should return new ItemIds or not.
     * @return  {Promise<ServiceResponseCollection<MoveCopyItemResponse>>}      A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    MoveItems(itemIds: ItemId[], destinationFolderId: FolderId, returnNewItemIds: boolean): Promise<ServiceResponseCollection<MoveCopyItemResponse>>;
    MoveItems(itemIds: ItemId[], destinationFolderId: FolderId, returnNewItemIds: boolean = null): Promise<ServiceResponseCollection<MoveCopyItemResponse>> {
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2010_SP1,
            "MoveItems");

        return this.InternalMoveItems(
            itemIds,
            destinationFolderId,
            returnNewItemIds,
            ServiceErrorHandling.ReturnErrors);
    }
    /**
     * @internal Sends an item.
     *
     * @param   {Item}      item                           The item.
     * @param   {FolderId}  savedCopyDestinationFolderId   The saved copy destination folder id.
     */
    SendItem(item: Item, savedCopyDestinationFolderId: FolderId): Promise<void> {
        var request: SendItemRequest = new SendItemRequest(this, ServiceErrorHandling.ThrowOnError);
        request.Items = [item];
        request.SavedCopyDestinationFolderId = savedCopyDestinationFolderId;
        return <any>request.Execute();
    }
    /**
     * @internal Updates an item.
     *
     * @param   {Item}                                  item                                 The item to update.
     * @param   {FolderId}                              savedItemsDestinationFolderId        The folder in which to save sent messages, meeting invitations or cancellations. If null, the message, meeting invitation or cancellation is saved in the Sent Items folder.
     * @param   {ConflictResolutionMode}                conflictResolution                   The conflict resolution mode.
     * @param   {MessageDisposition}                    messageDisposition                   Indicates the disposition mode for an item of type EmailMessage. Required if item is an EmailMessage instance.
     * @param   {SendInvitationsOrCancellationsMode}    sendInvitationsOrCancellationsMode   Indicates if and how invitations and/or cancellations should be sent for ian tem of type Appointment. Required if item is an Appointment instance.
     * @return  {Promise<Item>}                                                              Updated item : Promise.
     */
    UpdateItem(item: Item, savedItemsDestinationFolderId: FolderId, conflictResolution: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode): Promise<Item>;
    /**
     * @internal Updates an item.
     *
     * @param   {Item}                                  item                                 The item to update.
     * @param   {FolderId}                              savedItemsDestinationFolderId        The folder in which to save sent messages, meeting invitations or cancellations. If null, the message, meeting invitation or cancellation is saved in the Sent Items folder.
     * @param   {ConflictResolutionMode}                conflictResolution                   The conflict resolution mode.
     * @param   {MessageDisposition}                    messageDisposition                   Indicates the disposition mode for an item of type EmailMessage. Required if item is an EmailMessage instance.
     * @param   {SendInvitationsOrCancellationsMode}    sendInvitationsOrCancellationsMode   Indicates if and how invitations and/or cancellations should be sent for ian tem of type Appointment. Required if item is an Appointment instance.
     * @param   {boolean}                               suppressReadReceipts                 Whether to suppress read receipts
     * @return  {Promise<Item>}                                                              Updated item : Promise.
     */
    UpdateItem(item: Item, savedItemsDestinationFolderId: FolderId, conflictResolution: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode, suppressReadReceipts: boolean): Promise<Item>;
    UpdateItem(item: Item, savedItemsDestinationFolderId: FolderId, conflictResolution: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode, suppressReadReceipts: boolean = false): Promise<Item> {
        return this.InternalUpdateItems(
            [item],
            savedItemsDestinationFolderId,
            conflictResolution,
            messageDisposition,
            sendInvitationsOrCancellationsMode,
            ServiceErrorHandling.ThrowOnError,
            suppressReadReceipts).then((responses) => {

                return responses.__thisIndexer(0).ReturnedItem;

            });
    }
    /**
     * Updates multiple items in a single EWS call. UpdateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                                items                                The items to update.
     * @param   {FolderId}                              savedItemsDestinationFolderId        The folder in which to save sent messages, meeting invitations or cancellations. If null, the message, meeting invitation or cancellation is saved in the Sent Items folder.
     * @param   {ConflictResolutionMode}                conflictResolution                   The conflict resolution mode.
     * @param   {MessageDisposition}                    messageDisposition                   Indicates the disposition mode for an item of type EmailMessage. Required if item is an EmailMessage instance.
     * @param   {SendInvitationsOrCancellationsMode}    sendInvitationsOrCancellationsMode   Indicates if and how invitations and/or cancellations should be sent for ian tem of type Appointment. Required if item is an Appointment instance.
     * @return  {Promise<Item>}                                                              A ServiceResponseCollection providing update results for each of the specified items : Promise.
     */
    UpdateItems(items: Item[], savedItemsDestinationFolderId: FolderId, conflictResolution: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode): Promise<ServiceResponseCollection<UpdateItemResponse>>;
    /**
     * Updates multiple items in a single EWS call. UpdateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                                items                                The items to update.
     * @param   {FolderId}                              savedItemsDestinationFolderId        The folder in which to save sent messages, meeting invitations or cancellations. If null, the message, meeting invitation or cancellation is saved in the Sent Items folder.
     * @param   {ConflictResolutionMode}                conflictResolution                   The conflict resolution mode.
     * @param   {MessageDisposition}                    messageDisposition                   Indicates the disposition mode for an item of type EmailMessage. Required if item is an EmailMessage instance.
     * @param   {SendInvitationsOrCancellationsMode}    sendInvitationsOrCancellationsMode   Indicates if and how invitations and/or cancellations should be sent for ian tem of type Appointment. Required if item is an Appointment instance.
     * @param   {boolean}                               suppressReadReceipts                 Whether to suppress read receipts
     * @return  {Promise<Item>}                                                              A ServiceResponseCollection providing update results for each of the specified items : Promise.
     */
    UpdateItems(items: Item[], savedItemsDestinationFolderId: FolderId, conflictResolution: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode, suppressReadReceipts: boolean): Promise<ServiceResponseCollection<UpdateItemResponse>>;
    UpdateItems(items: Item[], savedItemsDestinationFolderId: FolderId, conflictResolution: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode, suppressReadReceipts: boolean = false): Promise<ServiceResponseCollection<UpdateItemResponse>> {
        // All items have to exist on the server (!new) and modified (dirty)
        if (!items.every((item) => (!item.IsNew && item.IsDirty))) {
            throw new ServiceValidationException(Strings.UpdateItemsDoesNotSupportNewOrUnchangedItems);
        }

        // Make sure that all items do *not* have unprocessed attachments.
        if (!items.every((item) => !item.HasUnprocessedAttachmentChanges())) {
            throw new ServiceValidationException(Strings.UpdateItemsDoesNotAllowAttachments);
        }

        return this.InternalUpdateItems(
            items,
            savedItemsDestinationFolderId,
            conflictResolution,
            messageDisposition,
            sendInvitationsOrCancellationsMode,
            ServiceErrorHandling.ReturnErrors,
            suppressReadReceipts);
    }
    /* #endregion Item operations 47*/


    /* #region Attachment operations */

    /**
     * @internal Creates attachments.
     *
     * @param   {string}            parentItemId   The parent item id.
     * @param   {Attachment[]}      attachments            The attachments.
     * @return  {Promise<ServiceResponseCollection<CreateAttachmentResponse>>}      Service response collection :Promise.
     */
    CreateAttachments(parentItemId: string, attachments: Attachment[]): Promise<ServiceResponseCollection<CreateAttachmentResponse>> {
        let request: CreateAttachmentRequest = new CreateAttachmentRequest(this, ServiceErrorHandling.ReturnErrors);

        request.ParentItemId = parentItemId;
        ArrayHelper.AddRange(request.Attachments, attachments); //request.Attachments.AddRange(attachments);

        return request.Execute();
    }

    /**
     * @internal Deletes attachments.
     *
     * @param   {Attachment[]}   attachments   The attachments.
     * @return  {Promise<ServiceResponseCollection<DeleteAttachmentResponse>>}      Service response collection :Promise.
     */
    DeleteAttachments(attachments: Attachment[]): Promise<ServiceResponseCollection<DeleteAttachmentResponse>> {
        let request: DeleteAttachmentRequest = new DeleteAttachmentRequest(this, ServiceErrorHandling.ReturnErrors);

        ArrayHelper.AddRange(request.Attachments, attachments); //request.Attachments.AddRange(attachments);

        return request.Execute();
    }

    /**
     * @internal Gets an attachment.
     *
     * @param   {Attachment}                    attachment             The attachment.
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     */
    GetAttachment(attachment: Attachment, bodyType: BodyType, additionalProperties: PropertyDefinitionBase[]): Promise<void> {
        return <any>this.InternalGetAttachments(
            [attachment],
            bodyType,
            additionalProperties,
            ServiceErrorHandling.ThrowOnError);
    }
    /**
     * Gets attachments.
     *
     * @param   {Attachment[]}                  attachments            The attachments.
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     * @return  {Promise<ServiceResponseCollection<GetAttachmentResponse>>}         Service response collection :Promise.
     */
    GetAttachments(attachments: Attachment[], bodyType: BodyType, additionalProperties: PropertyDefinitionBase[]): Promise<ServiceResponseCollection<GetAttachmentResponse>>;
    /**
     * Gets attachments.
     *
     * @param   {string[]}                      attachmentIds          The attachment ids.
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     * @return  {Promise<ServiceResponseCollection<GetAttachmentResponse>>}         Service response collection :Promise.
     */
    GetAttachments(attachmentIds: string[], bodyType: BodyType, additionalProperties: PropertyDefinitionBase[]): Promise<ServiceResponseCollection<GetAttachmentResponse>>;
    GetAttachments(attachmentsOrIds: Attachment[] | string[], bodyType: BodyType, additionalProperties: PropertyDefinitionBase[]): Promise<ServiceResponseCollection<GetAttachmentResponse>> {
        var ids = ArrayHelper.OfType<string, any[]>(<any[]>attachmentsOrIds, (attachment: any) => { return typeof attachment === 'string'; });
        if (ids && ids.length > 0) {
            var request: GetAttachmentRequest = new GetAttachmentRequest(this, ServiceErrorHandling.ReturnErrors);
            ArrayHelper.AddRange(request.AttachmentIds, <string[]>attachmentsOrIds);
            request.BodyType = bodyType;

            if (additionalProperties != null) {
                ArrayHelper.AddRange(request.AdditionalProperties, additionalProperties);
                //request.AdditionalProperties.AddRange(additionalProperties);
            }
            return request.Execute();

        }
        else {
            return this.InternalGetAttachments(
                <Attachment[]>attachmentsOrIds,
                bodyType,
                additionalProperties,
                ServiceErrorHandling.ReturnErrors);
        }
    }
    /**
     * Gets attachments.
     *
     * @param   {string[]}                      attachmentIds          The attachment ids.
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     * @return  {Promise<ServiceResponseCollection<GetAttachmentResponse>>}         Service response collection :Promise.
     */
    private InternalGetAttachments(attachments: Attachment[], bodyType: BodyType, additionalProperties: PropertyDefinitionBase[], errorHandling: ServiceErrorHandling): Promise<ServiceResponseCollection<GetAttachmentResponse>> {
        var request: GetAttachmentRequest = new GetAttachmentRequest(this, errorHandling);
        ArrayHelper.AddRange(request.Attachments, attachments);
        request.BodyType = bodyType;

        if (additionalProperties != null) {
            ArrayHelper.AddRange(request.AdditionalProperties, additionalProperties);
            //request.AdditionalProperties.AddRange(additionalProperties);
        }
        return request.Execute();
    }

    /* #endregion Attachment operations */


    /* #region AD related operations */

    /**
     * Expands a group by retrieving a list of its members. Calling this method results in a call to EWS.
     *
     * @param   {ItemId}   groupId   The Id of the group to expand.
     * @return  {Promise<ExpandGroupResults>}       An ExpandGroupResults containing the members of the group :Promise.
     */
    ExpandGroup(groupId: ItemId): Promise<ExpandGroupResults>;
    /**
     * Expands a group by retrieving a list of its members. Calling this method results in a call to EWS.
     *
     * @param   {string}   smtpAddress   The SMTP address of the group to expand.
     * @return  {Promise<ExpandGroupResults>}       An ExpandGroupResults containing the members of the group :Promise.
     */
    ExpandGroup(smtpAddress: string): Promise<ExpandGroupResults>;
    /**
     * Expands a group by retrieving a list of its members. Calling this method results in a call to EWS.
     *
     * @param   {EmailAddress}   emailAddress   The e-mail address of the group.
     * @return  {Promise<ExpandGroupResults>}       An ExpandGroupResults containing the members of the group :Promise.
     */
    ExpandGroup(emailAddress: EmailAddress): Promise<ExpandGroupResults>;
    /**
     * Expands a group by retrieving a list of its members. Calling this method results in a call to EWS.
     *
     * @param   {string}   address       The SMTP address of the group to expand.
     * @param   {string}   routingType   The routing type of the address of the group to expand.
     * @return  {Promise<ExpandGroupResults>}       An ExpandGroupResults containing the members of the group :Promise.
     */
    ExpandGroup(address: string, routingType: string): Promise<ExpandGroupResults>;
    ExpandGroup(emailAddressOrsmtpAddressOrGroupId: EmailAddress | string | ItemId, routingType?: string): Promise<ExpandGroupResults> {
        // EwsUtilities.ValidateParam(emailAddressOrsmtpAddressOrGroupId, "address");
        // EwsUtilities.ValidateParam(routingType, "routingType");
        //EwsUtilities.ValidateParam(emailAddress, "emailAddress");
        var emailAddress: EmailAddress = new EmailAddress();

        if (emailAddressOrsmtpAddressOrGroupId instanceof EmailAddress) {
            emailAddress = emailAddressOrsmtpAddressOrGroupId;
        }
        else if (emailAddressOrsmtpAddressOrGroupId instanceof ItemId) {
            emailAddress.Id = emailAddressOrsmtpAddressOrGroupId;
        }
        else if (typeof emailAddressOrsmtpAddressOrGroupId === 'string') {
            emailAddress = new EmailAddress(emailAddressOrsmtpAddressOrGroupId);
        }

        if (routingType) {
            emailAddress.RoutingType = routingType;
        }

        var request: ExpandGroupRequest = new ExpandGroupRequest(this);

        request.EmailAddress = emailAddress;

        return request.Execute().then((response) => {
            return response.__thisIndexer(0).Members;
        });

    }
    /**
     * Get the password expiration date
     *
     * @param   {string}   mailboxSmtpAddress   The e-mail address of the user.
     * @return  {Promise<DateTime>}             The password expiration date :Promise.
     */
    GetPasswordExpirationDate(mailboxSmtpAddress: string): Promise<DateTime> {
        var request: GetPasswordExpirationDateRequest = new GetPasswordExpirationDateRequest(this);
        request.MailboxSmtpAddress = mailboxSmtpAddress;

        return request.Execute().then((response) => {
            return response.PasswordExpirationDate;
        });
    }

    /**
     * Finds contacts in the Global Address List and/or in specific contact folders that have names that match the one passed as a parameter. Calling this method results in a call to EWS.
     *
     * @param   {string}    nameToResolve               The name to resolve.
     * @return  {Promise<NameResolutionCollection>}     A collection of name resolutions whose names match the one passed as a parameter :Promise.
     */
    ResolveName(nameToResolve: string): Promise<NameResolutionCollection>;
    /**
     * Finds contacts in the Global Address List and/or in specific contact folders that have names that match the one passed as a parameter. Calling this method results in a call to EWS.
     *
     * @param   {string}                        nameToResolve               The name to resolve.
     * @param   {ResolveNameSearchLocation}     searchScope                 The scope of the search.
     * @param   {boolean}                       returnContactDetails        Indicates whether full contact information should be returned for each of the found contacts.
     * @return  {Promise<NameResolutionCollection>}                         A collection of name resolutions whose names match the one passed as a parameter :Promise.
     */
    ResolveName(nameToResolve: string, searchScope: ResolveNameSearchLocation, returnContactDetails: boolean): Promise<NameResolutionCollection>;
    /**
     * Finds contacts in the Global Address List and/or in specific contact folders that have names that match the one passed as a parameter. Calling this method results in a call to EWS.
     *
     * @param   {string}                        nameToResolve               The name to resolve.
     * @param   {ResolveNameSearchLocation}     searchScope                 The scope of the search.
     * @param   {boolean}                       returnContactDetails        Indicates whether full contact information should be returned for each of the found contacts.
     * @param   {PropertySet}                   contactDataPropertySet      The property set for the contct details
     * @return  {Promise<NameResolutionCollection>}                         A collection of name resolutions whose names match the one passed as a parameter :Promise.
     */
    ResolveName(nameToResolve: string, searchScope: ResolveNameSearchLocation, returnContactDetails: boolean, contactDataPropertySet: PropertySet): Promise<NameResolutionCollection>;
    /**
     * Finds contacts in the Global Address List and/or in specific contact folders that have names that match the one passed as a parameter. Calling this method results in a call to EWS.
     *
     * @param   {string}                        nameToResolve               The name to resolve.
     * @param   {FolderId[]}                    parentFolderIds             The Ids of the contact folders in which to look for matching contacts.
     * @param   {ResolveNameSearchLocation}     searchScope                 The scope of the search.
     * @param   {boolean}                       returnContactDetails        Indicates whether full contact information should be returned for each of the found contacts.
     * @return  {Promise<NameResolutionCollection>}                         A collection of name resolutions whose names match the one passed as a parameter :Promise.
     */
    ResolveName(nameToResolve: string, parentFolderIds: FolderId[], searchScope: ResolveNameSearchLocation, returnContactDetails: boolean): Promise<NameResolutionCollection>;
    /**
     * Finds contacts in the Global Address List and/or in specific contact folders that have names that match the one passed as a parameter. Calling this method results in a call to EWS.
     *
     * @param   {string}                        nameToResolve               The name to resolve.
     * @param   {FolderId[]}                    parentFolderIds             The Ids of the contact folders in which to look for matching contacts.
     * @param   {ResolveNameSearchLocation}     searchScope                 The scope of the search.
     * @param   {boolean}                       returnContactDetails        Indicates whether full contact information should be returned for each of the found contacts.
     * @param   {PropertySet}                   contactDataPropertySet      The property set for the contct details
     * @return  {Promise<NameResolutionCollection>}                         A collection of name resolutions whose names match the one passed as a parameter :Promise.
     */
    ResolveName(nameToResolve: string, parentFolderIds: FolderId[], searchScope: ResolveNameSearchLocation, returnContactDetails: boolean, contactDataPropertySet: PropertySet): Promise<NameResolutionCollection>;

    ResolveName(
        nameToResolve: string,
        parentFolderIdsOrSearchScope?: ResolveNameSearchLocation | FolderId[],
        searchScopeOrReturnContactDetails?: ResolveNameSearchLocation | boolean,
        returnContactDetailsOrContactDataPropertySet?: boolean | PropertySet,
        contactDataPropertySet: PropertySet = null
    ): Promise<NameResolutionCollection> {


        var argsLength = arguments.length;
        if (argsLength < 1 && argsLength > 5) {
            throw new Error("ExchangeService.ts - ResolveName - invalid number of arguments, check documentation and try again.");
        }

        //position 1 - nameToResolve - no change, same for all overload

        var searchScope: ResolveNameSearchLocation = null;
        var parentFolderIds: FolderId[] = null;

        //position 2 - parentFolderIdsOrSearchScope
        if (argsLength >= 2) {
            if (typeof parentFolderIdsOrSearchScope === 'number') {
                searchScope = parentFolderIdsOrSearchScope;
            }
            else if (Array.isArray(parentFolderIdsOrSearchScope)) {
                parentFolderIds = parentFolderIdsOrSearchScope;
            }
            //could be null        
            // else {
            //     throw new Error("ExchangeService.ts - FindItems - incorrect uses of parameters at 2nd position, must be string, ViewBase or SearchFilter");
            // }
        }

        var returnContactDetails: boolean = false;

        //position 3 - searchScopeOrReturnContactDetails
        if (argsLength >= 3) {
            if (typeof searchScopeOrReturnContactDetails === 'boolean') {
                if (typeof parentFolderIdsOrSearchScope !== 'number') {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 2nd position, it must be ResolveNameSearchLocation when using boolean at 3rd place");
                }
                returnContactDetails = searchScopeOrReturnContactDetails;
            }
            else if (typeof searchScopeOrReturnContactDetails === 'number') {
                if (!Array.isArray(parentFolderIdsOrSearchScope)) {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 2nd position, it must be FolderId[] when using ResolveNameSearchLocation at 3rd place");
                }
                searchScope = searchScopeOrReturnContactDetails;
            }
            else {
                throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, must be boolean, or ResolveNameSearchLocation");
            }
        }

        //position 4 - returnContactDetailsOrContactDataPropertySet
        if (argsLength >= 4) {
            if (returnContactDetailsOrContactDataPropertySet instanceof PropertySet) {
                if (typeof searchScopeOrReturnContactDetails !== 'boolean') {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, it must be boolean when using PropertySet at 4th place");
                }
                contactDataPropertySet = returnContactDetailsOrContactDataPropertySet;
            }
            else if (typeof returnContactDetailsOrContactDataPropertySet === 'boolean') {
                if (typeof searchScopeOrReturnContactDetails !== 'number') {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, it must be ResolveNameSearchLocation when using boolean at 4th place");
                }
                returnContactDetails = returnContactDetailsOrContactDataPropertySet;
            }
            else {
                throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 4th  position, must be  PropertySet or boolean");
            }
        }

        //position 5 - contactDataPropertySet
        if (argsLength >= 5) {
            if (typeof returnContactDetailsOrContactDataPropertySet !== 'boolean') {
                throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 4th position, it must be boolean when using PropertySet at 5th place");
            }
        }

        var request: ResolveNamesRequest = new ResolveNamesRequest(this);

        request.NameToResolve = nameToResolve;
        request.ReturnFullContactData = returnContactDetails;
        request.ParentFolderIds.AddRange(parentFolderIds);
        request.SearchLocation = searchScope;
        request.ContactDataPropertySet = contactDataPropertySet;

        return request.Execute().then((response) => {
            return response.__thisIndexer(0).Resolutions;
        });
    }

    /* #endregion AD related operations */


    /* #region Notification operations */

    // BeginGetEvents(callback: Function /*System.AsyncCallback*/, state: any, subscriptionId: string, watermark: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginGetEvents : Not implemented."); }
    // BeginSubscribeToPullNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, timeout: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPullNotifications : Not implemented."); }
    // BeginSubscribeToPullNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, timeout: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPullNotificationsOnAllFolders : Not implemented."); }
    // BeginSubscribeToPushNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, url: Uri, frequency: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotifications : Not implemented."); }
    // //BeginSubscribeToPushNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotifications : Not implemented."); }
    // BeginSubscribeToPushNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, url: Uri, frequency: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotificationsOnAllFolders : Not implemented."); }
    // //BeginSubscribeToPushNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotificationsOnAllFolders : Not implemented."); }
    // BeginSubscribeToStreamingNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToStreamingNotifications : Not implemented."); }
    // BeginSubscribeToStreamingNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToStreamingNotificationsOnAllFolders : Not implemented."); }
    // BeginUnsubscribe(callback: Function /*System.AsyncCallback*/, state: any, subscriptionId: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginUnsubscribe : Not implemented."); }

    /**
     * Builds an request to retrieve the latests events associated with a pull subscription.
     *
     * @param   {string}   subscriptionId   The Id of the pull subscription for which to get the events.
     * @param   {string}   watermark        The watermark representing the point in time where to start receiving events.
     * @return  {GetEventsRequest}          An request to retrieve the latests events associated with a pull subscription.
     */
    private BuildGetEventsRequest(subscriptionId: string, watermark: string): GetEventsRequest {
        EwsUtilities.ValidateParam(subscriptionId, "subscriptionId");
        EwsUtilities.ValidateParam(watermark, "watermark");

        let request: GetEventsRequest = new GetEventsRequest(this);

        request.SubscriptionId = subscriptionId;
        request.Watermark = watermark;

        return request;
    }

    /**
     * Builds a request to subscribe to pull notifications in the authenticated user's mailbox.
     *
     * @param   {FolderId[]}    folderIds    The Ids of the folder to subscribe to.
     * @param   {number}        timeout      The timeout, in minutes, after which the subscription expires. Timeout must be between 1 and 1440.
     * @param   {string}        watermark    An optional watermark representing a previously opened subscription.
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {SubscribeToPullNotificationsRequest}   A request to subscribe to pull notifications in the authenticated user's mailbox.
     */
    private BuildSubscribeToPullNotificationsRequest(folderIds: FolderId[], timeout: number, watermark: string, eventTypes: EventType[]): SubscribeToPullNotificationsRequest {
        if (timeout < 1 || timeout > 1440) {
            throw new ArgumentOutOfRangeException("timeout", Strings.TimeoutMustBeBetween1And1440);
        }

        EwsUtilities.ValidateParamCollection(eventTypes, "eventTypes");

        let request: SubscribeToPullNotificationsRequest = new SubscribeToPullNotificationsRequest(this);

        if (folderIds != null) {
            request.FolderIds.AddRange(folderIds);
        }

        request.Timeout = timeout;
        ArrayHelper.AddRange(request.EventTypes, eventTypes); //request.EventTypes.AddRange(eventTypes);
        request.Watermark = watermark;

        return request;
    }

    /**
     * Builds an request to request to subscribe to push notifications in the authenticated user's mailbox.
     *
     * @param   {FolderId[]}    folderIds    The Ids of the folder to subscribe to.
     * @param   {Uri}           url          The URL of the Web Service endpoint the Exchange server should push events to.
     * @param   {number}        frequency    The frequency, in minutes, at which the Exchange server should contact the Web Service endpoint. Frequency must be between 1 and 1440.
     * @param   {string}        watermark    An optional watermark representing a previously opened subscription.
     * @param   {string}        callerData   Optional caller data that will be returned the call back.
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {SubscribeToPushNotificationsRequest}       A request to request to subscribe to push notifications in the authenticated user's mailbox.
     */
    private BuildSubscribeToPushNotificationsRequest(folderIds: FolderId[], url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: EventType[]): SubscribeToPushNotificationsRequest {
        EwsUtilities.ValidateParam(url, "url");

        if (frequency < 1 || frequency > 1440) {
            throw new ArgumentOutOfRangeException("frequency", Strings.FrequencyMustBeBetween1And1440);
        }

        EwsUtilities.ValidateParamCollection(eventTypes, "eventTypes");

        let request: SubscribeToPushNotificationsRequest = new SubscribeToPushNotificationsRequest(this);

        if (folderIds != null) {
            request.FolderIds.AddRange(folderIds);
        }

        request.Url = url;
        request.Frequency = frequency;
        ArrayHelper.AddRange(request.EventTypes, eventTypes);//request.EventTypes.AddRange(eventTypes);
        request.Watermark = watermark;
        request.CallerData = callerData;

        return request;
    }

    /**
     * Builds request to subscribe to streaming notifications in the authenticated user's mailbox.
     *
     * @param   {FolderId[]}    folderIds    The Ids of the folder to subscribe to.
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {SubscribeToStreamingNotificationsRequest}      A request to subscribe to streaming notifications in the authenticated user's mailbox.
     */
    private BuildSubscribeToStreamingNotificationsRequest(folderIds: FolderId[], eventTypes: EventType[]): SubscribeToStreamingNotificationsRequest {
        EwsUtilities.ValidateParamCollection(eventTypes, "eventTypes");

        let request: SubscribeToStreamingNotificationsRequest = new SubscribeToStreamingNotificationsRequest(this);

        if (folderIds != null) {
            request.FolderIds.AddRange(folderIds);
        }

        ArrayHelper.AddRange(request.EventTypes, eventTypes); //request.EventTypes.AddRange(eventTypes);

        return request;
    }

    /**
     * Buids a request to unsubscribe from a subscription.
     *
     * @param   {string}   subscriptionId   The Id of the subscription for which to get the events.
     * @return  {UnsubscribeRequest}        A request to unsubscribe from a subscription.
     */
    private BuildUnsubscribeRequest(subscriptionId: string): UnsubscribeRequest {
        EwsUtilities.ValidateParam(subscriptionId, "subscriptionId");

        let request: UnsubscribeRequest = new UnsubscribeRequest(this);

        request.SubscriptionId = subscriptionId;

        return request;
    }
    //EndGetEvents(asyncResult: Function /*System.IAsyncResult*/): GetEventsResults { throw new Error("ExchangeService.ts - EndGetEvents : Not implemented."); }
    //EndSubscribeToPullNotifications(asyncResult: Function /*System.IAsyncResult*/): PullSubscription { throw new Error("ExchangeService.ts - EndSubscribeToPullNotifications : Not implemented."); }
    //EndSubscribeToPushNotifications(asyncResult: Function /*System.IAsyncResult*/): PushSubscription { throw new Error("ExchangeService.ts - EndSubscribeToPushNotifications : Not implemented."); }
    //EndSubscribeToStreamingNotifications(asyncResult: Function /*System.IAsyncResult*/): StreamingSubscription { throw new Error("ExchangeService.ts - EndSubscribeToStreamingNotifications : Not implemented."); }
    //EndUnsubscribe(asyncResult: Function /*System.IAsyncResult*/): any { throw new Error("ExchangeService.ts - EndUnsubscribe : Not implemented."); }

    /**
     * Retrieves the latests events associated with a pull subscription. Calling this method results in a call to EWS.
     *
     * @param   {string}   subscriptionId   The Id of the pull subscription for which to get the events.
     * @param   {string}   watermark        The watermark representing the point in time where to start receiving events.
     * @return  {Promise<GetEventsResults>}     A GetEventsResults containing a list of events associated with the subscription.
     */
    GetEvents(subscriptionId: string, watermark: string): Promise<GetEventsResults> {
        return this.BuildGetEventsRequest(subscriptionId, watermark).Execute().then((response) => {
            return response.__thisIndexer(0).Results;
        });
    }

    /**
     * Set a TeamMailbox
     *
     * @param   {EmailAddress}                  emailAddress        TeamMailbox email address
     * @param   {Uri}                           sharePointSiteUrl   SharePoint site URL
     * @param   {TeamMailboxLifecycleState}     state               TeamMailbox lifecycle state
     * @return  {Promise<void>}     Promise.
     */
    SetTeamMailbox(emailAddress: EmailAddress, sharePointSiteUrl: Uri, state: TeamMailboxLifecycleState): Promise<void> {
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "SetTeamMailbox");

        if (emailAddress == null) {
            throw new ArgumentNullException("emailAddress");
        }

        if (sharePointSiteUrl == null) {
            throw new ArgumentNullException("sharePointSiteUrl");
        }

        let request: SetTeamMailboxRequest = new SetTeamMailboxRequest(this, emailAddress, sharePointSiteUrl, state);
        return <any>request.Execute();
    }

    /**
     * Subscribes to pull notifications. Calling this method results in a call to EWS   :Promise.
     *
     * @param   {FolderId[]}        folderIds    The Ids of the folder to subscribe to.
     * @param   {number}            timeout      The timeout, in minutes, after which the subscription expires. Timeout must be between 1 and 1440.
     * @param   {string}            watermark    An optional watermark representing a previously opened subscription.
     * @param   {...EventType[]}    eventTypes   The event types to subscribe to.
     * @return  {Promise<PullSubscription>}      A PullSubscription representing the new subscription.
     */
    SubscribeToPullNotifications(folderIds: FolderId[], timeout: number, watermark: string, ...eventTypes: EventType[]): Promise<PullSubscription> {
        EwsUtilities.ValidateParamCollection(folderIds, "folderIds");

        return this.BuildSubscribeToPullNotificationsRequest(
            folderIds,
            timeout,
            watermark,
            eventTypes).Execute().then((response) => {
                return response.__thisIndexer(0).Subscription;
            });
    }

    /**
     * Subscribes to pull notifications on all folders in the authenticated user's mailbox. Calling this method results in a call to EWS.   :Promise.
     *
     * @param   {FolderId[]}        folderIds    The Ids of the folder to subscribe to.
     * @param   {number}            timeout      The timeout, in minutes, after which the subscription expires. Timeout must be between 1 and 1440.
     * @param   {string}            watermark    An optional watermark representing a previously opened subscription.
     * @param   {...EventType[]}    eventTypes   The event types to subscribe to.
     * @return  {Promise<PullSubscription>}      A PullSubscription representing the new subscription.
     */
    SubscribeToPullNotificationsOnAllFolders(timeout: number, watermark: string, ...eventTypes: EventType[]): Promise<PullSubscription> {
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2010,
            "SubscribeToPullNotificationsOnAllFolders");

        return this.BuildSubscribeToPullNotificationsRequest(
            null,
            timeout,
            watermark,
            eventTypes).Execute().then((response) => {
                return response.__thisIndexer(0).Subscription;
            });
    }

    /**
     * Subscribes to push notifications. Calling this method results in a call to EWS.
     *
     * @param   {FolderId[]}        folderIds    The Ids of the folder to subscribe to.
     * @param   {Uri}               url          The URL of the Web Service endpoint the Exchange server should push events to.
     * @param   {number}            frequency    The frequency, in minutes, at which the Exchange server should contact the Web Service endpoint. Frequency must be between 1 and 1440.
     * @param   {string}            watermark    An optional watermark representing a previously opened subscription.
     * @param   {...EventType[]}    eventTypes   The event types to subscribe to.
     * @return  {Promise<PushSubscription>}      A PushSubscription representing the new subscription  :Promise.
     */
    SubscribeToPushNotifications(folderIds: FolderId[], url: Uri, frequency: number, watermark: string, ...eventTypes: EventType[]): Promise<PushSubscription>;
    /**
     * Subscribes to push notifications. Calling this method results in a call to EWS.
     *
     * @param   {FolderId[]}        folderIds    The Ids of the folder to subscribe to.
     * @param   {Uri}               url          The URL of the Web Service endpoint the Exchange server should push events to.
     * @param   {number}            frequency    The frequency, in minutes, at which the Exchange server should contact the Web Service endpoint. Frequency must be between 1 and 1440.
     * @param   {string}            watermark    An optional watermark representing a previously opened subscription.
     * @param   {string}            callerData   Optional caller data that will be returned the call back.
     * @param   {...EventType[]}    eventTypes   The event types to subscribe to.
     * @return  {Promise<PushSubscription>}      A PushSubscription representing the new subscription  :Promise.
     */
    SubscribeToPushNotifications(folderIds: FolderId[], url: Uri, frequency: number, watermark: string, callerData: string, ...eventTypes: EventType[]): Promise<PushSubscription>;
    SubscribeToPushNotifications(folderIds: FolderId[], url: Uri, frequency: number, watermark: string, callerDataOrEventTypes: string | EventType, ...eventTypes: EventType[]): Promise<PushSubscription> {

        EwsUtilities.ValidateParamCollection(folderIds, "folderIds");

        let callerData: string = null;

        if (typeof callerDataOrEventTypes === 'string') {
            callerData = callerDataOrEventTypes;
        }
        else {
            eventTypes.push(callerDataOrEventTypes); //info: ref: typescript generates eventTypes from arguments.length, need to push to it.
        }

        return this.BuildSubscribeToPushNotificationsRequest(
            folderIds,
            url,
            frequency,
            watermark,
            callerData,
            eventTypes).Execute().then((response) => {
                return response.__thisIndexer(0).Subscription;
            });
    }

    /**
     * Subscribes to push notifications on all folders in the authenticated user's mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Uri}               url          The URL of the Web Service endpoint the Exchange server should push events to.
     * @param   {number}            frequency    The frequency, in minutes, at which the Exchange server should contact the Web Service endpoint. Frequency must be between 1 and 1440.
     * @param   {string}            watermark    An optional watermark representing a previously opened subscription.
     * @param   {...EventType[]}    eventTypes   The event types to subscribe to.
     * @return  {Promise<PushSubscription>}      A PushSubscription representing the new subscription    :Promise.
     */
    SubscribeToPushNotificationsOnAllFolders(url: Uri, frequency: number, watermark: string, ...eventTypes: EventType[]): Promise<PushSubscription>;
    /**
     * Subscribes to push notifications on all folders in the authenticated user's mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Uri}               url          The URL of the Web Service endpoint the Exchange server should push events to.
     * @param   {number}            frequency    The frequency, in minutes, at which the Exchange server should contact the Web Service endpoint. Frequency must be between 1 and 1440.
     * @param   {string}            watermark    An optional watermark representing a previously opened subscription.
     * @param   {string}            callerData   Optional caller data that will be returned the call back.
     * @param   {...EventType[]}    eventTypes   The event types to subscribe to.
     * @return  {Promise<PushSubscription>}      A PushSubscription representing the new subscription    :Promise.
     */
    SubscribeToPushNotificationsOnAllFolders(url: Uri, frequency: number, watermark: string, callerData: string, ...eventTypes: EventType[]): Promise<PushSubscription>;
    SubscribeToPushNotificationsOnAllFolders(url: Uri, frequency: number, watermark: string, callerDataOrEventTypes: string | EventType, ...eventTypes: EventType[]): Promise<PushSubscription> {
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2010,
            "SubscribeToPushNotificationsOnAllFolders");

        let callerData: string = null;

        if (typeof callerDataOrEventTypes === 'string') {
            callerData = callerDataOrEventTypes;
        }
        else {
            eventTypes.push(callerDataOrEventTypes); //info: ref: typescript generates eventTypes from arguments.length, need to push to it.
        }

        return this.BuildSubscribeToPushNotificationsRequest(
            null,
            url,
            frequency,
            watermark,
            callerData,
            eventTypes).Execute().then((response) => {
                return response.__thisIndexer(0).Subscription;
            });
    }

    /**
     * Subscribes to streaming notifications. Calling this method results in a call to EWS.
     *
     * @param   {FolderId[]}   folderIds    The Ids of the folder to subscribe to.
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {Promise<StreamingSubscription>}        A StreamingSubscription representing the new subscription   :Promise.
     */
    SubscribeToStreamingNotifications(folderIds: FolderId[], ...eventTypes: EventType[]): Promise<StreamingSubscription> {
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2010_SP1,
            "SubscribeToStreamingNotifications");

        EwsUtilities.ValidateParamCollection(folderIds, "folderIds");

        return this.BuildSubscribeToStreamingNotificationsRequest(folderIds, eventTypes).Execute().then((responses) => {
            return responses.__thisIndexer(0).Subscription;
        });

    }

    /**
     * Subscribes to streaming notifications on all folders in the authenticated user's mailbox. Calling this method results in a call to EWS.
     *
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {Promise<StreamingSubscription>}        A StreamingSubscription representing the new subscription   :Promise.
     */
    SubscribeToStreamingNotificationsOnAllFolders(...eventTypes: EventType[]): Promise<StreamingSubscription> {
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2010_SP1,
            "SubscribeToStreamingNotificationsOnAllFolders");

        return this.BuildSubscribeToStreamingNotificationsRequest(null, eventTypes).Execute().then((responses) => {
            return responses.__thisIndexer(0).Subscription;
        });
    }

    /**
     * Unpin a TeamMailbox
     *
     * @param   {EmailAddress}      emailAddress        TeamMailbox email address
     * @return  {Promise<void>}     Promise.
     */
    UnpinTeamMailbox(emailAddress: EmailAddress): Promise<void> {
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "UnpinTeamMailbox");

        if (emailAddress == null) {
            throw new ArgumentNullException("emailAddress");
        }

        let request: UnpinTeamMailboxRequest = new UnpinTeamMailboxRequest(this, emailAddress);
        return <any>request.Execute();
    }

    /**
     * @internal Unsubscribes from a subscription. Calling this method results in a call to EWS.
     *
     * @param   {string}   subscriptionId   The Id of the pull subscription to unsubscribe from.
     */
    Unsubscribe(subscriptionId: string): Promise<void> {
        return <any>this.BuildUnsubscribeRequest(subscriptionId).Execute();
    }

    /* #endregion Notification operations */


    /* #region Synchronization operations */

    // BeginSyncFolderItems(callback: Function /*System.AsyncCallback*/, state: any, syncFolderId: FolderId, propertySet: PropertySet, ignoredItemIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, maxChangesReturned: number, syncScope: SyncFolderItemsScope, syncState: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSyncFolderItems : Not implemented."); }
    // BeginSyncFolderItems(callback: Function /*System.AsyncCallback*/, state: any, syncFolderId: FolderId, propertySet: PropertySet, ignoredItemIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, maxChangesReturned: number, numberOfDays: number, syncScope: SyncFolderItemsScope, syncState: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSyncFolderItems : Not implemented."); }

    /**
     * Builds a request to synchronize the items of a specific folder.
     *
     * @param   {FolderId}              syncFolderId         The Id of the folder containing the items to synchronize with.
     * @param   {PropertySet}           propertySet          The set of properties to retrieve for synchronized items.
     * @param   {ItemId[]}              ignoredItemIds       The optional list of item Ids that should be ignored.
     * @param   {number}                maxChangesReturned   The maximum number of changes that should be returned.
     * @param   {number}                numberOfDays         Limit the changes returned to this many days ago; 0 means no limit.
     * @param   {SyncFolderItemsScope}  syncScope            The sync scope identifying items to include in the ChangeCollection.
     * @param   {string}                syncState            The optional sync state representing the point in time when to start the synchronization.
     * @return  {SyncFolderItemsRequest}        A request to synchronize the items of a specific folder.
     */
    private BuildSyncFolderItemsRequest(syncFolderId: FolderId, propertySet: PropertySet, ignoredItemIds: ItemId[], maxChangesReturned: number, numberOfDays: number, syncScope: SyncFolderItemsScope, syncState: string): SyncFolderItemsRequest {
        EwsUtilities.ValidateParam(syncFolderId, "syncFolderId");
        EwsUtilities.ValidateParam(propertySet, "propertySet");

        let request: SyncFolderItemsRequest = new SyncFolderItemsRequest(this);

        request.SyncFolderId = syncFolderId;
        request.PropertySet = propertySet;
        if (ignoredItemIds != null) {
            request.IgnoredItemIds.AddRange(ignoredItemIds);
        }
        request.MaxChangesReturned = maxChangesReturned;
        request.NumberOfDays = numberOfDays;
        request.SyncScope = syncScope;
        request.SyncState = syncState;

        return request;
    }
    //EndSyncFolderItems(asyncResult: Function /*System.IAsyncResult*/): ChangeCollection<ItemChange> { throw new Error("ExchangeService.ts - EndSyncFolderItems : Not implemented."); }

    /**
     * Synchronizes the items of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}              syncFolderId         The Id of the folder containing the items to synchronize with.
     * @param   {PropertySet}           propertySet          The set of properties to retrieve for synchronized items.
     * @param   {ItemId[]}              ignoredItemIds       The optional list of item Ids that should be ignored.
     * @param   {number}                maxChangesReturned   The maximum number of changes that should be returned.
     * @param   {number}                numberOfDays         Limit the changes returned to this many days ago; 0 means no limit.
     * @param   {SyncFolderItemsScope}  syncScope            The sync scope identifying items to include in the ChangeCollection.
     * @param   {string}                syncState            The optional sync state representing the point in time when to start the synchronization.
     * @return  {Promise<ChangeCollection<ItemChange>>}      A ChangeCollection containing a list of changes that occurred in the specified folder   :Promise.
     */
    SyncFolderItems(syncFolderId: FolderId, propertySet: PropertySet, ignoredItemIds: ItemId[], maxChangesReturned: number, syncScope: SyncFolderItemsScope, syncState: string): Promise<ChangeCollection<ItemChange>>;
    /**
     * Synchronizes the items of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}              syncFolderId         The Id of the folder containing the items to synchronize with.
     * @param   {PropertySet}           propertySet          The set of properties to retrieve for synchronized items.
     * @param   {ItemId[]}              ignoredItemIds       The optional list of item Ids that should be ignored.
     * @param   {number}                maxChangesReturned   The maximum number of changes that should be returned.
     * @param   {number}                numberOfDays         Limit the changes returned to this many days ago; 0 means no limit.
     * @param   {SyncFolderItemsScope}  syncScope            The sync scope identifying items to include in the ChangeCollection.
     * @param   {string}                syncState            The optional sync state representing the point in time when to start the synchronization.
     * @return  {Promise<ChangeCollection<ItemChange>>}      A ChangeCollection containing a list of changes that occurred in the specified folder   :Promise.
     */
    SyncFolderItems(syncFolderId: FolderId, propertySet: PropertySet, ignoredItemIds: ItemId[], maxChangesReturned: number, numberOfDays: number, syncScope: SyncFolderItemsScope, syncState: string): Promise<ChangeCollection<ItemChange>>;
    SyncFolderItems(
        syncFolderId: FolderId,
        propertySet: PropertySet,
        ignoredItemIds: ItemId[],
        maxChangesReturned: number,
        numberOfDaysOrSyncScope: number | SyncFolderItemsScope,
        syncScopeOrSyncState: SyncFolderItemsScope | string,
        syncState: string = null): Promise<ChangeCollection<ItemChange>> {

        let numberOfDays: number = 0;
        let syncScope: SyncFolderItemsScope;

        if (arguments.length === 6) {
            syncState = <string>syncScopeOrSyncState;
            syncScope = numberOfDaysOrSyncScope;
        }
        else {
            numberOfDays = numberOfDaysOrSyncScope;
            syncScope = <SyncFolderItemsScope>syncScopeOrSyncState;
        }

        return this.BuildSyncFolderItemsRequest(
            syncFolderId,
            propertySet,
            ignoredItemIds,
            maxChangesReturned,
            numberOfDays,
            syncScope,
            syncState).Execute().then((responses) => {
                return responses.__thisIndexer(0).Changes;
            });
    }

    // BeginSyncFolderHierarchy(callback: Function /*System.AsyncCallback*/, state: any, propertySet: PropertySet, syncState: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSyncFolderHierarchy : Not implemented."); }
    // //BeginSyncFolderHierarchy(callback: Function /*System.AsyncCallback*/, state: any, syncFolderId: FolderId, propertySet: PropertySet, syncState: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSyncFolderHierarchy : Not implemented."); }

    /**
     * Builds a request to synchronize the specified folder hierarchy of the mailbox this Service is connected to.
     *
     * @param   {FolderId}      syncFolderId   The Id of the folder containing the items to synchronize with. A null value indicates the root folder of the mailbox.
     * @param   {PropertySet}   propertySet    The set of properties to retrieve for synchronized items.
     * @param   {string}        syncState      The optional sync state representing the point in time when to start the synchronization.
     * @return  {SyncFolderHierarchyRequest}        A request to synchronize the specified folder hierarchy of the mailbox this Service is connected to.
     */
    private BuildSyncFolderHierarchyRequest(syncFolderId: FolderId, propertySet: PropertySet, syncState: string): SyncFolderHierarchyRequest {
        EwsUtilities.ValidateParamAllowNull(syncFolderId, "syncFolderId");  // Null syncFolderId is allowed
        EwsUtilities.ValidateParam(propertySet, "propertySet");

        let request: SyncFolderHierarchyRequest = new SyncFolderHierarchyRequest(this);

        request.PropertySet = propertySet;
        request.SyncFolderId = syncFolderId;
        request.SyncState = syncState;

        return request;
    }

    //EndSyncFolderHierarchy(asyncResult: Function /*System.IAsyncResult*/): ChangeCollection<FolderChange> { throw new Error("ExchangeService.ts - EndSyncFolderHierarchy : Not implemented."); }

    /**
     * Synchronizes the sub-folders of a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      syncFolderId   The Id of the folder containing the items to synchronize with. A null value indicates the root folder of the mailbox.
     * @param   {PropertySet}   propertySet    The set of properties to retrieve for synchronized items.
     * @param   {string}        syncState      The optional sync state representing the point in time when to start the synchronization.
     * @return  {Promise<ChangeCollection<FolderChange>>}       A ChangeCollection containing a list of changes that occurred in the specified folder   :Promise.
     */
    SyncFolderHierarchy(syncFolderId: FolderId, propertySet: PropertySet, syncState: string): Promise<ChangeCollection<FolderChange>>;
    /**
     * Synchronizes the entire folder hierarchy of the mailbox this Service is connected to. Calling this method results in a call to EWS.
     *
     * @param   {PropertySet}   propertySet    The set of properties to retrieve for synchronized items.
     * @param   {string}        syncState      The optional sync state representing the point in time when to start the synchronization.
     * @return  {Promise<ChangeCollection<FolderChange>>}       A ChangeCollection containing a list of changes that occurred in the specified folder   :Promise.
     */
    SyncFolderHierarchy(propertySet: PropertySet, syncState: string): Promise<ChangeCollection<FolderChange>>;
    SyncFolderHierarchy(
        syncFolderIdOrPropertySet: FolderId | PropertySet,
        propertySetOrSyncState: PropertySet | string,
        syncState: string = null): Promise<ChangeCollection<FolderChange>> {

        let syncFolderId: FolderId = null;
        let propertySet: PropertySet;

        if (arguments.length === 2) {
            propertySet = <PropertySet>syncFolderIdOrPropertySet;
            syncState = <string>propertySetOrSyncState;
        }
        else {
            syncFolderId = <FolderId>syncFolderIdOrPropertySet;
            propertySet = <PropertySet>propertySetOrSyncState;
        }

        return this.BuildSyncFolderHierarchyRequest(
            syncFolderId,
            propertySet,
            syncState).Execute().then((responses) => {
                return responses.__thisIndexer(0).Changes;
            });
    }
    /* #endregion Synchronization operations */


    /* #region Availability operations */

    /**
     * Retrieves a collection of all room lists in the organization.
     *
     * @return  {Promise<EmailAddressCollection[]>}     A collection of EmailAddress objects representing all the rooms within the specifed room list   :Promise.
     */
    GetRoomLists(): Promise<EmailAddressCollection> {
        let request: GetRoomListsRequest = new GetRoomListsRequest(this);

        return request.Execute().then((response) => {
            return response.RoomLists;
        });
    }

    /**
     * Retrieves a collection of all rooms in the specified room list in the organization.
     *
     * @param   {EmailAddress}   emailAddress   The e-mail address of the room list.
     * @return  {Promise<EmailAddress[]>}       A collection of EmailAddress objects representing all the rooms within the specifed room list   :Promise.
     */
    GetRooms(emailAddress: EmailAddress): Promise<EmailAddress[]> {
        EwsUtilities.ValidateParam(emailAddress, "emailAddress");

        let request: GetRoomsRequest = new GetRoomsRequest(this);

        request.RoomList = emailAddress;

        return request.Execute().then((response) => {
            return response.Rooms;
        });
    }

    /**
     * Gets detailed information about the availability of a set of users, rooms, and resources within a specified time window.
     *
     * @param   {AttendeeInfo[]}        attendees           The attendees for which to retrieve availability information.
     * @param   {TimeWindow}            timeWindow          The time window in which to retrieve user availability information.
     * @param   {AvailabilityData}      requestedData       The requested data (free/busy and/or suggestions).
     * @return  {Promise<GetUserAvailabilityResults>}       The availability information for each user appears in a unique FreeBusyResponse object. The order of users in the request determines the order of availability data for each user in the response :Promise.
     */
    GetUserAvailability(attendees: AttendeeInfo[], timeWindow: TimeWindow, requestedData: AvailabilityData): Promise<GetUserAvailabilityResults>;
    /**
     * Gets detailed information about the availability of a set of users, rooms, and resources within a specified time window.
     *
     * @param   {AttendeeInfo[]}        attendees           The attendees for which to retrieve availability information.
     * @param   {TimeWindow}            timeWindow          The time window in which to retrieve user availability information.
     * @param   {AvailabilityData}      requestedData       The requested data (free/busy and/or suggestions).
     * @param   {AvailabilityOptions}   options             The options controlling the information returned.
     * @return  {Promise<GetUserAvailabilityResults>}       The availability information for each user appears in a unique FreeBusyResponse object. The order of users in the request determines the order of availability data for each user in the response :Promise.
     */
    GetUserAvailability(attendees: AttendeeInfo[], timeWindow: TimeWindow, requestedData: AvailabilityData, options: AvailabilityOptions): Promise<GetUserAvailabilityResults>;
    GetUserAvailability(attendees: AttendeeInfo[], timeWindow: TimeWindow, requestedData: AvailabilityData, options: AvailabilityOptions = new AvailabilityOptions()): Promise<GetUserAvailabilityResults> {
        EwsUtilities.ValidateParamCollection(attendees, "attendees");
        EwsUtilities.ValidateParam(timeWindow, "timeWindow");
        EwsUtilities.ValidateParam(options, "options");
        var request = new GetUserAvailabilityRequest(this);

        request.Attendees = attendees;
        request.TimeWindow = timeWindow;
        request.RequestedData = requestedData;
        request.Options = options;

        return request.Execute().then((responses) => {
            return responses;
        });

    }

    /**
     * Gets Out of Office (OOF) settings for a specific user. Calling this method results in a call to EWS.
     *
     * @param   {string}   smtpAddress   The SMTP address of the user for which to retrieve OOF settings.
     * @return  {Promise<OofSettings>}   An OofSettings instance containing OOF information for the specified user.
     */
    GetUserOofSettings(smtpAddress: string): Promise<OofSettings> {
        EwsUtilities.ValidateParam(smtpAddress, "smtpAddress");

        var request: GetUserOofSettingsRequest = new GetUserOofSettingsRequest(this);

        request.SmtpAddress = smtpAddress;

        return request.Execute().then((response) => {
            return response.OofSettings;
        });
    }

    /**
     * Sets the Out of Office (OOF) settings for a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {string}        smtpAddress   The SMTP address of the user for which to set OOF settings.
     * @param   {OofSettings}   oofSettings   The OOF settings.
     * @return  {Promise<void>}      Promise.
     */
    SetUserOofSettings(smtpAddress: string, oofSettings: OofSettings): Promise<void> {
        EwsUtilities.ValidateParam(smtpAddress, "smtpAddress");
        EwsUtilities.ValidateParam(oofSettings, "oofSettings");

        var request: SetUserOofSettingsRequest = new SetUserOofSettingsRequest(this);

        request.SmtpAddress = smtpAddress;
        request.OofSettings = oofSettings;

        return <any>request.Execute();
    }
    /* #endregion Availability operations */


    /* #region Conversation */

    /**
     * Applies ConversationAction on the specified conversation.
     *
     * @param   {ConversationActionType}    actionType            ConversationAction
     * @param   {ConversationId[]}          conversationIds       The conversation ids.
     * @param   {boolean}                   processRightAway      True to process at once . This is blocking and false to let the Assistant process it in the back ground
     * @param   {StringList}                categories            Catgories that need to be stamped can be null or empty
     * @param   {boolean}                   enableAlwaysDelete    True moves every current and future messages in the conversation to deleted items folder. False stops the alwasy delete action. This is applicable only if the action is AlwaysDelete
     * @param   {FolderId}                  destinationFolderId   Applicable if the action is AlwaysMove. This moves every current message and future  message in the conversation to the specified folder. Can be null if tis is then it stops the always move action
     * @param   {ServiceErrorHandling}      errorHandlingMode     The error handling mode.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    private ApplyConversationAction(
        actionType: ConversationActionType,
        conversationIds: ConversationId[],
        processRightAway: boolean,
        categories: StringList,
        enableAlwaysDelete: boolean,
        destinationFolderId: FolderId,
        errorHandlingMode: ServiceErrorHandling): Promise<ServiceResponseCollection<ServiceResponse>> {
        EwsLogging.Assert(
            actionType == ConversationActionType.AlwaysCategorize ||
            actionType == ConversationActionType.AlwaysMove ||
            actionType == ConversationActionType.AlwaysDelete,
            "ApplyConversationAction",
            "Invalic actionType");

        EwsUtilities.ValidateParam(conversationIds, "conversationId");
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2010_SP1,
            "ApplyConversationAction");

        let request: ApplyConversationActionRequest = new ApplyConversationActionRequest(this, errorHandlingMode);
        let action: ConversationAction = new ConversationAction();

        for (let conversationId of conversationIds) {
            action.Action = actionType;
            action.ConversationId = conversationId;
            action.ProcessRightAway = processRightAway;
            action.Categories = categories;
            action.EnableAlwaysDelete = enableAlwaysDelete;
            action.DestinationFolderId = destinationFolderId != null ? new FolderIdWrapper(destinationFolderId) : null;
            request.ConversationActions.push(action);
        }

        return request.Execute();
    }

    /**
     * Applies one time conversation action on items in specified folder inside the conversation.
     *
     * @param   {ConversationActionType}                        actionType             The action.
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idTimePairs            The id time pairs.
     * @param   {FolderId}                                      contextFolderId        The context folder id.
     * @param   {FolderId}                                      destinationFolderId    The destination folder id.
     * @param   {DeleteMode}                                    deleteType             Type of the delete.
     * @param   {boolean}                                       isRead                 The is read.
     * @param   {RetentionType}                                 retentionPolicyType    Retention policy type.
     * @param   {Guid}                                          retentionPolicyTagId   Retention policy tag id.  Null will clear the policy.
     * @param   {Flag}                                          flag                   Flag status.
     * @param   {boolean}                                       suppressReadReceipts   Suppress read receipts flag.
     * @param   {ServiceErrorHandling}                          errorHandlingMode      The error handling mode.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    private ApplyConversationOneTimeAction(
        actionType: ConversationActionType,
        idTimePairs: KeyValuePair<ConversationId, DateTime>[], // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs,
        contextFolderId: FolderId,
        destinationFolderId: FolderId,
        deleteType: DeleteMode,
        isRead: boolean,
        retentionPolicyType: RetentionType,
        retentionPolicyTagId: Guid,
        flag: Flag,
        suppressReadReceipts: boolean,
        errorHandlingMode: ServiceErrorHandling): Promise<ServiceResponseCollection<ServiceResponse>> {
        EwsLogging.Assert(
            actionType == ConversationActionType.Move ||
            actionType == ConversationActionType.Delete ||
            actionType == ConversationActionType.SetReadState ||
            actionType == ConversationActionType.SetRetentionPolicy ||
            actionType == ConversationActionType.Copy ||
            actionType == ConversationActionType.Flag,
            "ApplyConversationOneTimeAction",
            "Invalid actionType");

        EwsUtilities.ValidateParamCollection(idTimePairs, "idTimePairs");
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2010_SP1,
            "ApplyConversationAction");

        let request: ApplyConversationActionRequest = new ApplyConversationActionRequest(this, errorHandlingMode);

        for (let idTimePair of idTimePairs) {
            let action: ConversationAction = new ConversationAction();

            action.Action = actionType;
            action.ConversationId = idTimePair.key;
            action.ContextFolderId = contextFolderId != null ? new FolderIdWrapper(contextFolderId) : null;
            action.DestinationFolderId = destinationFolderId != null ? new FolderIdWrapper(destinationFolderId) : null;
            action.ConversationLastSyncTime = idTimePair.value;
            action.IsRead = isRead;
            action.DeleteType = deleteType;
            action.RetentionPolicyType = retentionPolicyType;
            action.RetentionPolicyTagId = retentionPolicyTagId;
            action.Flag = flag;
            action.SuppressReadReceipts = suppressReadReceipts;

            request.ConversationActions.push(action);
        }

        return request.Execute();
    }

    /**
     * Sets up a conversation so that any item received within that conversation is no longer categorized. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once disabling this rule and removing the categories from existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    DisableAlwaysCategorizeItemsInConversations(conversationId: ConversationId[], processSynchronously: boolean): Promise<ServiceResponseCollection<ServiceResponse>> {
        return this.ApplyConversationAction(
            ConversationActionType.AlwaysCategorize,
            conversationId,
            processSynchronously,
            null,
            false,
            null,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Sets up a conversation so that any item received within that conversation is no longer moved to Deleted Items folder. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once disabling this rule and restoring the items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    DisableAlwaysDeleteItemsInConversations(conversationId: ConversationId[], processSynchronously: boolean): Promise<ServiceResponseCollection<ServiceResponse>> {
        return this.ApplyConversationAction(
            ConversationActionType.AlwaysDelete,
            conversationId,
            processSynchronously,
            null,
            false,
            null,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Sets up a conversation so that any item received within that conversation is no longer moved to a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationIds        The conversation ids.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once disabling this rule is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    DisableAlwaysMoveItemsInConversations(conversationIds: ConversationId[], processSynchronously: boolean): Promise<ServiceResponseCollection<ServiceResponse>> {
        return this.ApplyConversationAction(
            ConversationActionType.AlwaysMove,
            conversationIds,
            processSynchronously,
            null,
            false,
            null,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Sets up a conversation so that any item received within that conversation is always categorized. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {string[]}          categories             The categories that should be stamped on items in the conversation.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once enabling this rule and stamping existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    EnableAlwaysCategorizeItemsInConversations(conversationId: ConversationId[], categories: string[], processSynchronously: boolean): Promise<ServiceResponseCollection<ServiceResponse>> {
        EwsUtilities.ValidateParamCollection(categories, "categories");
        return this.ApplyConversationAction(
            ConversationActionType.AlwaysCategorize,
            conversationId,
            processSynchronously,
            new StringList(categories),
            false,
            null,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Sets up a conversation so that any item received within that conversation is always moved to Deleted Items folder. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once enabling this rule and deleting existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    EnableAlwaysDeleteItemsInConversations(conversationId: ConversationId[], processSynchronously: boolean): Promise<ServiceResponseCollection<ServiceResponse>> {
        return this.ApplyConversationAction(
            ConversationActionType.AlwaysDelete,
            conversationId,
            processSynchronously,
            null,
            true,
            null,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Sets up a conversation so that any item received within that conversation is always moved to a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {FolderId}          destinationFolderId    The Id of the folder to which conversation items should be moved.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once enabling this rule and moving existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    EnableAlwaysMoveItemsInConversations(conversationId: ConversationId[], destinationFolderId: FolderId, processSynchronously: boolean): Promise<ServiceResponseCollection<ServiceResponse>> {
        EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        return this.ApplyConversationAction(
            ConversationActionType.AlwaysMove,
            conversationId,
            processSynchronously,
            null,
            false,
            destinationFolderId,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Retrieves a collection of all Conversations in the specified Folder.
     *
     * @param   {ViewBase}   view       The view controlling the number of conversations returned.
     * @param   {FolderId}   folderId   The Id of the folder in which to search for conversations.
     * @return  {Promise<Conversation[]>}       Collection of conversations.
     */
    FindConversation(view: ViewBase, folderId: FolderId): Promise<Conversation[]>;
    /**
     * Retrieves a collection of all Conversations in the specified Folder.
     *
     * @param   {ViewBase}  view                   The view controlling the number of conversations returned.
     * @param   {FolderId}  folderId               The Id of the folder in which to search for conversations.
     * @param   {string}    queryString            The query string for which the search is being performed
     * @return  {Promise<FindConversationResults>}      FindConversation results    :Promise.
     */
    FindConversation(view: ViewBase, folderId: FolderId, queryString: string): Promise<Conversation[]>;
    /**
     * Searches for and retrieves a collection of Conversations in the specified Folder. Along with conversations, a list of highlight terms are returned.
     *
     * @param   {ViewBase}  view                   The view controlling the number of conversations returned.
     * @param   {FolderId}  folderId               The Id of the folder in which to search for conversations.
     * @param   {string}    queryString            The query string for which the search is being performed
     * @param   {boolean}   returnHighlightTerms   Flag indicating if highlight terms should be returned in the response
     * @return  {Promise<FindConversationResults>}      FindConversation results    :Promise.
     */
    FindConversation(view: ViewBase, folderId: FolderId, queryString: string, returnHighlightTerms: boolean): Promise<FindConversationResults>;
    /**
     * Searches for and retrieves a collection of Conversations in the specified Folder. Along with conversations, a list of highlight terms are returned.
     *
     * @param   {ViewBase}                  view                   The view controlling the number of conversations returned.
     * @param   {FolderId}                  folderId               The Id of the folder in which to search for conversations.
     * @param   {string}                    queryString            The query string for which the search is being performed
     * @param   {boolean}                   returnHighlightTerms   Flag indicating if highlight terms should be returned in the response
     * @param   {MailboxSearchLocation?}    mailboxScope           The mailbox scope to reference.
     * @return  {Promise<FindConversationResults>}      FindConversation results    :Promise.
     */
    FindConversation(view: ViewBase, folderId: FolderId, queryString: string, returnHighlightTerms: boolean, mailboxScope: MailboxSearchLocation): Promise<FindConversationResults>;
    FindConversation(
        view: ViewBase,
        folderId: FolderId,
        queryString: string = null,
        returnHighlightTerms: boolean = null,
        mailboxScope: MailboxSearchLocation = null): Promise<FindConversationResults | Conversation[]> {

        let argsLength = arguments.length;

        EwsUtilities.ValidateParam(view, "view");
        EwsUtilities.ValidateParam(folderId, "folderId");

        let request: FindConversationRequest = new FindConversationRequest(this);
        request.View = view;
        request.FolderId = new FolderIdWrapper(folderId);

        if (argsLength > 2) {
            EwsUtilities.ValidateParamAllowNull(queryString, "queryString");
            request.QueryString = queryString;
        }

        if (argsLength > 3) {
            EwsUtilities.ValidateParam(returnHighlightTerms, "returnHighlightTerms");
            request.ReturnHighlightTerms = returnHighlightTerms;

            EwsUtilities.ValidateMethodVersion(
                this,
                ExchangeVersion.Exchange2013, // This method is only applicable for Exchange2013
                "FindConversation");
        }

        if (argsLength > 4) {
            request.MailboxScope = mailboxScope;
        }
        return request.Execute().then((responses: FindConversationResponse) => {
            if (argsLength > 3) {
                return responses.Results; // based on arguments it can return this or either Results.
            }
            else {
                return responses.Conversations;
            }
        });
    }

    /**
     * Retrieves a collection of all Conversations in the specified Folder.
     *
     * @param   {ViewBase}  view            The view controlling the number of conversations returned.
     * @param   {FolderId}  folderId        The Id of the folder in which to search for conversations.
     * @param   {string}    anchorMailbox   The anchorMailbox Smtp address to route the request directly to group mailbox.
     * @return  {Promise<Conversation[]>}   Collection of conversations :Promise.
     */
    FindGroupConversation(view: ViewBase, folderId: FolderId, anchorMailbox: string): Promise<Conversation[]> {

        EwsUtilities.ValidateParam(view, "view");
        EwsUtilities.ValidateParam(folderId, "folderId");
        EwsUtilities.ValidateParam(anchorMailbox, "anchorMailbox");
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2015,
            "FindConversation");

        let request: FindConversationRequest = new FindConversationRequest(this);

        request.View = view;
        request.FolderId = new FolderIdWrapper(folderId);
        request.AnchorMailbox = anchorMailbox;

        return request.Execute().then((responses: FindConversationResponse) => {
            return responses.Conversations;
        });
    }

    /**
     * Gets the items for a set of conversations.
     *
     * @param   {ConversationRequest[]}     conversations     Conversations with items to load.
     * @param   {PropertySet}               propertySet       The set of properties to load.
     * @param   {FolderId[]}                foldersToIgnore   The folders to ignore.
     * @param   {ConversationSortOrder}     sortOrder         Conversation item sort order.
     * @return  {Promise<ServiceResponseCollection<GetConversationItemsResponse>>}      GetConversationItems response    :Promise.
     */
    GetConversationItems(conversations: ConversationRequest[], propertySet: PropertySet, foldersToIgnore: FolderId[], sortOrder: ConversationSortOrder /* Nullable */): Promise<ServiceResponseCollection<GetConversationItemsResponse>>;
    /**
     * Gets the items for a set of conversations.
     *
     * @param   {ConversationRequest[]}     conversations     Conversations with items to load.
     * @param   {PropertySet}               propertySet       The set of properties to load.
     * @param   {FolderId[]}                foldersToIgnore   The folders to ignore.
     * @param   {ConversationSortOrder}     sortOrder         Conversation item sort order.
     * @param   {MailboxSearchLocation}     mailboxScope      The mailbox scope to reference.
     * @return  {Promise<ServiceResponseCollection<GetConversationItemsResponse>>}      GetConversationItems response    :Promise.
     */
    GetConversationItems(conversations: ConversationRequest[], propertySet: PropertySet, foldersToIgnore: FolderId[], sortOrder: ConversationSortOrder /* Nullable */, mailboxScope: MailboxSearchLocation /* Nullable */): Promise<ServiceResponseCollection<GetConversationItemsResponse>>;
    /**
     * Gets the items for a conversation.
     *
     * @param   {ConversationId}            conversationId    The conversation id.
     * @param   {PropertySet}               propertySet       The set of properties to load.
     * @param   {string}                    syncState         The optional sync state representing the point in time when to start the synchronization.
     * @param   {FolderId[]}                foldersToIgnore   The folders to ignore.
     * @param   {ConversationSortOrder}     sortOrder         Conversation item sort order.
     * @return  {Promise<ConversationResponse>}               GetConversationItems response    :Promise.
     */
    GetConversationItems(conversationId: ConversationId, propertySet: PropertySet, syncState: string, foldersToIgnore: FolderId[], sortOrder: ConversationSortOrder /* Nullable */): Promise<ConversationResponse>;
    GetConversationItems(
        conversationsOrConversationId: ConversationRequest[] | ConversationId,
        propertySet: PropertySet,
        foldersToIgnoreOrSyncState: FolderId[] | string,
        sortOrderOrFoldersToIgnore: ConversationSortOrder /* Nullable */ | FolderId[],
        mailboxScopeOrSortOrder: ConversationSortOrder | MailboxSearchLocation /* Nullable */ = null): Promise<ServiceResponseCollection<GetConversationItemsResponse> | ConversationResponse> {

        let conversations: ConversationRequest[] = [];
        let foldersToIgnore: FolderId[] = [];
        let syncState: string = null;
        let sortOrder: ConversationSortOrder = null;
        let mailboxScope: MailboxSearchLocation = null;
        let returnConversationResponse: boolean = false;

        if (conversationsOrConversationId instanceof ConversationId) {
            conversations.push(new ConversationRequest(conversationsOrConversationId, <string>foldersToIgnoreOrSyncState));
            foldersToIgnore = <FolderId[]>sortOrderOrFoldersToIgnore;
            sortOrder = <ConversationSortOrder>mailboxScopeOrSortOrder;
            returnConversationResponse = true;
        }
        else {
            conversations = conversationsOrConversationId;
            foldersToIgnore = <FolderId[]>foldersToIgnoreOrSyncState;
            sortOrder = <ConversationSortOrder>sortOrderOrFoldersToIgnore;
            mailboxScope = <MailboxSearchLocation>mailboxScopeOrSortOrder;

        }

        return this.InternalGetConversationItems(
            conversations,
            propertySet,
            foldersToIgnore,
            sortOrder, //todo: check why official repo has passed sortOrder as nulll when requested with ConversationRequest[] varient
            mailboxScope,           /* mailboxScope */
            null,           /* maxItemsToReturn */
            null, /* anchorMailbox */
            ServiceErrorHandling.ThrowOnError).then((responses: ServiceResponseCollection<GetConversationItemsResponse>) => {
                return returnConversationResponse ? responses.__thisIndexer(0).Conversation : responses;
            });

    }

    /**
     * Gets the items for a conversation.
     *
     * /remarks/    This API designed to be used primarily in groups scenarios where we want to set the anchor mailbox header so that request is routed directly to the group mailbox backend server.
     * @param   {ConversationId}            conversationId    The conversation id.
     * @param   {PropertySet}               propertySet       The set of properties to load.
     * @param   {string}                    syncState         The optional sync state representing the point in time when to start the synchronization.
     * @param   {FolderId[]}                foldersToIgnore   The folders to ignore.
     * @param   {ConversationSortOrder}     sortOrder         Conversation item sort order.
     * @param   {string}                    anchorMailbox     The smtp address of the mailbox hosting the conversations
     * @return  {Promise<ConversationResponse>}               ConversationResponseType response :Promise.
     */
    GetGroupConversationItems(conversationId: ConversationId, propertySet: PropertySet,
        syncState: string, foldersToIgnore: FolderId[], sortOrder: ConversationSortOrder /* Nullable */, anchorMailbox: string): Promise<ConversationResponse> {
        EwsUtilities.ValidateParam(anchorMailbox, "anchorMailbox");

        let conversations: ConversationRequest[] = [];
        conversations.push(new ConversationRequest(conversationId, syncState));

        return this.InternalGetConversationItems(
            conversations,
            propertySet,
            foldersToIgnore,
            sortOrder,
            null,           /* mailboxScope */
            null,           /* maxItemsToReturn */
            anchorMailbox, /* anchorMailbox */
            ServiceErrorHandling.ThrowOnError).then((responses: ServiceResponseCollection<GetConversationItemsResponse>) => {
                return responses.__thisIndexer(0).Conversation;
            });
    }

    /**
     * @internal Gets the items for a set of conversations.
     *
     * @param   {ConversationRequest[]}     conversations      Conversations with items to load.
     * @param   {PropertySet}               propertySet        The set of properties to load.
     * @param   {FolderId[]}                foldersToIgnore    The folders to ignore.
     * @param   {ConversationSortOrder?}    sortOrder          Sort order of conversation tree nodes.
     * @param   {MailboxSearchLocation?}    mailboxScope       The mailbox scope to reference.
     * @param   {number?}                   maxItemsToReturn   Maximum number of items to return.
     * @param   {string}                    anchorMailbox      The smtpaddress of the mailbox that hosts the conversations
     * @param   {ServiceErrorHandling}      errorHandling      What type of error handling should be performed.
     * @return  {Promise<ServiceResponseCollection<GetConversationItemsResponse>>}      GetConversationItems response.
     */
    InternalGetConversationItems(
        conversations: ConversationRequest[],
        propertySet: PropertySet,
        foldersToIgnore: FolderId[],
        sortOrder: ConversationSortOrder, //Nullable
        mailboxScope: MailboxSearchLocation, //Nullable
        maxItemsToReturn: number, //nullable
        anchorMailbox: string,
        errorHandling: ServiceErrorHandling): Promise<ServiceResponseCollection<GetConversationItemsResponse>> {

        EwsUtilities.ValidateParam(conversations, "conversations");
        EwsUtilities.ValidateParam(propertySet, "itemProperties");
        EwsUtilities.ValidateParamAllowNull(foldersToIgnore, "foldersToIgnore");
        EwsUtilities.ValidateMethodVersion(
            this,
            ExchangeVersion.Exchange2013,
            "GetConversationItems");

        let request: GetConversationItemsRequest = new GetConversationItemsRequest(this, errorHandling);
        request.ItemProperties = propertySet;
        request.FoldersToIgnore = new FolderIdCollection(foldersToIgnore);
        request.SortOrder = sortOrder;
        request.MailboxScope = mailboxScope;
        request.MaxItemsToReturn = maxItemsToReturn;
        request.AnchorMailbox = anchorMailbox;
        request.Conversations = conversations;

        return request.Execute();
    }

    /**
     * Copies the items in the specified conversation to the specified destination folder. Calling this method results in a call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs   The pairs of Id of conversation whose items should be copied and the date and time conversation was last synced (Items received after that date will not be copied).
     * @param   {FolderId}                                      contextFolderId       The context folder id.
     * @param   {FolderId}                                      destinationFolderId   The destination folder id.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    CopyItemsInConversations(idLastSyncTimePairs: KeyValuePair<ConversationId, DateTime>[], // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId: FolderId, destinationFolderId: FolderId): Promise<ServiceResponseCollection<ServiceResponse>> {
        EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        return this.ApplyConversationOneTimeAction(
            ConversationActionType.Copy,
            idLastSyncTimePairs,
            contextFolderId,
            destinationFolderId,
            null,
            null,
            null,
            null,
            null,
            null,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Deletes the items in the specified conversation. Calling this method results in a call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs   The pairs of Id of conversation whose items should be deleted and the date and time conversation was last synced (Items received after that date will not be deleted).
     * @param   {FolderId}                                      contextFolderId       The Id of the folder that contains the conversation.
     * @param   {DeleteMode}                                    deleteMode            The deletion mode.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    DeleteItemsInConversations(idLastSyncTimePairs: KeyValuePair<ConversationId, DateTime>[], // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId: FolderId, deleteMode: DeleteMode): Promise<ServiceResponseCollection<ServiceResponse>> {
        return this.ApplyConversationOneTimeAction(
            ConversationActionType.Delete,
            idLastSyncTimePairs,
            contextFolderId,
            null,
            deleteMode,
            null,
            null,
            null,
            null,
            null,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Moves the items in the specified conversation to the specified destination folder. Calling this method results in a call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs   The pairs of Id of conversation whose items should be moved and the dateTime conversation was last synced (Items received after that dateTime will not be moved).
     * @param   {FolderId}                                      contextFolderId       The Id of the folder that contains the conversation.
     * @param   {FolderId}                                      destinationFolderId   The Id of the destination folder.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    MoveItemsInConversations(idLastSyncTimePairs: KeyValuePair<ConversationId, DateTime>[], // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId: FolderId, destinationFolderId: FolderId): Promise<ServiceResponseCollection<ServiceResponse>> {

        EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        return this.ApplyConversationOneTimeAction(
            ConversationActionType.Move,
            idLastSyncTimePairs,
            contextFolderId,
            destinationFolderId,
            null,
            null,
            null,
            null,
            null,
            null,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Sets flag status for items in conversation. Calling this method would result in call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}   idLastSyncTimePairs   The pairs of Id of conversation whose items should have their read state set and the date and time conversation was last synced (Items received after that date will not have their read state set).
     * @param   {FolderId}   contextFolderId       The Id of the folder that contains the conversation.
     * @param   {Flag}   flagStatus            Flag status to apply to conversation items.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    SetFlagStatusForItemsInConversations(idLastSyncTimePairs: KeyValuePair<ConversationId, DateTime>[], // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId: FolderId, flagStatus: Flag): Promise<ServiceResponseCollection<ServiceResponse>> {

        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "SetFlagStatusForItemsInConversations");

        return this.ApplyConversationOneTimeAction(
            ConversationActionType.Flag,
            idLastSyncTimePairs,
            contextFolderId,
            null,
            null,
            null,
            null,
            null,
            flagStatus,
            null,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Sets the read state for items in conversation. Calling this method would result in call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs    The pairs of Id of conversation whose items should have their read state set and the date and time conversation was last synced (Items received after that date will not have their read state set).
     * @param   {FolderId}                                      contextFolderId        The Id of the folder that contains the conversation.
     * @param   {boolean}                                       isRead                 if set to true, conversation items are marked as read; otherwise they are marked as unread.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    SetReadStateForItemsInConversations(idLastSyncTimePairs: KeyValuePair<ConversationId, DateTime>[], // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId: FolderId, isRead: boolean): Promise<ServiceResponseCollection<ServiceResponse>>;
    /**
     * Sets the read state for items in conversation. Calling this method would result in call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs    The pairs of Id of conversation whose items should have their read state set and the date and time conversation was last synced (Items received after that date will not have their read state set).
     * @param   {FolderId}                                      contextFolderId        The Id of the folder that contains the conversation.
     * @param   {boolean}                                       isRead                 if set to true, conversation items are marked as read; otherwise they are marked as unread.
     * @param   {boolean}                                       suppressReadReceipts   if set to *true* read receipts are suppressed.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    SetReadStateForItemsInConversations(idLastSyncTimePairs: KeyValuePair<ConversationId, DateTime>[], // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId: FolderId, isRead: boolean, suppressReadReceipts: boolean): Promise<ServiceResponseCollection<ServiceResponse>>;
    SetReadStateForItemsInConversations(idLastSyncTimePairs: KeyValuePair<ConversationId, DateTime>[], // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId: FolderId, isRead: boolean, suppressReadReceipts: boolean = null): Promise<ServiceResponseCollection<ServiceResponse>> {

        if (arguments.length === 4) {
            EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "SetReadStateForItemsInConversations");
        }

        return this.ApplyConversationOneTimeAction(
            ConversationActionType.SetReadState,
            idLastSyncTimePairs,
            contextFolderId,
            null,
            null,
            isRead,
            null,
            null,
            null,
            suppressReadReceipts, //null when not included in call
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Sets the retention policy for items in conversation. Calling this method would result in call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs    The pairs of Id of conversation whose items should have their retention policy set and the date and time conversation was last synced (Items received after that date will not have their retention policy set).
     * @param   {FolderId}                                      contextFolderId        The Id of the folder that contains the conversation.
     * @param   {RetentionType}                                 retentionPolicyType    Retention policy type.
     * @param   {Guid?}                                         retentionPolicyTagId   Retention policy tag id.  Null will clear the policy.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    SetRetentionPolicyForItemsInConversations(idLastSyncTimePairs: KeyValuePair<ConversationId, DateTime>[], // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId: FolderId, retentionPolicyType: RetentionType, retentionPolicyTagId: Guid): Promise<ServiceResponseCollection<ServiceResponse>> {
        return this.ApplyConversationOneTimeAction(
            ConversationActionType.SetRetentionPolicy,
            idLastSyncTimePairs,
            contextFolderId,
            null,
            null,
            null,
            retentionPolicyType,
            retentionPolicyTagId,
            null,
            null,
            ServiceErrorHandling.ReturnErrors);
    }
    /* #end region Conversation */


    /* #region Id conversion operations */

    /**
     * Converts Id from one format to another in a single call to EWS.
     *
     * @param   {AlternateIdBase}   id                 The Id to convert.
     * @param   {IdFormat}          destinationFormat   The destination format.
     * @return  {Promise<AlternateIdBase>}     The converted Id :Promise.
     */
    ConvertId(id: AlternateIdBase, destinationFormat: IdFormat): Promise<AlternateIdBase> {
        EwsUtilities.ValidateParam(id, "id");

        return this.InternalConvertIds(
            [id],
            destinationFormat,
            ServiceErrorHandling.ThrowOnError).then((responses: ServiceResponseCollection<ConvertIdResponse>) => {
                return responses.__thisIndexer(0).ConvertedId;
            })

    }

    /**
     * Converts multiple Ids from one format to another in a single call to EWS.
     *
     * @param   {AlternateIdBase[]}     ids                 The Ids to convert.
     * @param   {IdFormat}              destinationFormat   The destination format.
     * @return  {Promise<ServiceResponseCollection<ConvertIdResponse>>}     A ServiceResponseCollection providing conversion results for each specified Ids :Promise.
     */
    ConvertIds(ids: AlternateIdBase[], destinationFormat: IdFormat): Promise<ServiceResponseCollection<ConvertIdResponse>> {
        EwsUtilities.ValidateParamCollection(ids, "ids");

        return this.InternalConvertIds(
            ids,
            destinationFormat,
            ServiceErrorHandling.ReturnErrors);
    }

    /**
     * Converts multiple Ids from one format to another in a single call to EWS.
     *
     * @param   {AlternateIdBase[]}     ids                 The Ids to convert.
     * @param   {IdFormat}              destinationFormat   The destination format.
     * @param   {ServiceErrorHandling}  errorHandling       Type of error handling to perform.
     * @return  {Promise<ServiceResponseCollection<ConvertIdResponse>>}     A ServiceResponseCollection providing conversion results for each specified Ids :Promise.
     */
    private InternalConvertIds(ids: AlternateIdBase[], destinationFormat: IdFormat, errorHandling: ServiceErrorHandling): Promise<ServiceResponseCollection<ConvertIdResponse>> {
        EwsUtilities.ValidateParamCollection(ids, "ids");

        let request: ConvertIdRequest = new ConvertIdRequest(this, errorHandling);
        ArrayHelper.AddRange(request.Ids, ids);//request.Ids.AddRange(ids);
        request.DestinationFormat = destinationFormat;

        return request.Execute();
    }
    /* #endregion Id conversion operations */


    /* #region Delegate management operations */

    /**
     * Adds delegates to a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Mailbox}                       mailbox                        The mailbox to add delegates to.
     * @param   {MeetingRequestsDeliveryScope}  meetingRequestsDeliveryScope   Indicates how meeting requests should be sent to delegates.
     * @param   {...DelegateUser[]}             delegateUsers                  The delegate users to add.
     * @return  {Promise<DelegateUserResponse[]>}       A collection of DelegateUserResponse objects providing the results of the operation :Promise.
     */
    AddDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, ...delegateUsers: DelegateUser[]): Promise<DelegateUserResponse[]>;
    /**
     * Adds delegates to a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Mailbox}                       mailbox                        The mailbox to add delegates to.
     * @param   {MeetingRequestsDeliveryScope}  meetingRequestsDeliveryScope   Indicates how meeting requests should be sent to delegates.
     * @param   {DelegateUser[]}                delegateUsers                  The delegate users to add.
     * @return  {Promise<DelegateUserResponse[]>}       A collection of DelegateUserResponse objects providing the results of the operation :Promise.
     */
    AddDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, delegateUsers: DelegateUser[]): Promise<DelegateUserResponse[]>;
    AddDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, delegateUser: DelegateUser[] | DelegateUser, ...delegateUsers: DelegateUser[]): Promise<DelegateUserResponse[]> {

        if (delegateUser) { //info: rest parameters are optional for typescript
            if (ArrayHelper.isArray(delegateUser)) {
                ArrayHelper.AddRange(delegateUsers, <DelegateUser[]>delegateUser);
            }
            else {
                delegateUsers.push(<DelegateUser>delegateUser);
            }
        }
        EwsUtilities.ValidateParam(mailbox, "mailbox");
        EwsUtilities.ValidateParamCollection(delegateUsers, "delegateUsers");

        let request: AddDelegateRequest = new AddDelegateRequest(this);

        request.Mailbox = mailbox;
        ArrayHelper.AddRange(request.DelegateUsers, delegateUsers); //request.DelegateUsers.AddRange(delegateUsers);
        request.MeetingRequestsDeliveryScope = meetingRequestsDeliveryScope;


        return request.Execute().then((response: DelegateManagementResponse) => {
            return response.DelegateUserResponses;
        })

    }


    /**
     * Retrieves the delegates of a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Mailbox}       mailbox                 The mailbox to retrieve the delegates of.
     * @param   {boolean}       includePermissions      Indicates whether detailed permissions should be returned fro each delegate.
     * @param   {...UserId[]}   userIds                 The optional Ids of the delegate users to retrieve.
     * @return  {Promise<DelegateInformation>}          A GetDelegateResponse providing the results of the operation    :Promise.
     */
    GetDelegates(mailbox: Mailbox, includePermissions: boolean, ...userIds: UserId[]): Promise<DelegateInformation>;
    /**
     * Retrieves the delegates of a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Mailbox}   mailbox                 The mailbox to retrieve the delegates of.
     * @param   {boolean}   includePermissions      Indicates whether detailed permissions should be returned fro each delegate.
     * @param   {UserId[]}  userIds                 The optional Ids of the delegate users to retrieve.
     * @return  {Promise<DelegateInformation>}      A GetDelegateResponse providing the results of the operation    :Promise.
     */
    GetDelegates(mailbox: Mailbox, includePermissions: boolean, userIds: UserId[]): Promise<DelegateInformation>;
    GetDelegates(mailbox: Mailbox, includePermissions: boolean, userId: UserId | UserId[], ...userIds: UserId[]): Promise<DelegateInformation> {

        if (userId) { //info: rest parameters are optional for typescript
            if (ArrayHelper.isArray(userId)) {
                ArrayHelper.AddRange(userIds, <UserId[]>userId);
            }
            else {
                userIds.push(<UserId>userId);
            }
        }

        EwsUtilities.ValidateParam(mailbox, "mailbox");

        let request: GetDelegateRequest = new GetDelegateRequest(this);

        request.Mailbox = mailbox;
        ArrayHelper.AddRange(request.UserIds, userIds); //request.UserIds.AddRange(userIds);
        request.IncludePermissions = includePermissions;

        return request.Execute().then((response: GetDelegateResponse) => {
            let delegateInformation: DelegateInformation = new DelegateInformation(
                response.DelegateUserResponses,
                response.MeetingRequestsDeliveryScope);

            return delegateInformation;
        });
    }

    /**
     * Removes delegates on a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Mailbox}       mailbox   The mailbox to remove delegates from.
     * @param   {...UserId[]}   userIds   The Ids of the delegate users to remove.
     * @return  {Promise<DelegateUserResponse[]>}       A collection of DelegateUserResponse objects providing the results of the operation :Promise.
     */
    RemoveDelegates(mailbox: Mailbox, ...userIds: UserId[]): Promise<DelegateUserResponse[]>;
    /**
     * Removes delegates on a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Mailbox}   mailbox   The mailbox to remove delegates from.
     * @param   {UserId[]}  userIds   The Ids of the delegate users to remove.
     * @return  {Promise<DelegateUserResponse[]>}       A collection of DelegateUserResponse objects providing the results of the operation :Promise.
     */
    RemoveDelegates(mailbox: Mailbox, userIds: UserId[]): Promise<DelegateUserResponse[]>;
    RemoveDelegates(mailbox: Mailbox, userId: UserId | UserId[], ...userIds: UserId[]): Promise<DelegateUserResponse[]> {

        if (userId) { //info: rest parameters are optional for typescript
            if (ArrayHelper.isArray(userId)) {
                ArrayHelper.AddRange(userIds, <UserId[]>userId);
            }
            else {
                userIds.push(<UserId>userId);
            }
        }
        EwsUtilities.ValidateParam(mailbox, "mailbox");
        EwsUtilities.ValidateParamCollection(userIds, "userIds");

        let request: RemoveDelegateRequest = new RemoveDelegateRequest(this);

        request.Mailbox = mailbox;
        ArrayHelper.AddRange(request.UserIds, userIds); //request.UserIds.AddRange(userIds);

        return request.Execute().then((response: DelegateManagementResponse) => {
            return response.DelegateUserResponses;
        })
    }

    /**
     * Updates delegates on a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Mailbox}                       mailbox                        The mailbox to update delegates on.
     * @param   {MeetingRequestsDeliveryScope}  meetingRequestsDeliveryScope   Indicates how meeting requests should be sent to delegates.
     * @param   {...DelegateUser[]}             delegateUsers                  The delegate users to update.
     * @return  {Promise<DelegateUserResponse[]>}       A collection of DelegateUserResponse objects providing the results of the operation :Promise.
     */
    UpdateDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, ...delegateUsers: DelegateUser[]): Promise<DelegateUserResponse[]>;
    /**
     * Updates delegates on a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {Mailbox}                       mailbox                        The mailbox to update delegates on.
     * @param   {MeetingRequestsDeliveryScope}  meetingRequestsDeliveryScope   Indicates how meeting requests should be sent to delegates.
     * @param   {DelegateUser[]}                delegateUsers                  The delegate users to update.
     * @return  {Promise<DelegateUserResponse[]>}       A collection of DelegateUserResponse objects providing the results of the operation :Promise.
     */
    UpdateDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, delegateUsers: DelegateUser[]): Promise<DelegateUserResponse[]>;
    UpdateDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, delegateUser: DelegateUser[] | DelegateUser, ...delegateUsers: DelegateUser[]): Promise<DelegateUserResponse[]> {

        if (delegateUser) { //info: rest parameters are optional for typescript
            if (ArrayHelper.isArray(delegateUser)) {
                ArrayHelper.AddRange(delegateUsers, <DelegateUser[]>delegateUser);
            }
            else {
                delegateUsers.push(<DelegateUser>delegateUser);
            }
        }
        EwsUtilities.ValidateParam(mailbox, "mailbox");
        EwsUtilities.ValidateParamCollection(delegateUsers, "delegateUsers");

        let request: UpdateDelegateRequest = new UpdateDelegateRequest(this);

        request.Mailbox = mailbox;
        ArrayHelper.AddRange(request.DelegateUsers, delegateUsers); //request.DelegateUsers.AddRange(delegateUsers);
        request.MeetingRequestsDeliveryScope = meetingRequestsDeliveryScope;

        return request.Execute().then((response: DelegateManagementResponse) => {
            return response.DelegateUserResponses;
        })
    }
    /* #endregion Delegate management operations */


    /* #region UserConfiguration operations */

    /**
     * Creates a UserConfiguration.
     *
     * @param   {UserConfiguration}   userConfiguration   The UserConfiguration.
     * @return  {Promise<void>}       :Promise.
     */
    CreateUserConfiguration(userConfiguration: UserConfiguration): Promise<void> {
        EwsUtilities.ValidateParam(userConfiguration, "userConfiguration");

        let request: CreateUserConfigurationRequest = new CreateUserConfigurationRequest(this);

        request.UserConfiguration = userConfiguration;

        return <any>request.Execute();
    }

    /**
     * Deletes a UserConfiguration.
     *
     * @param   {string}    name             Name of the UserConfiguration to retrieve.
     * @param   {FolderId}  parentFolderId   Id of the folder containing the UserConfiguration.
     * @return  {Promise<void>}     :Promise.
     */
    DeleteUserConfiguration(name: string, parentFolderId: FolderId): Promise<void> {
        EwsUtilities.ValidateParam(name, "name");
        EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");

        let request: DeleteUserConfigurationRequest = new DeleteUserConfigurationRequest(this);

        request.Name = name;
        request.ParentFolderId = parentFolderId;

        return <any>request.Execute();
    }

    /**
     * Gets a UserConfiguration.
     *
     * @param   {string}                        name             Name of the UserConfiguration to retrieve.
     * @param   {FolderId}                      parentFolderId   Id of the folder containing the UserConfiguration.
     * @param   {UserConfigurationProperties}   properties       Properties to retrieve.
     * @return  {Promise<UserConfiguration>}    A UserConfiguration.
     */
    GetUserConfiguration(name: string, parentFolderId: FolderId, properties: UserConfigurationProperties): Promise<UserConfiguration> {
        EwsUtilities.ValidateParam(name, "name");
        EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");

        let request: GetUserConfigurationRequest = new GetUserConfigurationRequest(this);

        request.Name = name;
        request.ParentFolderId = parentFolderId;
        request.Properties = properties;

        return request.Execute().then((response: ServiceResponseCollection<GetUserConfigurationResponse>) => {
            return response.__thisIndexer(0).UserConfiguration;
        })
    }

    /**
     * Loads the properties of the specified userConfiguration.
     *
     * @param   {UserConfiguration}             userConfiguration   The userConfiguration containing properties to load.
     * @param   {UserConfigurationProperties}   properties          Properties to retrieve.
     * @return  {Promise<void>}                 :Promise.
     */
    LoadPropertiesForUserConfiguration(userConfiguration: UserConfiguration, properties: UserConfigurationProperties): Promise<void> {
        EwsLogging.Assert(
            userConfiguration != null,
            "ExchangeService.LoadPropertiesForUserConfiguration",
            "userConfiguration is null");

        let request: GetUserConfigurationRequest = new GetUserConfigurationRequest(this);

        request.UserConfiguration = userConfiguration;
        request.Properties = properties;

        return <any>request.Execute();
    }

    /**
     * Updates a UserConfiguration.
     *
     * @param   {UserConfiguration}   userConfiguration   The UserConfiguration.
     * @return  {Promise<void>}       :Promise.
     */
    UpdateUserConfiguration(userConfiguration: UserConfiguration): Promise<void> {
        EwsUtilities.ValidateParam(userConfiguration, "userConfiguration");

        let request: UpdateUserConfigurationRequest = new UpdateUserConfigurationRequest(this);

        request.UserConfiguration = userConfiguration;

        return <any>request.Execute();
    }

    /* #endregion UserConfiguration operations */


    /* #region InboxRule operations */

    /**
     * Retrieves the inbox rules of the specified user.
     *
     * @return  {Promise<RuleCollection>}       A RuleCollection object containing the inbox rules of the specified user    :Promise.
     */
    GetInboxRules(): Promise<RuleCollection>;
    /**
     * Retrieves the inbox rules of the specified user.
     *
     * @param   {string}   mailboxSmtpAddress   The SMTP address of the user whose inbox rules should be retrieved.
     * @return  {Promise<RuleCollection>}       A RuleCollection object containing the inbox rules of the specified user    :Promise.
     */
    GetInboxRules(mailboxSmtpAddress: string): Promise<RuleCollection>;
    GetInboxRules(mailboxSmtpAddress: string = null): Promise<RuleCollection> {

        let request: GetInboxRulesRequest = new GetInboxRulesRequest(this);
        if (arguments.length > 0) {
            EwsUtilities.ValidateParam(mailboxSmtpAddress, "MailboxSmtpAddress");
            request.MailboxSmtpAddress = mailboxSmtpAddress;
        }
        return request.Execute().then((response: GetInboxRulesResponse) => {
            return response.Rules;
        });
    }

    /**
     * Update the specified user's inbox rules by applying the specified operations.
     *
     * @param   {RuleOperation[]}   operations              The operations that should be applied to the user's inbox rules.
     * @param   {boolean}           removeOutlookRuleBlob   Indicate whether or not to remove Outlook Rule Blob.
     * @param   {boolean}           mailboxSmtpAddress      The SMTP address of the user whose inbox rules should be updated.
     * @return  {Promise<void>}     :Promise
     */
    UpdateInboxRules(operations: RuleOperation[], removeOutlookRuleBlob: boolean, mailboxSmtpAddress: string): Promise<void>;
    /**
     * Update the specified user's inbox rules by applying the specified operations.
     *
     * @param   {RuleOperation[]}   operations              The operations that should be applied to the user's inbox rules.
     * @param   {boolean}           removeOutlookRuleBlob   Indicate whether or not to remove Outlook Rule Blob.
     * @return  {Promise<void>}     :Promise
     */
    UpdateInboxRules(operations: RuleOperation[], removeOutlookRuleBlob: boolean): Promise<void>;
    UpdateInboxRules(operations: RuleOperation[], removeOutlookRuleBlob: boolean, mailboxSmtpAddress?: string): Promise<void> {
        let request: UpdateInboxRulesRequest = new UpdateInboxRulesRequest(this);
        request.InboxRuleOperations = operations;
        request.RemoveOutlookRuleBlob = removeOutlookRuleBlob;

        if (arguments.length > 2) {
            request.MailboxSmtpAddress = mailboxSmtpAddress;
        }
        return <any>request.Execute();
    }

    /* #endregion InboxRule operations */


    /* #region eDiscovery/Compliance operations */

    //// BeginGetNonIndexableItemDetails(callback: Function /*System.AsyncCallback*/, state: any, parameters: GetNonIndexableItemDetailsParameters): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginGetNonIndexableItemDetails : Not implemented."); }
    //// BeginGetNonIndexableItemStatistics(callback: Function /*System.AsyncCallback*/, state: any, parameters: GetNonIndexableItemStatisticsParameters): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginGetNonIndexableItemStatistics : Not implemented."); }
    //// BeginSearchMailboxes(callback: Function /*System.AsyncCallback*/, state: any, searchParameters: SearchMailboxesParameters): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSearchMailboxes : Not implemented."); }
    //// EndGetNonIndexableItemDetails(asyncResult: Function /*System.IAsyncResult*/): GetNonIndexableItemDetailsResponse { throw new Error("ExchangeService.ts - EndGetNonIndexableItemDetails : Not implemented."); }
    //// EndGetNonIndexableItemStatistics(asyncResult: Function /*System.IAsyncResult*/): GetNonIndexableItemStatisticsResponse { throw new Error("ExchangeService.ts - EndGetNonIndexableItemStatistics : Not implemented."); }
    //// EndSearchMailboxes(asyncResult: Function /*System.IAsyncResult*/): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - EndSearchMailboxes : Not implemented."); }

    /**
     * Create get non indexable item details request
     *
     * @param   {GetNonIndexableItemDetailsParameters}   parameters   Get non indexable item details parameters
     * @return  {GetNonIndexableItemDetailsRequest}      GetNonIndexableItemDetails request
     */
    private CreateGetNonIndexableItemDetailsRequest(parameters: GetNonIndexableItemDetailsParameters): GetNonIndexableItemDetailsRequest {
        EwsUtilities.ValidateParam(parameters, "parameters");
        EwsUtilities.ValidateParam(parameters.Mailboxes, "parameters.Mailboxes");

        let request: GetNonIndexableItemDetailsRequest = new GetNonIndexableItemDetailsRequest(this);
        request.Mailboxes = parameters.Mailboxes;
        request.PageSize = parameters.PageSize;
        request.PageItemReference = parameters.PageItemReference;
        request.PageDirection = parameters.PageDirection;
        request.SearchArchiveOnly = parameters.SearchArchiveOnly;

        return request;
    }

    /**
     * Create get non indexable item statistics request
     *
     * @param   {GetNonIndexableItemStatisticsParameters}   parameters   Get non indexable item statistics parameters
     * @return  {GetNonIndexableItemStatisticsRequest}      Service response object
     */
    private CreateGetNonIndexableItemStatisticsRequest(parameters: GetNonIndexableItemStatisticsParameters): GetNonIndexableItemStatisticsRequest {
        EwsUtilities.ValidateParam(parameters, "parameters");
        EwsUtilities.ValidateParam(parameters.Mailboxes, "parameters.Mailboxes");

        let request: GetNonIndexableItemStatisticsRequest = new GetNonIndexableItemStatisticsRequest(this);
        request.Mailboxes = parameters.Mailboxes;
        request.SearchArchiveOnly = parameters.SearchArchiveOnly;

        return request;
    }

    /**
     * Creates SearchMailboxesRequest from SearchMailboxesParameters
     *
     * @param   {SearchMailboxesParameters}   searchParameters   search parameters
     * @return  {SearchMailboxesRequest}      request object
     */
    private CreateSearchMailboxesRequest(searchParameters: SearchMailboxesParameters): SearchMailboxesRequest {
        let request: SearchMailboxesRequest = new SearchMailboxesRequest(this, ServiceErrorHandling.ReturnErrors);
        ArrayHelper.AddRange(request.SearchQueries, searchParameters.SearchQueries); //request.SearchQueries.AddRange(searchParameters.SearchQueries);
        request.ResultType = searchParameters.ResultType;
        request.PreviewItemResponseShape = searchParameters.PreviewItemResponseShape;
        request.SortByProperty = searchParameters.SortBy;
        request.SortOrder = searchParameters.SortOrder;
        request.Language = searchParameters.Language;
        request.PerformDeduplication = searchParameters.PerformDeduplication;
        request.PageSize = searchParameters.PageSize;
        request.PageDirection = searchParameters.PageDirection;
        request.PageItemReference = searchParameters.PageItemReference;

        return request;
    }

    /**
     * Get dicovery search configuration
     *
     * @param   {string}    searchId                       Search Id
     * @param   {boolean}   expandGroupMembership          True if want to expand group membership
     * @param   {boolean}   inPlaceHoldConfigurationOnly   True if only want the inplacehold configuration
     * @return  {Promise<GetDiscoverySearchConfigurationResponse>}      Service response object    :Promise.
     */
    GetDiscoverySearchConfiguration(searchId: string, expandGroupMembership: boolean, inPlaceHoldConfigurationOnly: boolean): Promise<GetDiscoverySearchConfigurationResponse> {
        let request: GetDiscoverySearchConfigurationRequest = new GetDiscoverySearchConfigurationRequest(this);
        request.SearchId = searchId;
        request.ExpandGroupMembership = expandGroupMembership;
        request.InPlaceHoldConfigurationOnly = inPlaceHoldConfigurationOnly;

        return request.Execute();
    }

    /**
     * Get hold on mailboxes
     *
     * @param   {string}   holdId   Hold id
     * @return  {Promise<GetHoldOnMailboxesResponse>}       Service response object
     */
    GetHoldOnMailboxes(holdId: string): Promise<GetHoldOnMailboxesResponse> {
        let request: GetHoldOnMailboxesRequest = new GetHoldOnMailboxesRequest(this);
        request.HoldId = holdId;

        return request.Execute();
    }

    /**
     * Get non indexable item details
     *
     * @param   {string[]}  mailboxes           Array of mailbox legacy DN
     * @return  {Promise<GetNonIndexableItemDetailsResponse>}       Service response object :Promise.
     */
    GetNonIndexableItemDetails(mailboxes: string[]): Promise<GetNonIndexableItemDetailsResponse>;
    /**
     * Get non indexable item details
     *
     * @param   {string[]}              mailboxes           Array of mailbox legacy DN
     * @param   {number}                pageSize            The page size
     * @param   {string}                pageItemReference   Page item reference
     * @param   {SearchPageDirection}   pageDirection       Page direction
     * @return  {Promise<GetNonIndexableItemDetailsResponse>}       Service response object :Promise.
     */
    GetNonIndexableItemDetails(mailboxes: string[], pageSize: number, pageItemReference: string, pageDirection: SearchPageDirection): Promise<GetNonIndexableItemDetailsResponse>;
    /**
     * Get non indexable item details
     *
     * @param   {GetNonIndexableItemDetailsParameters}   parameters   Get non indexable item details parameters
     * @return  {Promise<GetNonIndexableItemDetailsResponse>}         Service response object   :Promise.
     */
    GetNonIndexableItemDetails(parameters: GetNonIndexableItemDetailsParameters): Promise<GetNonIndexableItemDetailsResponse>;
    GetNonIndexableItemDetails(mailboxesOrParameters: string[] | GetNonIndexableItemDetailsParameters, pageSize: number = null, pageItemReference: string = null, pageDirection: SearchPageDirection = null): Promise<GetNonIndexableItemDetailsResponse> {
        let parameters: GetNonIndexableItemDetailsParameters = null;
        if (mailboxesOrParameters instanceof GetNonIndexableItemDetailsParameters) {
            parameters = mailboxesOrParameters;
        }
        else {
            parameters = new GetNonIndexableItemDetailsParameters();
            parameters.Mailboxes = mailboxesOrParameters;
            parameters.PageSize = pageSize;
            parameters.PageItemReference = pageItemReference;
            parameters.PageDirection = pageDirection;
            parameters.SearchArchiveOnly = false;
        }

        let request: GetNonIndexableItemDetailsRequest = this.CreateGetNonIndexableItemDetailsRequest(parameters);

        return request.Execute();
    }

    /**
     * Get non indexable item statistics
     *
     * @param   {string[]}   mailboxes   Array of mailbox legacy DN
     * @return  {Promise<GetNonIndexableItemStatisticsResponse>}    Service response object :Promise.
     */
    GetNonIndexableItemStatistics(mailboxes: string[]): Promise<GetNonIndexableItemStatisticsResponse>;
    /**
     * Get non indexable item statistics
     *
     * @param   {GetNonIndexableItemStatisticsParameters}   parameters   Get non indexable item statistics parameters
     * @return  {Promise<GetNonIndexableItemStatisticsResponse>}         Service response object :Promise.
     */
    GetNonIndexableItemStatistics(parameters: GetNonIndexableItemStatisticsParameters): Promise<GetNonIndexableItemStatisticsResponse>;
    GetNonIndexableItemStatistics(mailboxesOrParameters: string[] | GetNonIndexableItemStatisticsParameters): Promise<GetNonIndexableItemStatisticsResponse> {
        let parameters: GetNonIndexableItemStatisticsParameters = null;
        if (mailboxesOrParameters instanceof GetNonIndexableItemStatisticsParameters) {
            parameters = mailboxesOrParameters;
        } else {
            parameters = new GetNonIndexableItemStatisticsParameters();
            parameters.Mailboxes = mailboxesOrParameters;
            parameters.SearchArchiveOnly = false;
        }

        let request: GetNonIndexableItemStatisticsRequest = this.CreateGetNonIndexableItemStatisticsRequest(parameters);

        return request.Execute();
    }

    /**
     * Get searchable mailboxes
     *
     * @param   {string}    searchFilter            Search filter
     * @param   {boolean}   expandGroupMembership   True if want to expand group membership
     * @return  {Promise<GetSearchableMailboxesResponse>}       Service response object :Promise
     */
    GetSearchableMailboxes(searchFilter: string, expandGroupMembership: boolean): Promise<GetSearchableMailboxesResponse> {
        let request: GetSearchableMailboxesRequest = new GetSearchableMailboxesRequest(this);
        request.SearchFilter = searchFilter;
        request.ExpandGroupMembership = expandGroupMembership;

        return request.Execute();
    }

    /**
     * Search mailboxes
     *
     * @param   {SearchMailboxesParameters}   searchParameters   Search mailboxes parameters
     * @return  {Promise<ServiceResponseCollection<SearchMailboxesResponse>>}       Collection of search mailboxes response object  :Promise.
     */
    SearchMailboxes(searchParameters: SearchMailboxesParameters): Promise<ServiceResponseCollection<SearchMailboxesResponse>>;
    /**
     * Search mailboxes
     *
     * @param   {MailboxQuery[]}        mailboxQueries      Collection of query and mailboxes
     * @param   {SearchResultType}      resultType          Search result type
     * @return  {Promise<ServiceResponseCollection<SearchMailboxesResponse>>}       Collection of search mailboxes response object  :Promise.
     */
    SearchMailboxes(mailboxQueries: MailboxQuery[], resultType: SearchResultType): Promise<ServiceResponseCollection<SearchMailboxesResponse>>;
    /**
     * Search mailboxes
     *
     * @param   {MailboxQuery[]}        mailboxQueries      Collection of query and mailboxes
     * @param   {SearchResultType}      resultType          Search result type
     * @param   {string}                sortByProperty      Sort by property name
     * @param   {SortDirection}         sortOrder           Sort order
     * @param   {number}                pageSize            Page size
     * @param   {SearchPageDirection}   pageDirection       Page navigation direction
     * @param   {string}                pageItemReference   Item reference used for paging
     * @return  {Promise<ServiceResponseCollection<SearchMailboxesResponse>>}       Collection of search mailboxes response object  :Promise.
     */
    SearchMailboxes(mailboxQueries: MailboxQuery[], resultType: SearchResultType, sortByProperty: string, sortOrder: SortDirection, pageSize: number, pageDirection: SearchPageDirection, pageItemReference: string): Promise<ServiceResponseCollection<SearchMailboxesResponse>>;
    SearchMailboxes(mailboxQueriesOrSearchParameters: MailboxQuery[] | SearchMailboxesParameters, resultType: SearchResultType = SearchResultType.PreviewOnly, sortByProperty: string = null, sortOrder: SortDirection = SortDirection.Ascending, pageSize: number = 0, pageDirection: SearchPageDirection = SearchPageDirection.Next, pageItemReference: string = null): Promise<ServiceResponseCollection<SearchMailboxesResponse>> {
        let request: SearchMailboxesRequest = null;
        if (mailboxQueriesOrSearchParameters instanceof SearchMailboxesParameters) {
            let searchParameters: SearchMailboxesParameters = null;
            searchParameters = mailboxQueriesOrSearchParameters;
            EwsUtilities.ValidateParam(searchParameters, "searchParameters");
            EwsUtilities.ValidateParam(searchParameters.SearchQueries, "searchParameters.SearchQueries");
            request = this.CreateSearchMailboxesRequest(searchParameters);
        }
        else {
            request = new SearchMailboxesRequest(this, ServiceErrorHandling.ReturnErrors);
            if (mailboxQueriesOrSearchParameters != null) {
                ArrayHelper.AddRange(request.SearchQueries, mailboxQueriesOrSearchParameters);
            }
            request.ResultType = resultType;

            if (arguments.length > 2) {
                request.SortByProperty = sortByProperty;
                request.SortOrder = sortOrder;
                request.PageSize = pageSize;
                request.PageDirection = pageDirection;
                request.PageItemReference = pageItemReference;
            }
        }
        return request.Execute();
    }

    /**
     * Set hold on mailboxes
     *
     * @param   {SetHoldOnMailboxesParameters}  parameters      Set hold parameters
     * @return  {Promise<SetHoldOnMailboxesResponse>}   Service response object :Promise.
     */
    SetHoldOnMailboxes(parameters: SetHoldOnMailboxesParameters): Promise<SetHoldOnMailboxesResponse>;
    /**
     * Set hold on mailboxes
     *
     * @param   {string}        holdId          Hold id
     * @param   {HoldAction}    actionType      Action type
     * @param   {string}        query           Query string
     * @param   {string[]}      mailboxes       Collection of mailboxes
     * @return  {Promise<SetHoldOnMailboxesResponse>}   Service response object :Promise.
     */
    SetHoldOnMailboxes(holdId: string, actionType: HoldAction, query: string, mailboxes: String[]): Promise<SetHoldOnMailboxesResponse>;
    /**
     * Set hold on mailboxes
     *
     * @param   {string}        holdId                Hold id
     * @param   {HoldAction}    actionType            Action type
     * @param   {string}        query                 Query string
     * @param   {string}        inPlaceHoldIdentity   in-place hold identity
     * @return  {Promise<SetHoldOnMailboxesResponse>}   Service response object :Promise.
     */
    SetHoldOnMailboxes(holdId: string, actionType: HoldAction, query: string, inPlaceHoldIdentity: string): Promise<SetHoldOnMailboxesResponse>;
    /**
     * Set hold on mailboxes
     *
     * @param   {string}        holdId                Hold id
     * @param   {HoldAction}    actionType            Action type
     * @param   {string}        query                 Query string
     * @param   {string}        inPlaceHoldIdentity   in-place hold identity
     * @param   {string}        itemHoldPeriod        item hold period
     * @return  {Promise<SetHoldOnMailboxesResponse>}   Service response object :Promise.
     */
    SetHoldOnMailboxes(holdId: string, actionType: HoldAction, query: string, inPlaceHoldIdentity: string, itemHoldPeriod: string): Promise<SetHoldOnMailboxesResponse>;
    SetHoldOnMailboxes(holdIdOrParameters: string | SetHoldOnMailboxesParameters, _actionType: HoldAction = null, _query: string = null, mailboxesOrInPlaceHoldIdentity: String[] | string = null, _itemHoldPeriod: string = null): Promise<SetHoldOnMailboxesResponse> {

        let holdId: string = <string>holdIdOrParameters;
        let actionType: HoldAction = _actionType;
        let query: string = _query;
        let mailboxes: string[] = <string[]>mailboxesOrInPlaceHoldIdentity;
        let inPlaceHoldIdentity: string = <string>mailboxesOrInPlaceHoldIdentity;
        let itemHoldPeriod: string = _itemHoldPeriod;

        let request: SetHoldOnMailboxesRequest = new SetHoldOnMailboxesRequest(this);
        let argsLength = arguments.length;
        if (argsLength === 1) { //SetHoldOnMailboxesParameters
            let parameters: SetHoldOnMailboxesParameters = <SetHoldOnMailboxesParameters>holdIdOrParameters;

            EwsUtilities.ValidateParam(parameters, "parameters");

            holdId = parameters.HoldId;
            actionType = parameters.ActionType;
            query = parameters.Query;
            mailboxes = parameters.Mailboxes;
            request.Language = parameters.Language;
            inPlaceHoldIdentity = parameters.InPlaceHoldIdentity;

            /** per #120 */
            itemHoldPeriod = request.ItemHoldPeriod;
            request.PerformDeduplication = parameters.PerformDeduplication;
            request.IncludeNonIndexableItems = parameters.IncludeNonIndexableItems;

        }
        else {
            if (ArrayHelper.isArray(mailboxesOrInPlaceHoldIdentity)) {
                inPlaceHoldIdentity = null;
            }
            else {
                mailboxes = null;
            }
        }

        request.HoldId = holdId;
        request.ActionType = actionType;
        request.Query = query;
        request.Mailboxes = mailboxes;
        request.InPlaceHoldIdentity = inPlaceHoldIdentity;
        request.ItemHoldPeriod = itemHoldPeriod;

        return request.Execute();
    }

    /* #endregion eDiscovery/Compliance operations */


    /* #region MRM operations */

    /**
     * Get user retention policy tags.
     *
     * @return  {Promise<GetUserRetentionPolicyTagsResponse>}       Service response object.
     */
    GetUserRetentionPolicyTags(): Promise<GetUserRetentionPolicyTagsResponse> {
        let request: GetUserRetentionPolicyTagsRequest = new GetUserRetentionPolicyTagsRequest(this);

        return request.Execute();
    }
    /* #endregion MRM operations */


    /* #region Autodiscover */

    /**
     * Adjusts the service URI based on the current type of credentials.
     *
     * @param   {Uri}   uri   The URI.
     * @return  {Uri}         Adjusted URL.
     */
    private AdjustServiceUriFromCredentials(uri: Uri): Uri {
        return (this.Credentials != null)
            ? this.Credentials.AdjustUrl(uri)
            : uri;
    }
    /**
     * Initializes the Url property to the Exchange Web Services URL for the specified e-mail address by calling the Autodiscover service.
     *
     * @param   {string}   emailAddress     The email address to use.
     */
    AutodiscoverUrl(emailAddress: string): Promise<void>;
    /**
     * Initializes the Url property to the Exchange Web Services URL for the specified e-mail address by calling the Autodiscover service.
     *
     * @param   {string}   emailAddress                             The email address to use.
     * @param   {AutodiscoverRedirectionUrlValidationCallback}      validateRedirectionUrlCallback   The callback used to validate redirection URL.
     */
    AutodiscoverUrl(emailAddress: string, validateRedirectionUrlCallback: AutodiscoverRedirectionUrlValidationCallback): Promise<void>;
    AutodiscoverUrl(emailAddress: string, validateRedirectionUrlCallback: AutodiscoverRedirectionUrlValidationCallback = this.DefaultAutodiscoverRedirectionUrlValidationCallback): Promise<void> {
        //validateRedirectionUrlCallback = validateRedirectionUrlCallback || this.DefaultAutodiscoverRedirectionUrlValidationCallback;

        var exchangeServiceUrl: Uri = null;

        if (this.RequestedServerVersion > ExchangeVersion.Exchange2007_SP1) {

            return this.GetAutodiscoverUrl(
                emailAddress,
                this.RequestedServerVersion,
                validateRedirectionUrlCallback).then((url) => {
                    exchangeServiceUrl = url;
                    this.Url = this.AdjustServiceUriFromCredentials(exchangeServiceUrl);
                    //return;
                }, (err) => {
                    //catch (AutodiscoverLocalException ex)
                    this.TraceMessage(
                        TraceFlags.AutodiscoverResponse,
                        StringHelper.Format("Autodiscover service call failed with error '{0}'. Will try legacy service", err));
                    //catch (ServiceRemoteException ex)

                    // Special case: if the caller's account is locked we want to return this exception, not continue.
                    //        if (ex is AccountIsLockedException)
                    //{
                    //    throw;
                    //}

                    //this.TraceMessage(
                    //    TraceFlags.AutodiscoverResponse,
                    //    string.Format("Autodiscover service call failed with error '{0}'. Will try legacy service", ex.Message));


                    // Try legacy Autodiscover provider

                    var exchangeServiceUrl = this.GetAutodiscoverUrl(
                        emailAddress,
                        ExchangeVersion.Exchange2007_SP1,
                        validateRedirectionUrlCallback).then((url) => {

                            this.Url = this.AdjustServiceUriFromCredentials(url);
                        });

                });
        }







    }
    /**
     * Default implementation of AutodiscoverRedirectionUrlValidationCallback. Always returns true indicating that the URL can be used.
     *
     * @param   {string}   redirectionUrl   The redirection URL.
     * @return  {boolean}                    Returns true.
     */
    private DefaultAutodiscoverRedirectionUrlValidationCallback(redirectionUrl: string): boolean { //ref: need to fix this type - Always returns true indicating that the URL can be used

        throw new AutodiscoverLocalException(StringHelper.Format(Strings.AutodiscoverRedirectBlocked, redirectionUrl));
    }
    /**
     * Gets the EWS URL from Autodiscover.
     *
     * @param   {string}                                        emailAddress                     The email address.
     * @param   {ExchangeVersion}                               requestedServerVersion           Exchange version.
     * @param   {AutodiscoverRedirectionUrlValidationCallback}  validateRedirectionUrlCallback   The validate redirection URL callback.
     * @return  {Promise<Uri>}                                  Ews URL :Promise.
     */
    private GetAutodiscoverUrl(emailAddress: string, requestedServerVersion: ExchangeVersion, validateRedirectionUrlCallback: AutodiscoverRedirectionUrlValidationCallback): Promise<Uri> {
        var autodiscoverService: AutodiscoverService = new AutodiscoverService(null, null, requestedServerVersion);
        autodiscoverService.Credentials = this.Credentials;
        autodiscoverService.XHRApi = this.XHRApi;
        autodiscoverService.RedirectionUrlValidationCallback = validateRedirectionUrlCallback,
            autodiscoverService.EnableScpLookup = this.EnableScpLookup

        return autodiscoverService.GetUserSettings(
            emailAddress,
            UserSettingName.InternalEwsUrl,
            UserSettingName.ExternalEwsUrl)
            .then<Uri>((response) => {
                switch (response.ErrorCode) {
                    case AutodiscoverErrorCode.NoError:
                        return this.GetEwsUrlFromResponse(response, autodiscoverService.IsExternal);

                    case AutodiscoverErrorCode.InvalidUser:
                        throw new ServiceRemoteException(
                            StringHelper.Format(Strings.InvalidUser, emailAddress));

                    case AutodiscoverErrorCode.InvalidRequest:
                        throw new ServiceRemoteException(
                            StringHelper.Format(Strings.InvalidAutodiscoverRequest, response.ErrorMessage));

                    default:
                        this.TraceMessage(
                            TraceFlags.AutodiscoverConfiguration,
                            StringHelper.Format("No EWS Url returned for user {0}, error code is {1}", emailAddress, response.ErrorCode));

                        throw new ServiceRemoteException(response.ErrorMessage);
                }
            }, (err) => {
                throw err;
            });

    }
    /**
     * Gets the EWS URL from Autodiscover GetUserSettings response.
     *
     * @param   {GetUserSettingsResponse}   response     The response.
     * @param   {boolean}                   isExternal   If true, Autodiscover call was made externally.
     * @return  {Uri}                       EWS URL.
     */
    private GetEwsUrlFromResponse(response: GetUserSettingsResponse, isExternal: boolean): Uri {

        var uriString = response.GetSettingValue<string>(UserSettingName.ExternalEwsUrl)

        // Figure out which URL to use: Internal or External.
        // AutoDiscover may not return an external protocol. First try external, then internal.
        // Either protocol may be returned without a configured URL.
        if ((isExternal &&
            uriString) &&
            !StringHelper.IsNullOrEmpty(uriString)) {
            return new Uri(uriString);
        }
        else {
            uriString = response.GetSettingValue<string>(UserSettingName.InternalEwsUrl) || uriString;
            if (!StringHelper.IsNullOrEmpty(uriString)) {
                return new Uri(uriString);
            }
        }
        // If Autodiscover doesn't return an internal or external EWS URL, throw an exception.
        throw new AutodiscoverLocalException(Strings.AutodiscoverDidNotReturnEwsUrl);
    }
    /* #endregion Autodiscover */


    /* #region ClientAccessTokens */

    /**
     * GetClientAccessToken
     *
     * @param   {KeyValuePair<string, ClientAccessTokenType>[]}   idAndTypes   Id and Types
     * @return  {Promise<ServiceResponseCollection<GetClientAccessTokenResponse>>}      A ServiceResponseCollection providing token results for each of the specified id and types  :Promise.
     */
    GetClientAccessToken(idAndTypes: KeyValuePair<string, ClientAccessTokenType>[]): Promise<ServiceResponseCollection<GetClientAccessTokenResponse>>;
    /**
     * GetClientAccessToken
     *
     * @param   {ClientAccessTokenRequest[]}   tokenRequests   Token requests array
     * @return  {Promise<ServiceResponseCollection<GetClientAccessTokenResponse>>}      A ServiceResponseCollection providing token results for each of the specified id and types  :Promise.
     */
    GetClientAccessToken(tokenRequests: ClientAccessTokenRequest[]): Promise<ServiceResponseCollection<GetClientAccessTokenResponse>>;
    GetClientAccessToken(tokenRequestsOrIdAndTypes: KeyValuePair<string, ClientAccessTokenType>[] | ClientAccessTokenRequest[]): Promise<ServiceResponseCollection<GetClientAccessTokenResponse>> {
        if (!tokenRequestsOrIdAndTypes && tokenRequestsOrIdAndTypes.length === 0) {
            throw new ArgumentOutOfRangeException(Strings.IndexIsOutOfRange);
        }

        let requestList: ClientAccessTokenRequest[] = [];

        if (tokenRequestsOrIdAndTypes[0] instanceof ClientAccessTokenRequest) {
            requestList = <ClientAccessTokenRequest[]>tokenRequestsOrIdAndTypes;
        }
        else {

            for (let idAndType of <KeyValuePair<string, ClientAccessTokenType>[]>tokenRequestsOrIdAndTypes) {
                let clientAccessTokenRequest: ClientAccessTokenRequest = new ClientAccessTokenRequest(idAndType.key, idAndType.value);
                requestList.push(clientAccessTokenRequest);
            }
        }

        let request: GetClientAccessTokenRequest = new GetClientAccessTokenRequest(this, ServiceErrorHandling.ReturnErrors);
        request.TokenRequests = requestList;
        return request.Execute();
    }
    /* #end region ClientAccessTokens */


    /* #region Client Extensibility */

    /**
     * Get the app manifests.
     *
     * @return  {Promise<string[]>}              Collection of manifests xml file as base64 encoded string :Promise.
     */
    GetAppManifests(): Promise<string[]>;
    /**
     * Get the app manifests.  Works with Exchange 2013 SP1 or later EWS.
     *
     * @param   {string}   apiVersionSupported      The api version supported by the client.
     * @param   {string}   schemaVersionSupported   The schema version supported by the client.
     * @return  {Promise<ClientApp[]>}              Collection of manifests :Promise.
     */
    GetAppManifests(apiVersionSupported: string, schemaVersionSupported: string): Promise<ClientApp[]>;
    GetAppManifests(apiVersionSupported: string = null, schemaVersionSupported: string = null): Promise<ClientApp[] | string[]> {
        let argsLength = arguments.length;
        let request: GetAppManifestsRequest = new GetAppManifestsRequest(this);

        if (argsLength !== 0) {
            request.ApiVersionSupported = apiVersionSupported;
            request.SchemaVersionSupported = schemaVersionSupported;
        }

        return request.Execute().then((response: GetAppManifestsResponse) => {
            if (argsLength !== 0) {
                return response.Apps;
            }
            else {
                return response.Manifests;
            }
        });


    }

    /**
     * Get App Marketplace Url.
     *
     * /remarks/                        Exception will be thrown for errors. 
     * @return  {Promise<string>}       marketplace url as string :Promise.
     */
    GetAppMarketplaceUrl(): Promise<string>;
    /**
     * Get App Marketplace Url.  Works with Exchange 2013 SP1 or later EWS.
     *
     * /remarks/                                    Exception will be thrown for errors. 
     * @param   {string}   apiVersionSupported      The api version supported by the client.
     * @param   {string}   schemaVersionSupported   The schema version supported by the client.
     * @return  {Promise<string>}                   marketplace url as string :Promise.
     */
    GetAppMarketplaceUrl(apiVersionSupported: string, schemaVersionSupported: string): Promise<string>;
    GetAppMarketplaceUrl(apiVersionSupported: string = null, schemaVersionSupported: string = null): Promise<string> {

        let request: GetAppMarketplaceUrlRequest = new GetAppMarketplaceUrlRequest(this);
        request.ApiVersionSupported = apiVersionSupported;
        request.SchemaVersionSupported = schemaVersionSupported;

        return request.Execute().then((response: GetAppMarketplaceUrlResponse) => {

            return response.AppMarketplaceUrl;
        });
    }

    /**
     * Disable an App.
     *
     * /remarks/    Exception will be thrown for errors. 
     * @param   {string}                id              App ID
     * @param   {DisableReasonType}     disableReason   Disable reason
     * @return  {Promise<void>}         :Promise.
     */
    DisableApp(id: string, disableReason: DisableReasonType): Promise<void> {
        EwsUtilities.ValidateParam(id, "id");
        EwsUtilities.ValidateParam(disableReason, "disableReason");

        let request: DisableAppRequest = new DisableAppRequest(this, id, disableReason);

        return <any>request.Execute();
    }

    /**
     * Install an App.
     *
     * /remarks/    Exception will be thrown for errors. 
     * @param   {string}   manifestStream   The manifest's plain text XML as base64 encoded string.
     * @return  {Promise<void>}     :Promise.
     */
    InstallApp(manifestStream: string): Promise<void> {
        EwsUtilities.ValidateParam(manifestStream, "manifestStream");

        let request: InstallAppRequest = new InstallAppRequest(this, manifestStream);

        return <any>request.Execute();
    }

    /**
     * Uninstall an App.
     *
     * /remarks/    Exception will be thrown for errors. 
     * @param   {string}   id   App ID
     * @return  {Promise<void>}     :Promise.
     */
    UninstallApp(id: string): Promise<void> {
        EwsUtilities.ValidateParam(id, "id");

        let request: UninstallAppRequest = new UninstallAppRequest(this, id);

        return <any>request.Execute();
    }

    //info - not used in client side, only server side calls are supported per function documentation.
    // GetClientExtension(requestedExtensionIds: StringList, shouldReturnEnabledOnly: boolean, isUserScope: boolean, userId: string, userEnabledExtensionIds: StringList, userDisabledExtensionIds: StringList, isDebug: boolean): GetClientExtensionResponse { throw new Error("ExchangeService.ts - GetClientExtension : Not implemented."); }
    // SetClientExtension(actions: Function[] /*System.Collections.Generic.List<T>*/): any { throw new Error("ExchangeService.ts - SetClientExtension : Not implemented."); }
    // GetEncryptionConfiguration(): GetEncryptionConfigurationResponse { throw new Error("ExchangeService.ts - GetEncryptionConfiguration : Not implemented."); }
    // SetEncryptionConfiguration(imageBase64: string, emailText: string, portalText: string, disclaimerText: string): any { throw new Error("ExchangeService.ts - SetEncryptionConfiguration : Not implemented."); }
    /* #endregion Client Extensibility */


    /* #region Diagnostic Method -- Only used by test */

    //ExecuteDiagnosticMethod(verb: string, parameter: System.Xml.XmlNode): System.Xml.XmlDocument { throw new Error("ExchangeService.ts - ExecuteDiagnosticMethod : Not implemented."); }    
    /* #endregion Diagnostic Method -- Only used by test */


    /* #region Validation */

    static IsMajorMinor(versionPart: string): boolean {
        var MajorMinorSeparator: string = '.';//char

        var parts: string[] = versionPart.split(MajorMinorSeparator);
        if (parts.length != 2) {
            return false;
        }

        for (var s of parts) {
            for (var c of s.split('')) {
                if (isNaN(<any>c)) {
                    return false;
                }
            }
        }

        return true;
    }
    /**
     * @internal Validates this instance.
     *
     */
    Validate(): void {
        super.Validate();

        if (this.Url == null) {
            throw new ServiceLocalException(Strings.ServiceUrlMustBeSet);
        }

        if (this.PrivilegedUserId != null && this.ImpersonatedUserId != null) {
            throw new ServiceLocalException(Strings.CannotSetBothImpersonatedAndPrivilegedUser);
        }

        // only one of PrivilegedUserId|ImpersonatedUserId|ManagementRoles can be set.
    }
    /**
     * @internal Validates a new-style version string. This validation is not as strict as server-side validation.
     *
     * @param   {string}   version   the version string
     */
    static ValidateTargetVersion(version: string): void {
        var ParameterSeparator: string = ';'; //char
        var LegacyVersionPrefix: string = "Exchange20";
        var ParameterValueSeparator: string = '='; //char
        var ParameterName: string = "minimum";

        if (StringHelper.IsNullOrEmpty(version)) {
            throw new ArgumentException("Target version must not be empty.");
        }

        var parts: string[] = version.trim().split(ParameterSeparator);

        if (parts.length > 2) {
            throw new ArgumentException("Target version should have the form.");
        }

        var skipPart1: boolean = true;
        if (parts.length === 2) {
            // Validate the optional minimum version parameter, "minimum=X.Y"
            var part2: string = parts[1].trim();
            var minParts: string[] = part2.split(ParameterValueSeparator);
            if (minParts.length == 2 &&
                minParts[0].trim().toUpperCase() === ParameterName.toUpperCase() &&
                ExchangeService.IsMajorMinor(minParts[1].trim())) {
                skipPart1 = false;
            }
            else {
                throw new ArgumentException("Target version must match X.Y or Exchange20XX.");
            }
        }

        if (parts.length >= 0 && !skipPart1) {
            // Validate the header value. We allow X.Y or Exchange20XX.
            var part1: string = parts[0].trim();
            if (parts[0].indexOf(LegacyVersionPrefix) === 0) {
                // Close enough; misses corner cases like "Exchange2001". Server will do complete validation.
            }
            else if (ExchangeService.IsMajorMinor(part1)) {
                // Also close enough; misses corner cases like ".5".
            }
            else {
                throw new ArgumentException("Target version must match X.Y or Exchange20XX.");
            }
        }
    }
    /* #endregion Validation */


    /* #region Utilities */

    /**
     * @internal Creates an IXHROptions instance and initializes it with the appropriate parameters, based on the configuration of this service object.
     *
     * @param   {string}   methodName   Name of the method.
     * @return  {IXHROptions}           An instance of IXHROptions to call web service with.
     */
    PrepareHttpWebRequest(methodName: string): IXHROptions {
        var endpoint = this.Url;
        //this.RegisterCustomBasicAuthModule();

        if (this.RenderingMethod === RenderingMode.JSON) {
            //endpoint = new Uri(
            //    endpoint,
            //    string.Format("{0}/{1}{2}", endpoint.AbsolutePath, methodName, endpoint.Query));
        }
        else {
            endpoint = this.AdjustServiceUriFromCredentials(endpoint);
        }

        var request = this.PrepareHttpWebRequestForUrl(
            endpoint,
            this.AcceptGzipEncoding,
            true);

        if (!StringHelper.IsNullOrEmpty(this.TargetServerVersion)) {
            request.headers[ExchangeService.TargetServerVersionHeaderName] = this.TargetServerVersion;
        }

        return request;
    }

    /**
     * @internal Processes an HTTP error response.
     *
     * @param   {XMLHttpRequest}   httpWebResponse      The HTTP web response.
     * @param   {SoapFaultDetails}   soapFault          The SoapFault Instance.
     */
    ProcessHttpErrorResponse(httpWebResponse: XMLHttpRequest, soapFault: SoapFaultDetails): void {
        this.InternalProcessHttpErrorResponse(
            httpWebResponse,
            soapFault,
            TraceFlags.EwsResponseHttpHeaders,
            TraceFlags.EwsResponse);
    }

    /**
     * Sets the type of the content.
     *
     * @param   {IXHROptions}   request   The request.
     */
    SetContentType(request: IXHROptions /*IEwsHttpWebRequest*/): void {
        if (this.renderingMode == RenderingMode.Xml) {
            request.headers["Content-Type"] = "text/xml; charset=utf-8";
            request.headers["Accept"] = "text/xml";
        }
        else if (this.renderingMode == RenderingMode.JSON) {
            request.headers["Content-Type"] = "application/json; charset=utf-8";
            request.headers["Accept"] = "application/json";
        }
        else {
            super.SetContentType(request);
        }
    }
    /* #endregion Utilities */

    //#region Additional Operations not in official EWS Managed Api in the commit

    /**
     * Get the TimeZoneInfo objects from server
     * 
     * @returns {Promise<TimeZoneInfo[]>} 
     */
    GetServerTimeZones(): Promise<TimeZoneInfo[]> {
        let argsLength = arguments.length;
        let request: GetServerTimeZonesRequest = new GetServerTimeZonesRequest(this);

        return request.Execute().then((response: ServiceResponseCollection<GetServerTimeZonesResponse>) => {
            return response.Responses[0].TimeZones;
        });
    }
    
    //#endregion
}

//module ExchangeService { -> moved to its own file to remove circular dependency.
//    export enum RenderingMode {
//        Xml = 0,
//        JSON = 1
//    }
//}


/**
 * JSON names not shared with the XmlElementNames or XmlAttributeNames classes.
 */
export module JsonNames {
  export var Events: string = "Events";
  export var NotificationType: string = "NotificationType";
  export var OldFolderId: string = "OldFolderId";
  export var OldItemId: string = "OldItemId";
  export var PathToExtendedFieldType: string = "ExtendedPropertyUri";
  export var PathToIndexedFieldType: string = "DictionaryPropertyUri";
  export var PathToUnindexedFieldType: string = "PropertyUri";
  export var Path: string = "Path";
  export var RecurrencePattern: string = "RecurrencePattern";
  export var RecurrenceRange: string = "RecurrenceRange";
}
export class JsonObject /*extends System.Collections.Generic.Dictionary<string, any>*/ {
	 	private static TypeAttribute: string = "__type";
        private static JsonTypeNamespace: string = "Exchange";
        static JsonValueString: string = "Value";
	// Add(name: string, value: number): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// //Add(name: string, value: JsonObject): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// //Add(name: string, value: string): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// //Add(name: string, value: System.Enum): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// //Add(name: string, value: boolean): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// //Add(name: string, value: number): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// //Add(name: string, value: number): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// //Add(name: string, value: number): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// //Add(name: string, value: any): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// //Add(name: string, value: any[] /*System.Collections.Generic.IEnumerable<any>*/): void{ throw new Error("JsonObject.ts - Add : Not implemented.");}
	// AddBase64(key: string, buffer: any /*System.Byte[]*/): void{ throw new Error("JsonObject.ts - AddBase64 : Not implemented.");}
	// //AddBase64(key: string, stream: any /*System.IO.Stream*/): void{ throw new Error("JsonObject.ts - AddBase64 : Not implemented.");}
	// //AddBase64(key: string, buffer: any /*System.Byte[]*/, offset: number, count: number): void{ throw new Error("JsonObject.ts - AddBase64 : Not implemented.");}
	// AddTypeParameter(typeName: string): void{ throw new Error("JsonObject.ts - AddTypeParameter : Not implemented.");}
	// HasTypeProperty(): boolean{ throw new Error("JsonObject.ts - HasTypeProperty : Not implemented.");}
	// InternalAdd(name: string, value: any): void{ throw new Error("JsonObject.ts - InternalAdd : Not implemented.");}
	// ReadAsArray(key: string): any[]{ throw new Error("JsonObject.ts - ReadAsArray : Not implemented.");}
	// ReadAsBase64Content(key: string): any /*System.Byte[]*/{ throw new Error("JsonObject.ts - ReadAsBase64Content : Not implemented.");}
	// //ReadAsBase64Content(key: string, stream: any /*System.IO.Stream*/): void{ throw new Error("JsonObject.ts - ReadAsBase64Content : Not implemented.");}
	// ReadAsBool(key: string): boolean{ throw new Error("JsonObject.ts - ReadAsBool : Not implemented.");}
	// ReadAsDouble(key: string): number{ throw new Error("JsonObject.ts - ReadAsDouble : Not implemented.");}
	// ReadAsInt(key: string): number{ throw new Error("JsonObject.ts - ReadAsInt : Not implemented.");}
	// ReadAsJsonObject(key: string): JsonObject{ throw new Error("JsonObject.ts - ReadAsJsonObject : Not implemented.");}
	// ReadAsString(key: string): string{ throw new Error("JsonObject.ts - ReadAsString : Not implemented.");}
	// ReadEnumValue<T>(key: string): T{ throw new Error("JsonObject.ts - ReadEnumValue<T> : Not implemented.");}
	// ReadTypeString(): string{ throw new Error("JsonObject.ts - ReadTypeString : Not implemented.");}
	// SerializeToJson(stream: any /*System.IO.Stream*/): void{ throw new Error("JsonObject.ts - SerializeToJson : Not implemented.");}
	// //SerializeToJson(stream: any /*System.IO.Stream*/, prettyPrint: boolean): void{ throw new Error("JsonObject.ts - SerializeToJson : Not implemented.");}
	// ValidateObject(entry: any): void{ throw new Error("JsonObject.ts - ValidateObject : Not implemented.");}
	// WriteKeyValuePair(writer: JsonWriter, key: string, value: any): void{ throw new Error("JsonObject.ts - WriteKeyValuePair : Not implemented.");}
	// WriteValue(writer: JsonWriter, value: any): void{ throw new Error("JsonObject.ts - WriteValue : Not implemented.");}
}






			

export class JsonParser {
	private tokenizer: JsonTokenizer;
	Parse(): JsonObject{ throw new Error("JsonParser.ts - Parse : Not implemented.");}
	ParseArray(): any[]{ throw new Error("JsonParser.ts - ParseArray : Not implemented.");}
	ParseKeyValuePair(jsonObject: JsonObject): void{ throw new Error("JsonParser.ts - ParseKeyValuePair : Not implemented.");}
	ParseNumber(valueToken: string): any{ throw new Error("JsonParser.ts - ParseNumber : Not implemented.");}
	ParseObject(): JsonObject{ throw new Error("JsonParser.ts - ParseObject : Not implemented.");}
	ParseValue(): any{ throw new Error("JsonParser.ts - ParseValue : Not implemented.");}
	ReadAndValidateToken(token: string, expectedTokenTypes: JsonTokenType[]): JsonTokenType{ throw new Error("JsonParser.ts - ReadAndValidateToken : Not implemented.");}
	UnescapeString(value: string): string{ throw new Error("JsonParser.ts - UnescapeString : Not implemented.");}
}






			

export class JsonTokenizer {
	private static JsonStringRegExCode: string = '"([^\\"]|\\"|\\\\|\\/|\\b|\\f|\\n|\\r|\\t|\\u[\da - fA - F]{4 }) * "';
	private static JsonNumberRegExCode: string = "-?\d+(.\d+)?([eE][+-]?\d+)?";
	private static JsonBooleanRegExCode: string = "(true|false)";
	private static JsonNullRegExCode: string = "null";
	private static JsonOpenObjectRegExCode: string = "\{";
	private static JsonCloseObjectRegExCode: string = "\}";
	private static JsonOpenArrayRegExCode: string = "\[";
	private static JsonCloseArrayRegExCode: string = "\]";
	private static JsonColonRegExCode: string = "\:";
	private static JsonCommaRegExCode: string = "\,";
	private currentMatch: any /*System.Text.RegularExpressions.Match*/;
	private nextTokenType: JsonTokenType;
	private nextToken: string;
	private nextTokenPeeked: boolean;
	private static jsonStringRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static jsonNumberRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static jsonBooleanRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static jsonNullRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static jsonOpenObjectRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static jsonCloseObjectRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static jsonOpenArrayRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static jsonCloseArrayRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static jsonColonRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static jsonCommaRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static whitespaceRegEx: any /*System.Text.RegularExpressions.Regex*/;
	private static tokenDictionary: any /*System.Collections.Generic.Dictionary<JsonTokenType, System.Text.RegularExpressions.Regex>*/;
	private static fullTokenizerRegex: any /*System.Text.RegularExpressions.Regex*/;
	AdvanceRegExMatch(): void { throw new Error("JsonTokenizer.ts - AdvanceRegExMatch : Not implemented."); }
	NextToken(token: string): JsonTokenType { throw new Error("JsonTokenizer.ts - NextToken : Not implemented."); }
	Peek(): JsonTokenType { throw new Error("JsonTokenizer.ts - Peek : Not implemented."); }
}






			

			
// class JsonWriter extends System.IO.TextWriter {
//private static Indentation: string = "  ";
//	Encoding: any /*System.Text.Encoding*/;
//	ShouldCloseStream: boolean;
//	private outStream: any /*System.IO.Stream*/;
//	private shouldCloseStream: boolean;
//	private prettyPrint: boolean;
//	private writingStringValue: boolean;
//	private smallBuffer: any /*System.Byte[]*/;
//	private singleCharBuffer: any[] /*System.Char[]*/;
//	private closures: string[] /*System.Collections.Generic.Stack<string>*/;
//	private closureHasMembers: boolean[] /*System.Collections.Generic.Stack<boolean>*/;
//	AddingValue(): void{ throw new Error("JsonWriter.ts - AddingValue : Not implemented.");}
//	Dispose(disposing: boolean): void{ throw new Error("JsonWriter.ts - Dispose : Not implemented.");}
//	PopClosure(): void{ throw new Error("JsonWriter.ts - PopClosure : Not implemented.");}
//	PushArrayClosure(): void{ throw new Error("JsonWriter.ts - PushArrayClosure : Not implemented.");}
//	PushObjectClosure(): void{ throw new Error("JsonWriter.ts - PushObjectClosure : Not implemented.");}
//	Write(value: string): void{ throw new Error("JsonWriter.ts - Write : Not implemented.");}
//	WriteIndentation(): void{ throw new Error("JsonWriter.ts - WriteIndentation : Not implemented.");}
//	WriteInternal(value: string): void{ throw new Error("JsonWriter.ts - WriteInternal : Not implemented.");}
//	WriteKey(key: string): void{ throw new Error("JsonWriter.ts - WriteKey : Not implemented.");}
//	WriteNullValue(): void{ throw new Error("JsonWriter.ts - WriteNullValue : Not implemented.");}
//	WriteQuote(): void{ throw new Error("JsonWriter.ts - WriteQuote : Not implemented.");}
//	WriteValue(value: number): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: number): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: number): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: System.Enum): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: boolean): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: string): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: Date): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: number): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//}
//export = JsonWriter;





			

/**
 * @internal Represents a property bag keyed on PropertyDefinition objects.
 */
export class PropertyBag {

    private owner: ServiceObject = null;
    private isDirty: boolean = false;
    private loading: boolean = false;
    private onlySummaryPropertiesRequested: boolean = false;
    private loadedProperties: PropertyDefinition[] = [];
    private properties: Dictionary<PropertyDefinition, any> = new DictionaryWithPropertyDefitionKey<PropertyDefinition, any>();
    private deletedProperties: Dictionary<PropertyDefinition, any> = new DictionaryWithPropertyDefitionKey<PropertyDefinition, any>();
    private modifiedProperties: PropertyDefinition[] = [];
    private addedProperties: PropertyDefinition[] = [];
    private requestedPropertySet: PropertySet = null;

    /**
     * @internal Gets a dictionary holding the bag's properties.
     */
    get Properties(): Dictionary<PropertyDefinition, any> {
        return this.properties;
    }

    /**
     * @internal Gets the owner of this bag.
     */
    get Owner(): ServiceObject {
        return this.owner;
    }

    /**
     * @internal True if the bag has pending changes, false otherwise.
     */
    get IsDirty(): boolean {
        let changes = this.modifiedProperties.length + this.deletedProperties.length + this.addedProperties.length;
        return changes > 0 || this.isDirty;
    }

    /**
     * @internal Initializes a new instance of **PropertyBag**.
     *
     * @param   {ServiceObject}   owner   The owner of the bag.
     */
    constructor(owner: ServiceObject) {
        EwsLogging.Assert(
            owner != null,
            "PropertyBag.ctor",
            "owner is null");

        this.owner = owner;
    }

    /**
     * @internal Gets or sets the value of a property.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property to get or set.
     * @return  {any}                   An object representing the value of the property.
     */
    _getItem(propertyDefinition: PropertyDefinition): any {
        let serviceException: IOutParam<ServiceLocalException> = { outValue: null, exception: null };
        let propertyValue = this.GetPropertyValueOrException(propertyDefinition, serviceException);
        if (serviceException.outValue === null) {
            return propertyValue;
        }
        else {
            throw serviceException.exception;
        }
    }
    /**
     * @internal Gets or sets the value of a property.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property to get or set.
     * @return  {any}                   An object representing the value of the property.
     */
    _setItem(propertyDefinition: PropertyDefinition, value: any) {
        if (propertyDefinition.Version > this.Owner.Service.RequestedServerVersion) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.PropertyIncompatibleWithRequestVersion,
                    propertyDefinition.Name,
                    ExchangeVersion[propertyDefinition.Version]), null);
        }

        // If the property bag is not in the loading state, we need to verify whether
        // the property can actually be set or updated.
        if (!this.loading) {
            // If the owner is new and if the property cannot be set, throw.
            if (this.Owner.IsNew && !propertyDefinition.HasFlag(PropertyDefinitionFlags.CanSet, this.Owner.Service.RequestedServerVersion)) {
                throw new Error("property is readonly\n" + JSON.stringify(propertyDefinition));//  ServiceObjectPropertyException(Strings.PropertyIsReadOnly, propertyDefinition);
            }

            if (!this.Owner.IsNew) {
                // If owner is an item attachment, properties cannot be updated (EWS doesn't support updating item attachments)
                let isItem = this.owner instanceof TypeContainer.Item;  //ref: //info: TypeContainer contains constructor of Item (not instance) to evade circular dependency. Assigned at bootstarp
                //debugger;
                //let ownerItem = <Item>this.Owner; - implemented IsAttachment on service object to remove dependency to Item object.
                if (isItem && (<Item>this.owner).IsAttachment) { // ownerItem.IsAttachment) {
                    throw new ServiceObjectPropertyException(Strings.ItemAttachmentCannotBeUpdated, propertyDefinition);
                }

                // If the property cannot be deleted, throw.
                if (value == null && !propertyDefinition.HasFlag(PropertyDefinitionFlags.CanDelete)) {
                    throw new ServiceObjectPropertyException(Strings.PropertyCannotBeDeleted, propertyDefinition);
                }

                // If the property cannot be updated, throw.
                if (!propertyDefinition.HasFlag(PropertyDefinitionFlags.CanUpdate)) {
                    throw new ServiceObjectPropertyException(Strings.PropertyCannotBeUpdated, propertyDefinition);
                }
            }
        }

        // If the value is set to null, delete the property.
        if (value == null) {
            this.DeleteProperty(propertyDefinition);
        }
        else {
            let complexProperty: ComplexProperty = null;
            let currentValue = this.properties.get(propertyDefinition);

            if (currentValue) {
                complexProperty = currentValue;

                if (complexProperty instanceof ComplexProperty) {
                    ArrayHelper.RemoveEntry(complexProperty.OnChange, this.PropertyChanged);  //cant do += or -= in javascript (hopefully in ECMA6)                    
                }
            }

            // If the property was to be deleted, the deletion becomes an update.
            if (this.deletedProperties.remove(propertyDefinition)) {
                PropertyBag.AddToChangeList(propertyDefinition, this.modifiedProperties);

            }
            else {
                // If the property value was not set, we have a newly set property.
                if (this.properties.getStringKeys().indexOf(propertyDefinition.Name) == -1 /*.ContainsKey(propertyDefinition)*/) {
                    PropertyBag.AddToChangeList(propertyDefinition, this.addedProperties);
                }
                else {
                    // The last case is that we have a modified property.
                    if (this.modifiedProperties.indexOf(propertyDefinition) == -1 /*.Contains(propertyDefinition)*/) {
                        PropertyBag.AddToChangeList(propertyDefinition, this.modifiedProperties);
                    }
                }
            }

            this.InitComplexProperty(value instanceof ComplexProperty ? <ComplexProperty>value : undefined);
            this.properties.set(propertyDefinition, value);

            this.Changed();
        }
    }

    /**
     * @internal Adds the specified property to the specified change list if it is not already present.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property to add to the change list.
     * @param   {PropertyDefinition[]}  changeList           The change list to add the property to.
     */
    static AddToChangeList(propertyDefinition: PropertyDefinition, changeList: PropertyDefinition[] /*System.Collections.Generic.List<PropertyDefinition>*/): void {
        if (changeList.indexOf(propertyDefinition) < 0) {
            changeList.push(propertyDefinition);
        }
    }

    /**
     * @internal Sets the isDirty flag to true and triggers dispatch of the change event to the owner of the property bag.
     * Changed must be called whenever an operation that changes the state of this property bag is performed (e.g. adding or removing a property).
     */
    Changed(): void {
        this.isDirty = true;

        this.owner.Changed();
    }

    /**
     * @internal Clears the bag.
     */
    Clear(): void {
        this.ClearChangeLog();
        this.properties.clear();
        this.loadedProperties.splice(0);
        this.requestedPropertySet = undefined;
    }

    /**
     * @internal Clears the bag's change log.
     */
    ClearChangeLog(): void {
        this.deletedProperties.clear();
        this.modifiedProperties.splice(0);
        this.addedProperties.splice(0);

        for (let val of this.properties.Values) {
            let complexProperty = <ComplexProperty>val;

            if (complexProperty instanceof ComplexProperty) {
                complexProperty.ClearChangeLog();
            }
        }

        this.isDirty = false;
    }

    /**
     * @internal Determines whether the property bag contains a specific property.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property to check against.
     * @return  {boolean}               True if the specified property is in the bag, false otherwise.
     */
    Contains(propertyDefinition: PropertyDefinition): boolean {
        return this.properties.containsKey(propertyDefinition);
    }

    /**
     * @internal Deletes the property from the bag.
     *
     * @param   {PropertyDefinition}   propertyDefinition   The property to delete.
     */
    DeleteProperty(propertyDefinition: PropertyDefinition): void {
        if (!this.deletedProperties.containsKey(propertyDefinition)) {
            let propertyValue: IOutParam<any> = { outValue: null };

            this.properties.tryGetValue(propertyDefinition, propertyValue);

            this.properties.remove(propertyDefinition);
            let modifiedIndex = this.modifiedProperties.indexOf(propertyDefinition);
            if (modifiedIndex >= 0)
                this.modifiedProperties.splice(modifiedIndex, 1);

            this.deletedProperties.Add(propertyDefinition, propertyValue);

            let complexProperty = <ComplexProperty>propertyValue.outValue;

            if (complexProperty instanceof ComplexProperty) {
                ArrayHelper.RemoveEntry(complexProperty.OnChange, this.PropertyChanged); // -= this.PropertyChanged; // counld not do c# like event -= in js                
            }
        }
    }

    /**
     * @internal Determines whether an EWS UpdateItem/UpdateFolder call is necessary to save the changes that occurred in the bag.
     *
     * @return  {boolean}      True if an UpdateItem/UpdateFolder call is necessary, false otherwise.
     */
    GetIsUpdateCallNecessary(): boolean {
        let propertyDefinitions: PropertyDefinition[] = [];

        propertyDefinitions = propertyDefinitions.concat(this.addedProperties);
        propertyDefinitions = propertyDefinitions.concat(this.modifiedProperties);
        propertyDefinitions = propertyDefinitions.concat(this.deletedProperties.Keys);

        for (let propertyDefinition of propertyDefinitions) {
            if (propertyDefinition.HasFlag(PropertyDefinitionFlags.CanUpdate)) {
                return true;
            }
        }
        return false;
    }

    /**
     * @internal Gets the name of the property update item.
     *
     * @param   {ServiceObject}     serviceObject   The service object.
     * @return  {string}            [description]
     */
    static GetPropertyUpdateItemName(serviceObject: ServiceObject): string {
        return serviceObject instanceof TypeContainer.Folder ? //ref: //info: TypeContainer contains constructor of Folder (not instance) to evade circular dependency. Assigned at bootstarp
            XmlElementNames.Folder :
            XmlElementNames.Item;
    }

    /**
     * Gets the property value.
     *
     * @param   {PropertyDefinition}                    propertyDefinition   The property definition.
     * @param   { IOutParam<ServiceLocalException>}     exception            Exception that would be raised if there's an error retrieving the property.
     * @return  {any}                                   Propert value. May be null.
     */
    private GetPropertyValueOrException(propertyDefinition: PropertyDefinition, exception: IOutParam<ServiceLocalException>): any {
        let propertyValue: IOutParam<any> = { outValue: null };

        if (propertyDefinition.Version > this.Owner.Service.RequestedServerVersion) {
            exception.outValue = new ServiceVersionException(
                StringHelper.Format(
                    Strings.PropertyIncompatibleWithRequestVersion,
                    propertyDefinition.Name,
                    ExchangeVersion[propertyDefinition.Version]));
            return null;
        }

        if (this.TryGetValue(propertyDefinition, propertyValue)) {
            // If the requested property is in the bag, return it.

            return propertyValue.outValue;
        }
        else {
            if (propertyDefinition.HasFlag(PropertyDefinitionFlags.AutoInstantiateOnRead)) {
                // The requested property is an auto-instantiate-on-read property
                let complexPropertyDefinition = <ComplexPropertyDefinitionBase>propertyDefinition;

                EwsLogging.Assert(
                    (complexPropertyDefinition instanceof ComplexPropertyDefinitionBase),
                    "PropertyBag.get_this[]",
                    "propertyDefinition is marked with AutoInstantiateOnRead but is not a descendant of ComplexPropertyDefinitionBase");

                propertyValue.outValue = complexPropertyDefinition.CreatePropertyInstance(this.Owner);

                if (propertyValue.outValue != null) {
                    this.InitComplexProperty(<ComplexProperty>propertyValue.outValue);
                    this.properties.set(propertyDefinition, propertyValue.outValue);
                }
            }
            else {
                // If the property is not the Id (we need to let developers read the Id when it's null) and if has
                // not been loaded, we throw.
                if (propertyDefinition != this.Owner.GetIdPropertyDefinition()) {
                    if (!this.IsPropertyLoaded(propertyDefinition)) {
                        exception.outValue = new ServiceObjectPropertyException(Strings.MustLoadOrAssignPropertyBeforeAccess, propertyDefinition);
                        return null;
                    }

                    // Non-nullable properties (int, bool, etc.) must be assigned or loaded; cannot return null value.
                    if (!propertyDefinition.IsNullable) {
                        let errorMessage = this.IsRequestedProperty(propertyDefinition)
                            ? Strings.ValuePropertyNotLoaded
                            : Strings.ValuePropertyNotAssigned;
                        exception.outValue = new ServiceObjectPropertyException(errorMessage, propertyDefinition);
                    }
                }
            }

            return propertyValue.outValue;
        }
    }

    /**
     * Initializes a ComplexProperty instance. When a property is inserted into the bag, it needs to be initialized in order for changes that occur on that property to be properly detected and dispatched.
     *
     * @param   {ComplexProperty}   complexProperty   The ComplexProperty instance to initialize.
     */
    private InitComplexProperty(complexProperty: ComplexProperty): void {

        if (complexProperty) {
            complexProperty.OnChange.push(this.PropertyChanged.bind(this)); // can't do += in javascript;

            if (TypeGuards.isIOwnedProperty(complexProperty)) { //IOwnedProperty ownedProperty = complexProperty as IOwnedProperty;
                complexProperty.Owner = this.Owner;
            }
        }
    }

    /**
     * @internal Determines whether specified property is loaded. This also includes properties that were requested when the property bag was loaded but were not returned by the server. In this case, the property value will be null.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @return  {boolean}               true if property was loaded or requested; otherwise, false.
     */
    IsPropertyLoaded(propertyDefinition: PropertyDefinition): boolean {
        // Is the property loaded?
        if (this.loadedProperties.indexOf(propertyDefinition) >= 0) {
            return true;
        }
        else {
            // Was the property requested?
            return this.IsRequestedProperty(propertyDefinition);
        }
    }

    /**
     * @internal Determines whether the specified property has been updated.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @return  {boolean}               true if the specified property has been updated; otherwise, false.
     */    
    IsPropertyUpdated(propertyDefinition: PropertyDefinition): boolean {
        return this.modifiedProperties.indexOf(propertyDefinition) >= 0 || this.addedProperties.indexOf(propertyDefinition) >= 0;
    }

    /**
     * Determines whether specified property was requested.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @return  {boolean}               true if property was requested; otherwise, false.
     */
    private IsRequestedProperty(propertyDefinition: PropertyDefinition): boolean {
        // If no requested property set, then property wasn't requested.
        if (this.requestedPropertySet == null || this.requestedPropertySet == undefined) {
            return false;
        }

        // If base property set is all first-class properties, use the appropriate list of
        // property definitions to see if this property was requested. Otherwise, property had
        // to be explicitly requested and needs to be listed in AdditionalProperties.
        if (this.requestedPropertySet.BasePropertySet == BasePropertySet.FirstClassProperties) {
            let firstClassProps = this.onlySummaryPropertiesRequested
                ? this.Owner.Schema.FirstClassSummaryProperties
                : this.Owner.Schema.FirstClassProperties;

            return firstClassProps.indexOf(propertyDefinition) >= 0 ||
                this.requestedPropertySet.Contains(propertyDefinition);
        }
        else {
            return this.requestedPropertySet.Contains(propertyDefinition);
        }
    }

    /**
     * @internal Loads from xml js object.
     *
     * @param   {any}   jsObject                The json service object.
     * @param   {ExchangeService}   service                          The service.
     * @param   {boolean}   clear                            Indicates whether the bag should be cleared before properties are loaded.
     * @param   {PropertySet}   requestedPropertySet             The requested property set.
     * @param   {boolean}   onlySummaryPropertiesRequested   Indicates whether summary or full properties were requested.
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService, clear: boolean, requestedPropertySet: PropertySet, onlySummaryPropertiesRequested: boolean): void {
        if (clear) {
            this.Clear();
        }

        // Put the property bag in "loading" mode. When in loading mode, no checking is done
        // when setting property values.
        this.loading = true;

        this.requestedPropertySet = requestedPropertySet;
        this.onlySummaryPropertiesRequested = onlySummaryPropertiesRequested;

        try {

            for (let key in jsObject) {
                if (key.indexOf("__") === 0) //skip xmljsobject conversion entries like __type and __prefix
                    continue;

                if (jsObject.hasOwnProperty(key)) {
                    let element = jsObject[key];

                    let propertyDefinition: IOutParam<PropertyDefinition> = { outValue: null };

                    if (this.owner.Schema.TryGetPropertyDefinition(key, propertyDefinition)) {
                        EwsLogging.Assert(false, EwsUtilities.GetPrintableTypeName(propertyDefinition.outValue), "\t\tLoading property :\t\t" + key);
                        propertyDefinition.outValue.LoadPropertyValueFromXmlJsObject(element, service, this);
                        this.loadedProperties.push(propertyDefinition.outValue);
                        EwsLogging.DebugLog(this._getItem(propertyDefinition.outValue), true);//todo:remove this after testing
                    }
                }
            }


            //            let objTypeName: string = jsObject["__type"];
            //            if (StringHelper.IsNullOrEmpty(objTypeName)) {
            //                objTypeName = TypeSystem.GetJsObjectTypeName(jsObject);
            //                jsObject = jsObject[objTypeName];
            //            }
            //            if (StringHelper.IsNullOrEmpty(objTypeName))
            //                throw new Error("error determining typename");
            //
            //            let propertyDefinition: IOutParam<PropertyDefinition> = { value: null };
            //
            //            if (this.Owner.Schema.TryGetPropertyDefinition(objTypeName, propertyDefinition)) {
            //                propertyDefinition.outValue.LoadPropertyValueFromXmlJsObject(jsObject, this);
            //
            //                this.loadedProperties.push(propertyDefinition.outValue);
            //            }
            this.ClearChangeLog();
        }
        catch (exception) {
            EwsLogging.Log(exception);
        }
        finally {
            this.loading = false;
        }
    }

    /**
     * @internal Handles a change event for the specified property.
     *
     * @param   {ComplexProperty}   complexProperty   The property that changes.
     */
    PropertyChanged(complexProperty: ComplexProperty): void {
        for (let keyValuePair of this.properties.Items) {
            if (keyValuePair.value == complexProperty) {
                if (!this.deletedProperties.containsKey(keyValuePair.key)) {
                    PropertyBag.AddToChangeList(keyValuePair.key, this.modifiedProperties);
                    this.Changed();
                }
            }
        }
    }

    /**
     * @internal Tries to get a property value based on a property definition.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @param   {IOutParam<any>}        propertyValue        The property value.
     * @return  {boolean}               True if property was retrieved.
     */
    TryGetProperty(propertyDefinition: PropertyDefinition, propertyValue: IOutParam<any>): boolean {
        let serviceException: IOutParam<ServiceLocalException> = { outValue: null };
        propertyValue.outValue = this.GetPropertyValueOrException(propertyDefinition, serviceException);
        return serviceException.outValue == null;
    }

    /**
     * @internal Tries to get a property value based on a property definition.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @param   {IOutParam<any>}        propertyValue        The property value.
     * @return  {boolean}               True if property was retrieved.
     */
    TryGetPropertyAs<T>(propertyDefinition: PropertyDefinition, propertyValue: IOutParam<T>): boolean {
        // Verify that the type parameter and property definition's type are compatible.
        //debug: 
        //todo: fix isassignablefrom use Typed parameter and default value of that type when asking.
        //if (!typeof (T).IsAssignableFrom(propertyDefinition.Type)) {
        //    string errorMessage = ExtensionMethods.stringFormatting.Format(
        //        Strings.PropertyDefinitionTypeMismatch,
        //        EwsUtilities.GetPrintableTypeName(propertyDefinition.Type),
        //        EwsUtilities.GetPrintableTypeName(typeof (T)));
        //    throw new ArgumentException(errorMessage, "propertyDefinition");
        //}

        let outValue: IOutParam<T> = { outValue: null };

        let result = this.TryGetProperty(propertyDefinition, outValue);

        propertyValue.outValue = result ? outValue.outValue : undefined;

        return result;
    }

    /**
     * @internal Tries to retrieve the value of the specified property.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property for which to retrieve a value.
     * @param   {IOutParam<any>}        propertyValue        If the method succeeds, contains the value of the property.
     * @return  {boolean}               True if the value could be retrieved, false otherwise.
     */
    TryGetValue(propertyDefinition: PropertyDefinition, propertyValue: IOutParam<any>): boolean {
        return this.properties.tryGetValue(propertyDefinition, propertyValue);
    }

    /**
     * @internal Validate property bag instance.
     */
    Validate(): void {
        for (let propertyDefinition of this.addedProperties) {
            this.ValidatePropertyValue(propertyDefinition);
        }

        for (let propertyDefinition of this.modifiedProperties) {
            this.ValidatePropertyValue(propertyDefinition);
        }
    }

    /**
     * Validates the property value.
     */
    private ValidatePropertyValue(propertyDefinition: PropertyDefinition): void {
        let propertyValue: IOutParam<any> = { outValue: null };
        if (this.TryGetProperty(propertyDefinition, propertyValue)) {

            if (TypeGuards.isISelfValidate(propertyValue.outValue)) {
                propertyValue.outValue.Validate();
            }
        }
    }

    /**
     * Writes an EWS DeleteUpdate opeartion for the specified property.
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer to write the update to.
     * @param   {PropertyDefinition}    propertyDefinition   The property fro which to write the update.
     * @param   {any}                   propertyValue        The current value of the property.
     */
    private WriteDeleteUpdateToXml(writer: EwsServiceXmlWriter, propertyDefinition: PropertyDefinition, propertyValue: any): void {
        // The following test should not be necessary since the property bag prevents
        // properties to be deleted (set to null) if they don't have the CanDelete flag,
        // but it doesn't hurt...
        if (propertyDefinition.HasFlag(PropertyDefinitionFlags.CanDelete)) {
            let handled = false;

            if (TypeGuards.isICustomUpdateSerializer(propertyValue)) { //ICustomUpdateSerializer updateSerializer = propertyValue as ICustomUpdateSerializer;
                handled = propertyValue.WriteDeleteUpdateToXml(writer, this.Owner);
            }

            if (!handled) {
                writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetDeleteFieldXmlElementName());
                propertyDefinition.WriteToXml(writer);
                writer.WriteEndElement();
            }
        }
    }

    /**
     * Writes an EWS SetUpdate opeartion for the specified property.
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer to write the update to.
     * @param   {PropertyDefinition}    propertyDefinition   The property fro which to write the update.
     */
    private WriteSetUpdateToXml(writer: EwsServiceXmlWriter, propertyDefinition: PropertyDefinition): void {
        // The following test should not be necessary since the property bag prevents
        // properties to be updated if they don't have the CanUpdate flag, but it
        // doesn't hurt...
        if (propertyDefinition.HasFlag(PropertyDefinitionFlags.CanUpdate)) {
            let propertyValue = this._getItem(propertyDefinition);

            let handled = false;

            if (TypeGuards.isICustomUpdateSerializer(propertyValue)) { //ICustomUpdateSerializer updateSerializer = propertyValue as ICustomUpdateSerializer;
                handled = propertyValue.WriteSetUpdateToXml(
                    writer,
                    this.Owner,
                    propertyDefinition);
            }

            if (!handled) {
                writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetSetFieldXmlElementName());

                propertyDefinition.WriteToXml(writer);

                writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetXmlElementName());
                propertyDefinition.WritePropertyValueToXml(writer, this, true /* isUpdateOperation */);
                writer.WriteEndElement();

                writer.WriteEndElement();
            }
        }
    }

    /**
     * @internal Writes the bag's properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer to write the properties to.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetXmlElementName());

        //debug: //todo: fix Schema objects IEnumerable.

        //
        for (let propertyDefinition of this.Owner.Schema.GetEnumerator()) {
            // The following test should not be necessary since the property bag prevents
            // properties to be set if they don't have the CanSet flag, but it doesn't hurt...
            if (propertyDefinition.HasFlag(PropertyDefinitionFlags.CanSet, writer.Service.RequestedServerVersion)) {
                if (this.Contains(propertyDefinition)) {
                    propertyDefinition.WritePropertyValueToXml(writer, this, false /* isUpdateOperation */);
                }
            }
        }

        writer.WriteEndElement();
    }

    /**
     * @internal Writes the EWS update operations corresponding to the changes that occurred in the bag to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer to write the updates to.
     */
    WriteToXmlForUpdate(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetChangeXmlElementName());

        this.Owner.GetId().WriteToXml(writer);

        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Updates);

        for (let propertyDefinition of this.addedProperties) {
            this.WriteSetUpdateToXml(writer, propertyDefinition);
        }

        for (let propertyDefinition of this.modifiedProperties) {
            this.WriteSetUpdateToXml(writer, propertyDefinition);
        }

        for (let kv of this.deletedProperties.Items) {
            this.WriteDeleteUpdateToXml(
                writer,
                kv.key,
                kv.value);
        }

        writer.WriteEndElement();
        writer.WriteEndElement();
    }
}

export type DefaultPropertySetDictionary = LazyMember<Dictionary<BasePropertySet, string>>;

/**
 * Represents a set of item or folder properties. Property sets are used to indicate what properties of an item or folder should be loaded when binding to an existing item or folder or when loading an item or folder's properties. 
 * 
 * @sealed
 */
export class PropertySet implements ISelfValidate, IEnumerable<PropertyDefinitionBase> {

    /**
     * Returns a predefined property set that only includes the Id property.
     */
    static readonly IdOnly: PropertySet = PropertySet.CreateReadonlyPropertySet(BasePropertySet.IdOnly);

    /**
     * Returns a predefined property set that includes the first class properties of an item or folder.
     */
    static readonly FirstClassProperties: PropertySet = PropertySet.CreateReadonlyPropertySet(BasePropertySet.FirstClassProperties);

    /**
     * Maps BasePropertySet values to EWS's BaseShape values.
     */
    private static defaultPropertySetMap: DefaultPropertySetDictionary = new LazyMember<Dictionary<BasePropertySet, string>>(() => {
        let result: Dictionary<BasePropertySet, string> = new Dictionary<BasePropertySet, string>((bps) => BasePropertySet[bps]);
        result.Add(BasePropertySet.IdOnly, "IdOnly");
        result.Add(BasePropertySet.FirstClassProperties, "AllProperties");
        return result;
    });

    /**
     * The base property set this property set is based upon.
     */
    private basePropertySet: BasePropertySet = BasePropertySet.IdOnly;

    /**
     * The list of additional properties included in this property set.
     */
    private additionalProperties: PropertyDefinitionBase[] = [];

    /**
     * The requested body type for get and find operations. If null, the "best body" is returned.
     */
    private requestedBodyType: BodyType = null; //nullable

    /**
     * The requested unique body type for get and find operations. If null, the should return the same value as body type.
     */
    private requestedUniqueBodyType: BodyType = null; //nullable

    /**
     * The requested normalized body type for get and find operations. If null, the should return the same value as body type.
     */
    private requestedNormalizedBodyType: BodyType = null; //nullable

    /**
     * Value indicating whether or not the server should filter HTML content.
     */
    private filterHtml: boolean = null; //nullable

    /**
     * Value indicating whether or not the server should convert HTML code page to UTF8.
     */
    private convertHtmlCodePageToUTF8: boolean = null; //nullable

    /**
     * Value of the URL template to use for the src attribute of inline IMG elements.
     */
    private inlineImageUrlTemplate: string = null;

    /**
     * Value indicating whether or not the server should block references to external images.
     */
    private blockExternalImages: boolean = null; //nullable

    /**
     * Value indicating whether or not to add a blank target attribute to anchor links.
     */
    private addTargetToLinks: boolean = null; //nullable

    /**
     * Value indicating whether or not this PropertySet can be modified.
     */
    private isReadOnly: boolean = false;

    /**
     * Value indicating the maximum body size to retrieve.
     */
    private maximumBodySize: number = null; //nullable

    /**
     * @internal Maps BasePropertySet values to EWS's BaseShape values.
     */
    static get DefaultPropertySetMap(): DefaultPropertySetDictionary {
        return this.defaultPropertySetMap;
    }

    /**
     * Gets or sets the base property set the property set is based upon.
     */
    get BasePropertySet(): BasePropertySet {
        return this.basePropertySet;
    }
    set BasePropertySet(value) {
        this.ThrowIfReadonly();
        this.basePropertySet = value;
    }

    /**
     * Gets or sets type of body that should be loaded on items. If RequestedBodyType is null, body is returned as HTML if available, plain text otherwise.
     * 
     * @Nullable
     */
    get RequestedBodyType(): BodyType {
        return this.requestedBodyType;
    }
    set RequestedBodyType(value) {
        this.ThrowIfReadonly();
        this.requestedBodyType = value;
    }

    /**
     * Gets or sets type of body that should be loaded on items. If null, the should return the same value as body type.
     * 
     * @nullable
     */
    get RequestedUniqueBodyType(): BodyType {
        return this.requestedUniqueBodyType;
    }
    set RequestedUniqueBodyType(value) {
        this.ThrowIfReadonly();
        this.requestedUniqueBodyType = value;
    }

    /**
     * Gets or sets type of normalized body that should be loaded on items. If null, the should return the same value as body type.
     * 
     * @nullable
     */
    get RequestedNormalizedBodyType(): BodyType {
        return this.requestedNormalizedBodyType;
    }
    set RequestedNormalizedBodyType(value) {
        this.ThrowIfReadonly();
        this.requestedNormalizedBodyType = value;
    }

    /**
     * Gets the number of explicitly added properties in this set.
     */
    get Count(): number {
        return this.additionalProperties.length;
    }

    /**
     * Gets or sets value indicating whether or not to filter potentially unsafe HTML content from message bodies.
     * 
     * @nullable
     */
    get FilterHtmlContent(): boolean {
        return this.filterHtml;
    }
    set FilterHtmlContent(value) {
        this.ThrowIfReadonly();
        this.filterHtml = value;
    }

    /**
     * Gets or sets value indicating whether or not to convert HTML code page to UTF8 encoding.
     * 
     * @nullable
     */
    get ConvertHtmlCodePageToUTF8(): boolean {
        return this.convertHtmlCodePageToUTF8;
    }
    set ConvertHtmlCodePageToUTF8(value) {
        this.ThrowIfReadonly();
        this.convertHtmlCodePageToUTF8 = value;
    }

    /**
     * Gets or sets a value of the URL template to use for the src attribute of inline IMG elements.
     * 
     * @nullable
     */
    get InlineImageUrlTemplate(): string {
        return this.inlineImageUrlTemplate;
    }
    set InlineImageUrlTemplate(value) {
        this.ThrowIfReadonly();
        this.inlineImageUrlTemplate = value;
    }

    /**
     * Gets or sets value indicating whether or not to convert inline images to data URLs.
     * 
     * @nullable
     */
    get BlockExternalImages(): boolean {
        return this.blockExternalImages;
    }
    set BlockExternalImages(value) {
        this.ThrowIfReadonly();
        this.blockExternalImages = value;
    }

    /**
     * Gets or sets value indicating whether or not to add blank target attribute to anchor links.
     * 
     * @nullable
     */
    get AddBlankTargetToLinks(): boolean {
        return this.addTargetToLinks;
    }
    set AddBlankTargetToLinks(value) {
        this.ThrowIfReadonly();
        this.addTargetToLinks = value;
    }

    /**
     * Gets or sets the maximum size of the body to be retrieved.
     * 
     * @nullable
     * 
     * @value   The maximum size of the body to be retrieved.
     */
    get MaximumBodySize(): number {
        return this.maximumBodySize;
    }
    set MaximumBodySize(value) {
        this.ThrowIfReadonly();
        this.maximumBodySize = value;
    }

    /**
     * Initializes a new instance of **PropertySet** based upon BasePropertySet.IdOnly.
     */
    constructor();
    /**
     * Initializes a new instance of **PropertySet** based upon BasePropertySet.IdOnly.
     *
     * @param   {BasePropertySet}   basePropertySet        The base property set to base the property set upon.
     */
    constructor(basePropertySet: BasePropertySet);

    /**
     * Initializes a new instance of **PropertySet** based upon BasePropertySet.IdOnly.
     *
     * @param   {PropertyDefinitionBase[]}  additionalProperties   Additional properties to include in the property set. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
     */
    constructor(additionalProperties: PropertyDefinitionBase[]);
    /**
     * Initializes a new instance of **PropertySet**.
     *
     * @param   {PropertyDefinitionBase[]}  additionalProperties   Additional properties to include in the property set. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
     */
    constructor(...additionalProperties: PropertyDefinitionBase[]);
    /**
     * Initializes a new instance of **PropertySet**.
     *
     * @param   {BasePropertySet}           basePropertySet        The base property set to base the property set upon.
     * @param   {PropertyDefinitionBase[]}  additionalProperties   Additional properties to include in the property set. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
     */
    constructor(basePropertySet: BasePropertySet, additionalProperties: PropertyDefinitionBase[]);
    /**
     * Initializes a new instance of **PropertySet**.
     *
     * @param   {BasePropertySet}           basePropertySet        The base property set to base the property set upon.
     * @param   {PropertyDefinitionBase[]}  additionalProperties   Additional properties to include in the property set. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
     */
    constructor(basePropertySet: BasePropertySet, ...additionalProperties: PropertyDefinitionBase[]);
    constructor(basePropertySetOrAdditionalProperties: BasePropertySet | PropertyDefinitionBase | PropertyDefinitionBase[] = null, _additionalProperties: PropertyDefinitionBase | PropertyDefinitionBase[] = null) {

        let argsLength = arguments.length;
        let basePropertySet: BasePropertySet = BasePropertySet.IdOnly;
        let additionalProperties: PropertyDefinitionBase[] = [];

        if (argsLength >= 1) {
            if (typeof basePropertySetOrAdditionalProperties === 'number') {
                basePropertySet = basePropertySetOrAdditionalProperties;
            }
            else if (ArrayHelper.isArray(basePropertySetOrAdditionalProperties)) {
                additionalProperties = basePropertySetOrAdditionalProperties;
            }
            else {
                additionalProperties = [basePropertySetOrAdditionalProperties];
            }
        }

        if (argsLength >= 2) {
            if (ArrayHelper.isArray(_additionalProperties)) {
                additionalProperties = _additionalProperties;
            }
            else {
                additionalProperties.push(_additionalProperties);
            }
        }

        if (argsLength > 2) {
            for (var _i = 2; _i < arguments.length; _i++) {
                additionalProperties.push(arguments[_i]);
            }
        }

        this.basePropertySet = basePropertySet;
        if (additionalProperties.length > 0) {
            this.additionalProperties = additionalProperties;
            //ArrayHelper.AddRange(this.additionalProperties, <any>additionalProperties);
            //this.additionalProperties.push.apply(this.additionalProperties, additionalProperties); //todo: addrange for array - http://typescript.codeplex.com/workitem/1422
        }
    }

    /**
     * Gets the **PropertyDefinitionBase** at the specified index. this[int] indexer
     *
     * @param   {number}   index   Index.
     */
    _getItem(index: number): PropertyDefinitionBase {
        return this.additionalProperties[index];
    }

    /**
     * Adds the specified property to the property set.
     *
     * @param   {PropertyDefinitionBase}   property   The property to add.
     */
    Add(property: PropertyDefinitionBase): void {
        this.ThrowIfReadonly();
        EwsUtilities.ValidateParam(property, "property");

        if (this.additionalProperties.indexOf(property) === -1) {
            this.additionalProperties.push(property);
        }
    }

    /**
     * Adds the specified properties to the property set.
     *
     * @param   {PropertyDefinitionBase[]}   properties   The properties to add.
     */
    AddRange(properties: PropertyDefinitionBase[]): void {
        this.ThrowIfReadonly();
        EwsUtilities.ValidateParamCollection(properties, "properties");

        for (let property of properties) {
            this.Add(property);
        }
    }

    /**
     * Remove all explicitly added properties from the property set.
     */
    Clear(): void {
        this.ThrowIfReadonly();
        this.additionalProperties.splice(0);
    }

    /**
     * Determines whether the specified property has been explicitly added to this property set using the Add or AddRange methods.
     *
     * @param   {PropertyDefinitionBase}    property   The property.
     * @return  {boolean}                   true if this property set contains the specified propert]; otherwise, false.
     */
    Contains(property: PropertyDefinitionBase): boolean { return this.additionalProperties.indexOf(property) !== -1; }

    /**
     * Creates a read-only PropertySet.
     *
     * @param   {BasePropertySet}   basePropertySet   The base property set.
     * @return  {PropertySet}       PropertySet
     */
    private static CreateReadonlyPropertySet(basePropertySet: BasePropertySet): PropertySet {
        let propertySet: PropertySet = new PropertySet(basePropertySet);
        propertySet.isReadOnly = true;
        return propertySet;
    }

    /**
     *  Returns an enumerator that iterates through the collection. this case this.additionalProperties itself
     */
    GetEnumerator(): PropertyDefinitionBase[] {
        return this.additionalProperties;
    }

    /**
     * Gets the name of the shape.
     *
     * @param   {ServiceObjectType}     serviceObjectType   Type of the service object.
     * @return  {string}                Shape name.
     */
    private static GetShapeName(serviceObjectType: ServiceObjectType): string {
        switch (serviceObjectType) {
            case ServiceObjectType.Item:
                return XmlElementNames.ItemShape;
            case ServiceObjectType.Folder:
                return XmlElementNames.FolderShape;
            case ServiceObjectType.Conversation:
                return XmlElementNames.ConversationShape;
            default:
                EwsLogging.Assert(
                    false,
                    "PropertySet.GetShapeName",
                    StringHelper.Format("An unexpected object type {0} for property shape. This code path should never be reached.", serviceObjectType));
                return StringHelper.Empty;
        }
    }

    /**
     * @internal Validates this property set.
     */
    InternalValidate(): void {
        for (let i = 0; i < this.additionalProperties.length; i++) {
            if (this.additionalProperties[i] == null) {
                throw new ServiceValidationException(StringHelper.Format(Strings.AdditionalPropertyIsNull, i));
            }
        }
    }

    /**
     * Removes the specified property from the set.
     *
     * @param   {PropertyDefinitionBase}    property   The property to remove.
     * @return  {boolean}                   true if the property was successfully removed, false otherwise.
     */
    Remove(property: PropertyDefinitionBase): boolean {
        this.ThrowIfReadonly();
        return ArrayHelper.RemoveEntry(this.additionalProperties, property);
    }

    /**
     * Throws if readonly property set.
     */
    private ThrowIfReadonly(): void {
        if (this.isReadOnly) {
            throw new Error(" PropertySet can not be modified");// System.NotSupportedException(Strings.PropertySetCannotBeModified);
        }
    }

    /**
     * Implements ISelfValidate.Validate. Validates this property set.
     */
    Validate(): void {
        this.InternalValidate();
    }

    /**
     * @internal Validates this property set instance for request to ensure that:
     *  1. Properties are valid for the request server version.
     *  2. If only summary properties are legal for this request (e.g. FindItem) then only summary properties were specified.
     *
     * @param   {ServiceRequestBase}    request                 The request.
     * @param   {boolean}               summaryPropertiesOnly   if set to true then only summary properties are allowed.
     */
    ValidateForRequest(request: ServiceRequestBase, summaryPropertiesOnly: boolean): void {
        for (let propDefBase of this.additionalProperties) {
            //let propDefBase: PropertyDefinitionBase = propItem;
            let propertyDefinition = <PropertyDefinition>propDefBase;
            if (propertyDefinition instanceof PropertyDefinition/* != null*/) {
                if (propertyDefinition.Version > request.Service.RequestedServerVersion) {
                    throw new ServiceVersionException(
                        StringHelper.Format(
                            Strings.PropertyIncompatibleWithRequestVersion,
                            propertyDefinition.Name,
                            ExchangeVersion[propertyDefinition.Version]));
                }

                if (summaryPropertiesOnly && !propertyDefinition.HasFlag(PropertyDefinitionFlags.CanFind, request.Service.RequestedServerVersion)) {
                    throw new ServiceValidationException(
                        StringHelper.Format(
                            Strings.NonSummaryPropertyCannotBeUsed,
                            propertyDefinition.Name,
                            request.GetXmlElementName()));
                }
            }
        }

        if (this.FilterHtmlContent/*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2010) {
                throw new ServiceVersionException(
                    StringHelper.Format(
                        Strings.PropertyIncompatibleWithRequestVersion,
                        "FilterHtmlContent",
                        ExchangeVersion[ExchangeVersion.Exchange2010]));
            }
        }

        if (this.ConvertHtmlCodePageToUTF8/*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2010_SP1) {
                throw new ServiceVersionException(
                    StringHelper.Format(
                        Strings.PropertyIncompatibleWithRequestVersion,
                        "ConvertHtmlCodePageToUTF8",
                        ExchangeVersion[ExchangeVersion.Exchange2010_SP1]));
            }
        }

        if (!StringHelper.IsNullOrEmpty(this.InlineImageUrlTemplate)) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(
                    StringHelper.Format(
                        Strings.PropertyIncompatibleWithRequestVersion,
                        "InlineImageUrlTemplate",
                        ExchangeVersion[ExchangeVersion.Exchange2013]));
            }
        }

        if (this.BlockExternalImages/*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(
                    StringHelper.Format(
                        Strings.PropertyIncompatibleWithRequestVersion,
                        "BlockExternalImages",
                        ExchangeVersion[ExchangeVersion.Exchange2013]));
            }
        }

        if (this.AddBlankTargetToLinks/*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(
                    StringHelper.Format(
                        Strings.PropertyIncompatibleWithRequestVersion,
                        "AddTargetToLinks",
                        ExchangeVersion[ExchangeVersion.Exchange2013]));
            }
        }

        if (this.MaximumBodySize/*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(
                    StringHelper.Format(
                        Strings.PropertyIncompatibleWithRequestVersion,
                        "MaximumBodySize",
                        ExchangeVersion[ExchangeVersion.Exchange2013]));
            }
        }
    }

    /**
     * @internal Writes additonal properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer                The writer to write to.
     * @param   {PropertyDefinitionBase[]}   propertyDefinitions   The property definitions to write.
     */
    static WriteAdditionalPropertiesToXml(writer: EwsServiceXmlWriter, propertyDefinitions: PropertyDefinitionBase[]): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AdditionalProperties);

        for (let propertyDefinition of propertyDefinitions) {
            propertyDefinition.WriteToXml(writer);
        }

        writer.WriteEndElement();
    }

    /**
     * @internal Writes the property set to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer to write to.
     * @param   {ServiceObjectType}     serviceObjectType   The type of service object the property set is emitted for.
     */
    WriteToXml(writer: EwsServiceXmlWriter, serviceObjectType: ServiceObjectType): void {
        let shapeElementName: string = PropertySet.GetShapeName(serviceObjectType);

        writer.WriteStartElement(XmlNamespace.Messages, shapeElementName);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.BaseShape,
            PropertySet.defaultPropertySetMap.Member.get(this.BasePropertySet));

        if (serviceObjectType == ServiceObjectType.Item) {
            if (this.RequestedBodyType/*.HasValue*/) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.BodyType,
                    BodyType[this.RequestedBodyType]/*.Value*/);
            }

            if (this.RequestedUniqueBodyType/*.HasValue*/) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.UniqueBodyType,
                    BodyType[this.RequestedUniqueBodyType]/*.Value*/);
            }

            if (this.RequestedNormalizedBodyType/*.HasValue*/) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.NormalizedBodyType,
                    BodyType[this.RequestedNormalizedBodyType]/*.Value*/);
            }

            if (this.FilterHtmlContent/*.HasValue*/) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.FilterHtmlContent,
                    this.FilterHtmlContent/*.Value*/);
            }

            if (this.ConvertHtmlCodePageToUTF8/*.HasValue*/ &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2010_SP1) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.ConvertHtmlCodePageToUTF8,
                    this.ConvertHtmlCodePageToUTF8/*.Value*/);
            }

            if (!StringHelper.IsNullOrEmpty(this.InlineImageUrlTemplate) &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.InlineImageUrlTemplate,
                    this.InlineImageUrlTemplate);
            }

            if (this.BlockExternalImages/*.HasValue*/ &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.BlockExternalImages,
                    this.BlockExternalImages/*.Value*/);
            }

            if (this.AddBlankTargetToLinks/*.HasValue*/ &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.AddBlankTargetToLinks,
                    this.AddBlankTargetToLinks/*.Value*/);
            }

            if (this.MaximumBodySize/*.HasValue*/ &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.MaximumBodySize,
                    this.MaximumBodySize/*.Value*/);
            }
        }

        if (this.additionalProperties.length > 0) {
            PropertySet.WriteAdditionalPropertiesToXml(writer, this.additionalProperties);
        }

        writer.WriteEndElement(); // Item/FolderShape
    }
}

export class SimplePropertyBag<TKey> {
	private items: Dictionary<TKey, any> = null;
	private removedItems: TKey[] = [];
	private addedItems: TKey[] = [];
	private modifiedItems: TKey[] = [];
	public OnChange: PropertyBagChangedDelegate[] = [];
	get AddedItems(): TKey[] {
		return this.addedItems;
	}
	get RemovedItems(): TKey[] {
		return this.removedItems;
	}
	get ModifiedItems(): TKey[] {
		return this.modifiedItems;
	}


	constructor(keyPicker: StringKeyPicker<TKey>) {
		this.items = new Dictionary<TKey, any>(keyPicker);
	}

	_getItem(key: TKey): any {
        var value: IOutParam<any> = { outValue: null };

		if (this.TryGetValue(key, value)) {
			return value.outValue;
		}
		else {
			return null;
		}
    }

    _setItem(key: TKey, value: any) {
        if (value == null) {
			this.InternalRemoveItem(key);
		}
		else {
			// If the item was to be deleted, the deletion becomes an update.
			if (ArrayHelper.RemoveEntry(this.removedItems, key)) {
				this.InternalAddItemToChangeList(key, this.modifiedItems);
			}
			else {
				// If the property value was not set, we have a newly set property.
				if (!this.ContainsKey(key)) {
					this.InternalAddItemToChangeList(key, this.addedItems);
				}
				else {
					// The last case is that we have a modified property.
					if (this.modifiedItems.indexOf(key) === -1) {
						this.InternalAddItemToChangeList(key, this.modifiedItems);
					}
				}
			}

			this.items.set(key, value);
			this.Changed();
		}
    }

	Changed(): void {
		if (this.OnChange != null) {
			EwsLogging.Assert(false, "SimplePropertyBag.Changed", "OnChange events not fired due to circular calling, todo: fix needed");
			return;
			for (var changeDelegate of this.OnChange) {
				changeDelegate();
			}
		}
	}
	ClearChangeLog(): void {
		this.removedItems.splice(0);
		this.addedItems.splice(0);
		this.modifiedItems.splice(0);
	}
	ContainsKey(key: TKey): boolean { return this.items.containsKey(key); }
	GetEnumerator(): any /*System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, any>>*/ { throw new Error("SimplePropertyBag.ts - GetEnumerator : Not implemented."); }
	InternalAddItemToChangeList(key: TKey, changeList: TKey[]): void {
		if (changeList.indexOf(key) === -1) {
			changeList.push(key);
		}
	}
	InternalRemoveItem(key: TKey): void {
		var value: IOutParam<any> = { outValue: null };

		if (this.TryGetValue(key, value)) {
			this.items.remove(key);
			this.removedItems.push(key);
			this.Changed();
		}
	}
	TryGetValue(key: TKey, value: IOutParam<any>): boolean { return this.items.tryGetValue(key, value); }
}
/**
 * ## @internal *Not Implemented* 
 */
export class AsyncRequestResult {
	ServiceRequest: ServiceRequestBase;
	WebRequest: IEwsHttpWebRequest;
	WebAsyncResult: any /*System.IAsyncResult*/;
	AsyncState: any;
	AsyncWaitHandle: any /*System.Threading.WaitHandle*/;
	CompletedSynchronously: boolean;
	IsCompleted: boolean;
	ExtractServiceRequest<T>(exchangeService: ExchangeService, asyncResult: any /*System.IAsyncResult*/): T{ throw new Error("AsyncRequestResult.ts - ExtractServiceRequest<T> : Not implemented.");}
}

/**
 * @internal Represents an abstract service request.
 */
export abstract class ServiceRequestBase {

    //#region private static and const
    //ref:this may be from newer code overall i am using, update when updating from ews base code library //todo:

    /**
     * The two contants below are used to set the AnchorMailbox and ExplicitLogonUser values in the request header.
     * 
     * /remarks/    Note: Setting this values will route the request directly to the backend hosting the AnchorMailbox. These headers should be used primarily for UnifiedGroup scenario where a request needs to be routed directly to the group mailbox versus the user mailbox.
     */
    protected static AnchorMailboxHeaderName: string = "X-AnchorMailbox";
    protected static ExplicitLogonUserHeaderName: string = "X-OWA-ExplicitLogonUser";

    protected static RequestIdResponseHeaders: string[] = ["RequestId", "request-id"];
    protected static XMLSchemaNamespace: string = "http://www.w3.org/2001/XMLSchema";
    protected static XMLSchemaInstanceNamespace: string = "http://www.w3.org/2001/XMLSchema-instance";
    protected static ClientStatisticsRequestHeader: string = "X-ClientStatistics";

    /**
     * Maintains the collection of client side statistics for requests already completed
     */
    protected static clientStatisticsCache: string[] = [];

    private service: ExchangeService;

    /**
     * @internal Gets the service.
     * 
     * @value   The service.
     */
    get Service(): ExchangeService {
        return this.service;
    }
    //#endregion

    /**
     * @internal Gets or sets the anchor mailbox associated with the request
     *
     * /remarks/    Setting this value will add special headers to the request which in turn will route the request directly to the mailbox server against which the request is to be executed.
     */
    AnchorMailbox: string = null;

    /** ews-javascript-api specific */
    private SoapFaultDetails: SoapFaultDetails;


    /**
     *  @internal Initializes a new instance of the **ServiceRequestBase** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        if (service == null) {
            throw new ArgumentNullException("service");
        }
        this.service = service;
        this.ThrowIfNotSupportedByRequestedServerVersion();
    }

    // #region abstract Methods for subclasses to override

    /**
     *  @internal Gets a value indicating whether the TimeZoneContext SOAP header should be eimitted.
     * 
     * @value   true if the time zone should be emitted; otherwise, false.
     */
    get EmitTimeZoneHeader(): boolean {
        return false;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string { throw new Error("abstract method, must override"); }

    /**
     * @internal Gets the minimum server version required to process this request.
     *
     * @return  {ExchangeVersion}      Exchange server version.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { throw new Error("abstract method, must override"); }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string { throw new Error("abstract method, must override"); }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        var serviceResponse: ServiceResponse = new ServiceResponse();
        serviceResponse.LoadFromXmlJsObject(jsonBody, this.Service);
        return serviceResponse;
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { throw new Error("abstract method, must override"); }

    //#endregion

    /**
     * @internal Allows the subclasses to add their own header information
     *
     * @param   {any}   webHeaderCollection   The HTTP request headers
     */
    AddHeaders(webHeaderCollection: any /*WebHeaderCollection*/): void {
        if (!StringHelper.IsNullOrEmpty(this.AnchorMailbox)) {
            webHeaderCollection.Set(ServiceRequestBase.AnchorMailboxHeaderName, this.AnchorMailbox);
            webHeaderCollection.Set(ServiceRequestBase.ExplicitLogonUserHeaderName, this.AnchorMailbox);
        }
    }

    //BuildEwsHttpWebRequest(): IEwsHttpWebRequest { throw new Error("Could not implemented."); }
    BuildXHR(): IXHROptions {

        var request = this.Service.PrepareHttpWebRequest(this.GetXmlElementName());
        //try
        //{
        //    IEwsHttpWebRequest request = this.Service.PrepareHttpWebRequest(this.GetXmlElementName());

        //    this.Service.TraceHttpRequestHeaders(TraceFlags.EwsRequestHttpHeaders, request);

        //    bool needSignature = this.Service.Credentials != null && this.Service.Credentials.NeedSignature;
        //    bool needTrace = this.Service.IsTraceEnabledFor(TraceFlags.EwsRequest);

        //    // If tracing is enabled, we generate the request in-memory so that we
        //    // can pass it along to the ITraceListener. Then we copy the stream to
        //    // the request stream.
        //    if (needSignature || needTrace) {
        //        this.TraceAndEmitRequest(request, needSignature, needTrace);
        //    }
        //    else {
        this.EmitRequest(request);
        //    }

        return request;
        //}
        //catch (WebException ex)
        //{
        //    if (ex.Status == WebExceptionStatus.ProtocolError && ex.Response != null) {
        //        this.ProcessWebException(ex);
        //    }

        //    // Wrap exception if the above code block didn't throw
        //    throw new ServiceRequestException(string.Format(Strings.ServiceRequestFailed, ex.Message), ex);
        //}
        //catch (IOException e)
        //{
        //    // Wrap exception.
        //    throw new ServiceRequestException(string.Format(Strings.ServiceRequestFailed, e.Message), e);
        //}
    }
    BuildResponseObjectFromJson(jsObject: any): any {
        if (jsObject[XmlElementNames.SOAPHeaderElementName]) {
            this.ReadSoapHeader(jsObject[XmlElementNames.SOAPHeaderElementName]);
        }

        return this.ParseResponse(jsObject[XmlElementNames.SOAPBodyElementName]);
    }
    //CreateJsonHeaders(): JsonObject { throw new Error("Could not implemented."); }
    //CreateJsonRequest(): JsonObject { throw new Error("Could not implemented."); }

    /**
     * Emits the request.
     *
     * @param   {IXHROptions}   request   The request.
     */
    private EmitRequest(request: IXHROptions): void {
        if (this.Service.RenderingMethod === RenderingMode.Xml) {

            var writer: EwsServiceXmlWriter = new EwsServiceXmlWriter(this.service);//writer.Service
            this.WriteToXml(writer);
            request.data = writer.GetXML();

        }
        else if (this.Service.RenderingMethod === RenderingMode.JSON) {
            //JsonObject requestObject = this.CreateJsonRequest();

            //using(Stream serviceRequestStream = this.GetWebRequestStream(request))
            //{
            //    requestObject.SerializeToJson(serviceRequestStream);
            //}
            //debugger;
        }
    }
    //EndGetEwsHttpWebResponse(request: IEwsHttpWebRequest, asyncResult: any /*System.IAsyncResult*/): IEwsHttpWebResponse { throw new Error("Could not implemented."); }
    GetEwsHttpWebResponse(request: IXHROptions /*IEwsHttpWebRequest*/): Promise<XMLHttpRequest> { return this.service.XHRApi.xhr(request); }

    /**
     * Gets string representation of requested server version.
     *
     * /remarks/    In order to support E12 RTM servers, ExchangeService has another flag indicating that we should use "Exchange2007" as the server version string rather than Exchange2007_SP1.
     * @return  {string}      String representation of requested server version.
     */
    private GetRequestedServiceVersionString(): string {
        if (this.Service.Exchange2007CompatibilityMode && this.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
            return "Exchange2007";
        }
        else {
            return ExchangeVersion[this.Service.RequestedServerVersion];
        }
    }
    //GetResponseStream(response: IEwsHttpWebResponse): any /*System.IO.Stream*/ { throw new Error("Could not implemented."); }
    //GetResponseStream(response: IEwsHttpWebResponse, readTimeout: number):any /*System.IO.Stream*/{ throw new Error("ServiceRequestBase.ts - GetResponseStream : Not implemented.");}
    //GetWebRequestStream(request: IEwsHttpWebRequest): any /*System.IO.Stream*/ { throw new Error("Could not implemented."); }

    /**
     * Processes the web exception.
     *
     * @param   {XMLHttpRequest}   webException   The web response XHR object.
     * @return  {SoapFaultDetails}      Soap fault details if any.
     */
    protected ProcessWebException(webException: XMLHttpRequest): SoapFaultDetails {
        if (webException) {
            //IEwsHttpWebResponse httpWebResponse = this.Service.HttpWebRequestFactory.CreateExceptionResponse(webException);
            var soapFaultDetails: SoapFaultDetails = null;

            if (webException.status == 500  /*System.Net.HttpStatusCode.InternalServerError*/) {
                //this.Service.ProcessHttpResponseHeaders(TraceFlags.EwsResponseHttpHeaders, httpWebResponse);

                // If tracing is enabled, we read the entire response into a MemoryStream so that we
                // can pass it along to the ITraceListener. Then we parse the response from the
                // MemoryStream.
                //if (this.Service.IsTraceEnabledFor(TraceFlags.EwsResponse)) {
                //    using(MemoryStream memoryStream = new MemoryStream())
                //    {
                //        using(Stream serviceResponseStream = ServiceRequestBase.GetResponseStream(httpWebResponse))
                //        {
                //            // Copy response to in-memory stream and reset position to start.
                //            EwsUtilities.CopyStream(serviceResponseStream, memoryStream);
                //            memoryStream.Position = 0;
                //        }

                //        if (this.Service.RenderingMethod == ExchangeService.RenderingMode.Xml) {
                //            this.TraceResponseXml(httpWebResponse, memoryStream);

                //            EwsServiceXmlReader reader = new EwsServiceXmlReader(memoryStream, this.Service);
                //            soapFaultDetails = this.ReadSoapFault(reader);
                //        }
                //        else if (this.Service.RenderingMethod == ExchangeService.RenderingMode.JSON) {
                //            this.TraceResponseJson(httpWebResponse, memoryStream);

                //            try {
                //                JsonObject jsonSoapFault = new JsonParser(memoryStream).Parse();
                //                soapFaultDetails = this.ReadSoapFault(jsonSoapFault);
                //            }
                //            catch (ServiceJsonDeserializationException) {
                //                // If no valid JSON response was returned, just return null SoapFault details
                //            }
                //        }
                //        else {
                //            throw new InvalidOperationException();
                //        }
                //    }
                //}
                //else {
                //    using(Stream stream = ServiceRequestBase.GetResponseStream(httpWebResponse))
                //    {
                //        if (this.Service.RenderingMethod == ExchangeService.RenderingMode.Xml) {
                //            EwsServiceXmlReader reader = new EwsServiceXmlReader(stream, this.Service);
                //            soapFaultDetails = this.ReadSoapFault(reader);
                //        }
                //        else if (this.Service.RenderingMethod == ExchangeService.RenderingMode.JSON) {
                //            try {
                //                JsonObject jsonSoapFault = new JsonParser(stream).Parse();
                //                soapFaultDetails = this.ReadSoapFault(jsonSoapFault);
                //            }
                //            catch (ServiceJsonDeserializationException) {
                //                // If no valid JSON response was returned, just return null SoapFault details
                //            }
                //        }
                //        else {
                //            throw new InvalidOperationException();
                //        }
                //    }
                //}
                //todo: fix tracing and other operations here
                var reader = new EwsServiceXmlReader(webException.responseText, this.Service);
                soapFaultDetails = this.ReadSoapFault(reader.JsObject);

                if (soapFaultDetails != null) {
                    //todo: implement soap fault error throw
                    this.SoapFaultDetails = soapFaultDetails;
                    soapFaultDetails.HttpStatusCode = webException.status;

                    //    switch (soapFaultDetails.ResponseCode) {
                    //        case ServiceError.ErrorInvalidServerVersion:
                    //            throw new Exceptions.ServiceVersionException(Strings.ServerVersionNotSupported);

                    //        case ServiceError.ErrorSchemaValidation:
                    //            // If we're talking to an E12 server (8.00.xxxx.xxx), a schema validation error is the same as a version mismatch error.
                    //            // (Which only will happen if we send a request that's not valid for E12).
                    //            if ((this.Service.ServerInfo != null) &&
                    //                (this.Service.ServerInfo.MajorVersion == 8) && (this.Service.ServerInfo.MinorVersion == 0)) {
                    //                throw new Exceptions.ServiceVersionException(Strings.ServerVersionNotSupported);
                    //            }

                    //            break;

                    //        case ServiceError.ErrorIncorrectSchemaVersion:
                    //            // This shouldn't happen. It indicates that a request wasn't valid for the version that was specified.
                    //            EwsUtilities.Assert(
                    //                false,
                    //                "ServiceRequestBase.ProcessWebException",
                    //                "Exchange server supports requested version but request was invalid for that version");
                    //            break;

                    //        case ServiceError.ErrorServerBusy:
                    //            throw new ServerBusyException(new ServiceResponse(soapFaultDetails));

                    //        default:
                    //            // Other error codes will be reported as remote error
                    //            break;
                    //    }

                    //    // General fall-through case: throw a ServiceResponseException
                    //    throw new ServiceResponseException(new ServiceResponse(soapFaultDetails));
                }
            }
            else {
                soapFaultDetails = new SoapFaultDetails(webException && (<any>webException).message ? (<any>webException).message : '');
                soapFaultDetails.HttpStatusCode = webException.status;
                if ((<any>webException).stack)
                    soapFaultDetails.stack = (<any>webException).stack;

                this.Service.ProcessHttpErrorResponse(webException, soapFaultDetails);
            }

            return soapFaultDetails;
        }
        return null;
    }

    /**
     * Reads the response from converted XML JS Object Soap enevlop is is omited, object has Body and Header as direct member.
     *
     * @param   {any}   jsObject    The converted XMl JS Object.
     * @return  {any}               Service response.
     */
    protected ReadResponseXmlJsObject(jsObject: any): any {
        if (jsObject[XmlElementNames.SOAPHeaderElementName]) {
            this.ReadSoapHeader(jsObject[XmlElementNames.SOAPHeaderElementName]);
        }

        if (!jsObject[XmlElementNames.SOAPBodyElementName]) {
            throw new Error("invalid soap message");
        }
        var serviceResponse: any;
        let jsBody = jsObject[XmlElementNames.SOAPBodyElementName]
        let jsResponse = jsBody[this.GetResponseXmlElementName()];
        serviceResponse = this.ParseResponse(jsResponse);
        return serviceResponse;
    }

    /**
     * Reads the SOAP fault.
     *
     * @param   {any}   jsonSoapFault   The SOAP fault.
     * @return  {SoapFaultDetails}      Parsed SoapFaultDetails
     */
    private ReadSoapFault(jsSoapFault: any): SoapFaultDetails {
        let soapFaultDetails: SoapFaultDetails = null;

        if (jsSoapFault[XmlElementNames.SOAPHeaderElementName]) {
            this.ReadSoapHeader(jsSoapFault[XmlElementNames.SOAPHeaderElementName]);
        }

        if (jsSoapFault[XmlElementNames.SOAPBodyElementName]) {
            let jsSoapBody = jsSoapFault[XmlElementNames.SOAPBodyElementName];
            if (jsSoapBody[XmlElementNames.SOAPFaultElementName]) {
                soapFaultDetails = SoapFaultDetails.Parse(jsSoapBody[XmlElementNames.SOAPFaultElementName]);
            }
        }

        return soapFaultDetails;
    }

    /**
     * Read SOAP header and extract server version
     *
     * @param   {any}   jsObject   Header value in JsObject
     */
    private ReadSoapHeader(jsObject: any): void {
        if (jsObject[XmlElementNames.ServerVersionInfo]) {
            this.Service.ServerInfo = ExchangeServerInfo.Parse(jsObject[XmlElementNames.ServerVersionInfo]);
        }
    }

    /**
     * @internal Throw exception if request is not supported in requested server version.
     * 
     * @exception   {ServiceVersionException}   Raised if request requires a later version of Exchange.
     */
    ThrowIfNotSupportedByRequestedServerVersion(): void {

        if (this.Service.RequestedServerVersion < this.GetMinimumRequiredServerVersion()) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.RequestIncompatibleWithRequestVersion,
                    this.GetXmlElementName(),
                    ExchangeVersion[this.GetMinimumRequiredServerVersion()]), null);
        }
    }

    //TraceAndEmitRequest(request: IEwsHttpWebRequest, needSignature: boolean, needTrace: boolean): any { throw new Error("Could not implemented."); }
    //TraceJsonRequest(requestObject: JsonObject): any { throw new Error("Could not implemented."); }
    //TraceResponseJson(response: IEwsHttpWebResponse, memoryStream: any): any { throw new Error("Could not implemented."); }
    //TraceResponseXml(response: IEwsHttpWebResponse, memoryStream: any): any { throw new Error("Could not implemented."); }
    //TraceXmlRequest(memoryStream: any): any { throw new Error("Could not implemented."); }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        this.Service.Validate();
    }

    /**
     * Validates request parameters, and emits the request to the server.
     *
     * @param   {IXHROptions}               request   The request.
     * @return  {Promise<XMLHttpRequest>}  The response returned by the server.
     */
    protected ValidateAndEmitRequest(request: IXHROptions): Promise<XMLHttpRequest> {
        this.Validate();

        //var request = this.BuildXHR();

        if (this.service.SendClientLatencies) {
            var clientStatisticsToAdd: string = '';

            //lock(clientStatisticsCache)
            //{
            if (ServiceRequestBase.clientStatisticsCache.length > 0) {
                clientStatisticsToAdd = ServiceRequestBase.clientStatisticsCache[0];
                ServiceRequestBase.clientStatisticsCache.splice(0, 1);
            }
            //}

            if (!StringHelper.IsNullOrEmpty(clientStatisticsToAdd)) {
                if (request.headers[ServiceRequestBase.ClientStatisticsRequestHeader]) {
                    request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] =
                        request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] + clientStatisticsToAdd;
                }
                else {
                    request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] = clientStatisticsToAdd;
                }
            }
        }

        //var startTime = Date.now();// DateTime.UtcNow;
        //var response = XHR(request);
        EwsLogging.DebugLog("sending ews request");
        EwsLogging.DebugLog(request, true);

        return this.service.XHRApi.xhr(request);

        //try
        //{
        //    var response = this.GetEwsHttpWebResponse(request);
        //}
        //finally {
        //    if (this.service.SendClientLatencies) {
        //        int clientSideLatency = (int)(DateTime.UtcNow - startTime).TotalMilliseconds;
        //        string requestId = string.Empty;
        //        string soapAction = this.GetType().Name.Replace("Request", string.Empty);

        //        if (response != null && response.Headers != null) {
        //            foreach(string requestIdHeader in ServiceRequestBase.RequestIdResponseHeaders)
        //            {
        //                string requestIdValue = response.Headers.Get(requestIdHeader);
        //                if (!string.IsNullOrEmpty(requestIdValue)) {
        //                    requestId = requestIdValue;
        //                    break;
        //                }
        //            }
        //        }

        //        StringBuilder sb = new StringBuilder();
        //        sb.Append("MessageId=");
        //        sb.Append(requestId);
        //        sb.Append(",ResponseTime=");
        //        sb.Append(clientSideLatency);
        //        sb.Append(",SoapAction=");
        //        sb.Append(soapAction);
        //        sb.Append(";");

        //        lock(clientStatisticsCache)
        //        {
        //            clientStatisticsCache.Add(sb.ToString());
        //        }
        //    }
        //}

        //return response;
    }

    //WrapStream(responseStream: any /*System.IO.Stream*/, contentEncoding: string): any /*System.IO.Stream*/ { throw new Error("Could not implemented."); }

    /**
     * @internal Writes XML attributes.
     *
     * /remarks/    Subclass will override if it has XML attributes.
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void { }

    /**
     * @internal Writes XML body.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteBodyToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, this.GetXmlElementName());
        this.WriteAttributesToXml(writer);
        this.WriteElementsToXml(writer);
        writer.WriteEndElement(); // m:this.GetXmlElementName()
    }

    //#region HttpWebRequest-based implementation

    /**
     * @internal Writes XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPEnvelopeElementName);
        writer.WriteAttributeValue("xmlns", EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix, EwsUtilities.EwsXmlSchemaInstanceNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities.EwsMessagesNamespacePrefix, EwsUtilities.EwsMessagesNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities.EwsTypesNamespacePrefix, EwsUtilities.EwsTypesNamespace);
        if (writer.RequireWSSecurityUtilityNamespace) {
            writer.WriteAttributeValue("xmlns", EwsUtilities.WSSecurityUtilityNamespacePrefix, EwsUtilities.WSSecurityUtilityNamespace);
        }

        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPHeaderElementName);

        if (this.Service.Credentials != null) {
            //todo: fix extra soap headers if required
            this.Service.Credentials.EmitExtraSoapHeaderNamespaceAliases(null);
        }

        // Emit the RequestServerVersion header
        if (!this.Service.SuppressXmlVersionHeader) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.RequestServerVersion);
            writer.WriteAttributeValue(XmlAttributeNames.Version, this.GetRequestedServiceVersionString());
            writer.WriteEndElement(); // RequestServerVersion
        }

        // Against Exchange 2007 SP1, we always emit the simplified time zone header. It adds very little to
        // the request, so bandwidth consumption is not an issue. Against Exchange 2010 and above, we emit
        // the full time zone header but only when the request actually needs it.
        //
        // The exception to this is if we are in Exchange2007 Compat Mode, in which case we should never emit
        // the header.  (Note: Exchange2007 Compat Mode is enabled for testability purposes only.)
        //
        if ((this.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1 || this.EmitTimeZoneHeader) &&
            (!this.Service.Exchange2007CompatibilityMode)) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.TimeZoneContext);

            this.Service.TimeZoneDefinition.WriteToXml(writer);

            writer.WriteEndElement(); // TimeZoneContext

            writer.IsTimeZoneHeaderEmitted = true;
        }

        // Emit the MailboxCulture header
        if (this.Service.PreferredCulture != null) {
            //todo: fix preferred culture.
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.MailboxCulture,
                this.Service.PreferredCulture.Name);
        }

        // Emit the DateTimePrecision header
        if (this.Service.DateTimePrecision != DateTimePrecision.Default) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.DateTimePrecision,
                DateTimePrecision[this.Service.DateTimePrecision]);
            //this.Service.DateTimePrecision.ToString());
        }

        // Emit the ExchangeImpersonation header
        if (this.Service.ImpersonatedUserId != null) {
            this.Service.ImpersonatedUserId.WriteToXml(writer);
        }
        else if (this.Service.PrivilegedUserId != null) {
            //todo: find scenario if this is used anywhere, did not find any reference in MSDN
            this.Service.PrivilegedUserId.WriteToXml(writer, this.Service.RequestedServerVersion);
        }
        else if (this.Service.ManagementRoles != null) {
            this.Service.ManagementRoles.WriteToXml(writer);
        }

        if (this.Service.Credentials != null) {
            this.Service.Credentials.SerializeExtraSoapHeaders(writer, this.GetXmlElementName());
        }

        this.Service.DoOnSerializeCustomSoapHeaders(writer);

        writer.WriteEndElement(); // soap:Header

        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPBodyElementName);

        this.WriteBodyToXml(writer);

        writer.WriteEndElement(); // soap:Body
        writer.WriteEndElement(); // soap:Envelope
    }

    //#endregion
}

/**
 * @internal Represents a collection of arguments for the HangingServiceRequestBase.HangingRequestDisconnectHandler delegate method.
 */
export class HangingRequestDisconnectEventArgs {  //extends  EventArgs{

	/**
	 * Gets the reason that the user was disconnected.
	 * 
	 * internal set
	 */
	Reason: HangingRequestDisconnectReason;

	/**
	 * Gets the exception that caused the disconnection. Can be null.
	 * 
	 * internal set
	 */
	Exception: Exception;

	/**
	 * Initializes a new instance of the **HangingRequestDisconnectEventArgs** class.
	 *
	 * @param   {HangingRequestDisconnectReason}   	reason      The reason.
	 * @param   {Exception}   						exception   The exception.
	 */
	constructor(
		reason: HangingRequestDisconnectReason,
		exception: Exception) {
		this.Reason = reason;
		this.Exception = exception;
	}
}

/**
 * @internal Represents an abstract, hanging service request.
 */
export class HangingServiceRequestBase extends ServiceRequestBase {
    private static BufferSize: number = 4096;
    static LogAllWireBytes: boolean;
    private responseHandler: HandleResponseObject = null;
    private response: IXHROptions = null;
    private request: IXHROptions = null;
    heartbeatFrequencyMilliseconds: number = 0;
    private lockObject: any;
	/**
	 * @internal Occurs when the hanging request is disconnected. events converted into array of delagte function
	 */
    OnDisconnect: HangingRequestDisconnectHandler[] = [];
    IsConnected: boolean = false;

    /**
     * ews-javascript-api: Response Headers delegate    
     */
    OnResponseHeader: Function;

    // /**
    //  * ews-javascript-api:  FetchStream object
    //  */
    // private stream: FetchStream;

	/**
	 * @internal Initializes a new instance of the **HangingServiceRequestBase** class.
	 *
	 * @param   {ExchangeService}   	service                	The service.
	 * @param   {HandleResponseObject} 	handler   				Callback delegate to handle response objects.
	 * @param   {number}   				heartbeatFrequency      Frequency at which we expect heartbeats, in milliseconds.
	 */
    constructor(service: ExchangeService, handler: HandleResponseObject, heartbeatFrequency: number) {
        super(service);
        this.responseHandler = handler;
        this.heartbeatFrequencyMilliseconds = heartbeatFrequency;
    }

    /**
     * Disconnects the request.
     */
    Disconnect(): void
    /**
     * Disconnects the request with the specified reason and exception.
     *
     * @param   {HangingRequestDisconnectReason}    reason      The reason.
     * @param   {Exception}                         exception   The exception.
     */
    Disconnect(reason: HangingRequestDisconnectReason, exception: Exception): void;
    Disconnect(reason: HangingRequestDisconnectReason = HangingRequestDisconnectReason.UserInitiated, exception: Exception = null): void {
        if (this.IsConnected) {
            this.Service.XHRApi.disconnect();
            this.InternalOnDisconnect(reason, exception);
        }
    }

    /**
     * Stores chunked data from fetch FetchStream
     */
    private chunk: string = '';

    /**
	 * @internal Exectures the request.
	 */
    InternalExecute(): Promise<void> {
        //lock (this.lockObject){
        //this.response = this.ValidateAndEmitRequest(this.BuildXHR());

        return new Promise<void>((successDelegate, errorDelegate) => {
            var request = this.BuildXHR();
            //this.ReadResponsePrivate(response);
            this.ValidateAndEmitRequest(request, (progress: IXHRProgress) => {

                switch (progress.type) {
                    case "data":
                        this.InternalOnConnect();

                        progress.data = progress.data.trim();
                        this.chunk += progress.data;
                        let _continue = false;
                        let xml = '';
                        if (!StringHelper.IsNullOrEmpty(this.chunk)) {
                            //"<Envelope>indexOf</Envelope>"
                            let start = this.chunk.indexOf("<Envelope");
                            let end = this.chunk.indexOf("</Envelope>")
                            if (start >= 0 && end > 0) {
                                xml = this.chunk.substr(start, end - start + 11)
                                this.chunk = this.chunk.substr(end + 11);
                                _continue = true;
                            }
                        }
                        if (_continue) {
                            var dom = new DOMParser();
                            var xml2js = new xml2JsObject();
                            let req;
                            try {
                                //req = xml2js.parseXMLNode(dom.parseFromString(xml, "text/xml").documentElement, true);
                                //EwsLogging.DebugLog(req, true);
                                EwsLogging.DebugLog(xml, true);
                                var ewsXmlReader: EwsServiceXmlReader = new EwsServiceXmlReader(xml, this.Service);
                                EwsLogging.DebugLog(ewsXmlReader.JsObject, true);
                                //var serviceResponse = 
                                this.ParseResponses(ewsXmlReader.JsObject);

                                // if (successDelegate)
                                //     successDelegate(serviceResponse || xml);
                                // else {
                                //     if (errorDelegate)
                                //         errorDelegate(xml);
                                // }
                            } catch (error) {
                                if (errorDelegate)
                                    errorDelegate(error);
                            }

                        }
                        break;
                    case "header":
                        this.InternalOnConnect();
                        if (this.OnResponseHeader && typeof this.OnResponseHeader === 'function') {
                            this.OnResponseHeader(progress.headers);
                        }
                        //console.log(meta);
                        break;
                    case "end":
                        this.InternalOnDisconnect(HangingRequestDisconnectReason.Clean, null);
                        break;
                    case "error":
                        this.Disconnect(HangingRequestDisconnectReason.Exception, <any>progress.error);
                        if (errorDelegate) {
                            errorDelegate(progress.error);
                        }
                        break;
                    default:
                        break;
                }
            }).then((xhrResponse: any) => { //<any> used for progress delegate, not in standard promise
                //console.log(xhrResponse);
                //successDelegate(void 0);
            }, (resperr: XMLHttpRequest) => {
                if (resperr.status && resperr.getAllResponseHeaders) {
                    EwsLogging.Log("Error in calling service, error code: " + resperr.status + "\r\n " + resperr.getAllResponseHeaders());
                }
                else {
                    EwsLogging.Log("Error in calling service, error code: " + (resperr.status || (<any>resperr).message));
                }
                if (errorDelegate) errorDelegate(this.ProcessWebException(resperr) || resperr);
            });
        });
    }

    /**
     * Perform any bookkeeping needed when we connect 
     */
    private InternalOnConnect(): void {
        if (!this.IsConnected) {
            this.IsConnected = true;

            // Trace Http headers
            // this.Service.ProcessHttpResponseHeaders(
            //     TraceFlags.EwsResponseHttpHeaders,
            //     this.response);

            //info: //ref: - not needed, no threadpool, handled in 
            // ThreadPool.QueueUserWorkItem(
            //     new WaitCallback(this.ParseResponses));
        }
    }

    /**
     * Perform any bookkeeping needed when we disconnect (cleanly or forcefully)
     *
     * @param   {HangingRequestDisconnectReason}    reason      [description]
     * @param   {Exception}                         exception   [description]
     */
    InternalOnDisconnect(reason: HangingRequestDisconnectReason, exception: Exception): void {
        if (this.IsConnected) {
            this.IsConnected = false;

            if (this.OnDisconnect && ArrayHelper.isArray(this.OnDisconnect)) {
                try {
                    this.OnDisconnect.forEach((OnDisconnect) => {
                        OnDisconnect(this,
                            new HangingRequestDisconnectEventArgs(reason, exception));
                    });
                }
                catch (e) { }
            }
        }
    }

    //* @return  {any}   parsed response object.
    /**
     * Parses the responses.
     *
     * @param   {any}   state   Notification state.
     */
    private ParseResponses(state: any): void {
        try {
            let responseObject = this.ReadResponseXmlJsObject(state);
            this.responseHandler(responseObject);
        } catch (error) {
            this.Disconnect(HangingRequestDisconnectReason.Exception, error);
            console.log("error parsing object....\n TODO: Implement better parse error for Notifications");
            //console.log(state);
        }

        // try
        //     {
        //         Guid traceId = Guid.Empty;
        //         HangingTraceStream tracingStream = null;
        //         MemoryStream responseCopy = null;

        //         try
        //         {
        //             bool traceEwsResponse = this.Service.IsTraceEnabledFor(TraceFlags.EwsResponse);

        //             using (Stream responseStream = this.response.GetResponseStream())
        //             {
        //                 responseStream.ReadTimeout = 2 * this.heartbeatFrequencyMilliseconds;
        //                 tracingStream = new HangingTraceStream(responseStream, this.Service);

        //                 // EwsServiceMultiResponseXmlReader.Create causes a read.
        //                 if (traceEwsResponse)
        //                 {
        //                     responseCopy = new MemoryStream();
        //                     tracingStream.SetResponseCopy(responseCopy);
        //                 }

        //                 EwsServiceMultiResponseXmlReader ewsXmlReader = EwsServiceMultiResponseXmlReader.Create(tracingStream, this.Service);

        //                 while (this.IsConnected)
        //                 {
        //                     object responseObject = null;
        //                     if (traceEwsResponse)
        //                     {
        //                         try
        //                         {
        //                             responseObject = this.ReadResponse(ewsXmlReader, this.response.Headers);
        //                         }
        //                         finally
        //                         {
        //                             this.Service.TraceXml(TraceFlags.EwsResponse, responseCopy);
        //                         }

        //                         // reset the stream collector.
        //                         responseCopy.Close();
        //                         responseCopy = new MemoryStream();
        //                         tracingStream.SetResponseCopy(responseCopy);
        //                     }
        //                     else
        //                     {
        //                         responseObject = this.ReadResponse(ewsXmlReader, this.response.Headers);
        //                     }

        //                     this.responseHandler(responseObject);
        //                 }
        //             }
        //         }
        //         catch (TimeoutException ex)
        //         {
        //             // The connection timed out.
        //             this.Disconnect(HangingRequestDisconnectReason.Timeout, ex);
        //             return;
        //         }
        //         catch (IOException ex)
        //         {
        //             // Stream is closed, so disconnect.
        //             this.Disconnect(HangingRequestDisconnectReason.Exception, ex);
        //             return;
        //         }
        //         catch (HttpException ex)
        //         {
        //             // Stream is closed, so disconnect.
        //             this.Disconnect(HangingRequestDisconnectReason.Exception, ex);
        //             return;
        //         }
        //         catch (WebException ex)
        //         {
        //             // Stream is closed, so disconnect.
        //             this.Disconnect(HangingRequestDisconnectReason.Exception, ex);
        //             return;
        //         }
        //         catch (ObjectDisposedException ex)
        //         {
        //             // Stream is closed, so disconnect.
        //             this.Disconnect(HangingRequestDisconnectReason.Exception, ex);
        //             return;
        //         }
        //         catch (NotSupportedException)
        //         {
        //             // This is thrown if we close the stream during a read operation due to a user method call.
        //             // Trying to delay closing until the read finishes simply results in a long-running connection.
        //             this.Disconnect(HangingRequestDisconnectReason.UserInitiated, null);
        //             return;
        //         }
        //         catch (XmlException ex)
        //         {
        //             // Thrown if server returned no XML document.
        //             this.Disconnect(HangingRequestDisconnectReason.UserInitiated, ex);
        //             return;
        //         }
        //         finally
        //         {
        //             if (responseCopy != null)
        //             {
        //                 responseCopy.Dispose();
        //                 responseCopy = null;
        //             }
        //         }
        //     }
        //     catch (ServiceLocalException exception)
        //     {
        //         this.Disconnect(HangingRequestDisconnectReason.Exception, exception);
        //     }
    }

    //ReadPreamble(ewsXmlReader: EwsServiceXmlReader): void { throw new Error("HangingServiceRequestBase.ts - ReadPreamble : Not implemented."); }


    /* ews-javascript-api specific */
	/**
     * Validates request parameters, and emits the request to the server.
     *
     * @param   {IXHROptions}               request   The request.
     * @return  {Promise<XMLHttpRequest>}   The response returned by the server.
     */
    protected ValidateAndEmitRequest(request: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<any> {
        this.Validate();

        //var request = this.BuildXHR();

        if (this.Service.SendClientLatencies) {
            var clientStatisticsToAdd: string = '';

            //lock(clientStatisticsCache)
            //{
            if (ServiceRequestBase.clientStatisticsCache.length > 0) {
                clientStatisticsToAdd = ServiceRequestBase.clientStatisticsCache[0];
                ServiceRequestBase.clientStatisticsCache.splice(0, 1);
            }
            //}

            if (!StringHelper.IsNullOrEmpty(clientStatisticsToAdd)) {
                if (request.headers[ServiceRequestBase.ClientStatisticsRequestHeader]) {
                    request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] =
                        request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] + clientStatisticsToAdd;
                }
                else {
                    request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] = clientStatisticsToAdd;
                }
            }
        }

        //var startTime = Date.now();// DateTime.UtcNow;
        //var response = XHR(request);
        EwsLogging.DebugLog("sending ews request");
        EwsLogging.DebugLog(request, true);

        return this.Service.XHRApi.xhrStream(request, progressDelegate);
        // return new Promise((successDelegate, errorDelegate) => {
        //     this.stream = new FetchStream(this.Service.Url.ToString(), request);

        //     this.stream.on("data", (chunk) => {
        //         //console.log(chunk.toString());
        //         progressDelegate(chunk.toString());
        //     });

        //     this.stream.on("meta", (meta) => {
        //         if (this.OnResponseHeader && typeof this.OnResponseHeader === 'function') {
        //             this.OnResponseHeader(meta["responseHeaders"])
        //         }
        //         //console.log(meta);
        //     });

        //     this.stream.on("end", (data) => {
        //         this.IsConnected = false;
        //     });

        //     this.stream.on('error', (error) => {
        //         this.Disconnect(HangingRequestDisconnectReason.Exception, <any>error);
        //         if (errorDelegate) {
        //             errorDelegate(error);
        //         }
        //     });
        // });

        //try
        //{
        //    var response = this.GetEwsHttpWebResponse(request);
        //}
        //finally {
        //    if (this.service.SendClientLatencies) {
        //        int clientSideLatency = (int)(DateTime.UtcNow - startTime).TotalMilliseconds;
        //        string requestId = string.Empty;
        //        string soapAction = this.GetType().Name.Replace("Request", string.Empty);

        //        if (response != null && response.Headers != null) {
        //            foreach(string requestIdHeader in ServiceRequestBase.RequestIdResponseHeaders)
        //            {
        //                string requestIdValue = response.Headers.Get(requestIdHeader);
        //                if (!string.IsNullOrEmpty(requestIdValue)) {
        //                    requestId = requestIdValue;
        //                    break;
        //                }
        //            }
        //        }

        //        StringBuilder sb = new StringBuilder();
        //        sb.Append("MessageId=");
        //        sb.Append(requestId);
        //        sb.Append(",ResponseTime=");
        //        sb.Append(clientSideLatency);
        //        sb.Append(",SoapAction=");
        //        sb.Append(soapAction);
        //        sb.Append(";");

        //        lock(clientStatisticsCache)
        //        {
        //            clientStatisticsCache.Add(sb.ToString());
        //        }
        //    }
        //}

        //return response;
    }
}

/**
 * @internal interface to declare Delegate method to handle a hanging request disconnection. 
 */
export interface HangingRequestDisconnectHandler {
    /**
     * Delegate method to handle a hanging request disconnection.
     *
     * @param   {any}                                   sender   The object invoking the delegate.
     * @param   {HangingRequestDisconnectEventArgs}     args     Event data.
     */
    (sender: any, args: HangingRequestDisconnectEventArgs): void;
}

/**
 * @internal interface to declare Callback delegate to handle asynchronous responses.
 */
export interface HandleResponseObject {
    /**
     * Callback delegate to handle asynchronous responses.
     *
     * @param   {any}   response   Response received from the server
     */
    (response: any): void;
}

/**
 * @internal Represents a GetStreamingEvents request.
 */
export class GetStreamingEventsRequest extends HangingServiceRequestBase {

	static HeartbeatFrequencyDefault: number = 45000;

	/**
	 * @internal Allow test code to change heartbeat value
	 * /remarks/	set only.
	 */
	static set HeartbeatFrequency(value: number) {
		this.heartbeatFrequency = value;
	}
	private subscriptionIds: string[];
	private connectionTimeout: number;
	private static heartbeatFrequency: number = GetStreamingEventsRequest.HeartbeatFrequencyDefault;

	/**
	 * @internal Initializes a new instance of the **GetStreamingEventsRequest** class.
	 *
	 * @param   {ExchangeService}   	service                The service.
	 * @param   {HandleResponseObject} 	serviceObjectHandler   Callback method to handle response objects received.
	 * @param   {string[]}   			subscriptionIds        List of subscription ids to listen to on this request.
	 * @param   {number}   				connectionTimeout      Connection timeout, in minutes.
	 */
	constructor(service: ExchangeService,
		serviceObjectHandler: HandleResponseObject,
		subscriptionIds: string[],
		connectionTimeout: number) {
		super(service, serviceObjectHandler, GetStreamingEventsRequest.heartbeatFrequency);
		this.subscriptionIds = subscriptionIds;
		this.connectionTimeout = connectionTimeout;
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
	GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2010_SP1; }

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
	GetResponseXmlElementName(): string { return XmlElementNames.GetStreamingEventsResponse; }

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
	GetXmlElementName(): string { return XmlElementNames.GetStreamingEvents; }

	/**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
	ParseResponse(jsBody: any): any {
		var jsResponseMessages: any = jsBody[XmlElementNames.ResponseMessages]

		let response = new GetStreamingEventsResponse(this);
		response.LoadFromXmlJsObject(jsResponseMessages[XmlElementNames.GetStreamingEventsResponseMessage], this.Service);

		return response;

	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SubscriptionIds);

		for (let id of this.subscriptionIds) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.SubscriptionId,
				id);
		}

		writer.WriteEndElement();

		writer.WriteElementValue(
			XmlNamespace.Messages,
			XmlElementNames.ConnectionTimeout,
			this.connectionTimeout);
	}
}

/** @internal */
export class SimpleServiceRequestBase extends ServiceRequestBase {
    //BeginExecute(callback: System.AsyncCallback, state: any): any/*System.IAsyncResult*/ { throw new Error("SimpleServiceRequestBase.ts - BeginExecute : Not implemented.");}
    //EndInternalExecute(asyncResult: any/*System.IAsyncResult*/): any { throw new Error("SimpleServiceRequestBase.ts - EndInternalExecute : Not implemented.");}
    InternalExecute(): Promise<any> {


        //var writer = new Data.EwsServiceXmlWriter();
        //this.WriteSoapRequest(this.url, writer);

        //if (!this.Service && !this.Service.Credentials && (!this.Service.Credentials.UserName || this.service.Credentials.Password))
        //    throw new Error("missing credential");

        //var cred = "Basic " + btoa(this.Service.Credentials.UserName + ":" + this.Service.Credentials.Password);
        //var cc = writer.GetXML();
        //var xhrOptions: IXHROptions = {
        //    type: "POST",
        //    data: cc,
        //    url: "https://pod51045.outlook.com/autodiscover/autodiscover.svc",
        //    headers: { "Content-Type": "text/xml", "Authorization": cred },
        //    //customRequestInitializer: function (x) {
        //    //    var m = x;
        //    //}
        //};

        return new Promise((successDelegate, errorDelegate) => {
            var request = this.BuildXHR();

            //this.ReadResponsePrivate(response);
            this.ValidateAndEmitRequest(request).then((xhrResponse: XMLHttpRequest) => {
                var dom = new DOMParser();
                var xml2js = new xml2JsObject();
                var req = xml2js.parseXMLNode(dom.parseFromString(request.data, "text/xml").documentElement, true);
                EwsLogging.DebugLog(req, true);
                if (xhrResponse.status == 200) {
                    EwsLogging.DebugLog(xhrResponse, true);
                    try {

                        var ewsXmlReader: EwsServiceXmlReader = new EwsServiceXmlReader(xhrResponse.responseText || xhrResponse.response, this.Service);
                        //EwsLogging.DebugLog(ewsXmlReader.JsObject, true);
                        var serviceResponse = this.ReadResponsePrivate(ewsXmlReader.JsObject);

                        if (successDelegate)
                            successDelegate(serviceResponse || xhrResponse.responseText || xhrResponse.response);
                    } catch (err) {
                        if (err instanceof Exception)
                            errorDelegate(err);
                        else
                            errorDelegate(new SoapFaultDetails(err.message));
                    }

                }
                else {
                    if (errorDelegate)
                        errorDelegate(this.ProcessWebException(xhrResponse) || xhrResponse);
                }
            }, (resperr: XMLHttpRequest) => {
                EwsLogging.Log("Error in calling service, error code:" + resperr.status + "\r\n" + ((resperr.getAllResponseHeaders) ? resperr.getAllResponseHeaders() : ""));
                if (errorDelegate) errorDelegate(this.ProcessWebException(resperr) || resperr);
            });
        });

    }
    private ReadResponsePrivate(response: any /*IEwsHttpWebResponse*/): any {
        var serviceResponse: any;

        try {
            this.Service.ProcessHttpResponseHeaders(TraceFlags.EwsResponseHttpHeaders, response);
            // If tracing is enabled, we read the entire response into a MemoryStream so that we
            // can pass it along to the ITraceListener. Then we parse the response from the
            // MemoryStream.
            if (this.Service.IsTraceEnabledFor(TraceFlags.EwsResponse)) { //todo: implement tracing
                //using(MemoryStream memoryStream = new MemoryStream())
                //{
                //    using(Stream serviceResponseStream = ServiceRequestBase.GetResponseStream(response))
                //    {
                //        // Copy response to in-memory stream and reset position to start.
                //        EwsUtilities.CopyStream(serviceResponseStream, memoryStream);
                //        memoryStream.Position = 0;
                //    }
                //    if (this.Service.RenderingMethod == ExchangeService.RenderingMode.Xml) {
                //        this.TraceResponseXml(response, memoryStream);
                //        serviceResponse = this.ReadResponseXml(memoryStream);
                //    }
                //    else if (this.Service.RenderingMethod == ExchangeService.RenderingMode.JSON) {
                //        this.TraceResponseJson(response, memoryStream);
                //        serviceResponse = this.ReadResponseJson(memoryStream);
                //    }
                //    else {
                //        throw new InvalidOperationException("Unknown RenderingMethod.");
                //    }
                //}
            }
            else {


                if (this.Service.RenderingMethod == RenderingMode.Xml) {
                    serviceResponse = this.ReadResponseXmlJsObject(response);
                }
                else if (this.Service.RenderingMethod == RenderingMode.JSON) {
                    serviceResponse = this.ReadResponseJson(response);
                }
                else {
                    throw new Error/*InvalidOperationException*/("Unknown RenderingMethod.");
                }

            }
        }
        catch (ex) {
            if (ex.Response != null) {
                //IEwsHttpWebResponse exceptionResponse = this.Service.HttpWebRequestFactory.CreateExceptionResponse(e);
                this.Service.ProcessHttpResponseHeaders(TraceFlags.EwsResponseHttpHeaders, response);
            }
            throw new ServiceRequestException(StringHelper.Format(Strings.ServiceRequestFailed, ex.message /* ex can be generic Error*/), ex);
        }


        return serviceResponse;
    }
    ReadResponseJson(jsObject: any/*System.IO.Stream*/): any {

        //var jsonResponse: JsonObject = new JsonParser(responseStream).Parse();
        return super.BuildResponseObjectFromJson(jsObject);
    }
    WebRequestAsyncCallback(webAsyncResult: any/*System.IAsyncResult*/): any { throw new Error("SimpleServiceRequestBase.ts - WebRequestAsyncCallback : Not implemented."); }
}


/**
 * @internal Represents a DisableApp request.
 * 
 * @sealed
 */
export class DisableAppRequest extends SimpleServiceRequestBase {

	/**
	 * Extension id
	 */
	private Id: string = null;

	/**
	 * Disable reason
	 */
	private DisableReason: DisableReasonType = DisableReasonType.NoReason;

	/**
	 * @internal Initializes a new instance of the **DisableAppRequest** class.
	 *
	 * @param   {ExchangeService}   	service         The service.
	 * @param   {string}   				id              Extension id.
	 * @param   {DisableReasonType}   	disableReason   Disable reason.
	 */
	constructor(service: ExchangeService, id: string, disableReason: DisableReasonType) {
		super(service);
		this.Id = id;
		this.DisableReason = disableReason;
	}

	/**
     * @internal Executes this request.
     *
     * @return  {Promise<DisableAppResponse>}      Service response  :Promise.
     */
    Execute(): Promise<DisableAppResponse> {

		return this.InternalExecute().then((serviceResponse: DisableAppResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2013;
	}

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
		return XmlElementNames.DisableAppResponse;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
		return XmlElementNames.DisableAppRequest;
	}

	/**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
		let response: DisableAppResponse = new DisableAppResponse();
		response.LoadFromXmlJsObject(jsonBody, this.Service);
		return response;
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ID, this.Id);
		writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.DisableReason, DisableReasonType[this.DisableReason]);
	}
}
/**
 * ## @internal *Not Implemented* 
 */
export class DisconnectPhoneCallRequest extends SimpleServiceRequestBase {
    Id: PhoneCallId;
    private id: PhoneCallId;
    Execute(): ServiceResponse { throw new Error("DisconnectPhoneCallRequest.ts - Execute : Not implemented."); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { throw new Error("DisconnectPhoneCallRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); }
    GetResponseXmlElementName(): string { throw new Error("DisconnectPhoneCallRequest.ts - GetResponseXmlElementName : Not implemented."); }
    GetXmlElementName(): string { throw new Error("DisconnectPhoneCallRequest.ts - GetXmlElementName : Not implemented."); }
    ParseResponse(reader: EwsServiceXmlReader): any { throw new Error("DisconnectPhoneCallRequest.ts - ParseResponse : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("DisconnectPhoneCallRequest.ts - WriteElementsToXml : Not implemented."); }
}

/**
 * @internal Represents a request to a Find Conversation operation
 * 
 * @sealed
 */
export class FindConversationRequest extends SimpleServiceRequestBase {//IJsonSerializable

    private view: ViewBase = null;
    private folderId: FolderIdWrapper = null;
    private queryString: string = null;
    private returnHighlightTerms: boolean = false;
    private mailboxScope: MailboxSearchLocation = null;

    /**
     * Gets or sets the view controlling the number of conversations returned.
     */
    get View(): ViewBase {
        return this.view;
    }
    set View(value: ViewBase) {
        this.view = value;
        if (this.view instanceof SeekToConditionItemView) {
            (<SeekToConditionItemView>this.view).SetServiceObjectType(ServiceObjectType.Conversation);
        }
    }

    /**
     * @internal Gets or sets folder id
     */
    get FolderId(): FolderIdWrapper {
        return this.folderId;
    }
    set FolderId(value: FolderIdWrapper) {
        this.folderId = value;
    }

    /**
     * @internal Gets or sets the query string for search value.
     */
    get QueryString(): string {
        return this.queryString;
    }
    set QueryString(value: string) {
        this.queryString = value;
    }

    /**
     * @internal Gets or sets the query string highlight terms.
     */
    get ReturnHighlightTerms(): boolean {
        return this.returnHighlightTerms;
    }
    set ReturnHighlightTerms(value: boolean) {
        this.returnHighlightTerms = value;
    }

    /**
     * @internal Gets or sets the mailbox search location to include in the search.
     */
    get MailboxScope(): MailboxSearchLocation {
        return this.mailboxScope;
    }
    set MailboxScope(value: MailboxSearchLocation) {
        this.mailboxScope = value;
    }

    /**
     * @internal Initializes a new instance of the **FindConversationRequest** class.
     *
     * @param   {service}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<FindConversationResponse>}      Service response  :Promise.
     */
    Execute(): Promise<FindConversationResponse> {
        return this.InternalExecute().then((serviceResponse: FindConversationResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010_SP1;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.FindConversationResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.FindConversation;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: FindConversationResponse = new FindConversationResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();
        this.view.InternalValidate(this);

        // query string parameter is only valid for Exchange2013 or higher
        //
        if (!StringHelper.IsNullOrEmpty(this.queryString) &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "queryString",
                    ExchangeVersion[ExchangeVersion.Exchange2013]));
        }

        // ReturnHighlightTerms parameter is only valid for Exchange2013 or higher
        //
        if (this.ReturnHighlightTerms &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "returnHighlightTerms",
                    ExchangeVersion[ExchangeVersion.Exchange2013]));
        }

        // SeekToConditionItemView is only valid for Exchange2013 or higher
        //
        if ((this.View instanceof SeekToConditionItemView) && //todo: better detection of types with "is"
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "SeekToConditionItemView",
                    ExchangeVersion[ExchangeVersion.Exchange2013]));
        }

        // MailboxScope is only valid for Exchange2013 or higher
        //
        if (this.MailboxScope &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "MailboxScope",
                    ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
    }

    /**
	 * @internal Writes XML attributes.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        this.View.WriteAttributesToXml(writer);
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        // Emit the view element
        //
        this.View.WriteToXml(writer, null);

        // Emit the Sort Order
        //
        this.View.WriteOrderByToXml(writer);

        // Emit the Parent Folder Id
        //
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ParentFolderId);
        this.FolderId.WriteToXml(writer);
        writer.WriteEndElement();

        // Emit the MailboxScope flag
        // 
        if (hasValue(this.MailboxScope)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MailboxScope, MailboxSearchLocation[this.MailboxScope]);
        }

        if (!StringHelper.IsNullOrEmpty(this.queryString)) {
            // Emit the QueryString
            //
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.QueryString);

            if (this.ReturnHighlightTerms) {
                writer.WriteAttributeString(XmlAttributeNames.ReturnHighlightTerms, this.ReturnHighlightTerms.toString().toLowerCase()); //todo: better tolower() .ToString().ToLowerInvariant());
            }

            writer.WriteValue(this.queryString, XmlElementNames.QueryString);
            writer.WriteEndElement();
        }

        if (this.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
            if (this.View.PropertySet != null) {
                this.View.PropertySet.WriteToXml(writer, ServiceObjectType.Conversation);
            }
        }
    }
}

/**
 *  @internal Represents a GetAppManifests request. 
 * 
 * @sealed
*/
export class GetAppManifestsRequest extends SimpleServiceRequestBase {

	/**
	 * @internal Gets or sets the api version supported by the client. 
	 * This tells Exchange service which app manifests should be returned based on the api version.
	 * 
	 * @value	The Api version supported.
	 */
	ApiVersionSupported: string = null;

	/**
	 * @internal Gets or sets the Schema version supported by the client. 
	 * This tells Exchange service which app manifests should be returned based on the schema version.
	 * 
	 * @value	The schema version supported.
	 */
	SchemaVersionSupported: string = null;

	/**
	 * @internal Initializes a new instance of the **GetAppManifestsRequest** class.
	 *
	 * @param   {ExchangeService}   service   The service.
	 */
	constructor(service: ExchangeService) {
		super(service);
	}

	/**
     * @internal Executes this request.
     *
     * @return  {Promise<GetAppManifestsResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetAppManifestsResponse> {

		return this.InternalExecute().then((serviceResponse: GetAppManifestsResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2013;
	}

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
		return XmlElementNames.GetAppManifestsResponse;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
		return XmlElementNames.GetAppManifestsRequest;
	}

	/**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
		let response: GetAppManifestsResponse = new GetAppManifestsResponse();
		response.LoadFromXmlJsObject(jsonBody, this.Service);
		return response;
	}

	/**
	 * @internal Validate request.
	 */
	Validate(): void {
		super.Validate();
		EwsUtilities.ValidateNonBlankStringParamAllowNull(this.ApiVersionSupported, "ApiVersionSupported");
		EwsUtilities.ValidateNonBlankStringParamAllowNull(this.SchemaVersionSupported, "SchemaVersionSupported");
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		if (!StringHelper.IsNullOrEmpty(this.ApiVersionSupported)) {
			writer.WriteElementValue(XmlNamespace.Messages, "ApiVersionSupported", this.ApiVersionSupported);
		}

		if (!StringHelper.IsNullOrEmpty(this.SchemaVersionSupported)) {
			writer.WriteElementValue(XmlNamespace.Messages, "SchemaVersionSupported", this.SchemaVersionSupported);
		}
	}
}

/**
 * @internal Represents a GetAppMarketplaceUrl request.
 * 
 * @sealed 
 */
export class GetAppMarketplaceUrlRequest extends SimpleServiceRequestBase {

	/**
	 * @internal Gets or sets the api version supported by the client. 
	 * This is used by EWS to generate a market place url with the correct version filter.
	 * 
	 * @value	The Api version supported.
	 */
	ApiVersionSupported: string = null;

	/**
	 * @internal Gets or sets the Schema version supported by the client. 
	 * This is used by EWS to generate a market place url with the correct version filter.
	 * 
	 * @value	The schema version supported.
	 */
	SchemaVersionSupported: string = null;

	/**
	 * @internal Initializes a new instance of the **GetAppMarketplaceUrlRequest** class.
	 *
	 * @param   {ExchangeService}   service   The service.
	 */
	constructor(service: ExchangeService) {
		super(service);
	}

	/**
     * @internal Executes this request.
     *
     * @return  {Promise<GetAppMarketplaceUrlResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetAppMarketplaceUrlResponse> {

		return this.InternalExecute().then((serviceResponse: GetAppMarketplaceUrlResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2013;
	}

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
		return XmlElementNames.GetAppMarketplaceUrlResponse;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
		return XmlElementNames.GetAppMarketplaceUrlRequest;
	}

	/**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
		let response: GetAppMarketplaceUrlResponse = new GetAppMarketplaceUrlResponse();
		response.LoadFromXmlJsObject(jsonBody, this.Service);
		return response;
	}

	/**
	 * @internal Validate request.
	 */
	Validate(): void {
		super.Validate();
		EwsUtilities.ValidateNonBlankStringParamAllowNull(this.ApiVersionSupported, "ApiVersionSupported");
		EwsUtilities.ValidateNonBlankStringParamAllowNull(this.SchemaVersionSupported, "SchemaVersionSupported");
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		if (!StringHelper.IsNullOrEmpty(this.ApiVersionSupported)) {
			writer.WriteElementValue(XmlNamespace.Messages, "ApiVersionSupported", this.ApiVersionSupported);
		}

		if (!StringHelper.IsNullOrEmpty(this.SchemaVersionSupported)) {
			writer.WriteElementValue(XmlNamespace.Messages, "SchemaVersionSupported", this.SchemaVersionSupported);
		}
	}
}
/**
 * ## @internal *Not Implemented*  Server to server call - not needed
 */
export class GetClientExtensionRequest extends SimpleServiceRequestBase {
    private requestedExtensionIds: StringList;
    private shouldReturnEnabledOnly: boolean;
    private isUserScope: boolean;
    private userId: string;
    private userEnabledExtensionIds: StringList;
    private userDisabledExtensionIds: StringList;
    private isDebug: boolean;
    Execute(): GetClientExtensionResponse { throw new Error("GetClientExtensionRequest.ts - Execute : Not implemented."); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { throw new Error("GetClientExtensionRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); }
    GetResponseXmlElementName(): string { throw new Error("GetClientExtensionRequest.ts - GetResponseXmlElementName : Not implemented."); }
    GetXmlElementName(): string { throw new Error("GetClientExtensionRequest.ts - GetXmlElementName : Not implemented."); }
    ParseResponse(reader: EwsServiceXmlReader): any { throw new Error("GetClientExtensionRequest.ts - ParseResponse : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("GetClientExtensionRequest.ts - WriteElementsToXml : Not implemented."); }
}

/**
 * @internal Represents a GetDiscoverySearchConfigurationRequest.
 * 
 * @sealed
 */
export class GetDiscoverySearchConfigurationRequest extends SimpleServiceRequestBase {

    /**
     * Search Id
     */
    SearchId: string = null;

    /**
     * Expand group membership
     */
    ExpandGroupMembership: boolean = false;

    /**
     * In-Place hold configuration only
     */
    InPlaceHoldConfigurationOnly: boolean = false;

    /**
     * @internal Initializes a new instance of the **GetDiscoverySearchConfigurationRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetDiscoverySearchConfigurationResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetDiscoverySearchConfigurationResponse> {
        return this.InternalExecute().then((serviceResponse: GetDiscoverySearchConfigurationResponse) => {
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetDiscoverySearchConfigurationResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetDiscoverySearchConfiguration;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: GetDiscoverySearchConfigurationResponse = new GetDiscoverySearchConfigurationResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SearchId, this.SearchId || StringHelper.Empty);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ExpandGroupMembership, this.ExpandGroupMembership);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.InPlaceHoldConfigurationOnly, this.InPlaceHoldConfigurationOnly);
    }
}
/**
 * ## @internal *Not Implemented*   Server to server call - not needed
 */
export class GetEncryptionConfigurationRequest extends SimpleServiceRequestBase {
    Execute(): GetEncryptionConfigurationResponse { throw new Error("GetEncryptionConfigurationRequest.ts - Execute : Not implemented."); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { throw new Error("GetEncryptionConfigurationRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); }
    GetResponseXmlElementName(): string { throw new Error("GetEncryptionConfigurationRequest.ts - GetResponseXmlElementName : Not implemented."); }
    GetXmlElementName(): string { throw new Error("GetEncryptionConfigurationRequest.ts - GetXmlElementName : Not implemented."); }
    ParseResponse(reader: EwsServiceXmlReader): any { throw new Error("GetEncryptionConfigurationRequest.ts - ParseResponse : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("GetEncryptionConfigurationRequest.ts - WriteElementsToXml : Not implemented."); }
}

/**
 * @internal Represents a GetHoldOnMailboxesRequest request.
 * 
 * @sealed
 */
export class GetHoldOnMailboxesRequest extends SimpleServiceRequestBase {

    /**
     * Hold id
     */
    HoldId: string = null;

    /**
     * @internal Initializes a new instance of the **GetHoldOnMailboxesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetHoldOnMailboxesResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetHoldOnMailboxesResponse> {
        return this.InternalExecute().then((serviceResponse: GetHoldOnMailboxesResponse) => {
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetHoldOnMailboxesResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetHoldOnMailboxes;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: GetHoldOnMailboxesResponse = new GetHoldOnMailboxesResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();

        if (StringHelper.IsNullOrEmpty(this.HoldId)) {
            throw new ServiceValidationException(Strings.HoldIdParameterIsNotSpecified);
        }
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.HoldId, this.HoldId);
    }
}

/**
 * @internal Represents a GetInboxRules request.
 * 
 * @sealed
 */
export class GetInboxRulesRequest extends SimpleServiceRequestBase {

	/**
	 * The smtp address of the mailbox from which to get the inbox rules.
	 */
	private mailboxSmtpAddress: string;

	/**
	 * Gets or sets the address of the mailbox from which to get the inbox rules.
	 */
	get MailboxSmtpAddress(): string {
		return this.mailboxSmtpAddress;
	}
	set MailboxSmtpAddress(value: string) {
		this.mailboxSmtpAddress = value;
	}

	/**
     * @internal Initializes a new instance of the **GetInboxRulesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

	/**
     * @internal Executes this request.
     *
     * @return  {Promise<GetInboxRulesResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetInboxRulesResponse> {
		return this.InternalExecute().then((serviceResponse: GetInboxRulesResponse) => {

            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
		});
	}

	/**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2010_SP1;
	}

	/**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string {
		return XmlElementNames.GetInboxRulesResponse;
	}

	/**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string {
		return XmlElementNames.GetInboxRules;
	}

	/**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
		let response: GetInboxRulesResponse = new GetInboxRulesResponse();
		response.LoadFromXmlJsObject(jsonBody, this.Service);
		return response;
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		if (!StringHelper.IsNullOrEmpty(this.mailboxSmtpAddress)) {
			writer.WriteElementValue(
				XmlNamespace.Messages,
				XmlElementNames.MailboxSmtpAddress,
				this.mailboxSmtpAddress);
		}
	}
}

/**
 * @internal Represents a GetNonIndexableItemDetailsRequest request. 
 * 
 * @sealed
 */
export class GetNonIndexableItemDetailsRequest extends SimpleServiceRequestBase {

    /**
     * Mailboxes
     */
    Mailboxes: string[] = null;

    /**
     * @Nullable Page size
     */
    PageSize: number = null;

    /**
     * Page item reference
     */
    PageItemReference: string = null;

    /**
     * @Nullable Page direction
     */
    PageDirection: SearchPageDirection = null;

    /**
     * Whether to search archive only
     */
    SearchArchiveOnly: boolean = false;

    /**
     * @internal Initializes a new instance of the **GetNonIndexableItemDetailsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetNonIndexableItemDetailsResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetNonIndexableItemDetailsResponse> {
        return this.InternalExecute().then((serviceResponse: GetNonIndexableItemDetailsResponse) => {
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetNonIndexableItemDetailsResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetNonIndexableItemDetails;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: GetNonIndexableItemDetailsResponse = new GetNonIndexableItemDetailsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();

        if (this.Mailboxes == null || this.Mailboxes.length == 0) {
            throw new ServiceValidationException(Strings.MailboxesParameterIsNotSpecified);
        }
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Mailboxes);
        for (let mailbox of this.Mailboxes) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LegacyDN, mailbox);
        }

        writer.WriteEndElement();

        if (this.PageSize) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageSize, this.PageSize);
        }

        if (!StringHelper.IsNullOrEmpty(this.PageItemReference)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageItemReference, this.PageItemReference);
        }

        if (hasValue(this.PageDirection)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageDirection, SearchPageDirection[this.PageDirection]);
        }

        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SearchArchiveOnly, this.SearchArchiveOnly);
    }
}

/**
 * @internal Represents the GetNonIndexableItemStatistics response.
 */
export class GetNonIndexableItemStatisticsRequest extends SimpleServiceRequestBase {

    /**
     * Mailboxes
     */
    Mailboxes: string[] = null;

    /**
     * Whether to search archive only
     */
    SearchArchiveOnly: boolean = false;

    /**
     * @internal Initializes a new instance of the **GetNonIndexableItemStatisticsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetNonIndexableItemStatisticsResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetNonIndexableItemStatisticsResponse> {
        return this.InternalExecute().then((serviceResponse: GetNonIndexableItemStatisticsResponse) => {
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetNonIndexableItemStatisticsResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetNonIndexableItemStatistics;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: GetNonIndexableItemStatisticsResponse = new GetNonIndexableItemStatisticsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();

        if (this.Mailboxes == null || this.Mailboxes.length == 0) {
            throw new ServiceValidationException(Strings.MailboxesParameterIsNotSpecified);
        }
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Mailboxes);
        for (let mailbox of this.Mailboxes) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LegacyDN, mailbox);
        }

        writer.WriteEndElement();

        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SearchArchiveOnly, this.SearchArchiveOnly);
    }
}
/** @internal */
export class GetPasswordExpirationDateRequest extends SimpleServiceRequestBase {//IJsonSerializable
    private mailboxSmtpAddress: string = null;
    get MailboxSmtpAddress(): string {
        return this.mailboxSmtpAddress;
    }
    set MailboxSmtpAddress(value: string) {
        this.mailboxSmtpAddress = value;
    }
    constructor(service: ExchangeService) {
        super(service);
    }

    Execute(): Promise<GetPasswordExpirationDateResponse> {
        return this.InternalExecute().then((serviceResponse) => {
            serviceResponse.ThrowIfNecessary();
            return <GetPasswordExpirationDateResponse>serviceResponse;
        });
    }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2010_SP1; }
    GetResponseXmlElementName(): string { return XmlElementNames.GetPasswordExpirationDateResponse; }
    GetXmlElementName(): string { return XmlElementNames.GetPasswordExpirationDateRequest; }
    //ParseResponse(reader: any): any { throw new Error("GetPasswordExpirationDateRequest.ts - ParseResponse : Not implemented."); }
    ParseResponse(jsonBody: any): any {
        var serviceResponse: GetPasswordExpirationDateResponse = new GetPasswordExpirationDateResponse();
        serviceResponse.LoadFromXmlJsObject(jsonBody, this.Service);
        return serviceResponse;
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MailboxSmtpAddress, this.MailboxSmtpAddress); }
}
/**
 * ## @internal *Not Implemented* 
 */
export class GetPhoneCallRequest extends SimpleServiceRequestBase {
    Id: PhoneCallId;
    private id: PhoneCallId;
    Execute(): GetPhoneCallResponse { throw new Error("GetPhoneCallRequest.ts - Execute : Not implemented."); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { throw new Error("GetPhoneCallRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); }
    GetResponseXmlElementName(): string { throw new Error("GetPhoneCallRequest.ts - GetResponseXmlElementName : Not implemented."); }
    GetXmlElementName(): string { throw new Error("GetPhoneCallRequest.ts - GetXmlElementName : Not implemented."); }
    ParseResponse(reader: EwsServiceXmlReader): any { throw new Error("GetPhoneCallRequest.ts - ParseResponse : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("GetPhoneCallRequest.ts - WriteElementsToXml : Not implemented."); }
}

/** 
 * @internal Represents a GetRoomList request. 
 * 
 * @sealed
 */
export class GetRoomListsRequest extends SimpleServiceRequestBase {
    
    /**
     * @internal Initializes a new instance of the **GetRoomListsRequest** class.
     *
     * @param   {service}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetRoomListsResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetRoomListsResponse> {
        return this.InternalExecute().then((serviceResponse: GetRoomListsResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetRoomListsResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetRoomListsRequest;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: GetRoomListsResponse = new GetRoomListsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        // Don't have parameter in request
    }
}

/**
 * @internal Represents a GetRooms request.
 * 
 * @sealed
 */
export class GetRoomsRequest extends SimpleServiceRequestBase {
    private roomList: EmailAddress = null;

    /**
     * @internal Gets or sets the room list to retrieve rooms from.
     */
    get RoomList(): EmailAddress {
        return this.roomList;
    }
    set RoomList(value: EmailAddress) {
        this.roomList = value;
    }

    /**
     * @internal Initializes a new instance of the **GetRoomsRequest** class.
     *
     * @param   {service}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetRoomsResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetRoomsResponse> {
        return this.InternalExecute().then((serviceResponse: GetRoomsResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetRoomsResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetRoomsRequest;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: GetRoomsResponse = new GetRoomsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        //this.RoomList.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.RoomList);
        this.RoomList.WriteToXml(writer, XmlElementNames.RoomList, XmlNamespace.Messages); //info: temp workaround github #52 
    }
}

/**
 * @internal Represents a GetSearchableMailboxesRequest request.
 */
export class GetSearchableMailboxesRequest extends SimpleServiceRequestBase {

    /**
     * Search filter
     */
    SearchFilter: string = null;

    /**
     * Expand group membership
     */
    ExpandGroupMembership: boolean = false;

    /**
     * @internal Initializes a new instance of the **GetSearchableMailboxesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetDiscoverySearchConfigurationResponse>}      Service response  :Promise.
     */
    Execute(): Promise<GetSearchableMailboxesResponse> {
        return this.InternalExecute().then((serviceResponse: GetSearchableMailboxesResponse) => {
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetSearchableMailboxesResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetSearchableMailboxes;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: GetSearchableMailboxesResponse = new GetSearchableMailboxesResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SearchFilter, this.SearchFilter || StringHelper.Empty);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ExpandGroupMembership, this.ExpandGroupMembership);
    }
}
/** @internal */
export class GetUserAvailabilityRequest extends SimpleServiceRequestBase {
    get EmitTimeZoneHeader(): boolean { return true; }
    get IsFreeBusyViewRequested(): boolean { return this.RequestedData == AvailabilityData.FreeBusy || this.RequestedData == AvailabilityData.FreeBusyAndSuggestions; }
    get IsSuggestionsViewRequested(): boolean { return this.RequestedData == AvailabilityData.Suggestions || this.RequestedData == AvailabilityData.FreeBusyAndSuggestions; }
    Attendees: AttendeeInfo[] = [];//System.Collections.Generic.IEnumerable<AttendeeInfo>;
    TimeWindow: TimeWindow = null;
    RequestedData: AvailabilityData = AvailabilityData.FreeBusyAndSuggestions;
    Options: AvailabilityOptions = null;
    // private attendees: AttendeeInfo[];//System.Collections.Generic.IEnumerable<AttendeeInfo>; - no need of backing field
    // private timeWindow: TimeWindow;
    // private requestedData: AvailabilityData;
    // private options: AvailabilityOptions;
    constructor(service: ExchangeService) {
        super(service);
    }
    Execute(): Promise<GetUserAvailabilityResults> { return <Promise<GetUserAvailabilityResults>>this.InternalExecute(); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseXmlElementName(): string { return XmlElementNames.GetUserAvailabilityResponse; }
    GetXmlElementName(): string { return XmlElementNames.GetUserAvailabilityRequest; }
    ParseResponse(jsonBody: any): any {
        var serviceResponse = new GetUserAvailabilityResults();

        if (this.IsFreeBusyViewRequested) {
            serviceResponse.AttendeesAvailability = new ServiceResponseCollection<AttendeeAvailability>();
            var responseArray: any = jsonBody[XmlElementNames.FreeBusyResponseArray];
            var responseMessages: any[] = responseArray[XmlElementNames.FreeBusyResponse];
            if (!Array.isArray(responseMessages)) {
                responseMessages = [responseMessages];
            }
            for (var responseMessage of responseMessages) {
                var freeBusyResponse: AttendeeAvailability = new AttendeeAvailability();
                freeBusyResponse.LoadFromXmlJsObject(responseMessage[XmlElementNames.ResponseMessage], this.Service);
                if (freeBusyResponse.ErrorCode == ServiceError.NoError) {
                    freeBusyResponse.LoadFreeBusyViewFromXmlJsObject(responseMessage[XmlElementNames.FreeBusyView], this.Options.RequestedFreeBusyView, this.Service);
                }
                serviceResponse.AttendeesAvailability.Add(freeBusyResponse);
            }
        }
        if (this.IsSuggestionsViewRequested) {
            serviceResponse.SuggestionsResponse = new SuggestionsResponse();

            var suggestionResponse = jsonBody[XmlElementNames.SuggestionsResponse];

            serviceResponse.SuggestionsResponse.LoadFromXmlJsObject(suggestionResponse[XmlElementNames.ResponseMessage], this.Service);

            if (serviceResponse.SuggestionsResponse.ErrorCode == ServiceError.NoError) {
                serviceResponse.SuggestionsResponse.LoadSuggestedDaysFromXml(suggestionResponse, this.Service);
            }
        }

        return serviceResponse;
    }
    Validate(): void {
        super.Validate();
        this.Options.Validate(this.TimeWindow.Duration);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        // Only serialize the TimeZone property against an Exchange 2007 SP1 server.
        // Against Exchange 2010, the time zone is emitted in the request's SOAP header.
        if (writer.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
            //todo: implement TimeZone and then LegacyAvailabilityTimeZone
            // var legacyTimeZone:LegacyAvailabilityTimeZone = new LegacyAvailabilityTimeZone(writer.Service.TimeZone);

            // legacyTimeZone.WriteToXml(writer, XmlElementNames.TimeZone);
        }

        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.MailboxDataArray);

        for (var attendee of this.Attendees) {
            attendee.WriteToXml(writer);
        }

        writer.WriteEndElement(); // MailboxDataArray

        this.Options.WriteToXml(writer, this);
    }
}


/**
 * @internal Represents a GetUserOofSettings request. 
 * 
 * @sealed
 */
export class GetUserOofSettingsRequest extends SimpleServiceRequestBase {
    private smtpAddress: string = null;
    
    /**
     * @internal Gets or sets the SMTP address.
     */
    get SmtpAddress(): string {
        return this.smtpAddress;
    }
    set SmtpAddress(value: string) {
        this.smtpAddress = value;
    }

    /**
     * @internal Initializes a new instance of the **GetUserOofSettingsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetUserOofSettingsResponse>}      Service response.
     */
    Execute(): Promise<GetUserOofSettingsResponse> {
        return this.InternalExecute().then((serviceResponse: GetUserOofSettingsResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string { return XmlElementNames.GetUserOofSettingsResponse; }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string { return XmlElementNames.GetUserOofSettingsRequest; }

    /**
     * Parses the response.
     *
     * @param   {any}   jsObjectBody   The jsObjectBody from XmlJsObject.
     * @return  {any}            Response object.
     */
    ParseResponse(jsObjectBody: any): any {
        var serviceResponse: GetUserOofSettingsResponse = new GetUserOofSettingsResponse();

        serviceResponse.LoadFromXmlJsObject(jsObjectBody[XmlElementNames.ResponseMessage], this.Service);

        if (serviceResponse.ErrorCode == ServiceError.NoError) {
            if (jsObjectBody[XmlElementNames.OofSettings]) {
                serviceResponse.OofSettings = new OofSettings();
                serviceResponse.OofSettings.LoadFromXmlJsObject(jsObjectBody[XmlElementNames.OofSettings], this.Service);
                serviceResponse.OofSettings.AllowExternalOof = <OofExternalAudience><any>OofExternalAudience[jsObjectBody[XmlElementNames.AllowExternalOof]]
            }
        }

        return serviceResponse;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParam(this.SmtpAddress, "SmtpAddress");
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Mailbox);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Address, this.SmtpAddress);
        writer.WriteEndElement(); // Mailbox
    }
}

/**
 * @internal Represents a GetUserRetentionPolicyTagsRequest request.
 * 
 * @sealed
 */
export class GetUserRetentionPolicyTagsRequest extends SimpleServiceRequestBase {

	/**
     * @internal Initializes a new instance of the **GetUserRetentionPolicyTagsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
  constructor(service: ExchangeService) {
    super(service);
  }

	/**
     * @internal Executes this request.
     *
     * @return  {Promise<GetUserRetentionPolicyTagsResponse>}      Service response  :Promise.
     */
  Execute(): Promise<GetUserRetentionPolicyTagsResponse> {
    return <Promise<GetUserRetentionPolicyTagsResponse>>this.InternalExecute();

  }

	/**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
  GetMinimumRequiredServerVersion(): ExchangeVersion {
    return ExchangeVersion.Exchange2013;
  }

	/**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
  GetResponseXmlElementName(): string {
    return XmlElementNames.GetUserRetentionPolicyTagsResponse;
  }

	/**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
  GetXmlElementName(): string {
    return XmlElementNames.GetUserRetentionPolicyTags;
  }

	/**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
  ParseResponse(jsonBody: any): any {
    let response: GetUserRetentionPolicyTagsResponse = new GetUserRetentionPolicyTagsResponse();
    response.LoadFromXmlJsObject(jsonBody, this.Service);
    return response;
  }

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
  WriteElementsToXml(writer: EwsServiceXmlWriter): void {
    // Don't have parameter in request.
  }
}

/**
 * @internal Represents a InstallApp request.
 * 
 * @sealed
 */
export class InstallAppRequest extends SimpleServiceRequestBase {

	/**
	 * The plain text manifest stream as base64 encoded string. 
	 */
	private manifestStream: string = null;

	/**
	 * Initializes a new instance of the **InstallAppRequest** class.
	 *
	 * @param   {ExchangeService}   service          The service.
	 * @param   {string}   			manifestStream   The manifest's plain text XML stream.
	 */
	constructor(service: ExchangeService, manifestStream: string) {
		super(service);
		this.manifestStream = manifestStream;
	}

	/**
     * @internal Executes this request.
     *
     * @return  {Promise<InstallAppResponse>}      Service response  :Promise.
     */
    Execute(): Promise<InstallAppResponse> {
		return this.InternalExecute().then((serviceResponse: InstallAppResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2013;
	}

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
		return XmlElementNames.InstallAppResponse;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
		return XmlElementNames.InstallAppRequest;
	}

	/**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
		let response: InstallAppResponse = new InstallAppResponse();
		response.LoadFromXmlJsObject(jsonBody, this.Service);
		return response;
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Manifest);

		//writer.WriteBase64ElementValue(manifestStream);
		writer.WriteValue(this.manifestStream, null);

		writer.WriteEndElement();
	}
}
/**
 * ## @internal *Not Implemented* 
 */
export class PlayOnPhoneRequest extends SimpleServiceRequestBase {//IJsonSerializable
    ItemId: ItemId;
    DialString: string;
    private itemId: ItemId;
    private dialString: string;
    Execute(): PlayOnPhoneResponse { throw new Error("PlayOnPhoneRequest.ts - Execute : Not implemented."); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { throw new Error("PlayOnPhoneRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); }
    GetResponseXmlElementName(): string { throw new Error("PlayOnPhoneRequest.ts - GetResponseXmlElementName : Not implemented."); }
    GetXmlElementName(): string { throw new Error("PlayOnPhoneRequest.ts - GetXmlElementName : Not implemented."); }
    ParseResponse(reader: EwsServiceXmlReader): any { throw new Error("PlayOnPhoneRequest.ts - ParseResponse : Not implemented."); }
    //ParseResponse(jsonBody: JsonObject): any { throw new Error("PlayOnPhoneRequest.ts - ParseResponse : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("PlayOnPhoneRequest.ts - WriteElementsToXml : Not implemented."); }
}
/**
 * ## @internal *Not Implemented*   Server to server call - not needed
 */
export class SetEncryptionConfigurationRequest extends SimpleServiceRequestBase {
    ImageBase64: string;
    EmailText: string;
    PortalText: string;
    DisclaimerText: string;
    private imageBase64: string;
    private emailText: string;
    private portalText: string;
    private disclaimerText: string;
    Execute(): ServiceResponse { throw new Error("SetEncryptionConfigurationRequest.ts - Execute : Not implemented."); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { throw new Error("SetEncryptionConfigurationRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); }
    GetResponseXmlElementName(): string { throw new Error("SetEncryptionConfigurationRequest.ts - GetResponseXmlElementName : Not implemented."); }
    GetXmlElementName(): string { throw new Error("SetEncryptionConfigurationRequest.ts - GetXmlElementName : Not implemented."); }
    ParseResponse(reader: EwsServiceXmlReader): any { throw new Error("SetEncryptionConfigurationRequest.ts - ParseResponse : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("SetEncryptionConfigurationRequest.ts - WriteElementsToXml : Not implemented."); }
}

/**
 * @internal Represents a SetHoldOnMailboxesRequest request.
 * 
 * @sealed 
 */
export class SetHoldOnMailboxesRequest extends SimpleServiceRequestBase { //IJsonSerializable

    /**
     * Action type
     */
    ActionType: HoldAction = HoldAction.Create;

    /**
     * Hold id
     */
    HoldId: string = null;

    /**
     * Query
     */
    Query: string = null;

    /**
     * Collection of mailboxes to be held/unheld
     */
    Mailboxes: string[] = null;

    /**
     * Query language
     */
    Language: string = null;

    /**
     * InPlaceHold Identity
     */
    InPlaceHoldIdentity: string = null;

    /**
     * Item hold period
     * *The text value can be "Unlimited" or the string value of any Timespan value.*
     */
    ItemHoldPeriod: string = null;

    /**
	 * Include Non Indexable Items
	 */
    IncludeNonIndexableItems: boolean = null;

	/**
	 * Perform deduplication
	 */
    PerformDeduplication: boolean = null;

    /**
     * @internal Initializes a new instance of the **SetHoldOnMailboxesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<SetHoldOnMailboxesResponse>}      Service response  :Promise.
     */
    Execute(): Promise<SetHoldOnMailboxesResponse> {
        return this.InternalExecute().then((serviceResponse: SetHoldOnMailboxesResponse) => {
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.SetHoldOnMailboxesResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.SetHoldOnMailboxes;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: SetHoldOnMailboxesResponse = new SetHoldOnMailboxesResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();

        if (StringHelper.IsNullOrEmpty(this.HoldId)) {
            throw new ServiceValidationException(Strings.HoldIdParameterIsNotSpecified);
        }

        if (StringHelper.IsNullOrEmpty(this.InPlaceHoldIdentity) && (this.Mailboxes == null || this.Mailboxes.length == 0)) {
            throw new ServiceValidationException(Strings.HoldMailboxesParameterIsNotSpecified);
        }
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ActionType, HoldAction[this.ActionType]);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.HoldId, this.HoldId);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Query, this.Query || StringHelper.Empty);

        if (this.Mailboxes != null && this.Mailboxes.length > 0) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Mailboxes);
            for (let mailbox of this.Mailboxes) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.String, mailbox);
            }

            writer.WriteEndElement();   // Mailboxes
        }

        // Language
        if (!StringHelper.IsNullOrEmpty(this.Language)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Language, this.Language);
        }

        if (!StringHelper.IsNullOrEmpty(this.InPlaceHoldIdentity)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.InPlaceHoldIdentity, this.InPlaceHoldIdentity);
        }

        /** per github issue #120 */
        if (this.IncludeNonIndexableItems !== null) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.IncludeNonIndexableItems, this.IncludeNonIndexableItems);
        }
        /** per github issue #120 */
        if (this.PerformDeduplication !== null) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Deduplication, this.PerformDeduplication);
        }

        if (!StringHelper.IsNullOrEmpty(this.ItemHoldPeriod)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ItemHoldPeriod, this.ItemHoldPeriod);
        }
    }
}

/**
 * @internal Represents a SetTeamMailbox request.
 * 
 * @sealed
 */
export class SetTeamMailboxRequest extends SimpleServiceRequestBase {

    /**
     * TeamMailbox email address
     */
    private emailAddress: EmailAddress = null;

    /**
     * SharePoint site URL
     */
    private sharePointSiteUrl: Uri = null;

    /**
     * TeamMailbox lifecycle state
     */
    private state: TeamMailboxLifecycleState = TeamMailboxLifecycleState.Active;

    /**
     * @internal Initializes a new instance of the **SetTeamMailboxRequest** class.
     *
     * @param   {ExchangeService}               service             The service
     * @param   {EmailAddress}                  emailAddress        TeamMailbox email address
     * @param   {Uri}                           sharePointSiteUrl   SharePoint site URL
     * @param   {TeamMailboxLifecycleState}     state               TeamMailbox state
     */
    constructor(service: ExchangeService, emailAddress: EmailAddress, sharePointSiteUrl: Uri, state: TeamMailboxLifecycleState) {
        super(service);
        if (emailAddress === null) {
            throw new ArgumentNullException("emailAddress");
        }
        if (sharePointSiteUrl === null) {
            throw new ArgumentNullException("sharePointSiteUrl");
        }

        this.emailAddress = emailAddress;
        this.sharePointSiteUrl = sharePointSiteUrl;
        this.state = state;
    }

    /**
     * @internal Executes this request.
     *
     * @return  {ServiceResponse}      Service response.
     */
    Execute(): Promise<ServiceResponse> {
        return this.InternalExecute().then((serviceResponse: ServiceResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.SetTeamMailboxResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetXmlElementName(): string {
        return XmlElementNames.SetTeamMailbox;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        var serviceResponse: ServiceResponse = new ServiceResponse();
        serviceResponse.LoadFromXmlJsObject(jsonBody, this.Service);
        return serviceResponse;
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        //this.emailAddress.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.EmailAddress);
        this.emailAddress.WriteToXml(writer, XmlElementNames.EmailAddress, XmlNamespace.Messages);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SharePointSiteUrl, this.sharePointSiteUrl.ToString());
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.State, TeamMailboxLifecycleState[this.state]);
    }
}

/**
 * @internal Represents a SetUserOofSettings request.
 * 
 * @sealed
 */
export class SetUserOofSettingsRequest extends SimpleServiceRequestBase {

    private smtpAddress: string = null;
    private oofSettings: OofSettings = null;

    /**
     * Gets or sets the SMTP address.
     */
    get SmtpAddress(): string {
        return this.smtpAddress;
    }
    set SmtpAddress(value: string) {
        this.smtpAddress = value;
    }

    /**
     * Gets or sets the oof settings.
     */
    get OofSettings(): OofSettings {
        return this.oofSettings;
    }
    set OofSettings(value: OofSettings) {
        this.oofSettings = value;
    }

    /**
     * @internal Initializes a new instance of the **SetUserOofSettingsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {ServiceResponse}      Service response.
     */
    Execute(): Promise<ServiceResponse> {
        return this.InternalExecute().then((serviceResponse: ServiceResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetResponseXmlElementName(): string { return XmlElementNames.SetUserOofSettingsResponse; }

    /**
     * Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string { return XmlElementNames.SetUserOofSettingsRequest; }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsObjectBody   The jsObjectBody from XmlJsObject.
     * @return  {any}            Service response.
     */
    ParseResponse(jsObjectBody: any): any {
        var serviceResponse: ServiceResponse = new ServiceResponse();
        serviceResponse.LoadFromXmlJsObject(jsObjectBody[XmlElementNames.ResponseMessage], this.Service);
        return serviceResponse;
    }

    /**
     * @internal Validate request..
     */
    Validate(): void {
        super.Validate();

        EwsUtilities.ValidateParam(this.SmtpAddress, "SmtpAddress");
        EwsUtilities.ValidateParam(this.OofSettings, "OofSettings");
    }

    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Mailbox);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Address, this.SmtpAddress);
        writer.WriteEndElement(); // Mailbox

        this.OofSettings.WriteToXml(writer, XmlElementNames.UserOofSettings);
    }
}

/**
 * @internal  Represents a UninstallApp request.
 * 
 * @sealed
 */
export class UninstallAppRequest extends SimpleServiceRequestBase {

	/**
	 * Extension ID
	 */
	private ID: string = null;

	/**
	 * @internal Initializes a new instance of the **UninstallAppRequest** class.
	 *
	 * @param   {ExchangeService}   service   The service.
	 * @param   {string}   			id        Extension ID
	 */	
	constructor(service: ExchangeService, id: string) {
		super(service);
		this.ID = id;
	}

	/**
     * @internal Executes this request.
     *
     * @return  {Promise<UninstallAppResponse>}      Service response  :Promise.
     */
    Execute(): Promise<UninstallAppResponse> { 
		return this.InternalExecute().then((serviceResponse: UninstallAppResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
	}
	
	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion { 
		return ExchangeVersion.Exchange2013;
	}
	
	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string { 
		return XmlElementNames.UninstallAppResponse;
	}
	
	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { 
		return XmlElementNames.UninstallAppRequest;
	}
	
	/**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any { 
		let response: UninstallAppResponse = new UninstallAppResponse();
		response.LoadFromXmlJsObject(jsonBody, this.Service);
		return response;
	}
	
	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { 
		writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ID, this.ID);
	}
}

/**
 * @internal Represents a UnpinTeamMailbox request.
 * 
 * @sealed
 */
export class UnpinTeamMailboxRequest extends SimpleServiceRequestBase {

    /**
     * TeamMailbox email address
     */
    private emailAddress: EmailAddress = null;

    /**
     * Initializes a new instance of the **UnpinTeamMailboxRequest** class.
     *
     * @param   {ExchangeService}   service        The service
     * @param   {EmailAddress}      emailAddress   TeamMailbox email address
     */
    constructor(service: ExchangeService, emailAddress: EmailAddress) {
        super(service);
        if (emailAddress === null) {
            throw new ArgumentNullException("emailAddress");
        }
        this.emailAddress = emailAddress;
    }

    /**
     * @internal Executes this request.
     *
     * @return  {ServiceResponse}      Service response.
     */
    Execute(): Promise<ServiceResponse> {
        return this.InternalExecute().then((serviceResponse: ServiceResponse) => {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.UnpinTeamMailboxResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetXmlElementName(): string {
        return XmlElementNames.UnpinTeamMailbox;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        var serviceResponse: ServiceResponse = new ServiceResponse();
        serviceResponse.LoadFromXmlJsObject(jsonBody, this.Service);
        return serviceResponse;
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        //this.emailAddress.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.EmailAddress);
        this.emailAddress.WriteToXml(writer, XmlElementNames.EmailAddress, XmlNamespace.Messages);
    }
}

/**
 * @internal Represents a UpdateInboxRulesRequest request.
 * 
 * @sealed 
 */
export class UpdateInboxRulesRequest extends SimpleServiceRequestBase {

    /**
     * The smtp address of the mailbox from which to get the inbox rules.
     */
    private mailboxSmtpAddress: string = null;

    /**
     * Remove OutlookRuleBlob or not.
     */
    private removeOutlookRuleBlob: boolean = false;

    /**
     * InboxRule operation collection.
     */
    private inboxRuleOperations: RuleOperation[] = null;


    get MailboxSmtpAddress(): string {
        return this.mailboxSmtpAddress;
    }
    set MailboxSmtpAddress(value: string) {
        this.mailboxSmtpAddress = value;
    }


    get RemoveOutlookRuleBlob(): boolean {
        return this.removeOutlookRuleBlob;
    }
    set RemoveOutlookRuleBlob(value: boolean) {
        this.removeOutlookRuleBlob = value;
    }


    get InboxRuleOperations(): RuleOperation[] {
        return this.inboxRuleOperations;
    }
    set InboxRuleOperations(value: RuleOperation[]) {
        this.inboxRuleOperations = value;
    }

    /**
     * @internal Initializes a new instance of the **UpdateInboxRulesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<UpdateInboxRulesResponse>}      Service response  :Promise.
     */
    Execute(): Promise<UpdateInboxRulesResponse> {
        return this.InternalExecute().then((serviceResponse: UpdateInboxRulesResponse) => {

            if (serviceResponse.Result == ServiceResult.Error) {
                throw new UpdateInboxRulesException(serviceResponse, this.inboxRuleOperations);
            }
            return serviceResponse;
        });
    }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010_SP1;
    }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string {
        return XmlElementNames.UpdateInboxRulesResponse;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string {
        return XmlElementNames.UpdateInboxRules;
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: UpdateInboxRulesResponse = new UpdateInboxRulesResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        if (this.inboxRuleOperations == null) {
            throw new ArgumentException("RuleOperations cannot be null.", "Operations");
        }

        let operationCount: number = 0;
        for (let operation of this.inboxRuleOperations) {
            EwsUtilities.ValidateParam(operation, "RuleOperation");
            operationCount++;
        }

        if (operationCount == 0) {
            throw new ArgumentException("RuleOperations cannot be empty.", "Operations");
        }

        this.Service.Validate();
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (!StringHelper.IsNullOrEmpty(this.mailboxSmtpAddress)) {
            writer.WriteElementValue(
                XmlNamespace.Messages,
                XmlElementNames.MailboxSmtpAddress,
                this.mailboxSmtpAddress);
        }

        writer.WriteElementValue(
            XmlNamespace.Messages,
            XmlElementNames.RemoveOutlookRuleBlob,
            this.RemoveOutlookRuleBlob);
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Operations);
        for (let operation of this.inboxRuleOperations) {
            operation.WriteToXml(writer, operation.XmlElementName);
        }
        writer.WriteEndElement();
    }
}

/**
 * @internal Represents an abstract delegate management request.
 * 
 * @typeparam   {TResponse}     The type of the response.
 */
export abstract class DelegateManagementRequestBase<TResponse extends DelegateManagementResponse> extends SimpleServiceRequestBase {

    private mailbox: Mailbox = null;

    /**
     *  Gets or sets the mailbox.
     * 
     * @value    The mailbox.
     */
    get Mailbox(): Mailbox {
        return this.mailbox;
    }
    set Mailbox(value: Mailbox) {
        this.mailbox = value;
    }

    /**
     * @internal Initializes a new instance of the **DelegateManagementRequestBase<TResponse>** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
	 * @internal Creates the response
	 *
	 * @return  {TResponse}		Response object.
	 */
    abstract CreateResponse(): TResponse;

    /**
     * @internal Executes this request.
     *
     * @return  {Promise<TResponse>}      Service response  :Promise.
     */
    Execute(): Promise<TResponse> {
        return this.InternalExecute().then((serviceResponse: TResponse) => {

            serviceResponse.ThrowIfNecessary();

            return serviceResponse;
        });
    }

    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let response: DelegateManagementResponse = this.CreateResponse();

        response.LoadFromXmlJsObject(jsonBody, this.Service);

        return response;
    }

    /**
	 * @internal Validate request.
	 */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParam(this.Mailbox, "Mailbox");
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.Mailbox.WriteToXml(
            writer,
            XmlElementNames.Mailbox,
            XmlNamespace.Messages);
    }
}

/**
 * @internal Represents an AddDelegate request. 
 */
export class AddDelegateRequest extends DelegateManagementRequestBase<DelegateManagementResponse> {

    private delegateUsers: DelegateUser[] = [];
    private meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope = null; //Nullable

    /**
     * Gets or sets the meeting requests delivery scope.
     * 
     * @value   The meeting requests delivery scope.
     */
    get MeetingRequestsDeliveryScope(): MeetingRequestsDeliveryScope {
        return this.meetingRequestsDeliveryScope;
    }
    set MeetingRequestsDeliveryScope(value: MeetingRequestsDeliveryScope) {
        this.meetingRequestsDeliveryScope = value;
    }

    /**
     * Gets the delegate users.
     * 
     * @value   The delegate users.
     */
    get DelegateUsers(): DelegateUser[] {
        return this.delegateUsers;
    }

    /**
     * @internal Initializes a new instance of the **AddDelegateRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
	 * @internal Creates the response
	 *
	 * @return  {DelegateManagementResponse}		Response object.
	 */
    CreateResponse(): DelegateManagementResponse {
        return new DelegateManagementResponse(true, this.delegateUsers);
    }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string {
        return XmlElementNames.AddDelegateResponse;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string {
        return XmlElementNames.AddDelegate;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParamCollection(this.DelegateUsers, "DelegateUsers");

        for (let delegateUser of this.DelegateUsers) {
            delegateUser.ValidateUpdateDelegate();
        }

        if (hasValue(this.MeetingRequestsDeliveryScope)) {
            EwsUtilities.ValidateEnumVersionValue(MeetingRequestsDeliveryScope, this.MeetingRequestsDeliveryScope, this.Service.RequestedServerVersion, "MeetingRequestsDeliveryScope");
        }
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.DelegateUsers);

        for (let delegateUser of this.DelegateUsers) {
            delegateUser.WriteToXml(writer, XmlElementNames.DelegateUser);
        }

        writer.WriteEndElement(); // DelegateUsers

        if (hasValue(this.MeetingRequestsDeliveryScope)) {
            writer.WriteElementValue(
                XmlNamespace.Messages,
                XmlElementNames.DeliverMeetingRequests,
                MeetingRequestsDeliveryScope[this.MeetingRequestsDeliveryScope]);
        }
    }
}

/**
 * @internal Represents a GetDelegate request. 
 */
export class GetDelegateRequest extends DelegateManagementRequestBase<GetDelegateResponse> {

    private userIds: UserId[] = [];
    private includePermissions: boolean = false;

    /**
     * Gets the user ids.
     * 
     * @value   The user ids.
     */
    get UserIds(): UserId[] {
        return this.userIds;
    }

    /**
     * Gets or sets a value indicating whether permissions are included.
     */
    get IncludePermissions(): boolean {
        return this.includePermissions;
    }
    set IncludePermissions(value: boolean) {
        this.includePermissions = value;
    }

    /**
     * @internal Initializes a new instance of the **GetDelegateRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
	 * @internal Creates the response
	 *
	 * @return  {GetDelegateResponse}		Response object.
	 */
    CreateResponse(): GetDelegateResponse {
        return new GetDelegateResponse(true);
    }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetDelegateResponse;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string {
        return XmlElementNames.GetDelegate;
    }

    /**
     * @internal Writes XML attributes.
     *
     * /remarks/    Subclass will override if it has XML attributes.
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        writer.WriteAttributeValue(XmlAttributeNames.IncludePermissions, this.IncludePermissions);
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        if (this.UserIds.length > 0) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.UserIds);

            for (let userId of this.UserIds) {
                userId.WriteToXml(writer, XmlElementNames.UserId);
            }

            writer.WriteEndElement(); // UserIds
        }
    }
}

/**
 * @internal Represents a RemoveDelete request. 
 */
export class RemoveDelegateRequest extends DelegateManagementRequestBase<DelegateManagementResponse> {

    private userIds: UserId[] = [];

    /**
     * Gets the user ids.
     * 
     * @value   The user ids.
     */
    get UserIds(): UserId[] {
        return this.userIds;
    }

    /**
     * @internal Initializes a new instance of the **RemoveDelegateRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
	 * @internal Creates the response
	 *
	 * @return  {DelegateManagementResponse}		Response object.
	 */
    CreateResponse(): DelegateManagementResponse {
        return new DelegateManagementResponse(false, null);
    }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string {
        return XmlElementNames.RemoveDelegateResponse;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string {
        return XmlElementNames.RemoveDelegate;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParamCollection(this.UserIds, "UserIds");
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.UserIds);

        for (let userId of this.UserIds) {
            userId.WriteToXml(writer, XmlElementNames.UserId);
        }

        writer.WriteEndElement(); // UserIds
    }
}

/**
 * @internal Represents an UpdateDelegate request. 
 */
export class UpdateDelegateRequest extends DelegateManagementRequestBase<DelegateManagementResponse> {

    private delegateUsers: DelegateUser[] = [];
    private meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope = null; //Nullable

    /**
     * Gets or sets the meeting requests delivery scope.
     * 
     * @value   The meeting requests delivery scope.
     */
    get MeetingRequestsDeliveryScope(): MeetingRequestsDeliveryScope {
        return this.meetingRequestsDeliveryScope;
    }
    set MeetingRequestsDeliveryScope(value: MeetingRequestsDeliveryScope) {
        this.meetingRequestsDeliveryScope = value;
    }

    /**
     * Gets the delegate users.
     * 
     * @value   The delegate users.
     */
    get DelegateUsers(): DelegateUser[] {
        return this.delegateUsers;
    }

    /**
     * @internal Initializes a new instance of the **UpdateDelegateRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
	 * @internal Creates the response
	 *
	 * @return  {DelegateManagementResponse}		Response object.
	 */
    CreateResponse(): DelegateManagementResponse {
        return new DelegateManagementResponse(true, this.delegateUsers);
    }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string {
        return XmlElementNames.UpdateDelegateResponse;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string {
        return XmlElementNames.UpdateDelegate;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParamCollection(this.DelegateUsers, "DelegateUsers");

        for (let delegateUser of this.DelegateUsers) {
            delegateUser.ValidateUpdateDelegate();
        }
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.DelegateUsers);

        for (let delegateUser of this.DelegateUsers) {
            delegateUser.WriteToXml(writer, XmlElementNames.DelegateUser);
        }

        writer.WriteEndElement(); // DelegateUsers

        if (hasValue(this.MeetingRequestsDeliveryScope)) {
            writer.WriteElementValue(
                XmlNamespace.Messages,
                XmlElementNames.DeliverMeetingRequests,
                MeetingRequestsDeliveryScope[this.MeetingRequestsDeliveryScope]);
        }
    }
}

/** @internal */
export class MultiResponseServiceRequest<TResponse extends ServiceResponse> extends SimpleServiceRequestBase {
    get ErrorHandlingMode(): ServiceErrorHandling { return this.errorHandlingMode; }
    private errorHandlingMode: ServiceErrorHandling;

    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service);
        this.errorHandlingMode = errorHandlingMode;
    }

    CreateServiceResponse(service: ExchangeService, responseIndex: number): TResponse { throw new Error("abstract; must implemented."); }
    //EndExecute(asyncResult: any/*System.IAsyncResult*/): ServiceResponseCollection<TResponse> { throw new Error("MultiResponseServiceRequest.ts - EndExecute : Not implemented."); }
    Execute(): Promise<ServiceResponseCollection<TResponse>> {

        return new Promise((successDelegate, errorDelegate) => {
            this.InternalExecute().then((value: any) => {
                var serviceResponses = <ServiceResponseCollection<TResponse>>value;

                if (this.ErrorHandlingMode == ServiceErrorHandling.ThrowOnError) {
                    EwsLogging.Assert(
                        serviceResponses.Count == 1,
                        "MultiResponseServiceRequest.Execute",
                        "ServiceErrorHandling.ThrowOnError error handling is only valid for singleton request");
                    try {

                        serviceResponses.__thisIndexer(0).ThrowIfNecessary();
                    }
                    catch (error) {
                        if (errorDelegate) {
                            errorDelegate(error);
                        }
                    }
                }

                //return serviceResponses; //no return succedssdelegates take care of returning


                if (successDelegate) {
                    successDelegate(serviceResponses);
                }

            }, (resperr: any) => {
                //debugger;
                if (errorDelegate) {
                    errorDelegate(resperr);
                }
            });
        });
    }
    GetExpectedResponseMessageCount(): number { throw new Error("Abstract; must implemented."); }
    GetResponseMessageXmlElementName(): string { throw new Error("Abstract; must implemented."); }
    ParseResponseXMLJsObject(jsObject: any): any {
        var serviceResponses = new ServiceResponseCollection<TResponse>();
        //set context to XmlElementNames.ResponseMessages
        //todo: this can have multiple reponse messages.
        var jsResponseMessages: any = jsObject[XmlElementNames.ResponseMessages]
        // if (!Array.isArray(jsResponseMessages)) {
        //     jsResponseMessages = [jsResponseMessages];
        // }

        var responseMessageXmlElementName = this.GetResponseMessageXmlElementName();
        let responseMessages = EwsServiceJsonReader.ReadAsArray(jsResponseMessages, responseMessageXmlElementName);
        //for (var i = 0; i < responses.length; i++) {
        for (var i = 0; i < this.GetExpectedResponseMessageCount(); i++) {
            var response: TResponse = this.CreateServiceResponse(this.Service, i);
            //ref: check need for responseMessageXmlElementName
            var jsResponseMessage = responseMessages[i];
            response.LoadFromXmlJsObject(jsResponseMessage, this.Service)//, responseMessageXmlElementName, this.Service);
            // Add the response to the list after it has been deserialized because the response
            // list updates an overall result as individual responses are added to it.
            serviceResponses.Add(response);
        }

        // If there's a general error in batch processing,
        // the server will return a single response message containing the error
        // (for example, if the SavedItemFolderId is bogus in a batch CreateItem
        // call). In this case, throw a ServiceResponsException. Otherwise this
        // is an unexpected server error.
        if (serviceResponses.Count < this.GetExpectedResponseMessageCount()) {
            if ((serviceResponses.Count >= 1) && (serviceResponses.__thisIndexer(0).Result == ServiceResult.Error)) {
                throw new ServiceResponseException(serviceResponses.__thisIndexer(0));
            }
            else {
                throw new ServiceXmlDeserializationException(
                    StringHelper.Format(
                        Strings.TooFewServiceReponsesReturned,
                        this.GetResponseMessageXmlElementName(),
                        this.GetExpectedResponseMessageCount(),
                        serviceResponses.Count));
            }
        }

        return serviceResponses;
    }
    ParseResponse(jsonBody: any): any {

        if (this.Service.RenderingMethod === RenderingMode.JSON) {
            throw new Error("not implemented");

            var serviceResponses = new ServiceResponseCollection<TResponse>();
            var jsonResponseMessages: any[] = jsonBody[XmlElementNames.ResponseMessages][XmlElementNames.Items];

            var responseCtr: number = 0;
            for (var jsonResponseObject of jsonResponseMessages) {
                var response: TResponse = this.CreateServiceResponse(this.Service, responseCtr);

                response.LoadFromXmlJsObject(jsonResponseObject, this.Service);

                // Add the response to the list after it has been deserialized because the response
                // list updates an overall result as individual responses are added to it.
                serviceResponses.Add(response);

                responseCtr++;
            }

            if (serviceResponses.Count < this.GetExpectedResponseMessageCount()) {
                if ((serviceResponses.Count == 1) && (serviceResponses[0].Result == ServiceResult.Error)) {
                    throw new ServiceResponseException(serviceResponses[0]);
                }
                else {
                    throw new ServiceJsonDeserializationException();
                }
            }
            return serviceResponses;
        }
        else {
            return this.ParseResponseXMLJsObject(jsonBody);
        }
    }
}

/**
 * @internal Represents a request to a Apply Conversation Action operation
 * 
 * @sealed 
 */
export class ApplyConversationActionRequest extends MultiResponseServiceRequest<ServiceResponse> {//IJsonSerializable

    private conversationActions: ConversationAction[] = [];

    get ConversationActions(): ConversationAction[] {
        return this.conversationActions;
    }

    /**
	 * @internal Initializes a new instance of the **ApplyConversationActionRequest** class.
	 *
	 * @param   {ExchangeService}       service   The service.
	 * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
	 */
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

	/**
	 * @internal Creates service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {ServiceResponse}	Service response.
	 */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse {
        return new ServiceResponse();
    }

	/**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return this.conversationActions.length;
    }

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010_SP1;
    }

	/**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseMessageXmlElementName(): string { return XmlElementNames.ApplyConversationActionResponseMessage; }

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseXmlElementName(): string { return XmlElementNames.ApplyConversationActionResponse; }

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.ApplyConversationAction; }

	/**
	 * @internal Validate the request.
	 */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParamCollection(this.conversationActions, "conversationActions");
		for (let iAction = 0; iAction < this.ConversationActions.length; iAction++) {
			this.ConversationActions[iAction].Validate();
		}
    }

	/**
	 * @internal Writes XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(
			XmlNamespace.Messages,
			XmlElementNames.ConversationActions);
		for (let iAction = 0; iAction < this.ConversationActions.length; iAction++) {
			this.ConversationActions[iAction].WriteElementsToXml(writer);
		}
		writer.WriteEndElement();
    }
}
/** @internal */
export class ArchiveItemRequest extends MultiResponseServiceRequest<ArchiveItemResponse> {//IJsonSerializable
    get Ids(): ItemIdWrapperList { return this.ids; }
    private sourceFolderId: FolderId;
    private ids: ItemIdWrapperList = new ItemIdWrapperList();
    get SourceFolderId(): FolderId {
        return this.sourceFolderId;
    }
    set SourceFolderId(value: FolderId) {
        this.sourceFolderId = value;
    }

    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }

    //AddIdsToJson(jsonObject: JsonObject, service: ExchangeService): any { throw new Error("ArchiveItemRequest.ts - AddIdsToJson : Not implemented."); }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ArchiveItemResponse { return new ArchiveItemResponse(); }
    GetExpectedResponseMessageCount(): number { return this.ids.Count; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2013; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.ArchiveItemResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.ArchiveItemResponse; }
    GetXmlElementName(): string { return XmlElementNames.ArchiveItem; }
    Validate(): void {
        //EwsUtilities.ValidateParam(this.sourceFolderId, "SourceFolderId");
        this.sourceFolderId.Validate(this.Service.RequestedServerVersion);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ArchiveSourceFolderId);
        this.SourceFolderId.WriteToXml(writer);
        writer.WriteEndElement();

        this.WriteIdsToXml(writer);
    }
    /**@internal */
    WriteIdsToXml(writer: EwsServiceXmlWriter): void {
        this.Ids.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.ItemIds);
    }
}

/**
 * @internal Represents a ConvertId request.
 * 
 * @sealed
 */
export class ConvertIdRequest extends MultiResponseServiceRequest<ConvertIdResponse> {//IJsonSerializable

    private destinationFormat: IdFormat = IdFormat.EwsId;
    private ids: AlternateIdBase[] = [];

    /**
     * Gets or sets the destination format.
     * 
     * @value   The destination format.
     */
    get DestinationFormat(): IdFormat {
        return this.destinationFormat;
    }
    set DestinationFormat(value: IdFormat) {
        this.destinationFormat = value;
    }

    /**
     * Gets the ids.
     * 
     * @value   The ids.
     */
    get Ids(): AlternateIdBase[] {
        return this.ids;
    }

    /**
     * @internal Initializes a new instance of the **ConvertIdRequest** class.
     *
     * @param   {ExchangeService}   service             The service.
     * @param   {ServiceErrorHandling}   errorHandlingMode   Indicates how errors should be handled.
     */
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {ConvertIdResponse}     Service response.
     */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ConvertIdResponse {
        return new ConvertIdResponse();
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return this.Ids.length;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.ConvertIdResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.ConvertIdResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetXmlElementName(): string {
        return XmlElementNames.ConvertId;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParamCollection(this.Ids, "Ids");
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.DestinationFormat, IdFormat[this.DestinationFormat]);

        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SourceIds);

        for (let alternateId of this.Ids) {
            alternateId.WriteToXml(writer);
        }

        writer.WriteEndElement(); // SourceIds
    }
}

/**
 * @internal Represents a CreateAttachment request.
 * @sealed
 */
export class CreateAttachmentRequest extends MultiResponseServiceRequest<CreateAttachmentResponse> { //IJsonSerializable

    private parentItemId: string = null;
    private attachments: Attachment[] = [];

    /**
     * @internal Gets a value indicating whether the TimeZoneContext SOAP header should be emitted.
     */
    get EmitTimeZoneHeader(): boolean {
        for (let itemAttachment of ArrayHelper.OfType<Attachment, ItemAttachment>(this.attachments, (item) => item instanceof ItemAttachment)) {
            if ((itemAttachment.Item != null) && itemAttachment.Item.GetIsTimeZoneHeaderRequired(false /* isUpdateOperation */)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Gets the attachments.
     */
    get Attachments(): Attachment[] {
        return this.attachments;
    }
    set ParentItemId(value: string) {
        this.parentItemId = value;
    }

    /**
     * Gets or sets the parent item id.
     * @value   The parent item id.
     */
    get ParentItemId(): string {
        return this.parentItemId;
    }

    /**
     * @internal Initializes a new instance of the **CreateAttachmentRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {CreateAttachmentResponse}     Service response.
     */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): CreateAttachmentResponse {
        return new CreateAttachmentResponse(this.Attachments[responseIndex]);
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return this.Attachments.length;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.CreateAttachmentResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.CreateAttachmentResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetXmlElementName(): string {
        return XmlElementNames.CreateAttachment;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParam(this.ParentItemId, "ParentItemId");
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ParentItemId);
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.ParentItemId);
        writer.WriteEndElement();

        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Attachments);
        for (let attachment of this.Attachments) {
            attachment.WriteToXml(writer, attachment.GetXmlElementName());
        }
        writer.WriteEndElement();
    }
}

/**
 * @internal Represents a CreateUserConfiguration request.
 * 
 * @sealed
 */
export class CreateUserConfigurationRequest extends MultiResponseServiceRequest<ServiceResponse> { //: IJsonSerializable

    protected userConfiguration: UserConfiguration = null;

    /**
     * Gets or sets the user configuration.
     * 
     * @value   The userConfiguration.
     */
    get UserConfiguration(): UserConfiguration {
        return this.userConfiguration;
    }
    set UserConfiguration(value: UserConfiguration) {
        this.userConfiguration = value;
    }

    /**
	 * @internal Initializes a new instance of the **CreateUserConfigurationRequest** class.
	 *
	 * @param   {ExchangeService}       service   The service.
	 */
    constructor(service: ExchangeService) {
        super(service, ServiceErrorHandling.ThrowOnError);
    }

    /**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {ServiceResponse}	Service response.
	 */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse {
        return new ServiceResponse();
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return 1;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.CreateUserConfigurationResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.CreateUserConfigurationResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.CreateUserConfiguration;
    }

    /**
	 * @internal Validate the request.
	 */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParam(this.userConfiguration, "userConfiguration");
    }

    /**
	 * @internal Writes XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        // Write UserConfiguation element
        this.userConfiguration.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.UserConfiguration);
    }
}

/**
 * @internal Represents a DeleteAttachment request.
 * @sealed
 */
export class DeleteAttachmentRequest extends MultiResponseServiceRequest<DeleteAttachmentResponse> {

    private attachments: Attachment[] = [];

    /**
     * Gets the attachments.
     * @value   The attachments.
     */
    get Attachments(): Attachment[] {
        return this.attachments;
    }

    /**
     * @internal Initializes a new instance of the **DeleteAttachmentRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {DeleteAttachmentResponse}     Service response.
     */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): DeleteAttachmentResponse {
        return new DeleteAttachmentResponse(this.Attachments[responseIndex]);
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return this.Attachments.length;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.DeleteAttachmentResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.DeleteAttachmentResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name,
	 */
    GetXmlElementName(): string {
        return XmlElementNames.DeleteAttachment;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParamCollection(this.Attachments, "Attachments");
        for (let i = 0; i < this.Attachments.length; i++) {
            EwsUtilities.ValidateParam(this.Attachments[i].Id, StringHelper.Format("Attachment[{0}].Id", i));
        }
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.AttachmentIds);

        for (let attachment of this.Attachments) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AttachmentId);
            writer.WriteAttributeValue(XmlAttributeNames.Id, attachment.Id);
            writer.WriteEndElement();
        }

        writer.WriteEndElement();
    }
}

/**
 * @internal Represents a DeleteUserConfiguration request.
 */
export class DeleteUserConfigurationRequest extends MultiResponseServiceRequest<ServiceResponse> { //: IJsonSerializable

    private name: string = null;
    private parentFolderId: FolderId = null;

    /**
     * @internal Gets or sets the name.
     *
     * @Value   The Name
     */
    get Name(): string {
        return this.name;
    }
    set Name(value: string) {
        this.name = value;
    }

    /**
     * @internal Gets or sets the parent folder Id.
     * 
     * @value   The parent folder Id.
     */
    get ParentFolderId(): FolderId {
        return this.parentFolderId;
    }
    set ParentFolderId(value: FolderId) {
        this.parentFolderId = value;
    }

    /**
	 * @internal Initializes a new instance of the **DeleteUserConfigurationRequest** class.
	 *
	 * @param   {ExchangeService}       service   The service.
	 */
    constructor(service: ExchangeService) {
        super(service, ServiceErrorHandling.ThrowOnError);
    }

    /**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {ServiceResponse}	Service response.
	 */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse {
        return new ServiceResponse();
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return 1;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.DeleteUserConfigurationResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.DeleteUserConfigurationResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.DeleteUserConfiguration;
    }

    /**
	 * @internal Validate the request.
	 */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParam(this.name, "name");
        EwsUtilities.ValidateParam(this.parentFolderId, "parentFolderId");
        this.ParentFolderId.Validate(this.Service.RequestedServerVersion);
    }

    /**
	 * @internal Writes XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        // Write UserConfiguationName element
        UserConfiguration.WriteUserConfigurationNameToXml(
            writer,
            XmlNamespace.Messages,
            this.name,
            this.parentFolderId);
    }
}
/**
 * ## @internal *Not Implemented* 
 */
export class ExecuteDiagnosticMethodRequest extends MultiResponseServiceRequest<ExecuteDiagnosticMethodResponse> {
    Verb: string;
    Parameter: any;//System.Xml.XmlNode;
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ExecuteDiagnosticMethodResponse { throw new Error("ExecuteDiagnosticMethodRequest.ts - CreateServiceResponse : Not implemented."); }
    GetExpectedResponseMessageCount(): number { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetExpectedResponseMessageCount : Not implemented."); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); }
    GetResponseMessageXmlElementName(): string { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetResponseMessageXmlElementName : Not implemented."); }
    GetResponseXmlElementName(): string { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetResponseXmlElementName : Not implemented."); }
    GetXmlElementName(): string { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetXmlElementName : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("ExecuteDiagnosticMethodRequest.ts - WriteElementsToXml : Not implemented."); }
}
/** @internal */
export class ExpandGroupRequest extends MultiResponseServiceRequest<ExpandGroupResponse> {
    private emailAddress: EmailAddress = null;
    get EmailAddress(): EmailAddress {
        return this.emailAddress;
    }
    set EmailAddress(value: EmailAddress) {
        this.emailAddress = value;
    }
    constructor(service: ExchangeService) {
        super(service, ServiceErrorHandling.ThrowOnError);
    }

    CreateServiceResponse(service: ExchangeService, responseIndex: number): ExpandGroupResponse { return new ExpandGroupResponse(); }
    GetExpectedResponseMessageCount(): number { return 1; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.ExpandDLResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.ExpandDLResponse; }
    GetXmlElementName(): string { return XmlElementNames.ExpandDL; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.EmailAddress, "EmailAddress");
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (this.EmailAddress != null) {
            this.EmailAddress.WriteToXml(
                writer,
                XmlElementNames.Mailbox,
                XmlNamespace.Messages
                );
        }
    }
}

/**
 * @internal Represents a GetAttachment request. 
 */
export class GetAttachmentRequest extends MultiResponseServiceRequest<GetAttachmentResponse> { //IJsonSerializable
    private attachments: Attachment[] = [];
    private attachmentIds: string[] = [];
    private additionalProperties: PropertyDefinitionBase[] = [];
    private bodyType: BodyType = null;

    /**
     * Gets the attachments.
     * 
     * @value The attachments.
     */
    get Attachments(): Attachment[] {
        return this.attachments;
    }

    /**
     * Gets the attachment ids.
     * 
     * @value The attachment ids.
     */
    get AttachmentIds(): string[] {
        return this.attachmentIds;
    }

    /**
     * Gets the additional properties.
     * 
     * @value The additional properties.
     */
    get AdditionalProperties(): PropertyDefinitionBase[] {
        return this.additionalProperties;
    }

    /**
     * Gets or sets the type of the body.
     * 
     * @value The type of the body.
     */
    get BodyType(): BodyType {
        return this.bodyType;
    }
    set BodyType(value: BodyType) {
        this.bodyType = value;
    }

    /**
     * @internal Gets a value indicating whether the TimeZoneContext SOAP header should be emitted.
     * 
     * @value *true* if the time zone should be emitted; otherwise, *false*.
     */
    get EmitTimeZoneHeader(): boolean {
        return this.additionalProperties.indexOf(Schemas.ItemSchema.MimeContent) >= 0;
    }

    /**
     * @internal Initializes a new instance of the **GetAttachmentRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {GetAttachmentResponse}             Service response.
     */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): GetAttachmentResponse {
        return new GetAttachmentResponse(this.Attachments.length > 0 ? this.Attachments[responseIndex] : null);
    }

    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    GetExpectedResponseMessageCount(): number { return this.Attachments.length + this.AttachmentIds.length; }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseMessageXmlElementName(): string { return XmlElementNames.GetAttachmentResponseMessage; }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string { return XmlElementNames.GetAttachmentResponse; }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string { return XmlElementNames.GetAttachment; }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        super.Validate();
        if (this.Attachments.length > 0) {
            EwsUtilities.ValidateParamCollection(this.Attachments, "Attachments");
        }

        if (this.AttachmentIds.length > 0) {
            EwsUtilities.ValidateParamCollection(this.AttachmentIds, "AttachmentIds");
        }

        if (this.AttachmentIds.length == 0 && this.Attachments.length == 0) {
            throw new ArgumentException(Strings.CollectionIsEmpty, "Attachments/AttachmentIds");
        }
        for (let i = 0; i < this.AdditionalProperties.length; i++) {
            EwsUtilities.ValidateParam(this.AdditionalProperties[i], StringHelper.Format("AdditionalProperties[{0}]", i));
        }
    }

    /**
     * @internal Writes attachment id elements.
     *
     * @param   {EwsServiceXmlWriter}   writer         The writer.
     * @param   {string}                attachmentId   The attachment id.
     */
    WriteAttachmentIdXml(writer: EwsServiceXmlWriter, attachmentId: string): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AttachmentId);
        writer.WriteAttributeValue(XmlAttributeNames.Id, attachmentId);
        writer.WriteEndElement();
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (this.BodyType || this.AdditionalProperties.length > 0) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.AttachmentShape);

            if (hasValue(this.BodyType)) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.BodyType,
                    BodyType[this.BodyType]);
            }

            if (this.AdditionalProperties.length > 0) {
                PropertySet.WriteAdditionalPropertiesToXml(writer, this.AdditionalProperties);
            }

            writer.WriteEndElement(); // AttachmentShape
        }

        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.AttachmentIds);

        for (let attachment of this.Attachments) {
            this.WriteAttachmentIdXml(writer, attachment.Id);
        }

        for (let attachmentId of this.AttachmentIds) {
            this.WriteAttachmentIdXml(writer, attachmentId);
        }

        writer.WriteEndElement();
    }
}

/**
 * @internal Represents a GetClientAccessToken request.
 * 
 * @sealed
 */
export class GetClientAccessTokenRequest extends MultiResponseServiceRequest<GetClientAccessTokenResponse> {

	TokenRequests: ClientAccessTokenRequest[] = [];

	/**
	 * @internal Initializes a new instance of the **GetClientAccessTokenRequest** class.
	 *
	 * @param   {ExchangeService}   	service             The service.
	 * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
	 */
	constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
		super(service, errorHandlingMode);
	}

	/**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {GetClientAccessTokenResponse}		Response object.
	 */
	CreateServiceResponse(service: ExchangeService, responseIndex: number): GetClientAccessTokenResponse {
		return new GetClientAccessTokenResponse(
			this.TokenRequests[responseIndex].Id,
			this.TokenRequests[responseIndex].TokenType);
	}

	/**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of items in response.
	 */
	GetExpectedResponseMessageCount(): number {
		return this.TokenRequests.length;
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2013;
	}

	/**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseMessageXmlElementName(): string {
		return XmlElementNames.GetClientAccessTokenResponseMessage;
	}

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
		return XmlElementNames.GetClientAccessTokenResponse;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
		return XmlElementNames.GetClientAccessToken;
	}

	/**
	 * @internal Validate request.
	 */
    Validate(): void {
		super.Validate();

		if (this.TokenRequests == null || this.TokenRequests.length == 0) {
			throw new ServiceValidationException(Strings.HoldIdParameterIsNotSpecified);
		}
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.TokenRequests);

		for (let tokenRequestInfo of this.TokenRequests) {
			writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.TokenRequest);
			writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Id, tokenRequestInfo.Id);
			writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.TokenType, ClientAccessTokenType[tokenRequestInfo.TokenType]);
			if (!StringHelper.IsNullOrEmpty(tokenRequestInfo.Scope)) {
				writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.HighlightTermScope, tokenRequestInfo.Scope);
			}

			writer.WriteEndElement();
		}

		writer.WriteEndElement();
	}
}

/**
 * @internal Represents a request to a GetConversationItems operation
 * 
 * @sealed
 */
export class GetConversationItemsRequest extends MultiResponseServiceRequest<GetConversationItemsResponse> {//IJsonSerializable

    /**
     * @internal Gets or sets the conversations.
     */
    Conversations: ConversationRequest[] = null;

    /**
     * Gets or sets the item properties.
     */
    ItemProperties: PropertySet = null;

    /**
     * @internal Gets or sets the folders to ignore.
     */
    FoldersToIgnore: FolderIdCollection = null;

    /**
     * @internal Gets or sets the maximum number of items to return.
     * 
     * @Nullable
     */
    MaxItemsToReturn: number = null;

    /**
     * @internal Gets or sets the conversation sort order.
     * 
     * @Nullable
     */
    SortOrder: ConversationSortOrder = null;

    /**
     * @internal Gets or sets the mailbox search location to include in the search.
     * 
     * @Nullable
     */
    MailboxScope: MailboxSearchLocation = null;

    /**
	 * @internal Initializes a new instance of the **GetConversationItemsRequest** class.
	 *
	 * @param   {ExchangeService}       service   The service.
	 * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
	 */
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    /**
	 * @internal Creates service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {GetConversationItemsResponse}	    Service response.
	 */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): GetConversationItemsResponse {
        return new GetConversationItemsResponse(this.ItemProperties);
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return this.Conversations ? this.Conversations.length : 0;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.GetConversationItemsResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetConversationItemsResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetConversationItems;
    }

    /**
	 * @internal Validate the request.
	 */
    Validate(): void {
        super.Validate();

        // SearchScope is only valid for Exchange2013 or higher
        //
        if (this.MailboxScope &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "MailboxScope",
                    ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
    }

    /**
	 * @internal Writes XML attributes.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);
    }

    /**
	 * @internal Writes XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.ItemProperties.WriteToXml(writer, ServiceObjectType.Item);

        //this.FoldersToIgnore.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.FoldersToIgnore);
        this.FoldersToIgnore.WriteToXml(writer, XmlElementNames.FoldersToIgnore, XmlNamespace.Messages); //info: temp workaround github #52 

        if (this.MaxItemsToReturn) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MaxItemsToReturn, this.MaxItemsToReturn);
        }

        if (hasValue(this.SortOrder)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SortOrder, ConversationSortOrder[this.SortOrder]);
        }

        if (hasValue(this.MailboxScope)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MailboxScope, MailboxSearchLocation[this.MailboxScope]);
        }

        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Conversations);

        this.Conversations.forEach((conversation) => conversation.WriteToXml(writer, XmlElementNames.Conversation));
        writer.WriteEndElement();
    }
}

/**
 * @internal GetEvents request
 */
export class GetEventsRequest extends MultiResponseServiceRequest<GetEventsResponse> {

	private subscriptionId: string = null;
	private watermark: string = null;

	/**
	 * Gets or sets the subscription id.
	 * 
	 * @value	The subscription id.
	 */
	get SubscriptionId(): string {
		return this.subscriptionId;
	}
	set SubscriptionId(value: string) {
		this.subscriptionId = value;
	}

	/**
	 * Gets or sets the watermark.
	 * 
	 * @value	The watermark.
	 */
	get Watermark(): string {
		return this.watermark;
	}
	set Watermark(value: string) {
		this.watermark = value;
	}

	/**
	 * @internal Initializes a new instance of the **GetEventsRequest** class.
	 *
	 * @param   {ExchangeService}   service   The service.
	 */
	constructor(service: ExchangeService) {
		super(service, ServiceErrorHandling.ThrowOnError);
	}

	/**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {GetEventsResponse}		Service response.
	 */
	CreateServiceResponse(service: ExchangeService, responseIndex: number): GetEventsResponse {
		return new GetEventsResponse();
	}

	/**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
	GetExpectedResponseMessageCount(): number {
		return 1;
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
	GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2007_SP1;
	}

	/**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      XML element name,
	 */
	GetResponseMessageXmlElementName(): string {
		return XmlElementNames.GetEventsResponseMessage;
	}

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
	GetResponseXmlElementName(): string {
		return XmlElementNames.GetEventsResponse;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
	GetXmlElementName(): string {
		return XmlElementNames.GetEvents;
	}

	/**
	 * @internal Validate request.
	 */
	Validate(): void {
		super.Validate();
		EwsUtilities.ValidateNonBlankStringParam(this.SubscriptionId, "SubscriptionId");
		EwsUtilities.ValidateNonBlankStringParam(this.Watermark, "Watermark");
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		writer.WriteElementValue(
			XmlNamespace.Messages,
			XmlElementNames.SubscriptionId,
			this.SubscriptionId);

		writer.WriteElementValue(
			XmlNamespace.Messages,
			XmlElementNames.Watermark,
			this.Watermark);
	}
}

/**
 * @internal Represents a GetServerTimeZones request.
 */
export class GetServerTimeZonesRequest extends MultiResponseServiceRequest<GetServerTimeZonesResponse> {
    private ids: string[];

    /**
     * @internal Gets or sets the ids of the time zones that should be returned by the server.
     */
    get Ids(): string[] {
        return this.ids;
    }
    set Ids(value: string[]) {
        this.ids = value;
    }

    /**
     * @internal Initializes a new instance of the **GetServerTimeZonesRequest** class.
     *
     * @param   {service}   service   The service.
     */
    constructor(service: ExchangeService) {
        super(service, ServiceErrorHandling.ThrowOnError);
    }

    /**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {SyncFolderItemsResponse}		Response object.
	 */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): GetServerTimeZonesResponse {
        return new GetServerTimeZonesResponse();
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of items in response.
	 */
    GetExpectedResponseMessageCount(): number {
        return 1;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.GetServerTimeZonesResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetServerTimeZonesResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetServerTimeZones;
    }

    /**
	 * @internal Validate request.
	 */
    Validate(): void {
        super.Validate();

        if (this.ids != null) {
            EwsUtilities.ValidateParamCollection(this.ids, "Ids");
        }
    }

    /**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (this.Ids != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Ids);

            for (let id of this.ids) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.Id,
                    id);
            }

            writer.WriteEndElement(); // Ids
        }
    }
}

/**
 * @internal Represents a GetUserConfiguration request.
 */
export class GetUserConfigurationRequest extends MultiResponseServiceRequest<GetUserConfigurationResponse> { //IJsonSerializable

    private static EnumDelimiter: string = ",";

    private name: string = null;
    private parentFolderId: FolderId = null;
    private properties: UserConfigurationProperties = UserConfigurationProperties.Id;
    private userConfiguration: UserConfiguration = null;

    /**
     * @internal Gets or sets the name.
     * 
     * @value   The name.
     */
    get Name(): string {
        return this.name;
    }
    set Name(value: string) {
        this.name = value;
    }

    /**
     * @internal Gets or sets the parent folder Id.
     * 
     * @value   The parent folder Id.
     */
    get ParentFolderId(): FolderId {
        return this.parentFolderId;
    }
    set ParentFolderId(value: FolderId) {
        this.parentFolderId = value;
    }

    /**
     * @internal Gets or sets the user configuration.
     * 
     * @value   The userConfiguration.
     */
    get UserConfiguration(): UserConfiguration {
        return this.userConfiguration;
    }
    set UserConfiguration(value: UserConfiguration) {
        this.userConfiguration = value;
        this.name = this.userConfiguration.Name;
        this.parentFolderId = this.userConfiguration.ParentFolderId;
    }

    /**
     * @internal Gets or sets the properties.
     * 
     * @value   The properties.
     */
    get Properties(): UserConfigurationProperties {
        return this.properties;
    }
    set Properties(value: UserConfigurationProperties) {
        this.properties = value;
    }

    /**
	 * @internal Initializes a new instance of the **GetUserConfigurationRequest** class.
	 *
	 * @param   {ExchangeService}       service   The service.
	 */
    constructor(service: ExchangeService) {
        super(service, ServiceErrorHandling.ThrowOnError);
    }

    /**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {GetUserConfigurationResponse}	    Service response.
	 */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): GetUserConfigurationResponse {
        // In the case of UserConfiguration.Load(), this.userConfiguration is set.
        if (this.userConfiguration == null) {
            this.userConfiguration = new UserConfiguration(service, this.properties);
            this.userConfiguration.Name = this.name;
            this.userConfiguration.ParentFolderId = this.parentFolderId;
        }

        return new GetUserConfigurationResponse(this.userConfiguration);
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return 1;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.GetUserConfigurationResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetUserConfigurationResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.GetUserConfiguration;
    }

    /**
	 * @internal Validate the request.
	 */
    Validate(): void {
        super.Validate();

        EwsUtilities.ValidateParam(this.name, "name");
        EwsUtilities.ValidateParam(this.parentFolderId, "parentFolderId");
        this.ParentFolderId.Validate(this.Service.RequestedServerVersion);
    }

    /**
	 * @internal Writes XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        // Write UserConfiguationName element
        UserConfiguration.WriteUserConfigurationNameToXml(
            writer,
            XmlNamespace.Messages,
            this.name,
            this.parentFolderId);

        // Write UserConfigurationProperties element
        writer.WriteElementValue(
            XmlNamespace.Messages,
            XmlElementNames.UserConfigurationProperties,
            this.properties === UserConfigurationProperties.All ? UserConfigurationProperties[this.properties] : EnumHelper.ToString(UserConfigurationProperties, this.properties).split(GetUserConfigurationRequest.EnumDelimiter).join("")); 
            //.replace(GetUserConfigurationRequest.EnumDelimiter, " ")); //info: replace only replaces first occurance
    }
}
/** @internal */
export class MarkAllItemsAsReadRequest extends MultiResponseServiceRequest<ServiceResponse> {//IJsonSerializable
    private folderIds: FolderIdWrapperList = new FolderIdWrapperList();
    get FolderIds(): FolderIdWrapperList {
        return this.folderIds;
    }
    ReadFlag: boolean = false;
    SuppressReadReceipts: boolean = false;
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { return new ServiceResponse(); }
    GetExpectedResponseMessageCount(): number { return this.FolderIds.Count; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2013; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.MarkAllItemsAsReadResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.MarkAllItemsAsReadResponse; }
    GetXmlElementName(): string { return XmlElementNames.MarkAllItemsAsRead; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ReadFlag, this.ReadFlag);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SuppressReadReceipts, this.SuppressReadReceipts);

        this.FolderIds.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.FolderIds);
    }
}


/** @internal */
export class MarkAsJunkRequest extends MultiResponseServiceRequest<MarkAsJunkResponse> {//IJsonSerializable
    private itemIds: ItemIdWrapperList = new ItemIdWrapperList();
    get ItemIds(): ItemIdWrapperList {
        return this.itemIds;
    }
    IsJunk: boolean = false;
    MoveItem: boolean = false;
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): MarkAsJunkResponse { return new MarkAsJunkResponse(); }
    GetExpectedResponseMessageCount(): number { return this.itemIds.Count; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2013; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.MarkAsJunkResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.MarkAsJunkResponse; }
    GetXmlElementName(): string { return XmlElementNames.MarkAsJunk; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.ItemIds, "ItemIds");
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.IsJunk, this.IsJunk);
        writer.WriteAttributeValue(XmlAttributeNames.MoveItem, this.MoveItem);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { this.itemIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.ItemIds); }
}
/** @internal */
export class ResolveNamesRequest extends MultiResponseServiceRequest<ResolveNamesResponse> {//IJsonSerializable

    
    private static searchScopeMap: LazyMember<Dictionary<ResolveNameSearchLocation, string>> = new LazyMember<Dictionary<ResolveNameSearchLocation, string>>(() => {
        var map: Dictionary<ResolveNameSearchLocation, string> = new Dictionary<ResolveNameSearchLocation, string>((rnsl) => ResolveNameSearchLocation[rnsl]);
        map.Add(ResolveNameSearchLocation.DirectoryOnly, "ActiveDirectory");
        map.Add(ResolveNameSearchLocation.DirectoryThenContacts, "ActiveDirectoryContacts");
        map.Add(ResolveNameSearchLocation.ContactsOnly, "Contacts");
        map.Add(ResolveNameSearchLocation.ContactsThenDirectory, "ContactsActiveDirectory");
        return map;
    });

    private nameToResolve: string = null;
    private returnFullContactData: boolean = false;
    private searchLocation: ResolveNameSearchLocation = ResolveNameSearchLocation.DirectoryOnly;
    private contactDataPropertySet: PropertySet = null;
    private parentFolderIds: FolderIdWrapperList = new FolderIdWrapperList();
    set NameToResolve(value: string) {
        this.nameToResolve = value;
    }
    get NameToResolve(): string {
        return this.nameToResolve;
    }
    get ReturnFullContactData(): boolean {
        return this.returnFullContactData;
    }
    set ReturnFullContactData(value: boolean) {
        this.returnFullContactData = value;
    }
    get SearchLocation(): ResolveNameSearchLocation {
        return this.searchLocation;
    }
    set SearchLocation(value: ResolveNameSearchLocation) {
        this.searchLocation = value;
    }
    get ContactDataPropertySet(): PropertySet {
        return this.contactDataPropertySet;
    }
    set ContactDataPropertySet(value: PropertySet) {
        this.contactDataPropertySet = value;
    }
    get ParentFolderIds(): FolderIdWrapperList {
        return this.parentFolderIds;
    }

    constructor(service: ExchangeService) {
        super(service, ServiceErrorHandling.ThrowOnError);
    }

    CreateServiceResponse(service: ExchangeService, responseIndex: number): ResolveNamesResponse {return new ResolveNamesResponse(service);}
    GetExpectedResponseMessageCount(): number { return 1; }
    GetMinimumRequiredServerVersion(): ExchangeVersion {return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.ResolveNamesResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.ResolveNamesResponse; }
    GetXmlElementName(): string { return XmlElementNames.ResolveNames;}
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateNonBlankStringParam(this.NameToResolve, "NameToResolve");
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(            
                XmlAttributeNames.ReturnFullContactData,
                this.ReturnFullContactData);

            var searchScope:IOutParam<string> = {outValue:null};

            ResolveNamesRequest.searchScopeMap.Member.tryGetValue(this.SearchLocation, searchScope);

            EwsLogging.Assert(
                !StringHelper.IsNullOrEmpty(searchScope.outValue),
                "ResolveNameRequest.WriteAttributesToXml",
                "The specified search location cannot be mapped to an EWS search scope.");

            var propertySet:IOutParam<string>  = {outValue:null};
            if (this.contactDataPropertySet != null)
            {
                PropertySet.DefaultPropertySetMap.Member.tryGetValue(this.contactDataPropertySet.BasePropertySet, propertySet);
            }

            if (!this.Service.Exchange2007CompatibilityMode)
            {
                writer.WriteAttributeValue(XmlAttributeNames.SearchScope, searchScope.outValue);
            }
            if (!StringHelper.IsNullOrEmpty(propertySet.outValue))
            {
                writer.WriteAttributeValue(XmlAttributeNames.ContactDataShape, propertySet.outValue);
            }
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
            this.ParentFolderIds.WriteToXml(
                writer,
                XmlNamespace.Messages,
                XmlElementNames.ParentFolderIds);

            writer.WriteElementValue(
                XmlNamespace.Messages,
                XmlElementNames.UnresolvedEntry,
                this.NameToResolve);
    }
}

/**
 * @internal Represents a SearchMailboxesRequest request. 
 * 
 * @sealed
 */
export class SearchMailboxesRequest extends MultiResponseServiceRequest<SearchMailboxesResponse> implements IDiscoveryVersionable {

    private searchQueries: MailboxQuery[] = [];
    private searchResultType: SearchResultType = SearchResultType.PreviewOnly;
    private sortOrder: SortDirection = SortDirection.Ascending;
    private sortByProperty: string = null;
    private performDeduplication: boolean = false;
    private pageSize: number = 0;
    private pageItemReference: string = null;
    private pageDirection: SearchPageDirection = SearchPageDirection.Next;
    private previewItemResponseShape: PreviewItemResponseShape = null;

    /**
     * Collection of query + mailboxes
     */
    get SearchQueries(): MailboxQuery[] {
        return this.searchQueries;
    }
    set SearchQueries(value: MailboxQuery[]) {
        this.searchQueries = value;
    }

    /**
     * Search result type
     */
    get ResultType(): SearchResultType {
        return this.searchResultType;
    }
    set ResultType(value: SearchResultType) {
        this.searchResultType = value;
    }

    /**
     * Preview item response shape
     */
    get PreviewItemResponseShape(): PreviewItemResponseShape {
        return this.previewItemResponseShape;
    }
    set PreviewItemResponseShape(value: PreviewItemResponseShape) {
        this.previewItemResponseShape = value;
    }

    /**
     * Sort order
     */
    get SortOrder(): SortDirection {
        return this.sortOrder;
    }
    set SortOrder(value: SortDirection) {
        this.sortOrder = value;
    }

    /**
     * Sort by property name
     */
    get SortByProperty(): string {
        return this.sortByProperty;
    }
    set SortByProperty(value: string) {
        this.sortByProperty = value;
    }

    /**
     * Query language
     */
    Language: string = null;

    /**
     * Perform deduplication or not
     */
    get PerformDeduplication(): boolean {
        return this.performDeduplication;
    }
    set PerformDeduplication(value: boolean) {
        this.performDeduplication = value;
    }

    /**
     * Page size
     */
    get PageSize(): number {
        return this.pageSize;
    }
    set PageSize(value: number) {
        this.pageSize = value;
    }

    /**
     * Page item reference
     */
    get PageItemReference(): string {
        return this.pageItemReference;
    }
    set PageItemReference(value: string) {
        this.pageItemReference = value;
    }

    /**
     * Page direction
     */
    get PageDirection(): SearchPageDirection {
        return this.pageDirection;
    }
    set PageDirection(value: SearchPageDirection) {
        this.pageDirection = value;
    }

    /**
     * Gets or sets the server version.
     * @interface IDiscoveryVersionable
     */
    ServerVersion: number = 0;

    /**
	 * @internal Initializes a new instance of the **SearchMailboxesRequest** class.
	 *
	 * @param   {ExchangeService}       service   The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
	 */
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    /**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {SearchMailboxesResponse}	Service response.
	 */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): SearchMailboxesResponse {
        return new SearchMailboxesResponse();
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return 1;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2013;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.SearchMailboxesResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.SearchMailboxesResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.SearchMailboxes;
    }

    /**
     * @internal Parses the response.
     * See O15:324151 (OfficeDev bug/issue not visible to external world) on why we need to override ParseResponse here instead of calling the one in MultiResponseServiceRequest.cs 
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ParseResponse(jsonBody: any): any {
        let serviceResponses: ServiceResponseCollection<SearchMailboxesResponse> = new ServiceResponseCollection<SearchMailboxesResponse>();

        let jsResponseMessages = EwsServiceJsonReader.ReadAsArray(jsonBody[XmlElementNames.ResponseMessages], this.GetResponseMessageXmlElementName());

        for (let jsResponseObject of jsResponseMessages) {
            let response: SearchMailboxesResponse = new SearchMailboxesResponse();
            response.LoadFromXmlJsObject(jsResponseObject, this.Service);
            serviceResponses.Add(response);
        }

        return serviceResponses;
    }

    /**
	 * @internal Validate the request.
	 */
    Validate(): void {
        super.Validate();

        if (this.SearchQueries == null || this.SearchQueries.length == 0) {
            throw new ServiceValidationException(Strings.MailboxQueriesParameterIsNotSpecified);
        }

        for (let searchQuery of this.SearchQueries) {
            if (searchQuery.MailboxSearchScopes == null || searchQuery.MailboxSearchScopes.length == 0) {
                throw new ServiceValidationException(Strings.MailboxQueriesParameterIsNotSpecified);
            }

            for (let searchScope of searchQuery.MailboxSearchScopes) {
                if (searchScope.ExtendedAttributes != null && searchScope.ExtendedAttributes.length > 0 && !DiscoverySchemaChanges.SearchMailboxesExtendedData.IsCompatible(this)) {
                    throw new ServiceVersionException(
                        StringHelper.Format(
                            Strings.ClassIncompatibleWithRequestVersion,
                            "ExtendedAttribute", //typeof (ExtendedAttribute).Name,
                            DiscoverySchemaChanges.SearchMailboxesExtendedData.MinimumServerVersion));
                }

                if (searchScope.SearchScopeType != MailboxSearchScopeType.LegacyExchangeDN && (!DiscoverySchemaChanges.SearchMailboxesExtendedData.IsCompatible(this) || !DiscoverySchemaChanges.SearchMailboxesAdditionalSearchScopes.IsCompatible(this))) {
                    throw new ServiceVersionException(
                        StringHelper.Format(
                            Strings.EnumValueIncompatibleWithRequestVersion,
                            MailboxSearchScopeType[searchScope.SearchScopeType],
                            "MailboxSearchScopeType", //typeof (MailboxSearchScopeType).Name,
                            DiscoverySchemaChanges.SearchMailboxesAdditionalSearchScopes.MinimumServerVersion));
                }
            }
        }

        if (!StringHelper.IsNullOrEmpty(this.SortByProperty)) {
            let prop: PropertyDefinitionBase = null;
            try {
                prop = ServiceObjectSchema.FindPropertyDefinition(this.SortByProperty);
            }
            catch (ex) { //KeyNotFoundException
            }

            if (prop == null) {
                throw new ServiceValidationException(StringHelper.Format(Strings.InvalidSortByPropertyForMailboxSearch, this.SortByProperty));
            }
        }
    }

    /**
     * @internal Writes XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SearchQueries);
        for (let mailboxQuery of this.SearchQueries) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MailboxQuery);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Query, mailboxQuery.Query);
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MailboxSearchScopes);
            for (let mailboxSearchScope of mailboxQuery.MailboxSearchScopes) {
                // The checks here silently downgrade the schema based on compatability checks, to recieve errors use the validate method
                if (mailboxSearchScope.SearchScopeType == MailboxSearchScopeType.LegacyExchangeDN || DiscoverySchemaChanges.SearchMailboxesAdditionalSearchScopes.IsCompatible(this)) {
                    writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MailboxSearchScope);
                    writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Mailbox, mailboxSearchScope.Mailbox);
                    writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SearchScope, MailboxSearchLocation[mailboxSearchScope.SearchScope]);

                    if (DiscoverySchemaChanges.SearchMailboxesExtendedData.IsCompatible(this)) {
                        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ExtendedAttributes);

                        if (mailboxSearchScope.SearchScopeType != MailboxSearchScopeType.LegacyExchangeDN) {
                            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ExtendedAttribute);
                            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExtendedAttributeName, XmlElementNames.SearchScopeType);
                            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExtendedAttributeValue, MailboxSearchScopeType[mailboxSearchScope.SearchScopeType]);
                            writer.WriteEndElement();
                        }

                        if (mailboxSearchScope.ExtendedAttributes != null && mailboxSearchScope.ExtendedAttributes.length > 0) {
                            for (let attribute of mailboxSearchScope.ExtendedAttributes) {
                                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ExtendedAttribute);
                                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExtendedAttributeName, attribute.Name);
                                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExtendedAttributeValue, attribute.Value);
                                writer.WriteEndElement();
                            }
                        }

                        writer.WriteEndElement();  // ExtendedData
                    }

                    writer.WriteEndElement();   // MailboxSearchScope
                }
            }

            writer.WriteEndElement();   // MailboxSearchScopes
            writer.WriteEndElement();   // MailboxQuery
        }

        writer.WriteEndElement();   // SearchQueries
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ResultType, SearchResultType[this.ResultType]);

        if (this.PreviewItemResponseShape != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.PreviewItemResponseShape);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.BaseShape, PreviewItemBaseShape[this.PreviewItemResponseShape.BaseShape]);
            if (this.PreviewItemResponseShape.AdditionalProperties != null && this.PreviewItemResponseShape.AdditionalProperties.length > 0) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AdditionalProperties);
                for (let additionalProperty of this.PreviewItemResponseShape.AdditionalProperties) {
                    additionalProperty.WriteToXml(writer);
                }

                writer.WriteEndElement();   // AdditionalProperties
            }

            writer.WriteEndElement();   // PreviewItemResponseShape
        }

        if (!StringHelper.IsNullOrEmpty(this.SortByProperty)) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SortBy);
            writer.WriteAttributeValue(XmlElementNames.Order, SortDirection[this.SortOrder]);
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.FieldURI);
            writer.WriteAttributeValue(XmlElementNames.FieldURI, this.sortByProperty);
            writer.WriteEndElement();   // FieldURI
            writer.WriteEndElement();   // SortBy
        }

        // Language
        if (!StringHelper.IsNullOrEmpty(this.Language)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Language, this.Language);
        }

        // Dedupe
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Deduplication, this.performDeduplication);

        if (this.PageSize > 0) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageSize, this.PageSize);
        }

        if (!StringHelper.IsNullOrEmpty(this.PageItemReference)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageItemReference, this.PageItemReference);
        }

        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageDirection, SearchPageDirection[this.PageDirection]);
    }
}
/** @internal */
export class SendItemRequest extends MultiResponseServiceRequest<ServiceResponse> {//IJsonSerializable
    
    private items: Item[] = [];
    private savedCopyDestinationFolderId: FolderId = null;
    get Items(): Item[] {
        return this.items;
    }
    set Items(value: Item[]) {
        this.items = value;
    }
    get SavedCopyDestinationFolderId(): FolderId {
        return this.savedCopyDestinationFolderId;
    }
    set SavedCopyDestinationFolderId(value: FolderId) {
        this.savedCopyDestinationFolderId = value;
    }

    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }

    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { return new ServiceResponse(); }
    GetExpectedResponseMessageCount(): number { return this.items.length; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.SendItemResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.SendItemResponse; }
    GetXmlElementName(): string { return XmlElementNames.SendItem; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.Items, "Items");

        if (this.SavedCopyDestinationFolderId != null) {
            this.SavedCopyDestinationFolderId.Validate(this.Service.RequestedServerVersion);
        }
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        writer.WriteAttributeValue(            
            XmlAttributeNames.SaveItemToFolder,
            this.SavedCopyDestinationFolderId != null);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ItemIds);

        for (var item of this.items) {
            item.Id.WriteToXml(writer);//, XmlElementNames.ItemId);
        }

        writer.WriteEndElement(); // ItemIds

        if (this.SavedCopyDestinationFolderId != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SavedItemFolderId);
            this.SavedCopyDestinationFolderId.WriteToXml(writer);
            writer.WriteEndElement();
        }
    }
}
/**
 * ## @internal *Not Implemented*   Server to server call - not needed
 */
export class SetClientExtensionRequest extends MultiResponseServiceRequest<ServiceResponse> {
    private actions: any[];//System.Collections.Generic.List<T>;
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { throw new Error("SetClientExtensionRequest.ts - CreateServiceResponse : Not implemented."); }
    GetExpectedResponseMessageCount(): number { throw new Error("SetClientExtensionRequest.ts - GetExpectedResponseMessageCount : Not implemented."); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { throw new Error("SetClientExtensionRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); }
    GetResponseMessageXmlElementName(): string { throw new Error("SetClientExtensionRequest.ts - GetResponseMessageXmlElementName : Not implemented."); }
    GetResponseXmlElementName(): string { throw new Error("SetClientExtensionRequest.ts - GetResponseXmlElementName : Not implemented."); }
    GetXmlElementName(): string { throw new Error("SetClientExtensionRequest.ts - GetXmlElementName : Not implemented."); }
    Validate(): any { throw new Error("SetClientExtensionRequest.ts - Validate : Not implemented."); }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("SetClientExtensionRequest.ts - WriteElementsToXml : Not implemented."); }
}

/**
 * @internal Represents a SyncFolderHierarchy request.
 */
export class SyncFolderHierarchyRequest extends MultiResponseServiceRequest<SyncFolderHierarchyResponse> {

	private propertySet: PropertySet = null;
	private syncFolderId: FolderId = null;
	private syncState: string = null;

	/**
	 * Gets or sets the property set.
	 * 
	 * @value	The property set
	 */
	get PropertySet(): PropertySet {
		return this.propertySet;
	}
	set PropertySet(value: PropertySet) {
		this.propertySet = value;
	}

	/**
	 * Gets or sets the sync folder id.
	 * 
	 * @value	The sync folder id.
	 */
	get SyncFolderId(): FolderId {
		return this.syncFolderId;
	}
	set SyncFolderId(value: FolderId) {
		this.syncFolderId = value;
	}

	/**
	 * Gets or sets the state of the sync.
	 * 
	 * @value	The state of the sync.
	 */
	get SyncState(): string {
		return this.syncState;
	}
	set SyncState(value: string) {
		this.syncState = value;
	}

	/**
	 * @internal Initializes a new instance of the **SyncFolderItemsRequest** class.
	 *
	 * @param   {ExchangeService}   	service             The service.
	 */
	constructor(service: ExchangeService) {
		super(service, ServiceErrorHandling.ThrowOnError);
	}

	/**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {SyncFolderItemsResponse}		Response object.
	 */
	CreateServiceResponse(service: ExchangeService, responseIndex: number): SyncFolderHierarchyResponse {
		return new SyncFolderHierarchyResponse(this.PropertySet);
	}

	/**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of items in response.
	 */
	GetExpectedResponseMessageCount(): number {
		return 1;
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2007_SP1;
	}

	/**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseMessageXmlElementName(): string {
		return XmlElementNames.SyncFolderHierarchyResponseMessage;
	}

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
		return XmlElementNames.SyncFolderHierarchyResponse;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
		return XmlElementNames.SyncFolderHierarchy;
	}

	/**
	 * @internal Validate request.
	 */
    Validate(): void {
		super.Validate();
		EwsUtilities.ValidateParam(this.PropertySet, "PropertySet");
		if (this.SyncFolderId != null) {
			this.SyncFolderId.Validate(this.Service.RequestedServerVersion);
		}

		this.PropertySet.ValidateForRequest(this, false /*summaryPropertiesOnly*/);
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		this.PropertySet.WriteToXml(writer, ServiceObjectType.Folder);

		if (this.SyncFolderId != null) {
			writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SyncFolderId);
			this.SyncFolderId.WriteToXml(writer);
			writer.WriteEndElement();
		}

		writer.WriteElementValue(
			XmlNamespace.Messages,
			XmlElementNames.SyncState,
			this.SyncState);
	}
}

/**
 * @internal Represents a SyncFolderItems request.
 */
export class SyncFolderItemsRequest extends MultiResponseServiceRequest<SyncFolderItemsResponse> {

	private propertySet: PropertySet = null;
	private syncFolderId: FolderId = null;
	private syncScope: SyncFolderItemsScope = SyncFolderItemsScope.NormalItems;
	private syncState: string = null;
	private ignoredItemIds: ItemIdWrapperList = new ItemIdWrapperList();
	private maxChangesReturned: number = 100;
	private numberOfDays: number = 0;

	/**
	 * Gets or sets the property set.
	 * 
	 * @value	The property set
	 */
	get PropertySet(): PropertySet {
		return this.propertySet;
	}
	set PropertySet(value: PropertySet) {
		this.propertySet = value;
	}

	/**
	 * Gets or sets the sync folder id.
	 * 
	 * @value	The sync folder id.
	 */
	get SyncFolderId(): FolderId {
		return this.syncFolderId;
	}
	set SyncFolderId(value: FolderId) {
		this.syncFolderId = value;
	}

	/**
	 * Gets or sets the scope of the sync.
	 * 
	 * @value	The scope of the sync.
	 */
	get SyncScope(): SyncFolderItemsScope {
		return this.syncScope;
	}
	set SyncScope(value: SyncFolderItemsScope) {
		this.syncScope = value;
	}

	/**
	 * Gets or sets the state of the sync.
	 * 
	 * @value	The state of the sync.
	 */
	get SyncState(): string {
		return this.syncState;
	}
	set SyncState(value: string) {
		this.syncState = value;
	}

	/**
	 * Gets the list of ignored item ids.
	 * 
	 * @value	The ignored item ids.
	 */
	get IgnoredItemIds(): ItemIdWrapperList {
		return this.ignoredItemIds;
	}

	/**
	 * Gets or sets the maximum number of changes returned by SyncFolderItems.
	 * Values must be between 1 and 512.
	 * Default is 100.
	 */
	get MaxChangesReturned(): number {
		return this.maxChangesReturned;
	}
	set MaxChangesReturned(value: number) {
		if (value >= 1 && value <= 512) {
			this.maxChangesReturned = value;
		}
		else {
			throw new ArgumentException(Strings.MaxChangesMustBeBetween1And512);
		}
	}

	/**
	 * Gets or sets the number of days of content returned by SyncFolderItems.
	 * Zero means return all content.
	 * Default is zero.
	 */
	get NumberOfDays(): number {
		return this.numberOfDays;
	}
	set NumberOfDays(value: number) {
		if (value >= 0) {
			this.numberOfDays = value;
		}
		else {
			throw new ArgumentException(Strings.NumberOfDaysMustBePositive);
		}
	}

	/**
	 * @internal Initializes a new instance of the **SyncFolderItemsRequest** class.
	 *
	 * @param   {ExchangeService}   	service             The service.
	 */
	constructor(service: ExchangeService) {
		super(service, ServiceErrorHandling.ThrowOnError);
	}

	/**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {SyncFolderItemsResponse}		Response object.
	 */
	CreateServiceResponse(service: ExchangeService, responseIndex: number): SyncFolderItemsResponse {
		return new SyncFolderItemsResponse(this.PropertySet);
	}

	/**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of items in response.
	 */
	GetExpectedResponseMessageCount(): number {
		return 1;
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2007_SP1;
	}

	/**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseMessageXmlElementName(): string {
		return XmlElementNames.SyncFolderItemsResponseMessage;
	}

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetResponseXmlElementName(): string {
		return XmlElementNames.SyncFolderItemsResponse;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string {
		return XmlElementNames.SyncFolderItems;
	}

	/**
	 * @internal Validate request.
	 */
    Validate(): void {
		super.Validate();
		EwsUtilities.ValidateParam(this.PropertySet, "PropertySet");
		EwsUtilities.ValidateParam(this.SyncFolderId, "SyncFolderId");
		this.SyncFolderId.Validate(this.Service.RequestedServerVersion);

		// SyncFolderItemsScope enum was introduced with Exchange2010.  Only
		// value NormalItems is valid with previous server versions.
		if (this.Service.RequestedServerVersion < ExchangeVersion.Exchange2010 &&
			this.syncScope != SyncFolderItemsScope.NormalItems) {
			throw new ServiceVersionException(
				StringHelper.Format(
					Strings.EnumValueIncompatibleWithRequestVersion,
					SyncFolderItemsScope[this.syncScope],
					"SyncFolderItemsScope",
					ExchangeVersion[ExchangeVersion.Exchange2010]));
		}

		// NumberOfDays was introduced with Exchange 2013.
		if (this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013 &&
			this.NumberOfDays != 0) {
			throw new ServiceVersionException(
				StringHelper.Format(
					Strings.ParameterIncompatibleWithRequestVersion,
					"numberOfDays",
					ExchangeVersion[ExchangeVersion.Exchange2013]));
		}

		// SyncFolderItems can only handle summary properties
		this.PropertySet.ValidateForRequest(this, true /*summaryPropertiesOnly*/);
	}

	/**
	 * @internal Writes the elements to XML writer.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		this.PropertySet.WriteToXml(writer, ServiceObjectType.Item);

		writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SyncFolderId);
		this.SyncFolderId.WriteToXml(writer);
		writer.WriteEndElement();

		writer.WriteElementValue(
			XmlNamespace.Messages,
			XmlElementNames.SyncState,
			this.SyncState);

		this.IgnoredItemIds.WriteToXml(
			writer,
			XmlNamespace.Messages,
			XmlElementNames.Ignore);

		writer.WriteElementValue(
			XmlNamespace.Messages,
			XmlElementNames.MaxChangesReturned,
			this.MaxChangesReturned);

		if (this.Service.RequestedServerVersion >= ExchangeVersion.Exchange2010) {
			writer.WriteElementValue(
				XmlNamespace.Messages,
				XmlElementNames.SyncScope,
				SyncFolderItemsScope[this.syncScope]);
		}

		if (this.NumberOfDays != 0) {
			writer.WriteElementValue(
				XmlNamespace.Messages,
				XmlElementNames.NumberOfDays,
				this.numberOfDays);
		}
	}
}

/**
 * @internal Represents an Unsubscribe request.
 */
export class UnsubscribeRequest extends MultiResponseServiceRequest<ServiceResponse> {

	/**
	 * Gets or sets the subscription id.
	 */
	SubscriptionId: string;

	/**
	 * @internal Initializes a new instance of the **UnsubscribeRequest** class.
	 *
	 * @param   {ExchangeService}   service   The service.
	 */
	constructor(service: ExchangeService) {
		super(service, ServiceErrorHandling.ThrowOnError);
	}

	/**
	 * @internal Creates service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {ServiceResponse}	Service response.
	 */
	CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { return new ServiceResponse(); }

	/**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
	GetExpectedResponseMessageCount(): number { return 1; }

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
	GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

	/**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
	GetResponseMessageXmlElementName(): string { return XmlElementNames.UnsubscribeResponseMessage; }

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
	GetResponseXmlElementName(): string { return XmlElementNames.UnsubscribeResponse; }

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
	GetXmlElementName(): string { return XmlElementNames.Unsubscribe; }

	/**
	 * @internal Validate the request.
	 */
	Validate(): void {
		super.Validate();
		EwsUtilities.ValidateNonBlankStringParam(this.SubscriptionId, "SubscriptionId");
	}

	/**
	 * @internal Writes XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		writer.WriteElementValue(
			XmlNamespace.Messages,
			XmlElementNames.SubscriptionId,
			this.SubscriptionId);
	}
}

/**
 * @internal Represents an UpdateFolder request.
 * 
 * @sealed
*/
export class UpdateFolderRequest extends MultiResponseServiceRequest<ServiceResponse> {

    private folders: Folder[] = [];

    /**
     * Gets the list of folders.
     * 
     * @value   The folders.
     */
    get Folders(): Folder[] {
        return this.folders;
    }

    /**
     * @internal Initializes a new instance of the **UpdateFolderRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   session         The session.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {ServiceResponse}   Service response.
     */
    CreateServiceResponse(session: ExchangeService, responseIndex: number): ServiceResponse {
        return new UpdateFolderResponse(this.Folders[responseIndex]);
    }

    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    GetExpectedResponseMessageCount(): number {
        return this.folders.length;
    }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.UpdateFolderResponseMessage;
    }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetResponseXmlElementName(): string {
        return XmlElementNames.UpdateFolderResponse;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetXmlElementName(): string {
        return XmlElementNames.UpdateFolder;
    }

    /**
     * @internal Validates the request.
     */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParamCollection(this.Folders, "Folders");
        for (var folder of this.folders) {
            if ((folder == null) || folder.IsNew) {
                throw new Error(StringHelper.Format(Strings.FolderToUpdateCannotBeNullOrNew, this.folders.indexOf(folder)));
            }

            folder.Validate();
        }
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.FolderChanges);

        for (var folder of this.folders) {
            folder.WriteToXmlForUpdate(writer);
        }

        writer.WriteEndElement();
    }
}
/** @internal */
export class UpdateItemRequest extends MultiResponseServiceRequest<UpdateItemResponse> {//IJsonSerializable
    private items: Item[] = [];
    private savedItemsDestinationFolder: FolderId = null;
    private conflictResolutionMode: ConflictResolutionMode = 0;
    private messageDisposition: MessageDisposition = null;
    private sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode = null;

    get EmitTimeZoneHeader(): boolean {
        for (var item of this.Items) {
            if (item.GetIsTimeZoneHeaderRequired(true /* isUpdateOpeartion */)) {
                return true;
            }
        }
        return false;
    }
    get MessageDisposition(): MessageDisposition {
        return this.messageDisposition;
    }
    set MessageDisposition(value: MessageDisposition) {
        this.messageDisposition = value;
    }
    get ConflictResolutionMode(): ConflictResolutionMode {
        return this.conflictResolutionMode;
    }
    set ConflictResolutionMode(value: ConflictResolutionMode) {
        this.conflictResolutionMode = value;
    }
    get SendInvitationsOrCancellationsMode(): SendInvitationsOrCancellationsMode {
        return this.sendInvitationsOrCancellationsMode;
    }
    set SendInvitationsOrCancellationsMode(value: SendInvitationsOrCancellationsMode) {
        this.sendInvitationsOrCancellationsMode = value;
    }
    SuppressReadReceipts: boolean = false;
    get Items(): Item[] {
        return this.items;
    }
    get SavedItemsDestinationFolder(): FolderId {
        return this.savedItemsDestinationFolder;
    }
    set SavedItemsDestinationFolder(value: FolderId) {
        this.savedItemsDestinationFolder = value;
    }

    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }

    CreateServiceResponse(service: ExchangeService, responseIndex: number): UpdateItemResponse { return new UpdateItemResponse(this.Items[responseIndex]); }
    GetExpectedResponseMessageCount(): number { return this.items.length; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.UpdateItemResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.UpdateItemResponse; }
    GetXmlElementName(): string { return XmlElementNames.UpdateItem; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParamCollection(this.Items, "Items");
        for (var i = 0; i < this.Items.length; i++) {
            if ((this.Items[i] == null) || this.Items[i].IsNew) {
                throw new Error(StringHelper.Format(Strings.ItemToUpdateCannotBeNullOrNew, i)); //ArgumentException
            }
        }

        if (this.SavedItemsDestinationFolder != null) {
            this.SavedItemsDestinationFolder.Validate(this.Service.RequestedServerVersion);
        }

        // Validate each item.
        for (var item of this.Items) {
            item.Validate();
        }

        if (this.SuppressReadReceipts && this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "SuppressReadReceipts",
                    ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        if (this.MessageDisposition !== null) {
            writer.WriteAttributeValue(XmlAttributeNames.MessageDisposition, MessageDisposition[this.MessageDisposition]);
        }

        if (hasValue(this.SuppressReadReceipts)) {
            writer.WriteAttributeValue(XmlAttributeNames.SuppressReadReceipts, true);
        }

        writer.WriteAttributeValue(XmlAttributeNames.ConflictResolution, ConflictResolutionMode[this.ConflictResolutionMode]);

        if (this.SendInvitationsOrCancellationsMode !== null) {
            writer.WriteAttributeValue(
                XmlAttributeNames.SendMeetingInvitationsOrCancellations,
                SendInvitationsOrCancellationsMode[this.SendInvitationsOrCancellationsMode]);
        }
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (this.SavedItemsDestinationFolder != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SavedItemFolderId);
            this.SavedItemsDestinationFolder.WriteToXml(writer);
            writer.WriteEndElement();
        }

        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ItemChanges);

        for (var item of this.items) {
            item.WriteToXmlForUpdate(writer);
        }

        writer.WriteEndElement();
    }
}

/**
 * @internal Represents a UpdateUserConfiguration request.
 */
export class UpdateUserConfigurationRequest extends MultiResponseServiceRequest<ServiceResponse> {//IJsonSerializable

    protected userConfiguration: UserConfiguration = null;

    /**
     * Gets or sets the user configuration.
     * 
     * @value   The userConfiguration.
     */
    get UserConfiguration(): UserConfiguration {
        return this.userConfiguration;
    }
    set UserConfiguration(value: UserConfiguration) {
        this.userConfiguration = value;
    }

    /**
	 * @internal Initializes a new instance of the **UpdateUserConfigurationRequest** class.
	 *
	 * @param   {ExchangeService}       service   The service.
	 */
    constructor(service: ExchangeService) {
        super(service, ServiceErrorHandling.ThrowOnError);
    }

    /**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {ServiceResponse}	Service response.
	 */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse {
        return new ServiceResponse();
    }

    /**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
    GetExpectedResponseMessageCount(): number {
        return 1;
    }

    /**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010;
    }

    /**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseMessageXmlElementName(): string {
        return XmlElementNames.UpdateUserConfigurationResponseMessage;
    }

    /**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetResponseXmlElementName(): string {
        return XmlElementNames.UpdateUserConfigurationResponse;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      Xml element name.
	 */
    GetXmlElementName(): string {
        return XmlElementNames.UpdateUserConfiguration;
    }

    /**
	 * @internal Validate the request.
	 */
    Validate(): void {
        super.Validate();
        EwsUtilities.ValidateParam(this.userConfiguration, "userConfiguration");
    }

    /**
	 * @internal Writes XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        // Write UserConfiguation element
        this.userConfiguration.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.UserConfiguration);
    }
}
/** @internal */
export class CreateRequest<TServiceObject extends ServiceObject, TResponse extends ServiceResponse> extends MultiResponseServiceRequest<TResponse> {//IJsonSerializable
    private parentFolderId: FolderId = null;
    private objects: TServiceObject[] = [];// null;
    set Objects(value: TServiceObject[]) {
        this.objects = value;
    }
    get Objects(): TServiceObject[] {
        return this.objects;
    }
    set ParentFolderId(value: FolderId) {
        this.parentFolderId = value;
    }
    get ParentFolderId(): FolderId {
        return this.parentFolderId;
    }
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    AddJsonProperties(jsonRequest: any, service: ExchangeService): any { throw new Error("CreateRequest.ts - AddJsonProperties : Not implemented."); }
    GetExpectedResponseMessageCount(): number { return this.Objects.length; }
    GetObjectCollectionXmlElementName(): string { throw new Error("CreateRequest.ts - GetObjectCollectionXmlElementName : abstract - must implement."); }
    GetParentFolderXmlElementName(): string { throw new Error("CreateRequest.ts - GetParentFolderXmlElementName : abstract - must implement."); }
    Validate(): void {
        super.Validate();
        if (this.ParentFolderId != null) {
            this.ParentFolderId.Validate(this.Service.RequestedServerVersion);
        }
    }
/**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        if (this.ParentFolderId != null) {
            writer.WriteStartElement(XmlNamespace.Messages, this.GetParentFolderXmlElementName());
            this.ParentFolderId.WriteToXml(writer);
            writer.WriteEndElement();
        }

        writer.WriteStartElement(XmlNamespace.Messages, this.GetObjectCollectionXmlElementName());
        for (var obj of this.objects) {
            obj.WriteToXml(writer);
        }
        writer.WriteEndElement();
    }
}

/** @internal */
export class CreateFolderRequest extends CreateRequest<Folder, ServiceResponse> {
    get Folders(): Folder[] {
        return this.Objects;
    }
    set Folders(value: Folder[]) {
        this.Objects = value;
    }
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { 
        //return new CreateFolderResponse(<Folder>EwsUtilities.GetEnumeratedObjectAt(this.Folders, responseIndex));
        if (this.Folders.length <= responseIndex) { throw new Error(Strings.IEnumerableDoesNotContainThatManyObject); }
        return new CreateFolderResponse(this.Folders[responseIndex]);
    }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetObjectCollectionXmlElementName(): string { return XmlElementNames.Folders; }
    GetParentFolderXmlElementName(): string { return XmlElementNames.ParentFolderId; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.CreateFolderResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.CreateFolderResponse; }
    GetXmlElementName(): string { return XmlElementNames.CreateFolder; }
    Validate(): void {
        super.Validate();
        
        //EwsUtilities.ValidateParam(this.Folders, "Folders");

        // Validate each folder.
        for (var folder of this.Folders) {
            folder.Validate();
        }
    }
}


/** @internal */
export class CreateItemRequestBase<TServiceObject extends ServiceObject, TResponse extends ServiceResponse> extends CreateRequest<TServiceObject, TResponse> {
    //private messageDisposition: MessageDisposition; - backing property not needed
    //private sendInvitationsMode: SendInvitationsMode;
    MessageDisposition: MessageDisposition = null;
    SendInvitationsMode: SendInvitationsMode = null;
    get Items(): TServiceObject[] {
        return this.Objects;
    }
    set Items(value: TServiceObject[]) {
        this.Objects = value;
    }
    get EmitTimeZoneHeader(): boolean {
        for (var serviceObject of this.Items) {
            if (serviceObject.GetIsTimeZoneHeaderRequired(false /* isUpdateOperation */)) {
                return true;
            }
        }
        return false;
    }

    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }
    AddJsonProperties(jsonRequest: any, service: ExchangeService): any { throw new Error("CreateItemRequestBase.ts - AddJsonProperties : Not implemented."); }
    GetObjectCollectionXmlElementName(): string { return XmlElementNames.Items; }
    GetParentFolderXmlElementName(): string { return XmlElementNames.SavedItemFolderId; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.CreateItemResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.CreateItemResponse; }
    GetXmlElementName(): string { return XmlElementNames.CreateItem; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.Items, "Items");
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        if (this.MessageDisposition !== null) {
            writer.WriteAttributeValue(XmlAttributeNames.MessageDisposition, MessageDisposition[this.MessageDisposition]);
        }

        if (this.SendInvitationsMode !== null) {
            writer.WriteAttributeValue(XmlAttributeNames.SendMeetingInvitations, SendInvitationsMode[this.SendInvitationsMode]);
        }
    }
}

/** @internal */
export class CreateItemRequest extends CreateItemRequestBase<Item, ServiceResponse> {
    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { return new CreateItemResponse(this.Items[responseIndex]); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    Validate(): void {
        super.Validate();

        // Validate each item.
        for (var item of this.Items) {
            item.Validate();
        }
    }
}
/** @internal */
export class CreateResponseObjectRequest extends CreateItemRequestBase<ServiceObject, CreateResponseObjectResponse> {
    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): CreateResponseObjectResponse { return new CreateResponseObjectResponse(); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
}
/** @internal */
export class DeleteRequest<TResponse extends ServiceResponse> extends MultiResponseServiceRequest<TResponse> {//IJsonSerializable
    private deleteMode: DeleteMode = DeleteMode.SoftDelete;
    get DeleteMode(): DeleteMode {
        return this.deleteMode;
    }
    set DeleteMode(value: DeleteMode) {
        this.deleteMode = value;
    }
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service,errorHandlingMode);
    }
    InternalToJson(body: any): any { throw new Error("DeleteRequest.ts - InternalToJson : Not implemented."); }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);
        writer.WriteAttributeValue(XmlAttributeNames.DeleteType, DeleteMode[this.DeleteMode]);
    }
}
/** @internal */
export class DeleteFolderRequest extends DeleteRequest<ServiceResponse> {
    private folderIds: FolderIdWrapperList = new FolderIdWrapperList();
    get FolderIds(): FolderIdWrapperList {
        return this.folderIds;
    }
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service,errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { return new ServiceResponse(); }
    GetExpectedResponseMessageCount(): number { return this.FolderIds.Count; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.DeleteFolderResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.DeleteFolderResponse; }
    GetXmlElementName(): string { return XmlElementNames.DeleteFolder; }
    InternalToJson(body: any): any { throw new Error("DeleteFolderRequest.ts - InternalToJson : Not implemented."); }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.FolderIds.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.FolderIds);
    }
}
/** @internal */
export class DeleteItemRequest extends DeleteRequest<ServiceResponse> {

    private itemIds: ItemIdWrapperList = new ItemIdWrapperList();
    private affectedTaskOccurrences: AffectedTaskOccurrence = null;
    private sendCancellationsMode: SendCancellationsMode = null;
    get ItemIds(): ItemIdWrapperList {
        return this.itemIds;
    }
    get AffectedTaskOccurrences(): AffectedTaskOccurrence {
        return this.affectedTaskOccurrences;
    }
    set AffectedTaskOccurrences(value: AffectedTaskOccurrence) {
        this.affectedTaskOccurrences = value;
    }
    get SendCancellationsMode(): SendCancellationsMode {
        return this.sendCancellationsMode;
    }
    set SendCancellationsMode(value: SendCancellationsMode) {
        this.sendCancellationsMode = value;
    }
    SuppressReadReceipts: boolean = false;

    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { return new ServiceResponse(); }
    GetExpectedResponseMessageCount(): number { return this.itemIds.Count; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.DeleteItemResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.DeleteItemResponse; }
    GetXmlElementName(): string { return XmlElementNames.DeleteItem; }
    InternalToJson(body: any): any { throw new Error("DeleteItemRequest.ts - InternalToJson : Not implemented."); }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.ItemIds, "ItemIds");

        if (this.SuppressReadReceipts && this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "SuppressReadReceipts",
                    ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        if (this.AffectedTaskOccurrences !== null) {
            writer.WriteAttributeValue(
                XmlAttributeNames.AffectedTaskOccurrences,
                AffectedTaskOccurrence[this.AffectedTaskOccurrences]);
        }

        if (this.SendCancellationsMode !== null) {
            writer.WriteAttributeValue(
                XmlAttributeNames.SendMeetingCancellations,
                SendCancellationsMode[this.SendCancellationsMode]);
        }

        if (this.SuppressReadReceipts) {
            writer.WriteAttributeValue(XmlAttributeNames.SuppressReadReceipts, true);
        }
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.itemIds.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.ItemIds);
    }
}
/** @internal */
export class EmptyFolderRequest extends DeleteRequest<ServiceResponse> {
    DeleteSubFolders: boolean = false;
    private folderIds: FolderIdWrapperList = new FolderIdWrapperList();
    get FolderIds(): FolderIdWrapperList {
        return this.folderIds;
    }
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { return new ServiceResponse(); }
    GetExpectedResponseMessageCount(): number { return this.FolderIds.Count; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2010_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.EmptyFolderResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.EmptyFolderResponse; }
    GetXmlElementName(): string { return XmlElementNames.EmptyFolder; }
    InternalToJson(body: any): any { throw new Error("EmptyFolderRequest.ts - InternalToJson : Not implemented."); }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        writer.WriteAttributeValue(XmlAttributeNames.DeleteSubFolders, this.DeleteSubFolders);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.FolderIds.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.FolderIds);
    }
}

/** @internal */
export class FindRequest<TResponse extends ServiceResponse> extends MultiResponseServiceRequest<TResponse> {//IJsonSerializable
    get ParentFolderIds(): FolderIdWrapperList { return this.parentFolderIds; }
    SearchFilter: SearchFilter = null;
    QueryString: string = null;
    ReturnHighlightTerms: boolean = null;
    View: ViewBase = null;
    private parentFolderIds: FolderIdWrapperList = new FolderIdWrapperList();
    //private searchFilter: SearchFilter;  - no backing property needed
    //private queryString: string;
    //private returnHighlightTerms: boolean;
    //private view: ViewBase;
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    
    GetExpectedResponseMessageCount(): number { return this.ParentFolderIds.Count; }
    GetGroupBy(): Grouping { return null; }
    Validate(): void {
        super.Validate();

        this.View.InternalValidate(this);

        // query string parameter is only valid for Exchange2010 or higher
        //
        if (!StringHelper.IsNullOrEmpty(this.QueryString) &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2010) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "queryString",
                    ExchangeVersion[ExchangeVersion.Exchange2010]));
        }

        // ReturnHighlightTerms parameter is only valid for Exchange2013 or higher
        //
        if (this.ReturnHighlightTerms &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "returnHighlightTerms",
                    ExchangeVersion[ExchangeVersion.Exchange2013]));
        }

        // SeekToConditionItemView is only valid for Exchange2013 or higher
        //
        if ((this.View instanceof SeekToConditionItemView) &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ParameterIncompatibleWithRequestVersion,
                    "SeekToConditionItemView",
                    ExchangeVersion[ExchangeVersion.Exchange2013]));
        }

        if (!StringHelper.IsNullOrEmpty(this.QueryString) &&
            this.SearchFilter != null) {
            throw new ServiceLocalException(Strings.BothSearchFilterAndQueryStringCannotBeSpecified);
        }
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);
        this.View.WriteAttributesToXml(writer);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        this.View.WriteToXml(writer, this.GetGroupBy());

        if (this.SearchFilter != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Restriction);
            this.SearchFilter.WriteToXml(writer);
            writer.WriteEndElement(); // Restriction
        }

        this.View.WriteOrderByToXml(writer);

        this.ParentFolderIds.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.ParentFolderIds);

        if (!StringHelper.IsNullOrEmpty(this.QueryString)) {
            // Emit the QueryString
            //
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.QueryString);

            if (this.ReturnHighlightTerms) {
                writer.WriteAttributeString(XmlAttributeNames.ReturnHighlightTerms, this.ReturnHighlightTerms.toString());
            }

            writer.WriteValue(this.QueryString, XmlElementNames.QueryString);
            writer.WriteEndElement();
        }
    }
}
/** @internal */
export class FindFolderRequest extends FindRequest<FindFolderResponse> {
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): FindFolderResponse { return new FindFolderResponse(this.View.GetPropertySetOrDefault()); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.FindFolderResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.FindFolderResponse; }
    GetXmlElementName(): string { return XmlElementNames.FindFolder; }
}

/**
 * @internal Represents a **FindItem** request.
 *
 * @type <TItem>   Item type.
 */
export class FindItemRequest<TItem extends Item> extends FindRequest<FindItemResponse<TItem>> {

    private groupBy: Grouping = null;

    /**
     * Gets or sets the group by.
     *
     * @value The group by.
     */
    get GroupBy(): Grouping {
        return this.groupBy;
    }
    set GroupBy(value: Grouping) {
        this.groupBy = value;
    }

    /**
     * @internal Initializes a new instance of the **FindItemRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    /**
     * Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {FindItemResponse<TItem>}           Service response.
     */
    CreateServiceResponse(service: ExchangeService, responseIndex: number): FindItemResponse<TItem> { return new FindItemResponse<TItem>(this.GroupBy != null, this.View.GetPropertySetOrDefault()); }

    /**
     * @internal Gets the group by clause.
     *
     * @return  {Grouping}      The group by clause, null if the request does not have or support grouping.
     */
    GetGroupBy(): Grouping { return this.GroupBy; }

    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name.
     */
    GetResponseMessageXmlElementName(): string { return XmlElementNames.FindItemResponseMessage; }

    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetResponseXmlElementName(): string { return XmlElementNames.FindItemResponse; }

    /**
     * @internal Gets the name of the XML element.
     * 
     * @return  {string} XML element name.
     */
    GetXmlElementName(): string { return XmlElementNames.FindItem; }
}

/** @internal */
export class GetRequest<TServiceObject extends ServiceObject, TResponse extends ServiceResponse> extends MultiResponseServiceRequest<TResponse> { //implements IJsonSerializable
    PropertySet: PropertySet;
    //private propertySet: PropertySet;
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    //abstract - AddIdsToRequest(jsonRequest: JsonObject, service: ExchangeService): any { throw new Error("GetRequest.ts - abstract - AddIdsToRequest : Not implemented."); }
    //IJsonSerializable.ToJson(ExchangeService service): any {
    //    JsonObject jsonRequest = new JsonObject();

    //    this.propertySet.WriteGetShapeToJson(jsonRequest, service, this.GetServiceObjectType());
    //    this.AddIdsToRequest(jsonRequest, service);

    //    return jsonRequest;
    //}
    GetServiceObjectType(): ServiceObjectType { throw new Error("Abstract; must implemented."); }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.PropertySet, "PropertySet");
        this.PropertySet.ValidateForRequest(this, false /*summaryPropertiesOnly*/);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void { this.PropertySet.WriteToXml(writer, this.GetServiceObjectType()); }
}

/** @internal */
export class GetFolderRequestBase<TResponse extends ServiceResponse> extends GetRequest<Folder, TResponse> {
    get FolderIds(): FolderIdWrapperList { return this.folderIds; }
    private folderIds: FolderIdWrapperList = new FolderIdWrapperList();

    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling:any) {
        super(service, errorHandlingModeServiceErrorHandling);
    }

    //AddIdsToRequest(jsonRequest: JsonObject, service: ExchangeService): any{ throw new Error("GetFolderRequestBase.ts - AddIdsToRequest : Not implemented.");}
    GetExpectedResponseMessageCount(): number { return this.FolderIds.Count; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.GetFolderResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.GetFolderResponse; }
    GetServiceObjectType(): ServiceObjectType { return ServiceObjectType.Folder; }
    GetXmlElementName(): string { return XmlElementNames.GetFolder; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParamCollection(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        this.FolderIds.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.FolderIds);
    }
}


/** @internal */
export class GetFolderRequest extends GetFolderRequestBase<GetFolderResponse> {
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): GetFolderResponse {
        return new GetFolderResponse(this.FolderIds._getItem(responseIndex).GetFolder(), this.PropertySet);
    }
}
/** @internal */
export class GetFolderRequestForLoad extends GetFolderRequestBase<ServiceResponse> {
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse {
        return new GetFolderResponse(this.FolderIds._getItem(responseIndex).GetFolder(), this.PropertySet);
    }
}
/** @internal */
export class GetItemRequestBase<TResponse extends ServiceResponse> extends GetRequest<Item, TResponse> {
    private itemIds: ItemIdWrapperList = new ItemIdWrapperList();
    get ItemIds(): ItemIdWrapperList {
        return this.itemIds;
    }
    get EmitTimeZoneHeader(): boolean {
        // currently we do not emit "ItemResponseShapeType.IncludeMimeContent".
        //
        return this.PropertySet.Contains(Schemas.ItemSchema.MimeContent);
    }
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    //AddIdsToRequest(jsonRequest: any, service: ExchangeService): any { throw new Error("GetItemRequestBase.ts - AddIdsToRequest : Not implemented."); }
    GetExpectedResponseMessageCount(): number { return this.ItemIds.Count; }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.GetItemResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.GetItemResponse; }
    GetServiceObjectType(): ServiceObjectType { return ServiceObjectType.Item; }
    GetXmlElementName(): string { return XmlElementNames.GetItem; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParamCollection(this.ItemIds, "ItemIds");
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        this.ItemIds.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.ItemIds);
    }
}
/** @internal */
export class GetItemRequest extends GetItemRequestBase<GetItemResponse> {
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): GetItemResponse { return new GetItemResponse(this.ItemIds[responseIndex], this.PropertySet); }
}
/** @internal */
export class GetItemRequestForLoad extends GetItemRequestBase<ServiceResponse> {
    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): ServiceResponse { return new GetItemResponse(this.ItemIds._getItem(responseIndex), this.PropertySet); }
}
/** @internal */
export class MoveCopyRequest<TServiceObject extends ServiceObject, TResponse extends ServiceResponse> extends MultiResponseServiceRequest<TResponse> {//IJsonSerializable
    private destinationFolderId: FolderId = null;
    get DestinationFolderId(): FolderId {
        return this.destinationFolderId;
    }
    set DestinationFolderId(value: FolderId) {
        this.destinationFolderId = value;
    }
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    AddIdsToJson(jsonObject: any, service: ExchangeService): any { throw new Error("MoveCopyRequest.ts - AddIdsToJson : Not implemented."); }
    Validate(): void {
        //EwsUtilities.ValidateParam(this.DestinationFolderId, "DestinationFolderId");
        this.DestinationFolderId.Validate(this.Service.RequestedServerVersion);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ToFolderId);
        this.DestinationFolderId.WriteToXml(writer);
        writer.WriteEndElement();
        this.WriteIdsToXml(writer);
    }
    /**@internal */
    WriteIdsToXml(writer: EwsServiceXmlWriter): void { throw new Error("MoveCopyRequest.ts - WriteIdsToXml : Abstract - must implement."); }
}
/** @internal */
export class MoveCopyFolderRequest<TResponse extends ServiceResponse> extends MoveCopyRequest<Folder, TResponse> {
    get FolderIds(): FolderIdWrapperList { return this.folderIds; }
    private folderIds: FolderIdWrapperList = new FolderIdWrapperList();
    
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }

    AddIdsToJson(jsonObject: JsonObject, service: ExchangeService): any { throw new Error("MoveCopyFolderRequest.ts - AddIdsToJson : Not implemented."); }
    GetExpectedResponseMessageCount(): number { return this.FolderIds.Count; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParamCollection(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    }
    /**@internal */
    WriteIdsToXml(writer: EwsServiceXmlWriter): void {
        this.folderIds.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.FolderIds);
    }
}


/** @internal */
export class CopyFolderRequest extends MoveCopyFolderRequest<MoveCopyFolderResponse> {
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): MoveCopyFolderResponse { return new MoveCopyFolderResponse(); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.CopyFolderResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.CopyFolderResponse; }
    GetXmlElementName(): string { return XmlElementNames.CopyFolder; }
}
/** @internal */
export class MoveFolderRequest extends MoveCopyFolderRequest<MoveCopyFolderResponse> {
    constructor(service: ExchangeService, errorHandlingMode: ServiceErrorHandling) {
        super(service, errorHandlingMode);
    }
    CreateServiceResponse(service: ExchangeService, responseIndex: number): MoveCopyFolderResponse { return new MoveCopyFolderResponse(); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.MoveFolderResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.MoveFolderResponse; }
    GetXmlElementName(): string { return XmlElementNames.MoveFolder; }
}


/** @internal */
export class MoveCopyItemRequest<TResponse extends ServiceResponse> extends MoveCopyRequest<Item, TResponse> {
    get ItemIds(): ItemIdWrapperList { return this.itemIds; }
    ReturnNewItemIds: boolean = null;//nullable
    private itemIds: ItemIdWrapperList = new ItemIdWrapperList();

    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }

    //AddIdsToJson(jsonObject: any, service: ExchangeService): any { throw new Error("MoveCopyItemRequest.ts - AddIdsToJson : Not implemented."); }
    GetExpectedResponseMessageCount(): number { return this.ItemIds.Count; }
    Validate(): void {
        super.Validate();
        //EwsUtilities.ValidateParam(this.ItemIds, "ItemIds");
    }
    /**@internal */
    WriteIdsToXml(writer: EwsServiceXmlWriter): void {
        this.ItemIds.WriteToXml(
            writer,
            XmlNamespace.Messages,
            XmlElementNames.ItemIds);

        if (this.ReturnNewItemIds) {
            writer.WriteElementValue(
                XmlNamespace.Messages,
                XmlElementNames.ReturnNewItemIds,
                this.ReturnNewItemIds);
        }
    }
}
/** @internal */
export class CopyItemRequest extends MoveCopyItemRequest<MoveCopyItemResponse> {

    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }

    CreateServiceResponse(service: ExchangeService, responseIndex: number): MoveCopyItemResponse { return new MoveCopyItemResponse(); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.CopyItemResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.CopyItemResponse; }
    GetXmlElementName(): string { return XmlElementNames.CopyItem; }
}
/** @internal */
export class MoveItemRequest extends MoveCopyItemRequest<MoveCopyItemResponse> {
    
    constructor(service: ExchangeService, errorHandlingModeServiceErrorHandling: ServiceErrorHandling) {
        super(service, errorHandlingModeServiceErrorHandling);
    }

    CreateServiceResponse(service: ExchangeService, responseIndex: number): MoveCopyItemResponse { return new MoveCopyItemResponse(); }
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    GetResponseMessageXmlElementName(): string { return XmlElementNames.MoveItemResponseMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.MoveItemResponse; }
    GetXmlElementName(): string { return XmlElementNames.MoveItem; }
}

/**
 * @internal Represents an abstract Subscribe request.
 * 
 * @typeparam	{TSubscription}		The type of the subscription.
 */
export abstract class SubscribeRequest<TSubscription extends SubscriptionBase> extends MultiResponseServiceRequest<SubscribeResponse<TSubscription>> {

	/**
	 * Gets the folder ids.
	 * 
	 * @private set
	 */
	FolderIds: FolderIdWrapperList;

	/**
	 * Gets the event types.
	 * 
	 * @private set
	 */
	EventTypes: EventType[];

	/**
	 * Gets or sets the watermark.
	 */
	Watermark: string;

	/**
	 * @internal Initializes a new instance of the **SubscribeRequest<TSubscription>** class.
	 *
	 * @param   {ExchangeService}   service   The service.
	 */
	constructor(service: ExchangeService) {
		super(service, ServiceErrorHandling.ThrowOnError);
		this.FolderIds = new FolderIdWrapperList();
		this.EventTypes = [];
	}

	/**
	 * @internal Gets the expected response message count.
	 *
	 * @return  {number}      Number of expected response messages.
	 */
	GetExpectedResponseMessageCount(): number { return 1; }

	/**
	 * @internal Gets the name of the response message XML element.
	 *
	 * @return  {string}      XML element name,
	 */
	GetResponseMessageXmlElementName(): string { return XmlElementNames.SubscribeResponseMessage; }

	/**
	 * @internal Gets the name of the response XML element.
	 *
	 * @return  {string}      XML element name,
	 */
	GetResponseXmlElementName(): string { return XmlElementNames.SubscribeResponse; }

	/**
	 * @internal Gets the name of the subscription XML element.
	 *
	 * @return  {string}      XML element name,
	 */
	abstract GetSubscriptionXmlElementName(): string;

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name,
	 */
	GetXmlElementName(): string { return XmlElementNames.Subscribe; }

	/**
	 * @internal Internal method to write XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	abstract InternalWriteElementsToXml(writer: EwsServiceXmlWriter): void;

	/**
	 * @internal Validate request.
	 */
	Validate(): void {
		super.Validate();
		EwsUtilities.ValidateParam(this.FolderIds, "FolderIds");
		EwsUtilities.ValidateParamCollection(this.EventTypes, "EventTypes");
		this.FolderIds.Validate(this.Service.RequestedServerVersion);

		// Check that caller isn't trying to subscribe to Status events.
		if (ArrayHelper.OfType<EventType, EventType>(this.EventTypes, (eventType) => eventType === EventType.Status).length > 0) { //  this.EventTypes.Count<EventType>(eventType => (eventType == EventType.Status)) > 0)
			throw new ServiceValidationException(Strings.CannotSubscribeToStatusEvents);
		}

		// If Watermark was specified, make sure it's not a blank string.
		if (!StringHelper.IsNullOrEmpty(this.Watermark)) {
			EwsUtilities.ValidateNonBlankStringParam(this.Watermark, "Watermark");
		}

		this.EventTypes.forEach((eventType) => {
			EwsUtilities.ValidateEnumVersionValue(EventType, eventType, this.Service.RequestedServerVersion, "EventType");
		});
	}

	/**
	 * @internal Writes XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void {

		writer.WriteStartElement(XmlNamespace.Messages, this.GetSubscriptionXmlElementName());

		if (this.FolderIds.Count == 0) {
			writer.WriteAttributeValue(
				XmlAttributeNames.SubscribeToAllFolders,
				true);
		}

		this.FolderIds.WriteToXml(
			writer,
			XmlNamespace.Types,
			XmlElementNames.FolderIds);

		writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.EventTypes);
		for (let eventType of this.EventTypes) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.EventType,
				EventType[eventType] + "Event");
		}
		writer.WriteEndElement();

		if (!StringHelper.IsNullOrEmpty(this.Watermark)) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.Watermark,
				this.Watermark);
		}

		this.InternalWriteElementsToXml(writer);

		writer.WriteEndElement();
	}
}

/**
 * @internal Represents a "pull" Subscribe request.
 */
export class SubscribeToPullNotificationsRequest extends SubscribeRequest<PullSubscription> {

	private timeout: number = 30;

	/**
	 * Gets or sets the timeout.
	 * 
	 * @value	The timeout.
	 */
	get Timeout(): number {
		return this.timeout;
	}
	set Timeout(value: number) {
		this.timeout = value;
	}

	/**
	 * @internal Initializes a new instance of the **SubscribeToPullNotificationsRequest** class.
	 *
	 * @param   {ExchangeService}   service   The service.
	 */
	constructor(service: ExchangeService) {
		super(service);
	}

	/**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {SubscribeResponse<PullSubscription>}		Service response.
	 */
	CreateServiceResponse(service: ExchangeService, responseIndex: number): SubscribeResponse<PullSubscription> {
		return new SubscribeResponse<PullSubscription>(new PullSubscription(service));
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
	GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2007_SP1;
	}

	/**
	 * @internal Gets the name of the subscription XML element.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
	GetSubscriptionXmlElementName(): string {
		return XmlElementNames.PullSubscriptionRequest;
	}

	/**
	 * @internal Internal method to write XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	InternalWriteElementsToXml(writer: EwsServiceXmlWriter): void {
		writer.WriteElementValue(
			XmlNamespace.Types,
			XmlElementNames.Timeout,
			this.Timeout);
	}

	/**
	 * @internal Validate request.
	 */
	Validate(): void {
		super.Validate();
		if ((this.Timeout < 1) || (this.Timeout > 1440)) {
			throw new ArgumentException(StringHelper.Format(Strings.InvalidTimeoutValue, this.Timeout));
		}
	}
}

/**
 * @internal Represents a "push" Subscribe request.
 */
export class SubscribeToPushNotificationsRequest extends SubscribeRequest<PushSubscription> {

	private frequency: number = 30;
	private url: Uri = null;
	private callerData: string = null;

	/**
	 * Gets or sets the frequency.
	 * 
	 * @value	The frequency.
	 */
	get Frequency(): number {
		return this.frequency;
	}
	set Frequency(value: number) {
		this.frequency = value;
	}

	/**
	 * Gets or sets the URL.
	 * 
	 * @value	The URL.
	 */
	get Url(): Uri {
		return this.url;
	}
	set Url(value: Uri) {
		this.url = value;
	}

	/**
	 * Gets or sets the CallerData.
	 * 
	 * @value	The CallerData.
	 */
	get CallerData(): string {
		return this.callerData;
	}
	set CallerData(value: string) {
		this.callerData = value;
	}

	/**
	 * @internal Initializes a new instance of the **SubscribeToPushNotificationsRequest** class.
	 *
	 * @param   {ExchangeService}   service   The service.
	 */
	constructor(service: ExchangeService) {
		super(service);
	}

	/**
	 * @internal Creates the service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {SubscribeResponse<PushSubscription>}		Service response.
	 */
	CreateServiceResponse(service: ExchangeService, responseIndex: number): SubscribeResponse<PushSubscription> {
		return new SubscribeResponse<PushSubscription>(new PushSubscription(service));
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
	GetMinimumRequiredServerVersion(): ExchangeVersion {
		return ExchangeVersion.Exchange2007_SP1;
	}

	/**
	 * @internal Gets the name of the subscription XML element.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
	GetSubscriptionXmlElementName(): string {
		return XmlElementNames.PushSubscriptionRequest;
	}

	/**
	 * @internal Internal method to write XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	InternalWriteElementsToXml(writer: EwsServiceXmlWriter): void {
		writer.WriteElementValue(
			XmlNamespace.Types,
			XmlElementNames.StatusFrequency,
			this.Frequency);

		writer.WriteElementValue(
			XmlNamespace.Types,
			XmlElementNames.URL,
			this.Url.ToString());

		if (this.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013
			&& !StringHelper.IsNullOrEmpty(this.callerData)) {
			writer.WriteElementValue(
				XmlNamespace.Types,
				XmlElementNames.CallerData,
				this.CallerData);
		}
	}

	/**
	 * @internal Validate request.
	 */
	Validate(): void {
		super.Validate();
		EwsUtilities.ValidateParam(this.Url, "Url");
		if ((this.Frequency < 1) || (this.Frequency > 1440)) {
			throw new ArgumentException(StringHelper.Format(Strings.InvalidFrequencyValue, this.Frequency));
		}
	}
}

/**
 * @internal Represents a *Streaming* Subscribe request.
 */
export class SubscribeToStreamingNotificationsRequest extends SubscribeRequest<StreamingSubscription> {

	/**
	 * @internal Initializes a new instance of the **SubscribeToStreamingNotificationsRequest** class.
	 *
	 * @param   {ExchangeService}   service   The service.
	 */
	constructor(service: ExchangeService) {
		super(service);
	}

	/**
	 * @internal Creates service response.
	 *
	 * @param   {ExchangeService}   service         The service.
	 * @param   {number}   			responseIndex   Index of the response.
	 * @return  {SubscribeResponse<StreamingSubscription>}	Service response.
	 */
	CreateServiceResponse(service: ExchangeService, responseIndex: number): SubscribeResponse<StreamingSubscription> {
		return new SubscribeResponse<StreamingSubscription>(new StreamingSubscription(service));
	}

	/**
	 * @internal Gets the request version.
	 *
	 * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
	 */
	GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2010_SP1; }

	/**
	 * @internal Gets the name of the subscription XML element.
	 *
	 * @return  {string}      XML element name,
	 */
	GetSubscriptionXmlElementName(): string { return XmlElementNames.StreamingSubscriptionRequest; }

	/**
	 * @internal Internal method to write XML elements.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	InternalWriteElementsToXml(writer: EwsServiceXmlWriter): void {
	}

	/**
	 * @internal Validate request.
	 */
	Validate(): void {
		super.Validate();

		if (!StringHelper.IsNullOrEmpty(this.Watermark)) {
			throw new ArgumentException("Watermarks cannot be used with StreamingSubscriptions.", "Watermark");
		}
	}
}

/**
 * Represents the standard response to an Exchange Web Services operation.
 */
export class ServiceResponse {

    private result: ServiceResult;
    private errorCode: ServiceError;
    private errorMessage: string;
    private errorDetails: Dictionary<string, string> = new DictionaryWithStringKey<string>();
    private errorProperties: PropertyDefinitionBase[] = [];;

    /**
     * @internal Gets a value indicating whether a batch request stopped processing before the end.
     */
    get BatchProcessingStopped(): boolean {
        return (this.result == ServiceResult.Warning) && (this.errorCode == ServiceError.ErrorBatchProcessingStopped);
    }

    /**
     * Gets the result associated with this response.
     */
    get Result(): ServiceResult {
        return this.result;
    }

    /**
     * Gets the error code associated with this response.
     */
    get ErrorCode(): ServiceError {
        return this.errorCode;
    }

    /**
     * Gets a detailed error message associated with the response. If Result is set to Success, ErrorMessage returns null. 
     * ErrorMessage is localized according to the PreferredCulture property of the ExchangeService object that was used to call the method that generated the response.
     */
    get ErrorMessage(): string {
        return this.errorMessage;
    }

    /**
     * Gets error details associated with the response. If Result is set to Success, ErrorDetailsDictionary returns null. 
     * Error details will only available for some error codes. For example, when error code is ErrorRecurrenceHasNoOccurrence, the ErrorDetailsDictionary will contain keys for EffectiveStartDate and EffectiveEndDate.
     * 
     * @value   The error details dictionary.
     */
    get ErrorDetails(): Dictionary<string, string> {
        return this.errorDetails;
    }

    /**
     * Gets information about property errors associated with the response. If Result is set to Success, ErrorProperties returns null. 
     * ErrorProperties is only available for some error codes. For example, when the error code is ErrorInvalidPropertyForOperation, ErrorProperties will contain the definition of the property that was invalid for the request.
     * 
     * @value   The error properties list.
     */
    get ErrorProperties(): PropertyDefinitionBase[] {
        return this.errorProperties;
    }

    /**
     * @internal Initializes a new instance of the **ServiceResponse** class. 
     */
    constructor();
    /**
     * @internal Initializes a new instance of the **ServiceResponse** class. 
     *
     * @param   {SoapFaultDetails}  soapFaultDetails   The SOAP fault details.
     */
    constructor(soapFaultDetails: SoapFaultDetails);
    /**
     * @internal Initializes a new instance of the **ServiceResponse** class. 
     * This is intended to be used by unit tests to create a fake service error response
     *
     * @param   {ServiceError}  responseCode   Response code
     * @param   {string}        errorMessage   Detailed error message
     */
    constructor(responseCode: ServiceError, errorMessage: string);
    constructor(soapFaultDetailsOrResponseCode?: SoapFaultDetails | ServiceError, errorMessage?: string) {
        var argsLength = arguments.length;
        if (argsLength == 0) return;

        if (typeof soapFaultDetailsOrResponseCode === 'number') {//(responseCode: ServiceError, errorMessage: string)
            this.result = ServiceResult.Error;
            this.errorCode = soapFaultDetailsOrResponseCode;
            this.errorMessage = errorMessage;
            this.errorDetails = null;
        }
        else {//(soapFaultDetails: SoapFaultDetails)
            this.result = ServiceResult.Error;
            this.errorCode = soapFaultDetailsOrResponseCode.ResponseCode;
            this.errorMessage = soapFaultDetailsOrResponseCode.FaultString;
            this.errorDetails = soapFaultDetailsOrResponseCode.ErrorDetails;
        }
    }

    /**
     * @internal Internal method that throws a ServiceResponseException if this response has its Result property set to Error.
     */
    InternalThrowIfNecessary(): void {
        if (this.Result == ServiceResult.Error) {
            throw new ServiceResponseException(this);
        }
    }

    /**
     * @internal Called when the response has been loaded from XML.
     */
    Loaded(): void { /* virtual void to be implemented throw new Error("Not implemented.");*/ }

    /**
     * @internal Loads extra error details from XML
     *
     * @param   {any}               responseObject      Json Object converted from XML.
     * @param   {ExchangeService}   service             The service.    
     */
    LoadExtraErrorDetailsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        if (responseObject[XmlElementNames.MessageXml]) {
            this.ParseMessageXml(responseObject[XmlElementNames.MessageXml]);
        }
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 responseObject        Json Object converted from XML.
     * @param   {ExchangeService}     service               The service.    
     */
    LoadFromXmlJsObject(responseObject: any, service: ExchangeService): any {

        this.result = ServiceResult[<string>responseObject[XmlAttributeNames.ResponseClass]];
        this.errorCode = ServiceError[<string>responseObject[XmlElementNames.ResponseCode]];

        // TODO: Deal with a JSON version of "LoadExtraDetailsFromXml"
        if (this.result == ServiceResult.Warning || this.result == ServiceResult.Error) {
            this.errorMessage = responseObject[XmlElementNames.MessageText];
            this.LoadExtraErrorDetailsFromXmlJsObject(responseObject, service);
        }

        if (this.result == ServiceResult.Success || this.result == ServiceResult.Warning) {
            if (!this.BatchProcessingStopped) {
                this.ReadElementsFromXmlJsObject(responseObject, service);
            }
        }

        this.MapErrorCodeToErrorMessage();

        this.Loaded();

    }

    /**
     * @internal Called after the response has been loaded from XML in order to map error codes to "better" error messages.
     */
    MapErrorCodeToErrorMessage(): void {
        // Use a better error message when an item cannot be updated because its changeKey is old.
        if (this.ErrorCode == ServiceError.ErrorIrresolvableConflict) {
            this.errorMessage = Strings.ItemIsOutOfDate;
        }
    }

    /**
     * Parses the message XML.
     *
     * @param   {any}   jsObject   The MessageXml Object.
     */
    ParseMessageXml(jsObject: any): void {

        for (var key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }

            switch (key) {
                case XmlElementNames.Value:
                    let values = EwsServiceJsonReader.ReadAsArray(jsObject, key);
                    values.forEach((value, index) => {
                        let name = value[XmlAttributeNames.Name];
                        if (name) {
                            if (this.ErrorDetails.containsKey(name)) {
                                name = name + " - " + (index + 1)
                            }
                            this.errorDetails.Add(name, value[key]);
                        }
                    });
                    break;
                case XmlElementNames.FieldURI:
                    this.errorProperties.push(ServiceObjectSchema.FindPropertyDefinition(jsObject[key][XmlAttributeNames.FieldURI]));
                    break;

                case XmlElementNames.IndexedFieldURI:
                    let indexFieldUriObject = jsObject[key];
                    this.errorProperties.push(
                        new IndexedPropertyDefinition(
                            indexFieldUriObject[XmlAttributeNames.FieldURI],
                            indexFieldUriObject[XmlAttributeNames.FieldIndex]));
                    break;

                case XmlElementNames.ExtendedFieldURI:
                    let extendedPropDef = new ExtendedPropertyDefinition();
                    extendedPropDef.LoadPropertyValueFromXmlJsObject(jsObject[key]);
                    this.errorProperties.push(extendedPropDef);
                    break;
                default:
                    EwsLogging.Assert(false, "ServiceResponse.ParseMessageXml", "Element: " + key + " - Please report example of this operation to ews-javascript-api repo to improve SoapFault parsing");
                    break;
            }
        }
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        /* virtualvoid to be implemented throw new Error("Not implemented.");*/
        let caller = "ServiceResponse->child";
        try {
            caller = (<any>this.constructor).name;
        }
        catch (e) { }
        EwsLogging.Assert(caller === "ServiceResponse", caller + ".ReadElementsFromXmlJsObject", "BatchProcessingStopped is false but ReadElementsFromXmlJsObject is not available in derived class to call.")
    }

    /**
     * @internal Throws a ServiceResponseException if this response has its Result property set to Error.
     */
    ThrowIfNecessary(): void {
        this.InternalThrowIfNecessary();
    }
}
export class ArchiveItemResponse extends ServiceResponse {
    Item: Item;
    private item: Item;
    GetObjectInstance(service: ExchangeService, xmlElementName: string): Item {
        return (new ItemInfo()).CreateEwsObjectFromXmlElementName<Item>(service, xmlElementName);
    }
    ReadElementsFromJson(responseObject: any, service: ExchangeService): any { throw new Error("ArchiveItemResponse.ts - ReadElementsFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        //debugger;
        var items: Item[] = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Item>(
            responseObject,
            service,
            XmlElementNames.Folders,
            this.GetObjectInstance.bind(this),
            false,  /* clearPropertyBag */
            null,   /* requestedPropertySet */
            false); /* summaryPropertiesOnly */

        if (items.length > 0) {
            this.item = items[0];
        }
    }
}
export class AttendeeAvailability extends ServiceResponse {
    get CalendarEvents(): CalendarEvent[] { return this.calendarEvents; }
    get ViewType(): FreeBusyViewType { return this.viewType; }
    get MergedFreeBusyStatus(): LegacyFreeBusyStatus[] { return this.mergedFreeBusyStatus; }
    get WorkingHours(): WorkingHours { return this.workingHours; }
    private calendarEvents: CalendarEvent[] = [];
    private mergedFreeBusyStatus: LegacyFreeBusyStatus[] = [];
    private viewType: FreeBusyViewType = FreeBusyViewType.None;
    private workingHours: WorkingHours = null;
    LoadFreeBusyViewFromXmlJsObject(jsObject: any, viewType: FreeBusyViewType, service: ExchangeService): void {
        var viewTypeString = jsObject[XmlElementNames.FreeBusyViewType];
        this.viewType = <FreeBusyViewType><any>FreeBusyViewType[viewTypeString];
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.MergedFreeBusy:
                    var mergedFreeBusy: string = jsObject[key];

                    for (var status of mergedFreeBusy.split('')) {
                        this.mergedFreeBusyStatus.push(<LegacyFreeBusyStatus>Number(status));
                    }
                    break;
                case XmlElementNames.CalendarEventArray:
                    var calendarEventArray = jsObject[key];
                    if (!calendarEventArray) break;
                    var calendarEvents:any[] = calendarEventArray[XmlElementNames.CalendarEvent];
                    if (!Array.isArray(calendarEvents)) {
                        calendarEvents = [calendarEvents]
                    }
                    for (var calendarEventObj of calendarEvents) {
                        var calendarEvent: CalendarEvent = new CalendarEvent();
                        calendarEvent.LoadFromXmlJsObject(calendarEventObj, service);
                        this.calendarEvents.push(calendarEvent);
                    }
                    break;
                case XmlElementNames.WorkingHours:
                    this.workingHours = new WorkingHours();
                    this.workingHours.LoadFromXmlJsObject(jsObject[key], service);
                    break;
            }
        }
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {        
    }
}

/**
 * Represents the response to an individual Id conversion operation.
 * 
 * @sealed
 */
export class ConvertIdResponse extends ServiceResponse {

    private convertedId: AlternateIdBase;

    /**
     * Gets the converted Id.
     */
    public get ConvertedId(): AlternateIdBase {
        return this.convertedId;
    }

    /**
     * @internal Initializes a new instance of the **ConvertIdResponse** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        let responseObject = jsObject[XmlElementNames.AlternateId];
        let alternateIdClass: string = responseObject[XmlAttributeNames.Type];
        if (alternateIdClass) {
            alternateIdClass = alternateIdClass.replace("t:", "");
        }

        switch (alternateIdClass) {
            case AlternateId.SchemaTypeName:
                this.convertedId = new AlternateId();
                break;
            case AlternatePublicFolderId.SchemaTypeName:
                this.convertedId = new AlternatePublicFolderId();
                break;
            case AlternatePublicFolderItemId.SchemaTypeName:
                this.convertedId = new AlternatePublicFolderItemId();
                break;
            default:
                EwsLogging.Assert(
                    false,
                    "ConvertIdResponse.ReadElementsFromXml",
                    StringHelper.Format("Unknown alternate Id class: {0}", alternateIdClass));
                break;
        }

        this.convertedId.LoadAttributesFromXmlJsObject(responseObject);
    }
}

/**
 * Represents the response to an individual attachment creation operation.
 * @sealed
 */
export class CreateAttachmentResponse extends ServiceResponse {

    private attachment: Attachment = null;

    /**
     * Gets the attachment that was created.
     */
    get Attachment(): Attachment {
        return this.attachment;
    }

    /**
     * Initializes a new instance of the **CreateAttachmentResponse** class.
     *
     * @param   {Attachment}   attachment   The attachment.
     */
    constructor(attachment: Attachment) {
        super();
        EwsLogging.Assert(
            attachment != null,
            "CreateAttachmentResponse.ctor",
            "attachment is null");

        this.attachment = attachment;
    }

    /**
      * @internal Reads response elements from Xml JsObject.
      *
      * @param   {any}               jsObject   The response object.
      * @param   {ExchangeService}   service    The service.
      */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        let attachmentArray: any[] = EwsServiceJsonReader.ReadAsArray(responseObject, XmlElementNames.Attachments);

        if (attachmentArray != null && attachmentArray.length > 0) {
            let attachmenTypetArray = EwsServiceJsonReader.ReadAsArray(attachmentArray[0], XmlElementNames.ItemAttachment);
            if (attachmenTypetArray.length > 0) {
                this.attachment.LoadFromXmlJsObject(attachmenTypetArray[0], service);
                return;
            }

            attachmenTypetArray = EwsServiceJsonReader.ReadAsArray(attachmentArray[0], XmlElementNames.FileAttachment);
            if (attachmenTypetArray.length > 0) {
                this.attachment.LoadFromXmlJsObject(attachmenTypetArray[0], service);
            }
        }
    }
}
export class CreateFolderResponse extends ServiceResponse {
    private folder: Folder = null;
    constructor(folder: Folder) {
        super();
        this.folder = folder;
    }
    GetObjectInstance(service: ExchangeService, xmlElementName: string): Folder {
        if (this.folder != null) {
            return this.folder;
        }
        else {
            var flinfo: FolderInfo = new FolderInfo();
            return flinfo.CreateEwsObjectFromXmlElementName<Folder>(service, xmlElementName);
        }
    }
    Loaded(): void {
        if (this.Result == ServiceResult.Success) {
            this.folder.ClearChangeLog();
        }
    }
    ReadElementsFromJson(responseObject: JsonObject, service: ExchangeService): any { throw new Error("CreateFolderResponse.ts - ReadElementsFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        if (responseObject[XmlElementNames.Folders]) {
            var folders: Folder[] = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Folder>(
                responseObject,
                service,
                XmlElementNames.Folders,
                this.GetObjectInstance.bind(this),
                false,               /* clearPropertyBag */
                null,   /* requestedPropertySet */
                false);              /* summaryPropertiesOnly */

            this.folder = folders[0];
        }
    }
}

/**
 * @internal Represents the response to a delegate managent-related operation.
 */
export class DelegateManagementResponse extends ServiceResponse {

    private readDelegateUsers: boolean = false;
    private delegateUsers: DelegateUser[] = null;
    private delegateUserResponses: DelegateUserResponse[] = null;

    /**
     * @internal Gets a collection of responses for each of the delegate users concerned by the operation.
     */
    get DelegateUserResponses(): DelegateUserResponse[] {
        return this.delegateUserResponses;
    }

    /**
     * @internal Initializes a new instance of the **DelegateManagementResponse** class.
     *
     * @param   {boolean}           readDelegateUsers   if set to *true* [read delegate users].
     * @param   {DelegateUser[]}    delegateUsers       List of existing delegate users to load.
     */
    constructor(readDelegateUsers: boolean, delegateUsers: DelegateUser[]) {
        super();
        this.readDelegateUsers = readDelegateUsers;
        this.delegateUsers = delegateUsers;
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        if (this.ErrorCode === ServiceError.NoError) {
            this.delegateUserResponses = [];
        }
        let jsResponses = responseObject[XmlElementNames.ResponseMessages];
        let delegateUserIndex: number = 0;

        for (let jsResponse of EwsServiceJsonReader.ReadAsArray(jsResponses, XmlElementNames.DelegateUserResponseMessageType)) {
            let delegateUser: DelegateUser = null;
            if (this.readDelegateUsers && (this.delegateUsers != null)) {
                delegateUser = this.delegateUsers[delegateUserIndex];
            }

            let delegateUserResponse: DelegateUserResponse = new DelegateUserResponse(this.readDelegateUsers, delegateUser);

            delegateUserResponse.LoadFromXmlJsObject(jsResponse, service);

            this.delegateUserResponses.push(delegateUserResponse);

            delegateUserIndex++;
        }
    }
} 

/**
 * Represents the response to an individual delegate user manipulation (add, remove, update) operation.
 * 
 * @sealed 
 */
export class DelegateUserResponse extends ServiceResponse {

    private readDelegateUser: boolean = false;
    private delegateUser: DelegateUser = null;

    /**
     * The delegate user that was involved in the operation.
     */
    get DelegateUser(): DelegateUser {
        return this.delegateUser;
    }

    /**
     * @internal Initializes a new instance of the **DelegateUserResponse** class.
     *
     * @param   {boolean}       readDelegateUsers   if set to *true* [read delegate users].
     * @param   {DelegateUser}  delegateUser        Existing DelegateUser to use (may be null).
     */
    constructor(readDelegateUser: boolean, delegateUser: DelegateUser) {
        super();
        this.readDelegateUser = readDelegateUser;
        this.delegateUser = delegateUser;
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        if (this.readDelegateUser) {
            if (this.delegateUser == null) {
                this.delegateUser = new DelegateUser();
            }

            this.delegateUser.LoadFromXmlJsObject(responseObject[XmlElementNames.DelegateUser], service);
        }
    }
}


/**
 * Represents the response to an individual attachment deletion operation.
 * @sealed
 */
export class DeleteAttachmentResponse extends ServiceResponse {

    private attachment: Attachment = null;

    /**
     * Gets the attachment that was deleted.
     */
    get Attachment(): Attachment {
        return this.attachment;
    }

    /**
     * Initializes a new instance of the **DeleteAttachmentResponse** class.
     *
     * @param   {Attachment}   attachment   The attachment.
     */
    constructor(attachment: Attachment) {
        super();
        EwsLogging.Assert(
            attachment != null,
            "CreateAttachmentResponse.ctor",
            "attachment is null");

        this.attachment = attachment;
    }

    /**
      * @internal Reads response elements from Xml JsObject.
      *
      * @param   {any}               jsObject   The response object.
      * @param   {ExchangeService}   service    The service.
      */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        if (responseObject[XmlElementNames.RootItemId]) {
            let jsRootItemId = responseObject[XmlElementNames.RootItemId];
            let changeKey;

            if (jsRootItemId[XmlAttributeNames.RootItemChangeKey] &&
                !StringHelper.IsNullOrEmpty(changeKey = jsRootItemId[XmlAttributeNames.RootItemChangeKey]) &&
                this.attachment.Owner != null) {
                this.attachment.Owner.RootItemId.ChangeKey = changeKey;
            }
        }
    }
}

/**
 * @internal  Represents the response to a DisableApp operation.
 * Today this class doesn't add extra functionality. Keep this class here so future we can return extension info up-on installation complete.
 * 
 * @sealed 
 */
export class DisableAppResponse extends ServiceResponse {

    /**
	 * @internal Initializes a new instance of the **DisableAppResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        //does nothing, here to supress base class message about ReadElementsFromXmlJsObject when BatchProcessingStopped is false
    }
}
/**
 * ## *Not Implemented* 
 */
export class ExecuteDiagnosticMethodResponse extends ServiceResponse {
    ReturnValue: any;// System.Xml.XmlDocument;
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("ExecuteDiagnosticMethodResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); }
}
export class ExpandGroupResponse extends ServiceResponse {
    private members: ExpandGroupResults = new ExpandGroupResults();
    get Members(): ExpandGroupResults {
        return this.members;
    }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        this.Members.LoadFromXmlJsObject(responseObject, service);
    }
}

/**
 * @internal Represents the response to a Conversation search operation.
 * 
 * @sealed
 */
export class FindConversationResponse extends ServiceResponse {

    /**
     * @internal Gets FindConversation results.
     * 
     * @private set()     * 
     * @returns FindConversation results.
     * 
     */
    Results: FindConversationResults;

    /**
     * @internal Gets the collection of conversations in results.
     */
    get Conversations(): Conversation[] {
        return this.Results.Conversations;
    }

    /**
     * @internal Initializes a new instance of the **FindConversationResponse** class.
     */
    constructor() {
        super();
        this.Results = new FindConversationResults();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        EwsLogging.Assert(
            this.Results.Conversations != null,
            "FindConversationResponse.ReadElementsFromXml",
            "conversations is null.");

        EwsLogging.Assert(
            this.Results.HighlightTerms != null,
            "FindConversationResponse.ReadElementsFromXml",
            "highlightTerms is null.");

        if (responseObject[XmlElementNames.Conversations]) {
            for (let conversationObject of EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.Conversations], XmlElementNames.Conversation)) {
                let jsonConversation: any = conversationObject;// as JsonObject;

                let item: Conversation = (new ItemInfo()).CreateEwsObjectFromXmlElementName<Conversation>(service, XmlElementNames.Conversation);

                if (item != null) {
                    item.LoadFromXmlJsObject(
                        jsonConversation,
                        service,
                        true,
                        null,
                        false);

                    this.Conversations.push(item);
                }
            }
        }

        if (responseObject[XmlElementNames.HighlightTerms]) {

            let highlightTermObjects: any[] = EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.HighlightTerms], XmlElementNames.HighlightTerm);
            if (highlightTermObjects != null) {
                for (let highlightTermObject of highlightTermObjects) {
                    let jsonHighlightTerm: any = highlightTermObject;// as JsonObject;
                    let term: HighlightTerm = new HighlightTerm();

                    term.LoadFromXmlJsObject(jsonHighlightTerm, service);
                    this.Results.HighlightTerms.push(term);
                }
            }
        }

        if (responseObject[XmlElementNames.TotalConversationsInView]) {
            this.Results.TotalCount = Convert.toNumber(responseObject[XmlElementNames.TotalConversationsInView]);
        }

        if (responseObject[XmlElementNames.IndexedOffset]) {
            this.Results.IndexedOffset = Convert.toNumber(responseObject[XmlElementNames.IndexedOffset]);
        }
    }
}
export class FindFolderResponse extends ServiceResponse {
    get Results(): FindFoldersResults { return this.results; }
    private results: FindFoldersResults = new FindFoldersResults();
    private propertySet: PropertySet;
    constructor(propertySet: PropertySet) {
        super();
        this.propertySet = propertySet;

        EwsLogging.Assert(
            this.propertySet != null,
            "FindFolderResponse.ctor",
            "PropertySet should not be null");
    }
    CreateFolderInstance(service: ExchangeService, xmlElementName: string): Folder {
        var flinfo: FolderInfo = new FolderInfo();
        return flinfo.CreateEwsObjectFromXmlElementName<Folder>(service, xmlElementName);

    }
    ReadElementsFromJson(responseObject: any, service: ExchangeService): any { throw new Error("FindFolderResponse.ts - ReadElementsFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        var rootFolder = responseObject[XmlElementNames.RootFolder];
        this.results.TotalCount = Number(rootFolder[XmlAttributeNames.TotalItemsInView]);
        this.results.MoreAvailable = !Convert.toBool(rootFolder[XmlAttributeNames.IncludesLastItemInRange]);

        // Ignore IndexedPagingOffset attribute if moreItemsAvailable is false.
        var nextPageOffset: number = null;
        if (this.results.MoreAvailable) {
            if (rootFolder[XmlAttributeNames.IndexedPagingOffset]) {
                nextPageOffset = Number(rootFolder[XmlAttributeNames.IndexedPagingOffset]);
            }
        }
        if (rootFolder[XmlElementNames.Folders]) {
            var folders: Folder[] = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Folder>(
                rootFolder,
                service,
                XmlElementNames.Folders,
                this.CreateFolderInstance,
                true,               /* clearPropertyBag */
                this.propertySet,   /* requestedPropertySet */
                true);              /* summaryPropertiesOnly */

            folders.forEach((item, index) => { this.results.Folders.push(item) });
        }
    }
}


export class FindItemResponse<TItem extends Item> extends ServiceResponse {
    get GroupedFindResults(): GroupedFindItemsResults<TItem> { return this.groupedFindResults; }
    get Results(): FindItemsResults<TItem> { return this.results; }
    private results: FindItemsResults<TItem>;
    private isGrouped: boolean = false;
    private groupedFindResults: GroupedFindItemsResults<TItem>;
    private propertySet: PropertySet;

    constructor(isGrouped: boolean, propertySet: PropertySet) {
        super();
        this.isGrouped = isGrouped;
        this.propertySet = propertySet;

        EwsLogging.Assert(
            this.propertySet != null,
            "FindItemResponse.ctor",
            "PropertySet should not be null");
    }
    CreateItemInstance(service: ExchangeService, xmlElementName: string): TItem {
        var itemInfo = new ItemInfo();
        return itemInfo.CreateEwsObjectFromXmlElementName<TItem>(service, xmlElementName);
        //return EwsUtilities.CreateEwsObjectFromXmlElementName<TItem>(service, xmlElementName);
    }
    InternalReadItemsFromJson(jsonObject: any /*JsonObject*/, propertySet: PropertySet, service: ExchangeService, destinationList: TItem[]/*System.Collections.Generic.IList<TItem>*/): void { throw new Error("FindItemResponse.ts - InternalReadItemsFromJson : Not implemented."); }
    InternalReadItemsFromXmlJsObject(jsonObject: any, propertySet: PropertySet, service: ExchangeService, destinationList: TItem[]/*System.Collections.Generic.IList<TItem>*/): void {
        EwsLogging.Assert(
            destinationList != null,
            "FindItemResponse.InternalReadItemsFromJson",
            "destinationList is null.");

        if (jsonObject[XmlElementNames.Items]) {
            var items: TItem[] = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<TItem>(
                jsonObject,
                service,
                XmlElementNames.Items,
                this.CreateItemInstance,
                true,               /* clearPropertyBag */
                this.propertySet,   /* requestedPropertySet */
                true);              /* summaryPropertiesOnly */

            items.forEach((item, index) => { destinationList.push(item) });
        }
    }
    ReadElementsFromJson(responseObject: any /*JsonObject*/, service: ExchangeService): void { throw new Error("FindItemResponse.ts - ReadElementsFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        var rootFolder = responseObject[XmlElementNames.RootFolder];
        var totalItemsInView: number = Number(rootFolder[XmlAttributeNames.TotalItemsInView]);
        var moreItemsAvailable: boolean = !Convert.toBool(rootFolder[XmlAttributeNames.IncludesLastItemInRange]);

        // Ignore IndexedPagingOffset attribute if moreItemsAvailable is false.
        var nextPageOffset: number = null;
        if (moreItemsAvailable) {
            if (rootFolder[XmlAttributeNames.IndexedPagingOffset]) {
                nextPageOffset = Number(rootFolder[XmlAttributeNames.IndexedPagingOffset]);
            }
        }

        if (!this.isGrouped) {
            this.results = new FindItemsResults<TItem>();
            this.results.TotalCount = totalItemsInView;
            this.results.NextPageOffset = nextPageOffset;
            this.results.MoreAvailable = moreItemsAvailable;
            this.InternalReadItemsFromXmlJsObject(
                rootFolder,
                this.propertySet,
                service,
                this.results.Items);
        }
        else {
            this.groupedFindResults = new GroupedFindItemsResults<TItem>();
            this.groupedFindResults.TotalCount = totalItemsInView;
            this.groupedFindResults.NextPageOffset = nextPageOffset;
            this.groupedFindResults.MoreAvailable = moreItemsAvailable;

            if (rootFolder[XmlElementNames.Groups]) {
                var jsGroups: any[] = EwsServiceJsonReader.ReadAsArray(rootFolder, XmlElementNames.Groups);

                for (var jsGroup of jsGroups) //jsGroups.OfType<JsonObject>()
                {
                    if (jsGroup[XmlElementNames.GroupedItems]) {
                        var jsGroupedItemCollection: any[] = EwsServiceJsonReader.ReadAsArray(jsGroup, XmlElementNames.GroupedItems);
                        for (var jsGroupedItem of jsGroupedItemCollection) {
                            var groupIndex: string = jsGroupedItem[XmlElementNames.GroupIndex];

                            var itemList: TItem[] = [];// new List<TItem>();
                            this.InternalReadItemsFromXmlJsObject(
                                jsGroupedItem,
                                this.propertySet,
                                service,
                                itemList);
                            this.groupedFindResults.ItemGroups.push(new ItemGroup<TItem>(groupIndex, itemList));
                        }
                    }
                }
            }
        }
        //debug: //ref: need to find example.
        //todo: check highlight terms and grouping.
        if (responseObject[XmlElementNames.HighlightTerms]) {
            var highlightTermElements: any[] = EwsServiceJsonReader.ReadAsArray(responseObject, XmlElementNames.HighlightTerms);
            for (var highlightTermElement of highlightTermElements) {
                if (highlightTermElement[XmlElementNames.HighlightTerm]) {
                    var highlightTermObjects = EwsServiceJsonReader.ReadAsArray(highlightTermElement, XmlElementNames.HighlightTerm);
                    for (var jsonHighlightTerm of highlightTermObjects) {
                        var term: HighlightTerm = new HighlightTerm();
                        term.LoadFromXmlJsObject(jsonHighlightTerm, service);
                        this.results.HighlightTerms.push(term);
                    }
                }
            }
        }
    }
}

/**
 * @internal Represents the response to a GetAppManifests operation.
 * 
 * @sealed
 */
export class GetAppManifestsResponse extends ServiceResponse {

	/**
	 * List of manifests returned in the response. 
	 */
	private manifests: string[] = [];//XmlDocument[]

	/**
	 * List of extensions returned in the response.
	 */
	private apps: ClientApp[] = [];

	/**
	 * Gets all manifests returned
	 * 
	 * /remarks/	Provided for backwards compatibility with Exchange 2013.
	 * base64 encoded xml file in string
	 */
	get Manifests(): string[] { //XmlDocument[]
		return this.manifests;
	}

	/**
	 * Gets all apps returned.
	 * 
	 * /remarks/	Introduced for Exchange 2013 Sp1 to return additional metadata.
	 */
	get Apps(): ClientApp[] {
		return this.apps;
	}

	/**
	 * @internal Initializes a new instance of the **GetAppManifestsResponse** class.
	 */
	constructor() {
		super();
	}

	/**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
	ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		this.Manifests.splice(0);

		// We can have a response from Exchange 2013 (first time this API was introduced)
		// or the newer response, starting in Exchange 2013 SP1, (X-EWS-TargetVersion: 2.5 or above) 
		let exchange2013Response: boolean = false;
		if (jsObject[XmlElementNames.Manifests]) {
			exchange2013Response = true;
		}
		else if (jsObject[XmlElementNames.Apps]) {
			exchange2013Response = false;
		}
		else {
			throw new ServiceXmlDeserializationException(
				StringHelper.Format(
					Strings.UnexpectedElement,
					EwsUtilities.GetNamespacePrefix(XmlNamespace.Messages),
					XmlElementNames.Manifests,
					"Element",
					"N/A",
					"N/A"));
		}

		if (exchange2013Response) {
			this.ReadFromExchange2013(jsObject, service);
		}
		else {
			this.ReadFromExchange2013Sp1(jsObject, service);
		}
	}

	/**
     * Read the response from Exchange 2013.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
	private ReadFromExchange2013(jsObject: any, service: ExchangeService): void {

		////<GetAppManifestsResponse ResponseClass="Success" xmlns="http://schemas.microsoft.com/exchange/services/2006/messages">
		////<ResponseCode>NoError</ResponseCode>
		////<m:Manifests xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">   
		////<m:Manifest>[base 64 encoded manifest]</m:Manifest>                              <--- reader should be at this node at the beginning of loop
		////<m:Manifest>[base 64 encoded manifest]</m:Manifest>
		//// ....
		////</m:Manifests>                                                                   <--- reader should be at this node at the end of the loop

		let responses: any[] = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.Manifests], XmlElementNames.Manifest);

		for (let response of responses) {
			this.manifests.push(response);
			let app: ClientApp = new ClientApp();
			app.Manifest = response;
			this.apps.push(app);
		}
	}


	/**
     * Read the response from Exchange 2013 SP1 and later.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
	private ReadFromExchange2013Sp1(jsObject: any, service: ExchangeService): void {

		////<GetAppManifestsResponse ResponseClass="Success" xmlns="http://schemas.microsoft.com/exchange/services/2006/messages">
		////  <ResponseCode>NoError</ResponseCode>
		////  <m:Apps xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">
		////    <t:App xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types">       <--- reader should be at this node at the beginning of the loop
		////      <t:Metadata>
		////        <t:EndNodeUrl>http://o15.officeredir.microsoft.com/r/rlidMktplcExchRedirect?app=outlook.exe&amp;ver=15&amp;clid=1033&amp;p1=15d0d766d0&amp;p2=4&amp;p3=0&amp;p4=WA&amp;p5=en-US\WA102996382&amp;Scope=2&amp;CallBackURL=https%3a%2f%2fexhv-4880%2fecp%2fExtension%2finstallFromURL.slab%3fexsvurl%3d1&amp;DeployId=EXHV-4680dom.extest.microsoft.com</t:EndNodeUrl>
		////        <t:AppStatus>2.3</t:AppStatus>
		////        <t:ActionUrl>http://o15.officeredir.microsoft.com/r/rlidMktplcExchRedirect?app=outlook.exe&amp;ver=15&amp;clid=1033&amp;p1=15d0d766d0&amp;p2=4&amp;p3=0&amp;p4=WA&amp;p5=en-US\WA102996382&amp;Scope=2&amp;CallBackURL=https%3a%2f%2fexhv-4880%2fecp%2fExtension%2finstallFromURL.slab%3fexsvurl%3d1&amp;DeployId=EXHV-4680dom.extest.microsoft.com</t:ActionUrl>
		////      </t:Metadata>
		////      <t:Manifest>[base 64 encoded manifest]</t:Manifest>
		////    </t:App>
		////    <t:App xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types">
		////      ....
		////  <m:Apps>    <----- reader should be at this node at the end of the loop

		let responses: any[] = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.Apps], XmlElementNames.App);

		for (let response of responses) {

			let clientApp: ClientApp = new ClientApp();

			clientApp.LoadFromXmlJsObject(response, service);

			this.apps.push(clientApp);
			this.manifests.push(clientApp.Manifest);
		}
	}
}

/**
 * @internal  Represents the response to a GetAppMarketplaceUrl operation
 * 
 * @sealed
 */
export class GetAppMarketplaceUrlResponse extends ServiceResponse {

	private appMarketplaceUrl: string;

	/**
	 * App Marketplace Url
	 */
	get AppMarketplaceUrl(): string {
		return this.appMarketplaceUrl;
	}

	/**
	 * @internal Initializes a new instance of the **GetAppMarketplaceUrlResponse** class.
	 */
	constructor() {
		super();
	}

	/**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {

		this.appMarketplaceUrl = <string>jsObject[XmlElementNames.AppMarketplaceUrl];
	}
}

/**
 * Represents the response to an individual attachment retrieval request.
 */
export class GetAttachmentResponse extends ServiceResponse {
    private attachment: Attachment = null;
    get Attachment(): Attachment {
        return this.attachment;
    }

    /**
     * @internal Initializes a new instance of the **GetAttachmentResponse** class.
     *
     * @param   {Attachment}   attachment   The attachment.
     */
    constructor(attachment: Attachment) {
        super();
        this.attachment = attachment;
    }

    /**
     * @internal Reads response elements from XMLJsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service          The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {

        if (jsObject[XmlElementNames.Attachments]) {
            let attachmentContainer = jsObject[XmlElementNames.Attachments];
            let attachment = attachmentContainer[XmlElementNames.FileAttachment] || attachmentContainer[XmlElementNames.ItemAttachment] || attachmentContainer;
            if (this.attachment == null) {
                if (attachmentContainer[XmlElementNames.FileAttachment]) {
                    this.attachment = new FileAttachment(service);
                }
                else if (attachmentContainer[XmlElementNames.ItemAttachment]) {
                    this.attachment = <any><any>new ItemAttachment(service);
                }
            }

            if (this.attachment != null) {
                this.attachment.LoadFromXmlJsObject(attachment, service);
            }
        }
    }
}

/**
 * Represents the response to a GetClientAccessToken operation.
 * 
 * @sealed
 */
export class GetClientAccessTokenResponse extends ServiceResponse {

	Id: string;
	TokenType: ClientAccessTokenType;
	TokenValue: string = null;
	TTL: number = 0;

	/**
	 * Initializes a new instance of the **GetClientAccessTokenResponse** class.
	 *
	 * @param   {string}   					id          Id
	 * @param   {ClientAccessTokenType}   	tokenType   Token type
	 */
	constructor(id: string, tokenType: ClientAccessTokenType);
	constructor(id: string = null, tokenType: ClientAccessTokenType = ClientAccessTokenType.CallerIdentity) {
		super();
		this.Id = id;
		this.TokenType = tokenType;
	}

	/**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {

		if (responseObject[XmlElementNames.Token]) {
			let jsObject = responseObject[XmlElementNames.Token];

			this.Id = jsObject[XmlElementNames.Id];
			this.TokenType = ClientAccessTokenType[<string>jsObject[XmlElementNames.TokenType]];
			this.TokenValue = jsObject[XmlElementNames.TokenValue];
			this.TTL = Convert.toNumber(jsObject[XmlElementNames.TTL]);
		}
	}
}
/**
 * ## *Not Implemented* 
 */
export class GetClientExtensionResponse extends ServiceResponse {
    ClientExtensions: ClientExtension[];//System.Collections.ObjectModel.Collection<ClientExtension>;
    RawMasterTableXml: string;
    private clientExtension: ClientExtension[];//System.Collections.ObjectModel.Collection<ClientExtension>;
    private rawMasterTableXml: string;
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("GetClientExtensionResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); }
}

/**
 * Represents the response to a GetConversationItems operation.
 * 
 * @sealed
 */
export class GetConversationItemsResponse extends ServiceResponse {

    private propertySet: PropertySet;

    /**
     * Gets or sets the conversation.
     * 
     * @value   The conversation.
     */
    Conversation: ConversationResponse;

    /**
     * @internal Initializes a new instance of the **GetConversationItemsResponse** class.
     *
     * @param   {PropertySet}   propertySet   The property set.
     */
    constructor(propertySet: PropertySet) {
        super();
        this.propertySet = propertySet;
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        this.Conversation = new ConversationResponse(this.propertySet);
        this.Conversation.LoadFromXmlJsObject(responseObject[XmlElementNames.Conversation], service);
    }
}

/**
 * Represents the GetDiscoverySearchConfiguration response.
 * 
 * @sealed
 */
export class GetDiscoverySearchConfigurationResponse extends ServiceResponse {

    private configurations: DiscoverySearchConfiguration[] = [];

    /**
     * Searchable mailboxes result
     */
    get DiscoverySearchConfigurations(): DiscoverySearchConfiguration[] {
        return this.configurations;
    }

    /**
	 * @internal Initializes a new instance of the **GetDiscoverySearchConfigurationResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        this.configurations.splice(0);

        //super.ReadElementsFromXmlJsObject(jsObject, service);

        if (jsObject[XmlElementNames.DiscoverySearchConfigurations]) {
            for (let searchConfiguration of EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.DiscoverySearchConfigurations], XmlElementNames.DiscoverySearchConfiguration)) {
                this.configurations.push(DiscoverySearchConfiguration.LoadFromXmlJsObject(searchConfiguration, service));
            }
        }
    }
}
/**
 * ## *Not Implemented* 
 */
export class GetEncryptionConfigurationResponse extends ServiceResponse {
    ImageBase64: string;
    EmailText: string;
    PortalText: string;
    DisclaimerText: string;
    private imageBase64: string;
    private emailText: string;
    private portalText: string;
    private disclaimerText: string;
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("GetEncryptionConfigurationResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); }
}

/**
 * @internal Represents the response to a subscription event retrieval operation.
 * 
 * @sealed
 */
export class GetEventsResponse extends ServiceResponse {

	private results: GetEventsResults = new GetEventsResults();

	/**
	 * @internal Gets event results from subscription.
	 */
	get Results(): GetEventsResults {
		return this.results;
	}

	/**
	 * @internal Initializes a new instance of the **GetEventsResponse** class.
	 */
	constructor() {
		super();
	}

	/**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		
		this.results.LoadFromXmlJsObject(jsObject, service);
	}
}
export class GetFolderResponse extends ServiceResponse {
    get Folder(): Folder { return this.folder; }
    private folder: Folder;
    private propertySet: PropertySet;

    constructor(folder: Folder, propertySet: PropertySet) {
        super();

        this.folder = folder;
        this.propertySet = propertySet;

        EwsLogging.Assert(
            this.propertySet != null,
            "GetFolderResponse.ctor",
            "PropertySet should not be null");
    }

    GetObjectInstance(service: ExchangeService, xmlElementName: string): Folder {
        if (this.Folder != null) {
            return this.Folder;
        }
        else {
            var flinfo: FolderInfo = new FolderInfo();
            return flinfo.CreateEwsObjectFromXmlElementName<Folder>(service, xmlElementName);
        }
    }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        if (responseObject[XmlElementNames.Folders]) {
            var folders: Folder[] = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Folder>(
                responseObject,
                service,
                XmlElementNames.Folders,
                this.GetObjectInstance.bind(this),
                true,               /* clearPropertyBag */
                this.propertySet,   /* requestedPropertySet */
                false);              /* summaryPropertiesOnly */

            this.folder = folders[0];
        }
    }

}

/**
 * Represents the GetHoldOnMailboxes response.
 * 
 * @sealed
 */
export class GetHoldOnMailboxesResponse extends ServiceResponse {

    private holdResult: MailboxHoldResult = null;

    /**
     * Mailbox hold result
     */
    get HoldResult(): MailboxHoldResult {
        return this.holdResult;
    }

    /**
	 * @internal Initializes a new instance of the **GetHoldOnMailboxesResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        //super.ReadElementsFromXmlJsObject(jsObject, service);

        if (jsObject[XmlElementNames.MailboxHoldResult]) {
            this.holdResult = MailboxHoldResult.LoadFromXmlJsObject(jsObject[XmlElementNames.MailboxHoldResult], service);
        }
    }
}

/**
 * @internal Represents the response to a GetInboxRules operation.
 * 
 * @sealed
 */
export class GetInboxRulesResponse extends ServiceResponse {

	/**
	 * Rule collection.
	 */
	private ruleCollection: RuleCollection;

	/**
	 * @internal Gets the rule collection in the response.
	 */
	get Rules(): RuleCollection {
		return this.ruleCollection;
	}

	/**
	 * @internal Initializes a new instance of the **GetInboxRulesResponse** class.
	 */
	constructor() {
		super()
		this.ruleCollection = new RuleCollection();
	}

	/**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
		this.ruleCollection.OutlookRuleBlobExists = Convert.toBool(responseObject[XmlElementNames.OutlookRuleBlobExists]);
		if (responseObject[XmlElementNames.InboxRules]) {
			this.ruleCollection.LoadFromXmlJsObject(responseObject[XmlElementNames.InboxRules], service);
		}
	}
}
export class GetItemResponse extends ServiceResponse {

    private item: Item = null;
    private propertySet: PropertySet = null;
    get Item(): Item {
        return this.item;
    }
    constructor(item: Item, propertySet: PropertySet) {
        super();
        this.item = item;
        this.propertySet = propertySet;
        EwsLogging.Assert(this.propertySet !== null, "GetItemResponse.ctor", "PropertySet should not be null");
    }
    GetObjectInstance(service: ExchangeService, xmlElementName: string): Item {
        if (this.Item != null) {
            return this.Item;
        }
        else {

            return new ItemInfo().CreateEwsObjectFromXmlElementName<Item>(service, xmlElementName);
        }
    }
    //ReadElementsFromJson(responseObject: any, service: ExchangeService): any { throw new Error("GetItemResponse.ts - ReadElementsFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        var items: Item[] = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Item>(
            responseObject,
            service,
            XmlElementNames.Items,
            (s, e) => { return this.GetObjectInstance(s, e); },
            true,               /* clearPropertyBag         */
            this.propertySet,   /* requestedPropertySet     */
            false);             /* summaryPropertiesOnly    */

        this.item = items[0];
    }
}

/**
 * Represents the GetNonIndexableItemDetails response.
 * 
 * @sealed
 */
export class GetNonIndexableItemDetailsResponse extends ServiceResponse {

    /**
     * Non indexable item result
     * 
     * internal set
     */
    NonIndexableItemsResult: NonIndexableItemDetailsResult = null;

    /**
	 * @internal Initializes a new instance of the **GetDiscoverySearchConfigurationResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        //super.ReadElementsFromXmlJsObject(jsObject,service);
        if (jsObject[XmlElementNames.NonIndexableItemDetailsResult]) {
            this.NonIndexableItemsResult = NonIndexableItemDetailsResult.LoadFromXmlJsObject(jsObject[XmlElementNames.NonIndexableItemDetailsResult], service);
        }
    }
}

/**
 * Represents the GetNonIndexableItemStatistics response.
 * 
 * @sealed
 */
export class GetNonIndexableItemStatisticsResponse extends ServiceResponse {

    /**
     * List of non indexable statistic
     */
    NonIndexableStatistics: NonIndexableItemStatistic[] = null;

    /**
	 * @internal Initializes a new instance of the **GetNonIndexableItemStatisticsResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        //super.ReadElementsFromXmlJsObject(jsObject,service);
        this.NonIndexableStatistics = [];
        if (jsObject[XmlElementNames.NonIndexableItemStatistics]) {
            for (let nonIndexableItemStatistic of EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.NonIndexableItemStatistics], XmlElementNames.NonIndexableItemStatistic)) {
                this.NonIndexableStatistics.push(NonIndexableItemStatistic.LoadFromXmlJsObject(nonIndexableItemStatistic, service));
            }
        }
    }
}
export class GetPasswordExpirationDateResponse extends ServiceResponse {
    private passwordExpirationDate: DateTime = null;
    get PasswordExpirationDate(): DateTime {
        return this.passwordExpirationDate;
    }
    ReadElementsFromJson(responseObject: any, service: ExchangeService): any { throw new Error("GetPasswordExpirationDateResponse.ts - ReadElementsFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        this.passwordExpirationDate = service.ConvertUniversalDateTimeStringToLocalDateTime(responseObject[XmlElementNames.PasswordExpirationDate]);
    }
}
/**
 * ## *Not Implemented* 
 */
export class GetPhoneCallResponse extends ServiceResponse {
    PhoneCall: PhoneCall;
    private phoneCall: PhoneCall;
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("GetPhoneCallResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); }
}

/**
 * @internal Represents the response to a GetRoomLists operation.
 */
export class GetRoomListsResponse extends ServiceResponse {

    private roomLists: EmailAddressCollection = new EmailAddressCollection();

    /**
     * Gets all room list returned
     */
    public get RoomLists(): EmailAddressCollection {
        return this.roomLists;
    }

    /**
     * @internal Initializes a new instance of the **GetRoomListsResponse** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        this.roomLists.Clear();
        let responses = EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.RoomLists], XmlElementNames.Address);
        for (let response of responses) {
            let emailAddress = new EmailAddress();
            emailAddress.LoadFromXmlJsObject(response, service);
            this.roomLists.Add(emailAddress);
        }
    }
}

/**
 * @internal Represents the response to a GetRooms operation.
 * 
 * @sealed
 */
export class GetRoomsResponse extends ServiceResponse {

    private rooms: EmailAddress[] = [];

    /**
     * Gets collection for all rooms returned
     */
    get Rooms(): EmailAddress[] {
        return this.rooms;
    }

    /**
     * @internal Initializes a new instance of the **GetRoomsResponse** class.
     */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        this.rooms.splice(0);
        let responses = EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.Rooms], XmlElementNames.Room);
        for (let response of responses) {
            let emailAddress = new EmailAddress();
            emailAddress.LoadFromXmlJsObject(response[XmlElementNames.RoomId], service);
            this.rooms.push(emailAddress);
        }
    }
}

/**
 * Represents the GetSearchableMailboxes response.
 * 
 * @sealed
 */
export class GetSearchableMailboxesResponse extends ServiceResponse {
    private searchableMailboxes: SearchableMailbox[] = [];

    /**
     * Searchable mailboxes result
     */
    get SearchableMailboxes(): SearchableMailbox[] {
        return this.searchableMailboxes;
    }

    /**
     * Failed mailboxes
     */
    FailedMailboxes: FailedSearchMailbox[] = null;

    /**
	 * @internal Initializes a new instance of the **GetSearchableMailboxesResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {

        this.searchableMailboxes.splice(0);

        //super.ReadElementsFromXmlJsObject(jsObject, service);

        if (jsObject[XmlElementNames.SearchableMailboxes]) {
            for (let searchableMailboxObject of EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.SearchableMailboxes], XmlElementNames.SearchableMailbox)) {
                this.searchableMailboxes.push(SearchableMailbox.LoadFromXmlJsObject(searchableMailboxObject, service));
            }
        }
        if (jsObject[XmlElementNames.FailedMailboxes]) {
            this.FailedMailboxes = FailedSearchMailbox.LoadFromXmlJsObject(jsObject[XmlElementNames.FailedMailboxes], service);
        }
    }
}

/**
 * internal Represents the response to a GetServerTimeZones request.
 */
export class GetServerTimeZonesResponse extends ServiceResponse {

    private timeZones: TimeZoneInfo[] = [];

    /**
     * Gets the time zones returned by the associated GetServerTimeZones request.
     * @value   The time zones.
     */
    get TimeZones(): TimeZoneInfo[] {
        return this.timeZones;
    }

    /**
	 * @internal Initializes a new instance of the **GetServerTimeZonesResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        if (responseObject[XmlElementNames.TimeZoneDefinitions]) {
            for (let tzObject of EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.TimeZoneDefinitions], XmlElementNames.TimeZoneDefinition)) {
                let timeZoneDefinition: TimeZoneDefinition = new TimeZoneDefinition();
                timeZoneDefinition.LoadFromXmlJsObject(tzObject, service)

                this.timeZones.push(timeZoneDefinition.ToTimeZoneInfo(service, true));
            }
        }
    }
}


/**
 * Enumeration of ConnectionStatus that can be returned by the server.
 */
enum ConnectionStatus {
	OK = 0,
	Closed = 1
}

/**
 * @internal Represents the response to a subscription event retrieval operation.
 * 
 * @sealed
 */
export class GetStreamingEventsResponse extends ServiceResponse {

	results: GetStreamingEventsResults = new GetStreamingEventsResults();
	request: HangingServiceRequestBase = null;

	/**
	 * Gets event results from subscription.
	 */
	get Results(): GetStreamingEventsResults {
		return this.results;
	}

	/**
	 * Gets the error subscription ids.
	 * 
	 * @private set
	 * @value	The error subscription ids.
	 */
	ErrorSubscriptionIds: string[] = [];

	/**
	 * Initializes a new instance of the **GetStreamingEventsResponse** class.
	 *
	 * @param   {HangingServiceRequestBase}   request   Request to disconnect when we get a close message.
	 */
	constructor(request: HangingServiceRequestBase) {
		super();
		this.ErrorSubscriptionIds = [];
		this.request = request;
	}

	/**
     * @internal Loads extra error details from XML
     *
     * @param   {any}   			responseObject      Json Object converted from XML.
     * @param   {ExchangeService}   service             The service.    
     */
    LoadExtraErrorDetailsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
		super.LoadExtraErrorDetailsFromXmlJsObject(responseObject, service);

		if (responseObject[XmlElementNames.ErrorSubscriptionIds]) {
			let errorSubscriptionIds = responseObject[XmlElementNames.ErrorSubscriptionIds];
			if (errorSubscriptionIds[XmlElementNames.SubscriptionId]) {
				let subscriptionIds = EwsServiceJsonReader.ReadAsArray(errorSubscriptionIds, XmlElementNames.SubscriptionId);
				subscriptionIds.forEach((subscriptionId) => {
					this.ErrorSubscriptionIds.push(subscriptionId);
				});
			}
		}
	}

	/**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		if (jsObject[XmlElementNames.Notifications]) {
			this.results.LoadFromXmlJsObject(jsObject[XmlElementNames.Notifications], service);
		}

		if (jsObject[XmlElementNames.ConnectionStatus]) {
			let connectionStatus: string = jsObject[XmlElementNames.ConnectionStatus];
			if (connectionStatus === ConnectionStatus[ConnectionStatus.Closed]) {
				this.request.Disconnect(HangingRequestDisconnectReason.Clean, null);
			}
		}
	}
}

/**
 * @internal Represents a response to a GetUserConfiguration request.
 * 
 * @sealed
 */
export class GetUserConfigurationResponse extends ServiceResponse {

    private userConfiguration: UserConfiguration = null;

    /**
     * Gets the user configuration that was created.
     */
    get UserConfiguration(): UserConfiguration {
        return this.userConfiguration;
    }

    /**
     * @internal Initializes a new instance of the **GetUserConfigurationResponse** class.
     *
     * @param   {UserConfiguration}   userConfiguration   The userConfiguration.
     */
    constructor(userConfiguration: UserConfiguration) {
        super();
        EwsLogging.Assert(userConfiguration !== null, "GetUserConfigurationResponse.ctor", "userConfiguration is null");
        this.userConfiguration = userConfiguration;
    }

    /**
     * @internal Reads response elements from XML parsed to JS Object.
     *
     * @param   {any}               responseObject   The response object.
     * @param   {ExchangeService}   service          The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        this.UserConfiguration.LoadFromXmlJsObject(responseObject[XmlElementNames.UserConfiguration], service);
    }
}

/**
 * @internal Represents response to GetUserOofSettings request.
 */
export class GetUserOofSettingsResponse extends ServiceResponse {
    private oofSettings: OofSettings = null;

    /**
     * Gets or sets the OOF settings.
     *
     * @value The oof settings.
     */
    get OofSettings(): OofSettings {
        return this.oofSettings;
    }
    set OofSettings(value: OofSettings) {
        this.oofSettings = value;
    }

    /**
     * @internal Initializes a new instance of the **GetUserOofSettingsResponse** class.
     */
    constructor() {
        super();
    }
}

/**
 * Represents the GetUserRetentionPolicyTagsResponse response.
 * 
 * @sealed
 */
export class GetUserRetentionPolicyTagsResponse extends ServiceResponse {

	private retentionPolicyTags: RetentionPolicyTag[] = [];

	/**
	 * Retention policy tags result.
	 */
	get RetentionPolicyTags(): RetentionPolicyTag[] {
		return this.retentionPolicyTags;
	}

	/**
	 * @internal Initializes a new instance of the **GetUserRetentionPolicyTagsResponse** class.
	 */
	constructor() {
		super()
	}

	/**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
		this.retentionPolicyTags.splice(0);

		if (responseObject[XmlElementNames.RetentionPolicyTags]) {
			for (let retentionPolicyTagObject of EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.RetentionPolicyTags], XmlElementNames.RetentionPolicyTag)) {
				this.retentionPolicyTags.push(RetentionPolicyTag.LoadFromXmlJsObject(retentionPolicyTagObject));
			}
		}
	}
}

/**
 * @internal  Represents the response to a InstallApp operation.
 * Today this class doesn't add extra functionality. Keep this class here so future we can return extension info up-on installation complete.
 * 
 * @sealed 
 */
export class InstallAppResponse extends ServiceResponse {

    /**
	 * @internal Initializes a new instance of the **InstallAppResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        //does nothing, here to supress base class message about ReadElementsFromXmlJsObject when BatchProcessingStopped is false
    }
}
export class MarkAsJunkResponse extends ServiceResponse {
    MovedItemId: ItemId = null;
    constructor() {
        super();
    }
    //ReadElementsFromJson(responseObject: any, service: ExchangeService): any { throw new Error("MarkAsJunkResponse.ts - ReadElementsFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        if (responseObject[XmlElementNames.Token]) {
            this.MovedItemId = new ItemId();
            this.MovedItemId.LoadFromXmlJsObject(responseObject[XmlElementNames.MovedItemId], service);
        }
    }
}
export class MoveCopyFolderResponse extends ServiceResponse {
    private folder: Folder = null;
    get Folder(): Folder {
        return this.folder;
    }
    constructor() {
        super();
    }
    GetObjectInstance(service: ExchangeService, xmlElementName: string): Folder {
        var flinfo: FolderInfo = new FolderInfo();
        return flinfo.CreateEwsObjectFromXmlElementName<Folder>(service, xmlElementName);
    }
    ReadElementsFromJson(responseObject: any, service: ExchangeService): any { throw new Error("MoveCopyFolderResponse.ts - ReadElementsFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        if (responseObject[XmlElementNames.Folders]) {
            //debug: check if this works
            var folders: Folder[] = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Folder>(
                responseObject,
                service,
                XmlElementNames.Folders,
                this.GetObjectInstance.bind(this),
                false,      /* clearPropertyBag */
                null,       /* requestedPropertySet */
                false);     /* summaryPropertiesOnly */

            this.folder = folders[0];
        }
    }
}

/**
 * Represents a response to a Move or Copy operation.
 * 
 */
export class MoveCopyItemResponse extends ServiceResponse {

    private item: Item = null;

    /**
     * Gets the copied or moved item. Item is null if the copy or move operation was between two mailboxes or between a mailbox and a public folder.
     *
     */
    get Item(): Item {
        return this.item;
    }

    /**
     * @internal Initializes a new instance of the *MoveCopyItemResponse* class.
     * 
     */
    constructor() {
        super();
    }

    /**
     * @internal Gets Item instance.
     *
     * @param   {ExchangeService}   service          The service.
     * @param   {string}            xmlElementName   Name of the XML element.
     * @return  {Item}              Item.
     */
    GetObjectInstance(service: ExchangeService, xmlElementName: string): Item {
        var itemInfo: ItemInfo = new ItemInfo();
        return itemInfo.CreateEwsObjectFromXmlElementName<Item>(service, xmlElementName);
    }

    /**
     * @internal Reads response elements from XML parsed to JS Object.
     *
     * @param   {any}               responseObject   The response object.
     * @param   {ExchangeService}   service          The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        if (responseObject[XmlElementNames.Items]) {
            //debug: check if this works
            var items: Item[] = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Item>(
                responseObject,
                service,
                XmlElementNames.Items,
                this.GetObjectInstance.bind(this),
                false,      /* clearPropertyBag */
                null,       /* requestedPropertySet */
                false);     /* summaryPropertiesOnly */
            // We only receive the copied or moved items if the copy or move operation was within
            // a single mailbox. No item is returned if the operation is cross-mailbox, from a
            // mailbox to a public folder or from a public folder to a mailbox.
            this.item = items[0];
        }
    }
}
/**
 * ## *Not Implemented* 
 */
export class PlayOnPhoneResponse extends ServiceResponse {
    PhoneCallId: PhoneCallId;
    private phoneCallId: PhoneCallId;
    ReadElementsFromJson(responseObject: JsonObject, service: ExchangeService): any { throw new Error("PlayOnPhoneResponse.ts - ReadElementsFromJson : Not implemented."); }
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("PlayOnPhoneResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); }
}
export class ResolveNamesResponse extends ServiceResponse {
    private resolutions: NameResolutionCollection = null;
    get Resolutions(): NameResolutionCollection {
        return this.resolutions;
    }
    constructor(service: ExchangeService) {
        super();
        EwsLogging.Assert(service !== null, "ResolveNamesResponse.ctor", "service is null");
        this.resolutions = new NameResolutionCollection(service);
    }

    InternalThrowIfNecessary(): void {
        if (this.ErrorCode != ServiceError.ErrorNameResolutionNoResults) {
            super.InternalThrowIfNecessary();
        }
    }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        this.Resolutions.LoadFromXmlJsObject(responseObject[XmlElementNames.ResolutionSet], service);
    }
}

/**
 * Represents the SearchMailboxes response.
 * 
 * @sealed
 */
export class SearchMailboxesResponse extends ServiceResponse {

    private searchResult: SearchMailboxesResult = null;

    /**
     * Search mailboxes result
     */
    get SearchResult(): SearchMailboxesResult {
        return this.searchResult;
    }
    /**@internal set*/
    set SearchResult(value: SearchMailboxesResult) {
        this.searchResult = value;
    }

    /**
	 * @internal Initializes a new instance of the **SearchMailboxesResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        //super.ReadElementsFromXmlJsObject(jsObject, service);

        if (jsObject[XmlElementNames.SearchMailboxesResult]) {
            this.searchResult = SearchMailboxesResult.LoadFromXmlJsObject(jsObject[XmlElementNames.SearchMailboxesResult], service);
        }
    }
}
/**
 * ## *Not Implemented* 
 */
export class SetEncryptionConfigurationResponse extends ServiceResponse {
}

/**
 * Represents the SetHoldOnMailboxes response.
 * 
 * @sealed
 */
export class SetHoldOnMailboxesResponse extends ServiceResponse {

    private holdResult: MailboxHoldResult = null;

    /**
     * Mailbox hold result
     */
    get HoldResult(): MailboxHoldResult {
        return this.holdResult;
    }

    /**
	 * @internal Initializes a new instance of the **SetHoldOnMailboxesResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.ReadElementsFromXmlJsObject(jsObject, service);

        if (jsObject[XmlElementNames.MailboxHoldResult]) {
            this.holdResult = MailboxHoldResult.LoadFromXmlJsObject(jsObject[XmlElementNames.MailboxHoldResult], service);
        }
    }
}

/**
 * @internal Represents the base response class to subscription creation operations.
 * 
 * @sealed
 * @typeparam	{TSubscription}		The type of the subscription.
 */
export class SubscribeResponse<TSubscription extends SubscriptionBase> extends ServiceResponse {

    private subscription: TSubscription;

    /**
     * Gets the subscription that was created.
     */
    get Subscription(): TSubscription {
        return this.subscription;
    }

    /**
     * @internal Initializes a new instance of the **SubscribeResponse<TSubscription>** class.
     *
     * @param   {TSubscription}   subscription   The subscription.
     */
    constructor(subscription: TSubscription) {
        super();
        EwsLogging.Assert(
            subscription != null,
            "SubscribeResponse.ctor",
            "subscription is null");

        this.subscription = subscription;
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               responseObject      The response object.
     * @param   {ExchangeService}   service             The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        this.subscription.LoadFromXmlJsObject(responseObject, service)
    }
}
export class SuggestionsResponse extends ServiceResponse {
    get Suggestions(): Suggestion[]{return this.daySuggestions;}//System.Collections.ObjectModel.Collection<Suggestion>;
    private daySuggestions: Suggestion[] = [];//System.Collections.ObjectModel.Collection<Suggestion>;
    LoadSuggestedDaysFromXml(jsonProperty: any, service: ExchangeService): void {
        var SuggestionArrayObj = jsonProperty[XmlElementNames.SuggestionDayResultArray];
        if(typeof SuggestionArrayObj === 'undefined') throw new Error("SuggestionsResponse.ts - LoadSuggestedDaysFromXml - invalid object returned ");
        
        var suggestions:any = EwsServiceJsonReader.ReadAsArray(SuggestionArrayObj,XmlElementNames.SuggestionDayResult);
        for(var suggestion of suggestions){
            var daySuggestion:Suggestion = new Suggestion();
            daySuggestion.LoadFromXmlJsObject(suggestion,service);
            this.daySuggestions.push(daySuggestion);
        }
    }
}

/**
 * @internal Represents the response to a UninstallApp operation.
 * Today this class doesn't add extra functionality. Keep this class here so future we can return extension info up-on installation complete.
 * 
 * @sealed 
 */
export class UninstallAppResponse extends ServiceResponse {

    /**
	 * @internal Initializes a new instance of the **UninstallAppResponse** class.
	 */
    constructor() {
        super();
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        //does nothing, here to supress base class message about ReadElementsFromXmlJsObject when BatchProcessingStopped is false
    }
}
export class UpdateFolderResponse extends ServiceResponse {
    private folder: Folder;
    constructor(folder: Folder) {
        super();
        EwsLogging.Assert(
            folder != null,
            "UpdateFolderResponse.ctor",
            "folder is null");
        this.folder = folder;
    }
    GetObjectInstance(session: ExchangeService, xmlElementName: string): Folder { return this.folder; }
    Loaded(): void {
        if (this.Result == ServiceResult.Success) {
            this.folder.ClearChangeLog();
        }
    }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        //debugger;//todo: check if this is needed. 
        //throw new Error("UpdateFolderResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); 
    }
}


/**
 * @internal Represents the response to a UpdateInboxRulesResponse operation.
 * 
 * @sealed
 */
export class UpdateInboxRulesResponse extends ServiceResponse {

	/**
	 * Rule operation error collection.
	 */
	private errors: RuleOperationErrorCollection = null;

	/**
	 * @internal Gets the rule operation errors in the response.
	 */
	get Errors(): RuleOperationErrorCollection {
		return this.errors;
	}

	/**
     * @internal Initializes a new instance of the **UpdateInboxRulesResponse** class. 
     */
    constructor() {
		super();
		this.errors = new RuleOperationErrorCollection();
	}

	/**
     * @internal Loads extra error details from XML
     *
     * @param   {any}   			responseObject      Json Object converted from XML.
     * @param   {ExchangeService}   service             The service.    
     */
    LoadExtraErrorDetailsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
		super.LoadExtraErrorDetailsFromXmlJsObject(responseObject, service);
        if (responseObject[XmlElementNames.RuleOperationErrors]) {
			this.errors.CreateFromXmlJsObjectCollection(responseObject[XmlElementNames.RuleOperationErrors][XmlElementNames.RuleOperationError], service);
		}
	}
}
export class UpdateItemResponse extends ServiceResponse {
    private item: Item = null;
    private returnedItem: Item = null;
    private conflictCount: number = 0;
    get ReturnedItem(): Item {
        return this.returnedItem;
    }
    get ConflictCount(): number {
        return this.conflictCount;
    }

    constructor(item: Item) {
        super();
        EwsLogging.Assert(
            item != null,
            "UpdateItemResponse.ctor",
            "item is null");
        this.item = item;
    }

    GetObjectInstance(service: ExchangeService, xmlElementName: string): Item {
        this.returnedItem = new ItemInfo().CreateEwsObjectFromXmlElementName<Item>(service, xmlElementName);
        return this.returnedItem;
    }
    Loaded(): void {
        if (this.Result == ServiceResult.Success) {
            this.item.ClearChangeLog();
        }
    }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {

        EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Item>(
            responseObject,
            service,
            XmlElementNames.Items,
            this.GetObjectInstance.bind(this),
            false,  /* clearPropertyBag */
            null,   /* requestedPropertySet */
            false); /* summaryPropertiesOnly */

        // ConflictResults was only added in 2007 SP1 so if this was a 2007 RTM request we shouldn't expect to find the element
        if (!service.Exchange2007CompatibilityMode) {
            this.conflictCount = Convert.toNumber(responseObject[XmlElementNames.ConflictResults][XmlElementNames.Count]);
        }

        // If UpdateItem returned an item that has the same Id as the item that
        // is being updated, this is a "normal" UpdateItem operation, and we need
        // to update the ChangeKey of the item being updated with the one that was
        // returned. Also set returnedItem to indicate that no new item was returned.
        //
        // Otherwise, this in a "special" UpdateItem operation, such as a recurring
        // task marked as complete (the returned item in that case is the one-off
        // task that represents the completed instance).
        //
        // Note that there can be no returned item at all, as in an UpdateItem call
        // with MessageDisposition set to SendOnly or SendAndSaveCopy.
        if (this.returnedItem != null) {
            if (this.item.Id.UniqueId == this.returnedItem.Id.UniqueId) {
                this.item.Id.ChangeKey = this.returnedItem.Id.ChangeKey;
                this.returnedItem = null;
            }
        }
    }
}
export class CreateItemResponseBase extends ServiceResponse {
    private items: Item[];//System.Collections.Generic.List<Item>;
    get Items(): Item[] {
        return this.items;
    }
    GetObjectInstance(service: ExchangeService, xmlElementName: string): Item { throw new Error("CreateItemResponseBase.ts - GetObjectInstance : abstract must implement."); }
    ReadElementsFromJson(responseObject: any, service: ExchangeService): any { throw new Error("CreateItemResponseBase.ts - ReadElementsFromJson : Not implemented."); }
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        
        if (responseObject[XmlElementNames.Items]) {
            this.items = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson<Item>(
                responseObject,
                service,
                XmlElementNames.Items,
                this.GetObjectInstance.bind(this),
                false,      /* clearPropertyBag */
                null,       /* requestedPropertySet */
                false);     /* summaryPropertiesOnly */


        }
    }
}

export class CreateItemResponse extends CreateItemResponseBase {
    private item: Item = null;
    constructor(item: Item) {
        super();
        this.item = item;
    }
    GetObjectInstance(service: ExchangeService, xmlElementName: string): Item { return this.item; }
    Loaded(): void {
        if (this.Result == ServiceResult.Success) {
            this.item.ClearChangeLog();
        }
    }
}
export class CreateResponseObjectResponse extends CreateItemResponseBase {
    GetObjectInstance(service: ExchangeService, xmlElementName: string): Item {
        var itemInfo = new ItemInfo();
        return itemInfo.CreateEwsObjectFromXmlElementName<Item>(service, xmlElementName);
        //return EwsUtilities.CreateEwsObjectFromXmlElementName<Item>(service, xmlElementName);
    }
}


/**
 * @internal Represents the response to a delegate user retrieval operation.
 * 
 * @sealed
 */
export class GetDelegateResponse extends DelegateManagementResponse {

    private meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope = MeetingRequestsDeliveryScope.NoForward;

    /**
     * @internal Gets a value indicating if and how meeting requests are delivered to delegates.
     */
    get MeetingRequestsDeliveryScope(): MeetingRequestsDeliveryScope {
        return this.meetingRequestsDeliveryScope;
    }

    /**
     * @internal Initializes a new instance of the **GetDelegateResponse** class.
     *
     * @param   {boolean}   readDelegateUsers   if set to *true* [read delegate users].
     */
    constructor(readDelegateUsers: boolean) {
        super(readDelegateUsers, null);
    }

    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
        super.ReadElementsFromXmlJsObject(responseObject, service);

        if (this.ErrorCode == ServiceError.NoError) {
            if (responseObject[XmlElementNames.DeliverMeetingRequests]) {
                this.meetingRequestsDeliveryScope = MeetingRequestsDeliveryScope[<string>responseObject[XmlElementNames.DeliverMeetingRequests]];
            }
        }
    }
}

/**
 * Represents a strogly typed list of service responses.
 * @sealed
 * @typeparam   {TResponse}     The type of response stored in the list.
 */
export class ServiceResponseCollection<TResponse extends ServiceResponse> implements IEnumerable<TResponse> {

    private responses: TResponse[] = [];

    private overallResult: ServiceResult = ServiceResult.Success;

    /**
     * Gets the total number of responses in the list.
     */
    get Count(): number {
        return this.responses.length;
    }

    get Responses(): TResponse[] { return this.responses; }

    /**
     * Gets a value indicating the overall result of the request that generated this response collection.
     * If all of the responses have their Result property set to Success, OverallResult returns Success.
     * If at least one response has its Result property set to Warning and all other responses have their Result property set to Success, OverallResult returns Warning. 
     * If at least one response has a its Result set to Error, OverallResult returns Error.
     */
    get OverallResult(): ServiceResult { return this.overallResult; }

    /**
     * @internal Initializes a new instance of the **ServiceResponseCollection<TResponse>** class.
     */
    constructor() {
    }

    /**
     * @internal Adds specified response.
     *
     * @param   {TResponse}   response   The response.
     */    
    Add(response: TResponse): void {
        EwsLogging.Assert(
            response != null,
            "EwsResponseList.Add",
            "response is null");

        if (response.Result > this.overallResult) {
            this.overallResult = response.Result;
        }

        this.responses.push(response);
    }

    /**
     * Gets an enumerator that iterates through the elements of the collection.
     *
     * @return  {TResponse[]}      An IEnumerator for the collection.
     */    
    GetEnumerator(): TResponse[] {
        return this.responses;
    }

    /**
     * Gets the response at the specified index.
     *
     * @param   {number}        index   The zero-based index of the response to get.
     * @return  {TResponse}     The response at the specified index.
     */
    __thisIndexer(index: number): TResponse {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }

        return this.responses[index];
    }

}

/**
 * Represents the base response class for synchronuization operations.
 * 
 * @sealed
 * @typeparam	{TServiceObject}	ServiceObject type.
 * @typeparam	{TChange}	Change type.
 */
export abstract class SyncResponse<TServiceObject extends ServiceObject, TChange extends Change> extends ServiceResponse {

	private changes: ChangeCollection<TChange> = new ChangeCollection<TChange>();
	private propertySet: PropertySet = null;

	/**
	 * Gets a list of changes that occurred on the synchronized folder.
	 */
	get Changes(): ChangeCollection<TChange> {
		return this.changes;
	}

	/**
	 * @internal Gets a value indicating whether this request returns full or summary properties.
	 */
	get SummaryPropertiesOnly(): boolean { return false; /* abstract */ }

	/**
	 * @internal Initializes a new instance of the **SyncResponse<TServiceObject, TChange>** class.
	 *
	 * @param   {PropertySet}   propertySet   Property set.
	 */
	constructor(propertySet: PropertySet) {
		super();
		this.propertySet = propertySet;

		EwsLogging.Assert(
			this.propertySet != null,
			"SyncResponse.ctor",
			"PropertySet should not be null");
	}

	/**
	 * @internal Creates an item change instance.
	 *
	 * @return  {ItemChange}      ItemChange instance
	 */
	abstract CreateChangeInstance(): TChange;

	/**
	 * @internal Gets the name of the change element.
	 *
	 * @return  {string}      Change element name.
	 */
	abstract GetChangeElementName(): string;

	/**
	 * @internal Gets the name of the change id element.
	 *
	 * @return  {string}      Change id element name.
	 */
	abstract GetChangeIdElementName(): string;

	/**
	 * @internal Gets the name of the includes last in range XML element.
	 *
	 * @return  {string}      XML element name.
	 */
	abstract GetIncludesLastInRangeXmlElementName(): string;

	/**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ReadElementsFromXmlJsObject(responseObject: any, service: ExchangeService): void {
		this.Changes.SyncState = responseObject[XmlElementNames.SyncState];
		this.Changes.MoreChangesAvailable = !Convert.toBool(responseObject[this.GetIncludesLastInRangeXmlElementName()]);

		let changesElement: any = responseObject[XmlElementNames.Changes];

		let folderInfo: FolderInfo = new FolderInfo();
		let itemInfo: ItemInfo = new ItemInfo();

		for (let changeElementKey in changesElement) {

			if (changeElementKey.indexOf("__") === 0) continue;

			let changeObjs: any[] = EwsServiceJsonReader.ReadAsArray(changesElement, changeElementKey);

			for (let changeObj of changeObjs) {


				let change: TChange = this.CreateChangeInstance();

				//let changeType:string = jsChange.ReadAsString(XmlElementNames.ChangeType);

				switch (changeElementKey) {
					case XmlElementNames.Create:
						change.ChangeType = ChangeType.Create;
						break;
					case XmlElementNames.Update:
						change.ChangeType = ChangeType.Update;
						break;
					case XmlElementNames.Delete:
						change.ChangeType = ChangeType.Delete;
						break;
					case XmlElementNames.ReadFlagChange:
						change.ChangeType = ChangeType.ReadFlagChange;
						break;
					default:
						break;
				}

				let changeObjectTypeName: string = TypeSystem.GetJsObjectOnlyChildName(changeObj);

				let serviceObjectInfo: ServiceObjectInfo = ServiceObjectInfo.IsFolderType(changeObjectTypeName) ? folderInfo : itemInfo;

				if (change != null) {
					let jsServiceObject = changeObj[changeObjectTypeName];
					switch (change.ChangeType) {
						case ChangeType.Delete:
						case ChangeType.ReadFlagChange:
							change.Id = change.CreateId();
							let jsChangeId = changeObj[this.GetChangeIdElementName()];
							change.Id.LoadFromXmlJsObject(jsChangeId, service);

							if (change.ChangeType == ChangeType.ReadFlagChange) {
								let itemChange: ItemChange = <ItemChange><any>change;

								EwsLogging.Assert(
									change instanceof ItemChange,
									"SyncResponse.ReadElementsFromXmlJsObject",
									"ReadFlagChange is only valid on ItemChange");

								itemChange.IsRead = Convert.toBool(changeObj[XmlElementNames.IsRead]);
							}

							break;
						default:

							change.ServiceObject = serviceObjectInfo.CreateEwsObjectFromXmlElementName<TServiceObject>(service, changeObjectTypeName);

							change.ServiceObject.LoadFromXmlJsObject(
								jsServiceObject,
								service,
								true, /* clearPropertyBag */
								this.propertySet,
								this.SummaryPropertiesOnly);
							break;
					}

					this.changes.Add(change);
				}
			}
		}

	}
}

/**
 * Represents the response to a folder synchronization operation.
 * 
 * @sealed
 */
export class SyncFolderHierarchyResponse extends SyncResponse<Folder, FolderChange> {

	/**
	 * @internal Gets a value indicating whether this request returns full or summary properties.
	 * 
	 * @value	*true* if summary properties only; otherwise, *false*.
	 */
	get SummaryPropertiesOnly(): boolean {
		return true;
	}

	/**
	 * @internal Initializes a new instance of the **SyncFolderHierarchyResponse** class.
	 *
	 * @param   {PropertySet}   propertySet   PropertySet from request.
	 */
	constructor(propertySet: PropertySet) {
		super(propertySet);
	}

	/**
	 * @internal Creates an item change instance.
	 *
	 * @return  {ItemChange}      ItemChange instance
	 */
	CreateChangeInstance(): FolderChange {
		return new FolderChange();
	}

	/**
	 * @internal Gets the name of the change element.
	 *
	 * @return  {string}      Change element name.
	 */
	GetChangeElementName(): string {
		return XmlElementNames.Folder;
	}

	/**
	 * @internal Gets the name of the change id element.
	 *
	 * @return  {string}      Change id element name.
	 */
	GetChangeIdElementName(): string {
		return XmlElementNames.FolderId;
	}

	/**
	 * @internal Gets the name of the includes last in range XML element.
	 *
	 * @return  {string}      XML element name.
	 */
	GetIncludesLastInRangeXmlElementName(): string {
		return XmlElementNames.IncludesLastFolderInRange;
	}
}

/**
 * Represents the response to a folder items synchronization operation.
 * 
 * @sealed
 */
export class SyncFolderItemsResponse extends SyncResponse<Item, ItemChange> {
	
	/**
	 * @internal Gets a value indicating whether this request returns full or summary properties.
	 * 
	 * @value	*true* if summary properties only; otherwise, *false*.
	 */
	get SummaryPropertiesOnly(): boolean{
		return true;
	}

	/**
	 * @internal Initializes a new instance of the **SyncFolderItemsResponse** class.
	 *
	 * @param   {PropertySet}   propertySet   PropertySet from request.
	 */
	constructor(propertySet: PropertySet) {
		super(propertySet);
	}

	/**
	 * @internal Creates an item change instance.
	 *
	 * @return  {ItemChange}      ItemChange instance
	 */
	CreateChangeInstance(): ItemChange {
		return new ItemChange();
	}

	/**
	 * @internal Gets the name of the change element.
	 *
	 * @return  {string}      Change element name.
	 */
	GetChangeElementName(): string {
		return XmlElementNames.Item;
	}

	/**
	 * @internal Gets the name of the change id element.
	 *
	 * @return  {string}      Change id element name.
	 */
	GetChangeIdElementName(): string {
		return XmlElementNames.ItemId;
	}

	/**
	 * @internal Gets the name of the includes last in range XML element.
	 *
	 * @return  {string}      XML element name.
	 */
	GetIncludesLastInRangeXmlElementName(): string {
		return XmlElementNames.IncludesLastItemInRange;
	}
}

/**
 * Represents the base abstract class for all item and folder types.
 */
export abstract class ServiceObject {

    private lockObject: any = {};

    //private service: ExchangeService;
    /** workaround for service variable exposer in console.log */
    private getService: () => ExchangeService;
    private setService: (service: ExchangeService) => void;

    private propertyBag: PropertyBag;
    private xmlElementName: string;

    /**
     * @internal The property bag holding property values for this object.
     */
    get PropertyBag(): PropertyBag { return this.propertyBag; }
    /**
     * Gets the schema associated with this type of object.
     */
    get Schema(): ServiceObjectSchema { return this.GetSchema(); }

    /**
     * Gets the ExchangeService the object is bound to.
     */
    get Service(): ExchangeService { return this.getService(); }
    /**@internal set*/
    set Service(value: ExchangeService) { this.setService(value); }

    /**
     * Indicates whether this object is a real store item, or if it's a local object that has yet to be saved.
     */
    get IsNew(): boolean {
        var id = this.GetId();
        return id == null ? true : !id.IsValid;
    }
    /**
     * Gets a value indicating whether the object has been modified and should be saved.
     */
    get IsDirty(): boolean {
        return this.PropertyBag.IsDirty;
    }

    /**
     * Defines an event that is triggered when the service object changes.
     */
    private OnChange: ServiceObjectChangedDelegate[] = [];

    /**
     * @internal Internal constructor.
     *
     * @param   {ExchangeService}   service   EWS service to which this object belongs.
     */
    constructor(service: ExchangeService) {
        //EwsUtilities.ValidateParam(service, "service");
        //EwsUtilities.ValidateServiceObjectVersion(this, service.RequestedServerVersion);

        //this.Service = service;
        var innerService = service;
        this.setService = (service) => { innerService = service; }
        this.getService = () => { return innerService; }
        this.propertyBag = new PropertyBag(this);
    }

    /**
     * Gets the value of specified property in this instance.
     * This Indexer of c# 
     * 
     * @param   {PropertyDefinitionBase}   propertyDefinition   Definition of the property to get.
     */
    _getItem(propertyDefinition: PropertyDefinitionBase): any {
        var propertyValue: any;

        var propDef: PropertyDefinition = <PropertyDefinition>propertyDefinition;

        if (propDef instanceof PropertyDefinition) {
            return this.PropertyBag._getItem(propDef);
        }
        else {
            var extendedPropDef: ExtendedPropertyDefinition = <ExtendedPropertyDefinition>propertyDefinition;
            if (extendedPropDef instanceof ExtendedPropertyDefinition) {
                if (this.TryGetExtendedProperty(extendedPropDef, propertyValue)) {
                    return propertyValue;
                }
                else {
                    throw new ServiceObjectPropertyException(Strings.MustLoadOrAssignPropertyBeforeAccess, propertyDefinition);
                }
            }
            else {
                // Other subclasses of PropertyDefinitionBase are not supported.
                let constructorName = "Chile of ServiceObject";
                if ((<any>propertyDefinition.constructor).name) {
                    constructorName = (<any>propertyDefinition.constructor).name;
                }
                throw new NotSupportedException(StringHelper.Format(
                    Strings.OperationNotSupportedForPropertyDefinitionType,
                    constructorName));
            }
        }
    }

    /**
     * @internal Triggers dispatch of the change event.
     */
    Changed(): void {
        if (this.OnChange != null) {
            for (var changeDelegate of this.OnChange) {
                changeDelegate(this);
            }
        }
    }

    /**
     * @internal Clears the object's change log.
     */
    ClearChangeLog(): void { this.PropertyBag.ClearChangeLog(); }

    /**
     * @internal Gets the name of the change XML element.
     *
     * @return  {string}      XML element name,
     */
    GetChangeXmlElementName(): string { return XmlElementNames.ItemChange; }

    /**
     * @internal Gets the name of the delete field XML element.
     *
     * @return  {string}      XML element name,
     */
    GetDeleteFieldXmlElementName(): string { return XmlElementNames.DeleteItemField; }

    /**
     * @internal Gets the extended properties collection.
     *
     * @return  {ExtendedPropertyCollection}      Extended properties collection.
     */
    GetExtendedProperties(): ExtendedPropertyCollection { return null; }

    /**
     * @internal The unique Id of this object.
     *
     * @return  {ServiceId}      A ServiceId instance..
     */
    GetId(): ServiceId {
        var idPropertyDefinition = this.GetIdPropertyDefinition();

        var serviceId: IOutParam<any> = { outValue: null };
        if (idPropertyDefinition != null) {
            this.PropertyBag.TryGetValue(idPropertyDefinition, serviceId);
        }

        return <ServiceId>serviceId.outValue;
    }

    /**
     * @internal The property definition for the Id of this object.
     *
     * @return  {PropertyDefinition}      A PropertyDefinition instance.
     */
    GetIdPropertyDefinition(): PropertyDefinition { return null; }

    /**
     * @internal Determines whether properties defined with ScopedDateTimePropertyDefinition require custom time zone scoping.
     *
     * @return  {boolean}      true if this item type requires custom scoping for scoped date/time properties; otherwise, false.
     */
    GetIsCustomDateTimeScopingRequired(): boolean { return false; }

    /**
     * @internal Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}     isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}     true if a time zone SOAP header should be emitted; otherwise, false.
     */
    GetIsTimeZoneHeaderRequired(isUpdateOperation: boolean): boolean { return false; }

    /**
     * Gets the collection of loaded property definitions.
     *
     * @return  {PropertyDefinitionBase[]}      Collection of property definitions.
     */
    GetLoadedPropertyDefinitions(): PropertyDefinitionBase[] /*System.Collections.ObjectModel.Collection<PropertyDefinitionBase>*/ {
        var propDefs: PropertyDefinitionBase[] = [];
        for (var propDef of this.PropertyBag.Properties.Keys) {
            propDefs.push(propDef);
        }

        if (this.GetExtendedProperties() != null) {
            for (var extProp of this.GetExtendedProperties().Items) {
                propDefs.push(extProp.PropertyDefinition);
            }
        }

        return propDefs;
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    abstract GetMinimumRequiredServerVersion(): ExchangeVersion;

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    abstract GetSchema(): ServiceObjectSchema;

    /**
     * @internal Gets the name of the set field XML element.
     *
     * @return  {string}      XML element name,
     */
    GetSetFieldXmlElementName(): string { return XmlElementNames.SetItemField; }

    /**
     * @internal GetXmlElementName retrieves the XmlElementName of this type based on the EwsObjectDefinition attribute that decorates it, if present.
     *
     * @return  {string}      The XML element name associated with this type.
     */
    GetXmlElementName(): string {
        throw new Error("ServiceObject.ts - GetXmlElementName -  this must be overridden by derived class - can not use reflection to get class attribute in javascript");
        if (StringHelper.IsNullOrEmpty(this.xmlElementName)) {
            this.xmlElementName = this.GetXmlElementNameOverride();

            EwsLogging.Assert(
                !StringHelper.IsNullOrEmpty(this.xmlElementName),
                "EwsObject.GetXmlElementName",
                StringHelper.Format("The class {0} does not have an associated XML element name.", "unknown decendent of ServiceObject - in serviceObject.GetXmlElementname"));
        }
        return this.xmlElementName;
    }

    /**
     * @internal This methods lets subclasses of ServiceObject override the default mechanism by which the XML element name associated with their type is retrieved.
     *
     * @return  {string}      The XML element name associated with this type. If this method returns null or empty, the XML element name associated with this type is determined by the EwsObjectDefinition attribute that decorates the type, if present.
     */
    GetXmlElementNameOverride(): string { return null; }

    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}              deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}   sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}  affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    abstract InternalDelete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence): Promise<void>;

    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    abstract InternalLoad(propertySet: PropertySet): Promise<void>;

    /**
     * Loads the first class properties. Calling this method results in a call to EWS.
     */
    Load(): Promise<void>;

    /**
     * Loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    Load(propertySet?: PropertySet): Promise<void>;
    Load(propertySet?: PropertySet): Promise<void> {
        return this.InternalLoad(propertySet || PropertySet.FirstClassProperties);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     * @param   {boolean}             clearPropertyBag        if set to true [clear property bag].
     * @param   {PropertySet}         requestedPropertySet    The property set.
     * @param   {boolean}             summaryPropertiesOnly   if set to true [summary props only].
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService, clearPropertyBag: boolean, requestedPropertySet: PropertySet = null, summaryPropertiesOnly: boolean = false): void {
        this.PropertyBag.LoadFromXmlJsObject(
            jsObject,
            service,
            clearPropertyBag,
            requestedPropertySet,
            summaryPropertiesOnly);
    }

    /**
     * @internal Throws exception if this is a new service object.
     */
    ThrowIfThisIsNew(): void {
        if (this.IsNew) {
            throw new InvalidOperationException(Strings.ServiceObjectDoesNotHaveId);
        }
    }

    /**
     * @internal Throws exception if this is not a new service object.
     */
    ThrowIfThisIsNotNew(): void {
        if (!this.IsNew) {
            throw new InvalidOperationException(Strings.ServiceObjectAlreadyHasId);
        }
    }

    /**
     * @internal Try to get the value of a specified extended property in this instance.
     *
     * @param   {ExtendedPropertyDefinition}  propertyDefinition   The property definition.
     * @param   {IOutParam<T>}                propertyValue        The property value.
     * @return  {boolean}                     True if property retrieved, false otherwise.
     */
    TryGetExtendedProperty<T>(propertyDefinition: ExtendedPropertyDefinition, propertyValue: IOutParam<T>): boolean {
        var propertyCollection: ExtendedPropertyCollection = this.GetExtendedProperties();

        if ((propertyCollection != null) &&
            propertyCollection.TryGetValue<T>(propertyDefinition, propertyValue)) {
            return true;
        }
        else {
            propertyValue.outValue = null;//default(T);
            return false;
        }
    }

    //todo:fix - implement type casting on specific type request version. 
    //TryGetProperty<T>(propertyDefinition: PropertyDefinitionBase, propertyValue: any): boolean { throw new Error("Need implementation."); }
    //TryGetProperty(propertyDefinition: PropertyDefinitionBase, propertyValue: any): boolean { throw new Error("ServiceObject.ts - TryGetProperty : Not implemented."); }

    /**
     * Try to get the value of a specified property in this instance.
     *
     * @param   {PropertyDefinitionBase}  propertyDefinition   The property definition.
     * @param   {IOutParam<T>}            propertyValue        The property value.
     * @return  {boolean}                 True if property retrieved, false otherwise.
     */
    TryGetProperty<T>(propertyDefinition: PropertyDefinitionBase, propertyValue: IOutParam<T>): boolean {
        var propDef: PropertyDefinition = <PropertyDefinition>propertyDefinition;// as PropertyDefinition;
        //info: fix for compatibility checking, if this is propertydefinition or extendedpropertydefinitionbase
        if (propDef instanceof PropertyDefinition) {
            return this.PropertyBag.TryGetPropertyAs<T>(propDef, propertyValue);
        }
        else {
            //info: fix for compatibility of extendedpropertydefition or propertydefition type.
            var extPropDef: ExtendedPropertyDefinition = <ExtendedPropertyDefinition>propertyDefinition;// as ExtendedPropertyDefinition;
            if (extPropDef instanceof ExtendedPropertyDefinition) {
                return this.TryGetExtendedProperty<T>(extPropDef, propertyValue);
            }
            else {
                // Other subclasses of PropertyDefinitionBase are not supported.
                let constructorName = "Child of ServiceObject";
                if ((<any>propertyDefinition.constructor).name) {
                    constructorName = (<any>propertyDefinition.constructor).name;
                }
                throw new NotSupportedException(StringHelper.Format(
                    Strings.OperationNotSupportedForPropertyDefinitionType,
                    propertyDefinition.Type));
            }
        }
    }

    /**
     * @internal Validates this instance.
     */
    Validate(): void { this.PropertyBag.Validate(); }

    /**
     * @internal Writes service object as XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void { this.PropertyBag.WriteToXml(writer); }

    /**
     * @internal Writes service object for update as XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXmlForUpdate(writer: EwsServiceXmlWriter): void { this.PropertyBag.WriteToXmlForUpdate(writer); }
}



/**
 * Moved part of CreateEwsObjectFromXmlElementName to different object type like FolderInfo, itemInfo etc
 */
export class ServiceObjectInfo {

    get XmlElementNameToServiceObjectClassMap(): IndexerWithStringKey<string> { return this.xmlElementNameToServiceObjectClassMap; }//  System.Collections.Generic.Dictionary<string, System.Type>;
    get ServiceObjectConstructorsWithServiceParam(): IndexerWithStringKey<CreateServiceObjectWithServiceParam> { return this.serviceObjectConstructorsWithServiceParam; }// System.Collections.Generic.Dictionary<System.Type, CreateServiceObjectWithServiceParam>;
    get ServiceObjectConstructorsWithAttachmentParam(): IndexerWithStringKey<CreateServiceObjectWithAttachmentParam> { return this.serviceObjectConstructorsWithAttachmentParam; }//System.Collections.Generic.Dictionary<System.Type, CreateServiceObjectWithAttachmentParam>;
    private xmlElementNameToServiceObjectClassMap: IndexerWithStringKey<string>;//System.Collections.Generic.Dictionary<string, System.Type>;
    private serviceObjectConstructorsWithServiceParam: IndexerWithStringKey<CreateServiceObjectWithServiceParam>;//System.Collections.Generic.Dictionary<System.Type, CreateServiceObjectWithServiceParam>;
    private serviceObjectConstructorsWithAttachmentParam: IndexerWithStringKey<CreateServiceObjectWithAttachmentParam>;//System.Collections.Generic.Dictionary<System.Type, CreateServiceObjectWithAttachmentParam>;

    constructor() {
        this.xmlElementNameToServiceObjectClassMap = {};
        this.serviceObjectConstructorsWithServiceParam = {};
        this.serviceObjectConstructorsWithAttachmentParam = {};

        this.InitializeServiceObjectClassMap();
    }

    protected AddServiceObjectType(xmlElementName: string, type: string /*System.Type*/, createServiceObjectWithServiceParam: CreateServiceObjectWithServiceParam, createServiceObjectWithAttachmentParam: CreateServiceObjectWithAttachmentParam): any {
        this.xmlElementNameToServiceObjectClassMap[xmlElementName] = type;
        this.serviceObjectConstructorsWithServiceParam[xmlElementName] = createServiceObjectWithServiceParam;
        if (createServiceObjectWithAttachmentParam) { //!= null) {
            this.serviceObjectConstructorsWithAttachmentParam[xmlElementName] = createServiceObjectWithAttachmentParam;
        }
    }

    InitializeServiceObjectClassMap(): any {
        throw new Error("abstract - ServiceObjectInfo.ts - InitializeServiceObjectClassMap: must be implemented")

        /**
         * Folder Types ->  folderinfo
              
        // CalendarFolder
        this.AddServiceObjectType(
            XmlElementNames.CalendarFolder,
            "CalendarFolder",
            (srv) => { return new CalendarFolder(srv); },
            null);
                 
        // ContactsFolder
        this.AddServiceObjectType(
            XmlElementNames.ContactsFolder,
            "ContactsFolder",
            (srv) => { return new ContactsFolder(srv); },
            null);

        // Folder
        this.AddServiceObjectType(
            XmlElementNames.Folder,
            "Folder",
            (srv) => { return new Folder(srv); },
            null);

        // SearchFolder
        this.AddServiceObjectType(
            XmlElementNames.SearchFolder,
            "SearchFolder",
            (srv) => { return new SearchFolder(srv); },
            null);

        // TasksFolder
        this.AddServiceObjectType(
            XmlElementNames.TasksFolder,
            "TasksFolder",
            (srv) => { return new TasksFolder(srv); },
            null);
            
        */

        /**
         * Item Types -> iteminfo
        
        // Appointment
        this.AddServiceObjectType(
            XmlElementNames.CalendarItem,
            "Appointment",
            (srv) => { return new Appointment(srv); },
            (itemAttachment, isNew) => { return new Appointment(itemAttachment, isNew); });


        // Contact
        this.AddServiceObjectType(
            XmlElementNames.Contact,
            "Contact",
            (srv) => { return new Contact(srv); },
            (itemAttachment, isNew) => { return new Contact(itemAttachment); });

        // ContactGroup
        this.AddServiceObjectType(
            XmlElementNames.DistributionList,
            "ContactGroup",
            (srv) => { return new ContactGroup(srv); },
            (itemAttachment, isNew) => { return new ContactGroup(itemAttachment); });

        // Conversation
        this.AddServiceObjectType(
            XmlElementNames.Conversation,
            "Conversation",
            (srv) => { return new Conversation(srv); },
            null);

        // EmailMessage
        this.AddServiceObjectType(
            XmlElementNames.Message,
            "EmailMessage",
            (srv) => { return new EmailMessage(srv); },
            (itemAttachment, isNew) => { return new EmailMessage(itemAttachment); });

        // Item
        this.AddServiceObjectType(
            XmlElementNames.Item,
            "Item",
            (srv) => { return new Item(srv); },
            (itemAttachment, isNew) => { return new Item(itemAttachment); });

        // MeetingCancellation
        this.AddServiceObjectType(
            XmlElementNames.MeetingCancellation,
            "MeetingCancellation",
            (srv) => { return new MeetingCancellation(srv); },
            (itemAttachment, isNew) => { return new MeetingCancellation(itemAttachment); });

        // MeetingMessage
        this.AddServiceObjectType(
            XmlElementNames.MeetingMessage,
            "MeetingMessage",
            (srv) => { return new MeetingMessage(srv); },
            (itemAttachment, isNew) => { return new MeetingMessage(itemAttachment); });

        // MeetingRequest
        this.AddServiceObjectType(
            XmlElementNames.MeetingRequest,
            "MeetingRequest",
            (srv) => { return new MeetingRequest(srv); },
            (itemAttachment, isNew) => { return new MeetingRequest(itemAttachment); });

        // MeetingResponse
        this.AddServiceObjectType(
            XmlElementNames.MeetingResponse,
            "MeetingResponse",
            (srv) => { return new MeetingResponse(srv); },
            (itemAttachment, isNew) => { return new MeetingResponse(itemAttachment); });

        // PostItem
        this.AddServiceObjectType(
            XmlElementNames.PostItem,
            "PostItem",
            (srv) => { return new PostItem(srv); },
            (itemAttachment, isNew) => { return new PostItem(itemAttachment); });

        // Task
        this.AddServiceObjectType(
            XmlElementNames.Task,
            "Task",
            (srv) => { return new Task(srv); },
            (itemAttachment, isNew) => { return new Task(itemAttachment); });

        */
    }

    CreateEwsObjectFromXmlElementName<TServiceObject extends ServiceObject>(service: ExchangeService, xmlElementName: string): TServiceObject {
        //var itemClass = this.XmlElementNameToServiceObjectClassMap[xmlElementName];
        //if (itemClass) {
        //    return new itemClass(service);
        //no need of itemclass due to lack of type conversion and dictionary implementation in javascript
        var creationDelegate = this.ServiceObjectConstructorsWithServiceParam[xmlElementName];

        if (creationDelegate) {
            return creationDelegate(service);
        }
        else {
            return null;
        }

    }

    CreateItemFromItemClass(itemAttachment: ItemAttachment, itemClass: string  /*System.Type*/, isNew: boolean): Item {
        var creationDelegate = this.ServiceObjectConstructorsWithAttachmentParam[itemClass];

        if (creationDelegate) {
            return creationDelegate(itemAttachment, isNew);
        }
        else {
            return null;
        }
    }

    static IsFolderType(xmlElementName: string): boolean {
        let folderTypes: string[] = [
            XmlElementNames.CalendarFolder,
            XmlElementNames.ContactsFolder,
            XmlElementNames.Folder,
            XmlElementNames.SearchFolder,
            XmlElementNames.TasksFolder,
        ];

        let itemType: string[] = [
            XmlElementNames.CalendarItem,
            XmlElementNames.Contact,
            XmlElementNames.DistributionList,
            XmlElementNames.Conversation,
            XmlElementNames.Message,
            XmlElementNames.Item,
            XmlElementNames.MeetingCancellation,
            XmlElementNames.MeetingMessage,
            XmlElementNames.MeetingRequest,
            XmlElementNames.MeetingResponse,
            XmlElementNames.PostItem,
            XmlElementNames.Task,
        ];

        return folderTypes.indexOf(xmlElementName) >= 0;
    }
}




/**
 * this is partial section of CreateEwsObjectFromXmlElementName from serviceobjectinfo, other parts are moved to different object type like itemInfo etc. 
 * this to is to avoid circular referencing with requirejs/commonjs/nodejs
 */
export class FolderInfo extends ServiceObjectInfo {

InitializeServiceObjectClassMap(): any {
        // CalendarFolder
        this.AddServiceObjectType(
            XmlElementNames.CalendarFolder,
            "CalendarFolder",
            (srv) => { return new CalendarFolder(srv); },
            null);

        // ContactsFolder
        this.AddServiceObjectType(
            XmlElementNames.ContactsFolder,
            "ContactsFolder",
            (srv) => { return new ContactsFolder(srv); },
            null);

        // Folder
        this.AddServiceObjectType(
            XmlElementNames.Folder,
            "Folder",
            (srv) => { return new Folder(srv); },
            null);


        // SearchFolder
        this.AddServiceObjectType(
            XmlElementNames.SearchFolder,
            "SearchFolder",
            (srv) => { return new SearchFolder(srv); },
            null);

        // TasksFolder
        this.AddServiceObjectType(
            XmlElementNames.TasksFolder,
            "TasksFolder",
            (srv) => { return new TasksFolder(srv); },
            null);
    }
    
    CreateEwsObjectFromXmlElementName<TServiceObject extends ServiceObject>(service: ExchangeService, xmlElementName: string): TServiceObject {
                
        //var itemClass = this.XmlElementNameToServiceObjectClassMap[xmlElementName];
        //if (itemClass) {
        //    return new itemClass(service);
        //no need of itemclass due to lack of type conversion and dictionary implementation in javascript
        var creationDelegate = this.ServiceObjectConstructorsWithServiceParam[xmlElementName];

        if (creationDelegate) {
            return creationDelegate(service);
        }
        else return null;

    }
}





/**
 ** this is partial section of CreateEwsObjectFromXmlElementName from serviceobjectinfo, other parts are moved to different object type like folderinfo etc. 
 * this to is to avoid circular referencing with requirejs/commonjs/nodejs
 */
export class ItemInfo extends ServiceObjectInfo {

    InitializeServiceObjectClassMap(): any {
        // Appointment
        this.AddServiceObjectType(
            XmlElementNames.CalendarItem,
            "Appointment",
            (srv) => { return new Appointment(srv); },
            (itemAttachment, isNew) => { return new Appointment(itemAttachment, isNew); });


        // Contact
        this.AddServiceObjectType(
            XmlElementNames.Contact,
            "Contact",
            (srv) => { return new Contact(srv); },
            (itemAttachment, isNew) => { return new Contact(itemAttachment); });

        // ContactGroup
        this.AddServiceObjectType(
            XmlElementNames.DistributionList,
            "ContactGroup",
            (srv) => { return new ContactGroup(srv); },
            (itemAttachment, isNew) => { return new ContactGroup(itemAttachment); });

        // Conversation
        this.AddServiceObjectType(
            XmlElementNames.Conversation,
            "Conversation",
            (srv) => { return new Conversation(srv); },
            null);

        // EmailMessage
        this.AddServiceObjectType(
            XmlElementNames.Message,
            "EmailMessage",
            (srv) => { return new EmailMessage(srv); },
            (itemAttachment, isNew) => { return new EmailMessage(itemAttachment); });

        // Item
        this.AddServiceObjectType(
            XmlElementNames.Item,
            "Item",
            (srv) => { return new Item(srv); },
            (itemAttachment, isNew) => { return new Item(itemAttachment); });

        // MeetingCancellation
        this.AddServiceObjectType(
            XmlElementNames.MeetingCancellation,
            "MeetingCancellation",
            (srv) => { return new MeetingCancellation(srv); },
            (itemAttachment, isNew) => { return new MeetingCancellation(itemAttachment); });

        // MeetingMessage
        this.AddServiceObjectType(
            XmlElementNames.MeetingMessage,
            "MeetingMessage",
            (srv) => { return new MeetingMessage(srv); },
            (itemAttachment, isNew) => { return new MeetingMessage(itemAttachment); });

        // MeetingRequest
        this.AddServiceObjectType(
            XmlElementNames.MeetingRequest,
            "MeetingRequest",
            (srv) => { return new MeetingRequest(srv); },
            (itemAttachment, isNew) => { return new MeetingRequest(itemAttachment); });

        // MeetingResponse
        this.AddServiceObjectType(
            XmlElementNames.MeetingResponse,
            "MeetingResponse",
            (srv) => { return new MeetingResponse(srv); },
            (itemAttachment, isNew) => { return new MeetingResponse(itemAttachment); });

        // PostItem
        this.AddServiceObjectType(
            XmlElementNames.PostItem,
            "PostItem",
            (srv) => { return new PostItem(srv); },
            (itemAttachment, isNew) => { return new PostItem(itemAttachment); });

        // Task
        this.AddServiceObjectType(
            XmlElementNames.Task,
            "Task",
            (srv) => { return new Task(srv); },
            (itemAttachment, isNew) => { return new Task(itemAttachment); });

    }
}

export class Folder extends ServiceObject {

    /**
     * Gets the Id of the folder.
     * 
     */
    get Id(): FolderId { return <FolderId>this.PropertyBag._getItem(this.GetIdPropertyDefinition()); }

    /**
     * Gets the Id of this folder's parent folder.
     * 
     */
    get ParentFolderId(): FolderId { return <FolderId>this.PropertyBag._getItem(Schemas.FolderSchema.ParentFolderId); }

    /**
     * Gets the number of child folders this folder has.
     * 
     */
    get ChildFolderCount(): number { return <number>this.PropertyBag._getItem(Schemas.FolderSchema.ChildFolderCount); }

    /**
     * Gets or sets the display name of the folder.
     * 
     */
    get DisplayName(): string { return <string>this.PropertyBag._getItem(Schemas.FolderSchema.DisplayName); }
    set DisplayName(value: string) { this.PropertyBag._setItem(Schemas.FolderSchema.DisplayName, value); }

    /**
     * Gets or sets the custom class name of this folder.
     * 
     */
    get FolderClass(): string { return <string>this.PropertyBag._getItem(Schemas.FolderSchema.FolderClass); }
    set FolderClass(value: string) { this.PropertyBag._setItem(Schemas.FolderSchema.FolderClass, value); }

    /**
     * Gets the total number of items contained in the folder.
     * 
     */
    get TotalCount(): number { return <number>this.PropertyBag._getItem(Schemas.FolderSchema.TotalCount); }

    /**
     * Gets a list of extended properties associated with the folder. **Unstable Need testing**
     * 
     */
    get ExtendedProperties(): ExtendedPropertyCollection { return <ExtendedPropertyCollection>this.PropertyBag._getItem(ServiceObjectSchema.ExtendedProperties); }

    /**
     * Gets the Email Lifecycle Management (ELC) information associated with the folder.
     * 
     */
    get ManagedFolderInformation(): ManagedFolderInformation { return <ManagedFolderInformation>this.PropertyBag._getItem(Schemas.FolderSchema.ManagedFolderInformation); }

    /**
     * Gets a value indicating the effective rights the current authenticated user has on the folder.
     * 
     */
    get EffectiveRights(): EffectiveRights { return <EffectiveRights>this.PropertyBag._getItem(Schemas.FolderSchema.EffectiveRights); }

    /**
     * Gets a list of permissions for the folder.
     * 
     */
    get Permissions(): FolderPermissionCollection { return <FolderPermissionCollection>this.PropertyBag._getItem(Schemas.FolderSchema.Permissions); }

    /**
     * Gets the number of unread items in the folder.
     * 
     */
    get UnreadCount(): number { return <number>this.PropertyBag._getItem(Schemas.FolderSchema.UnreadCount); }

    /**
     * Gets or sets the policy tag.
     * 
     */
    get PolicyTag(): PolicyTag { return <PolicyTag>this.PropertyBag._getItem(Schemas.FolderSchema.PolicyTag); }
    set PolicyTag(value: PolicyTag) { this.PropertyBag._setItem(Schemas.FolderSchema.PolicyTag, value); }

    /**
     * Gets or sets the archive tag.
     * 
     */
    get ArchiveTag(): ArchiveTag { return <ArchiveTag>this.PropertyBag._getItem(Schemas.FolderSchema.ArchiveTag); }
    set ArchiveTag(value) { this.PropertyBag._setItem(Schemas.FolderSchema.ArchiveTag, value); }

    /**
     * Gets the well known name of this folder, if any, as a string.
     * **value** - The well known name of this folder as a string, or null if this folder isn't a well known folder.
     * 
     */
    get WellKnownFolderNameAsString(): string { return WellKnownFolderName[<WellKnownFolderName>this.PropertyBag._getItem(Schemas.FolderSchema.WellKnownFolderName)]; }

    /**
     * Gets the well known name of this folder, if any.
     * **value** - The well known name of this folder, or null if this folder isn't a well known folder.
     * 
     */
    get WellKnownFolderName(): WellKnownFolderName { return WellKnownFolderName[this.WellKnownFolderNameAsString] || null; }

    /**
     * _FolderTYpe -> type of folder, use to avoid folder type detection using instanceof. some cases it has circular loop in nodejs/requirejs
     */
    //get _FolderType(): string { return XmlElementNames.Folder; }


    /**
     * Initializes an unsaved local instance of **Folder**. To bind to an existing folder, use Folder.Bind() instead.
     *
     * @param   {ExchangeService}   service   EWS service to which this object belongs.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * Binds to an existing folder, whatever its actual type is, and loads the specified set of properties. 
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the folder.
     * @param   {FolderId}          id            The Id of the folder to bind to.
     * @return  {Promise<Folder>}      A Folder instance representing the folder corresponding to the specified Id :Promise.
     */
    static Bind(service: ExchangeService, id: FolderId): Promise<Folder>;
    /**
     * Binds to an existing folder, whatever its actual type is, and loads the specified set of properties. 
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the folder.
     * @param   {WellKnownFolderName}   name          The name of the folder to bind to.
     * @return  {Promise<Folder>}      A Folder instance representing the folder corresponding to the specified name :Promise.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName): Promise<Folder>;
    /**
     * Binds to an existing folder, whatever its actual type is, and loads the specified set of properties. 
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the folder.
     * @param   {FolderId}          id            The Id of the folder to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<Folder>}      A Folder instance representing the folder corresponding to the specified Id :Promise.
     */
    static Bind(service: ExchangeService, id: FolderId, propertySet: PropertySet): Promise<Folder>;
    /**
     * Binds to an existing folder, whatever its actual type is, and loads the specified set of properties. 
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the folder.
     * @param   {WellKnownFolderName}   name          The name of the folder to bind to.
     * @param   {PropertySet}           propertySet   The set of properties to load.
     * @return  {Promise<Folder>}      A Folder instance representing the folder corresponding to the specified name :Promise.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName, propertySet: PropertySet): Promise<Folder>;
    static Bind(service: ExchangeService, idOrName: FolderId | WellKnownFolderName, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<Folder> {
        if (idOrName instanceof FolderId) {
            return service.BindToFolder(idOrName, propertySet);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder(new FolderId(idOrName), propertySet);
        }
        EwsLogging.Assert(false, "Folder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    }

    /**
     * Copies this folder into the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   destinationFolderName   The name of the folder in which to copy this folder.
     * @return  {Promise<Folder>}      A Folder representing the copy of this folder :Promise.
     */
    Copy(destinationFolderName: WellKnownFolderName): Promise<Folder>;
    /**
     * Copies this folder into a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   destinationFolderId    The Id of the folder in which to copy this folder.
     * @return  {Promise<Folder>}                  A Folder representing the copy of this folder :Promise.
     */
    Copy(destinationFolderId: FolderId): Promise<Folder>;
    Copy(destinationFolderIdOrName: FolderId | WellKnownFolderName): Promise<Folder> {
        this.ThrowIfThisIsNew();
        //EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");

        if (typeof destinationFolderIdOrName === 'undefined') {
            EwsLogging.Assert(false, "Folder.Copy", "unknown paramete type");
            throw new Error("unknow parameter type. this should not be  reached");
        }
        var folderId: FolderId = <FolderId>destinationFolderIdOrName;
        if (typeof destinationFolderIdOrName === 'number')
            folderId = new FolderId(destinationFolderIdOrName);

        return this.Service.CopyFolder(this.Id, folderId);
    }

    /**
     * Deletes the folder. Calling this method results in a call to EWS.
     *
     * @param   {DeleteMode}   deleteMode   Deletion mode.
     */
    Delete(deleteMode: DeleteMode): Promise<void> { return this.InternalDelete(deleteMode, null, null); }

    /**
     * Empties the folder. Calling this method results in a call to EWS.
     *
     * @param   {DeleteMode}    deleteMode         The deletion mode.
     * @param   {boolean}       deleteSubFolders   Indicates whether sub-folders should also be deleted.
     */
    Empty(deleteMode: DeleteMode, deleteSubFolders: boolean): Promise<void> {
        this.ThrowIfThisIsNew();
        return this.Service.EmptyFolder(
            this.Id,
            deleteMode,
            deleteSubFolders);
    }

    /**
     * Obtains a list of folders by searching the sub-folders of this folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderView}   view           The view controlling the number of folders returned.
     * @return  {Promise<FindFoldersResults>}      An object representing the results of the search operation :Promise.
     */
    FindFolders(view: FolderView): Promise<FindFoldersResults>;
    /**
     * Obtains a list of folders by searching the sub-folders of this folder. Calling this method results in a call to EWS.
     *
     * @param   {SearchFilter}      searchFilter    The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {FolderView}        view            The view controlling the number of folders returned.
     * @return  {Promise<FindFoldersResults>}      An object representing the results of the search operation :Promise.
     */
    FindFolders(searchFilter: SearchFilter, view: FolderView): Promise<FindFoldersResults>;
    FindFolders(viewOrSearchFilter: FolderView | SearchFilter, view?: FolderView): Promise<FindFoldersResults> {
        this.ThrowIfThisIsNew();
        //todo: better argument check with ewsutilities
        var argsLength = arguments.length;
        if (argsLength < 1 && argsLength > 2) {
            throw new Error("invalid arguments, check documentation and try again.");
        }

        if (viewOrSearchFilter instanceof FolderView) {
            return this.Service.FindFolders(this.Id, viewOrSearchFilter);
        }
        else if (viewOrSearchFilter instanceof SearchFilter) {
            if (typeof view === 'undefined' || !(view instanceof FolderView)) {
                throw new Error("Folder.ts - FindFolders - incorrect uses of parameters at 2nd position, must be FolderView");
            }
            return this.Service.FindFolders(this.Id, viewOrSearchFilter, view);
        }
        else {
            throw new Error("Folder.ts - FindFolders - incorrect uses of parameters at 1st position, must be FolderView or SearchFilter");
        }
    }

    /**
     * Obtains a list of items by searching the contents of this folder. Calling this method results in a call to EWS.
     *
     * @param   {ItemView}  view          The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}      An object representing the results of the search operation :Promise.
     */
    FindItems(view: ItemView): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a grouped list of items by searching the contents of this folder. Calling this method results in a call to EWS.
     *
     * @param   {ItemView}      view           The view controlling the number of items returned.
     * @param   {Grouping}      groupBy        The grouping criteria.
     * @return  {Promise<GroupedFindItemsResults<Item>>}       A collection of grouped items representing the contents of this folder :Promise.
     */
    FindItems(view: ItemView, groupBy: Grouping): Promise<GroupedFindItemsResults<Item>>;
    /**
     * Obtains a list of items by searching the contents of this folder. Calling this method results in a call to EWS.
     *
     * @param   {string}    queryString   query string to be used for indexed search
     * @param   {ItemView}  view          The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}      An object representing the results of the search operation :Promise.
     */
    FindItems(queryString: string, view: ItemView): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a list of items by searching the contents of this folder. Calling this method results in a call to EWS.
     *
     * @param   {SearchFilter}  searchFilter   The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {ItemView}      view          The view controlling the number of items returned.
     * @return  {Promise<FindItemsResults<Item>>}      An object representing the results of the search operation :Promise.
     */
    FindItems(searchFilter: SearchFilter, view: ItemView): Promise<FindItemsResults<Item>>;
    /**
     * Obtains a grouped list of items by searching the contents of this folder. Calling this method results in a call to EWS.
     *
     * @param   {string}        queryString    Query string to be used for indexed search
     * @param   {ItemView}      view           The view controlling the number of items returned.
     * @param   {Grouping}      groupBy        The grouping criteria.
     * @return  {Promise<GroupedFindItemsResults<Item>>}       A collection of grouped items representing the contents of this folder :Promise.
     */
    FindItems(queryString: string, view: ItemView, groupBy: Grouping): Promise<GroupedFindItemsResults<Item>>;
    /**
     * Obtains a grouped list of items by searching the contents of this folder. Calling this method results in a call to EWS.
     *
     * @param   {SearchFilter}  searchFilter   The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {ItemView}      view           The view controlling the number of items returned.
     * @param   {Grouping}      groupBy        The grouping criteria.
     * @return  {Promise<GroupedFindItemsResults<Item>>}       A collection of grouped items representing the contents of this folder :Promise.
     */
    FindItems(searchFilter: SearchFilter, view: ItemView, groupBy: Grouping): Promise<GroupedFindItemsResults<Item>>;

    FindItems(
        viewQueryStringOrSearchFilter: string | ItemView | SearchFilter,
        viewOrGroupBy?: ItemView | Grouping,
        groupBy?: Grouping
    ): Promise<FindItemsResults<Item> | GroupedFindItemsResults<Item>> {

        var argsLength = arguments.length;
        if (argsLength < 1 && argsLength > 3) {
            throw new Error("invalid arguments, check documentation and try again.");
        }

        //todo: better argument check with ewsutilities
        //EwsUtilities.ValidateParam(groupBy, "groupBy");
        //EwsUtilities.ValidateParamAllowNull(searchFilter, "searchFilter");
        //EwsUtilities.ValidateParamAllowNull(queryString, "queryString");

        //position 1 - viewQueryStringOrSearchFilter
        var queryString: string = null;
        var searchFilter: SearchFilter = null;
        var view: ItemView = null;

        if (typeof viewQueryStringOrSearchFilter === 'string') {
            queryString = viewQueryStringOrSearchFilter;
        }
        else if (viewQueryStringOrSearchFilter instanceof SearchFilter) {
            searchFilter = viewQueryStringOrSearchFilter;
        }
        else if (viewQueryStringOrSearchFilter instanceof ViewBase) {
            view = viewQueryStringOrSearchFilter;
        }
        else {
            throw new Error("Folder.ts - FindItems - incorrect uses of parameters at 1st position, must be string, Itemview or SearchFilter");
        }

        var groupResultBy: Grouping = null;
        var isGroupped: boolean = false; // to resturn GroupedFindItemsResults<Item>

        //position 2 - viewOrGroupBy
        if (argsLength >= 2) {
            if (viewOrGroupBy instanceof Grouping) {
                if (!(viewQueryStringOrSearchFilter instanceof ItemView)) {
                    throw new Error("Folder.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 1nd position, it must be Itemview when using Grouping at 2nd place");
                }
                groupResultBy = viewOrGroupBy;
                isGroupped = true;
            }
            else if (viewOrGroupBy instanceof ItemView) {
                view = viewOrGroupBy;
            }
            else {
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 2nd position, must be Itemsview or Grouping");
            }
        }

        //position 3 - groupBy
        if (argsLength === 3) {
            if (!(viewOrGroupBy instanceof ItemView)) {
                throw new Error("Folder.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 1nd position, it must be Itemview when using Grouping at 3rd place");
            }
            groupResultBy = <Grouping>groupBy;
            isGroupped = true;
        }

        return this.InternalFindItems<Item>(
            searchFilter || queryString,
            view,
            groupResultBy /* groupBy */)
            .then((res) => {
                if (isGroupped) {
                    return res.__thisIndexer(0).GroupedFindResults;
                }
                return res.__thisIndexer(0).Results;
            });
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.Folder; }

    /**
     * @internal Gets the name of the change XML element.
     *
     * @return  {string}      XML element name,
     */
    GetChangeXmlElementName(): string { return XmlElementNames.FolderChange; }

    /**
     * @internal Gets the name of the delete field XML element.
     *
     * @return  {string}      XML element name,
     */
    GetDeleteFieldXmlElementName(): string { return XmlElementNames.DeleteFolderField; }

    /**
     * @internal Gets a list of extended properties defined on this object.
     *
     * @return  {ExtendedPropertyCollection}      Extended properties collection.
     */
    GetExtendedProperties(): ExtendedPropertyCollection { return this.ExtendedProperties; }

    /**
     * @internal Get the property definition for the Id property.
     *
     * @return  {PropertyDefinition}      A PropertyDefinition instance.
     */
    GetIdPropertyDefinition(): PropertyDefinition { return Schemas.FolderSchema.Id; }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.FolderSchema.Instance; }

    /**
     * @internal Gets the name of the set field XML element.
     *
     * @return  {string}      XML element name,
     */
    GetSetFieldXmlElementName(): string { return XmlElementNames.SetFolderField; }

    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    InternalDelete(deleteMode: DeleteMode, sendCancellationsMode?: SendCancellationsMode, affectedTaskOccurrences?: AffectedTaskOccurrence): Promise<void> {
        this.ThrowIfThisIsNew();
        return this.Service.DeleteFolder(this.Id, deleteMode);
    }

    /**
     * @internal Find items.
     *
     * @param   {string}    queryString   Query string to be used for indexed search
     * @param   {ViewBase}  view          The view controlling the number of items returned.
     * @param   {Grouping}  groupBy       The group by.
     * @return  {Promise<ServiceResponseCollection<FindItemResponse<TItem>>>}      FindItems response collection :Promise.
     */
    InternalFindItems<TItem extends Item>(queryString: string, view: ViewBase, groupBy: Grouping): Promise<ServiceResponseCollection<FindItemResponse<TItem>>>;
    /**
     * @internal Find items.
     *
     * @param   {SearchFilter}  searchFilter   The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {ViewBase}      view          The view controlling the number of items returned.
     * @param   {Grouping}      groupBy       The group by.
     * @return  {Promise<ServiceResponseCollection<FindItemResponse<TItem>>>}      FindItems response collection :Promise.
     */
    InternalFindItems<TItem extends Item>(searchFilter: SearchFilter, view: ViewBase, groupBy: Grouping): Promise<ServiceResponseCollection<FindItemResponse<TItem>>>;
    /**
     * ### ~~*shim used internally to minimize code flow logic from calling functions*~~
    */
    InternalFindItems<TItem extends Item>(searchFilterOrQueryString: SearchFilter | string, view: ViewBase, groupBy: Grouping): Promise<ServiceResponseCollection<FindItemResponse<TItem>>>;
    InternalFindItems<TItem extends Item>(searchFilterOrQueryString: SearchFilter | string, view: ViewBase, groupBy: Grouping): Promise<ServiceResponseCollection<FindItemResponse<TItem>>> {
        this.ThrowIfThisIsNew();
        var searchFilter: SearchFilter = null;
        var queryString = null;
        if (searchFilterOrQueryString instanceof SearchFilter) {
            searchFilter = searchFilterOrQueryString;
        }
        else if (typeof searchFilterOrQueryString === 'string') {
            queryString = searchFilterOrQueryString;
        }
        //debug: //todo: //ref: verify if querystring is null
        return this.Service.FindItems<TItem>(
            [this.Id], // FolderId[]
            searchFilter, /* searchFilter */
            queryString, /* queryString */
            view,
            groupBy,
            ServiceErrorHandling.ThrowOnError);
    }

    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    InternalLoad(propertySet: PropertySet): Promise<void> {
        this.ThrowIfThisIsNew();
        return this.Service.LoadPropertiesForFolder(this, propertySet);
    }

    /**
     * Marks all items in folder as read. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   suppressReadReceipts   If true, suppress sending read receipts for items.
     */
    MarkAllItemsAsRead(suppressReadReceipts: boolean): Promise<void> {
        this.ThrowIfThisIsNew();
        return this.Service.MarkAllItemsAsRead(
            this.Id,
            true,
            suppressReadReceipts);
    }

    /**
     * Marks all items in folder as read. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   suppressReadReceipts   If true, suppress sending read receipts for items.
     */
    MarkAllItemsAsUnread(suppressReadReceipts: boolean): Promise<void> {
        this.ThrowIfThisIsNew();
        return this.Service.MarkAllItemsAsRead(
            this.Id,
            false,
            suppressReadReceipts);
    }

    /**
     * Moves this folder to the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   destinationFolderName   The name of the folder in which to move this folder.
     * @return  {Promise<Folder>}      A new folder representing this folder in its new location. After Move completes, this folder does not exist anymore :Promise.
     */
    Move(destinationFolderName: WellKnownFolderName): Promise<Folder>;
    /**
     * Moves this folder to a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   destinationFolderId   The Id of the folder in which to move this folder.
     * @return  {Promise<Folder>}      A new folder representing this folder in its new location. After Move completes, this folder does not exist anymore :Promise.
     */
    Move(destinationFolderId: FolderId): Promise<Folder>;
    Move(destinationFolderIdOrName: FolderId | WellKnownFolderName): Promise<Folder> {
        this.ThrowIfThisIsNew();
        if (typeof destinationFolderIdOrName === 'undefined') {
            EwsLogging.Assert(false, "Folder.Move", "unknown paramete type");
            throw new Error("unknow parameter type. this should not be  reached");
        }
        //EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");

        var folderId: FolderId = <FolderId>destinationFolderIdOrName;
        if (typeof destinationFolderIdOrName === 'number')
            folderId = new FolderId(destinationFolderIdOrName);

        return this.Service.MoveFolder(this.Id, folderId);
    }

    /**
     * Removes an extended property.
     *
     * @param   {ExtendedPropertyDefinition}   extendedPropertyDefinition   The extended property definition.
     * @return  {boolean}       True if property was removed.
     */
    RemoveExtendedProperty(extendedPropertyDefinition: ExtendedPropertyDefinition): boolean { return this.ExtendedProperties.RemoveExtendedProperty(extendedPropertyDefinition); }

    /**
     * Saves this folder in a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   parentFolderName   The name of the folder in which to save this folder.
     */
    Save(parentFolderName: WellKnownFolderName): Promise<void>;
    /**
     * Saves this folder in a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   parentFolderId   The Id of the folder in which to save this folder.
     */
    Save(parentFolderId: FolderId): Promise<void>;
    Save(parentFolderIdOrname: FolderId | WellKnownFolderName): Promise<void> {
        this.ThrowIfThisIsNotNew();
        if (typeof parentFolderIdOrname === 'undefined') {
            EwsLogging.Assert(false, "Folder.Save", "unknown paramete type");
            throw new Error("unknow parameter type. this should not be  reached");
        }
        //EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");
        var folderId: FolderId = <FolderId>parentFolderIdOrname;
        if (typeof parentFolderIdOrname === 'number')
            folderId = new FolderId(parentFolderIdOrname);

        if (this.IsDirty) {
            return this.Service.CreateFolder(this, folderId);
        }
        else return null;



    }

    /**
     * Sets the extended property.
     *
     * @param   {ExtendedPropertyDefinition}    extendedPropertyDefinition   The extended property definition.
     * @param   {any}                           value                        The value.
     */
    SetExtendedProperty(extendedPropertyDefinition: ExtendedPropertyDefinition, value: any): void { this.ExtendedProperties.SetExtendedProperty(extendedPropertyDefinition, value); }

    /**
     * Applies the local changes that have been made to this folder. Calling this method results in a call to EWS.
     *
     */
    Update(): Promise<void> {
        if (this.IsDirty) {
            if (this.PropertyBag.GetIsUpdateCallNecessary()) {
                return this.Service.UpdateFolder(this);
            }
        }
        return undefined;
    }

    /**
     * @internal Validates this instance.
     * 
     */
    Validate(): void {
        super.Validate();

        // Validate folder permissions
        if (this.PropertyBag.Contains(Schemas.FolderSchema.Permissions)) {
            this.Permissions.Validate();
        }
    }
}
/**
 * Represents a folder containing appointments. 
 */
export class CalendarFolder extends Folder {

    /**
     * Initializes an unsaved local instance of **CalendarFolder**. To bind to an existing calendar folder, use CalendarFolder.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the calendar folder will be bound.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * Binds to an existing calendar folder and loads its first class properties. 
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the calendar folder.
     * @param   {FolderId}          id            The Id of the calendar folder to bind to.
     * @return  {Promise<CalendarFolder>}      A CalendarFolder instance representing the folder corresponding to the specified Id :Promise.
     */
    static Bind(service: ExchangeService, id: FolderId): Promise<CalendarFolder>;
    /**
     * Binds to an existing calendar folder and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the calendar folder.
     * @param   {WellKnownFolderName}   name          The name of the calendar folder to bind to.
     * @return  {Promise<CalendarFolder>}      A CalendarFolder instance representing the folder corresponding to the specified name :Promise.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName): Promise<CalendarFolder>;
    /**
     * Binds to an existing calendar folder and loads the specified set of properties. 
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the calendar folder.
     * @param   {FolderId}          id            The Id of the calendar folder to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<CalendarFolder>}      A CalendarFolder instance representing the folder corresponding to the specified Id :Promise.
     */
    static Bind(service: ExchangeService, id: FolderId, propertySet: PropertySet): Promise<CalendarFolder>;
    /**
     * Binds to an existing calendar folder and loads the specified set of properties. 
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the folder.
     * @param   {WellKnownFolderName}   name          The name of the folder to bind to.
     * @param   {PropertySet}           propertySet   The set of properties to load.
     * @return  {Promise<CalendarFolder>}      A CalendarFolder instance representing the folder corresponding to the specified name :Promise.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName, propertySet: PropertySet): Promise<CalendarFolder>;
    static Bind(service: ExchangeService, idOrName: FolderId | WellKnownFolderName, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<CalendarFolder> {
        if (idOrName instanceof FolderId) {
            return service.BindToFolder<CalendarFolder>(idOrName, propertySet, TypeContainer.CalendarFolder);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder<CalendarFolder>(new FolderId(idOrName), propertySet, TypeContainer.CalendarFolder);
        }
        EwsLogging.Assert(false, "CalendarFolder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    }

    /**
     * Obtains a list of appointments by searching the contents of this folder and performing recurrence expansion for recurring appointments. Calling this method results in a call to EWS.
     *
     * @param   {CalendarView}   view   The view controlling the range of appointments returned.
     * @return  {FindItemsResults<Appointment>}          An object representing the results of the search operation.
     */
    FindAppointments(view: CalendarView): Promise<FindItemsResults<Appointment>> {
        EwsUtilities.ValidateParam(view, "view");
        return this.InternalFindItems<Appointment>(
            <SearchFilter>null,
            view,
            null /* groupBy */
        ).then((responses) => {
            return responses.__thisIndexer(0).Results
        });
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.CalendarFolder; }
}

/**
 * Represents a folder containing contacts. 
 */
export class ContactsFolder extends Folder {

    /**
     * Initializes an unsaved local instance of **ContactsFolder**. To bind to an existing contacts folder, use ContactsFolder.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the contacts folder will be bound.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * Binds to an existing contacts folder and loads the specified set of properties.
     *
     * @param   {ExchangeService}   service         The service to use to bind to the contacts folder.
     * @param   {FolderId}          id              The Id of the contacts folder to bind to.
     * @param   {PropertySet}       propertySet     The set of properties to load.
     * @return  {Promise<ContactsFolder>}      A ContactsFolder instance representing the contacts folder with the specified name :Promise.
     */
    static Bind(service: ExchangeService, id: FolderId, propertySet: PropertySet): Promise<ContactsFolder>;
    /**
     * Binds to an existing contacts folder and loads its first class properties.
     *
     * @param   {ExchangeService}   service         The service to use to bind to the contacts folder.
     * @param   {FolderId}          id              The Id of the contacts folder to bind to.
     * @return  {Promise<ContactsFolder>}      A ContactsFolder instance representing the contacts folder with the specified name :Promise.
     */
    static Bind(service: ExchangeService, id: FolderId): Promise<ContactsFolder>;
    /**
     * Binds to an existing contacts folder and loads the specified set of properties.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the contacts folder.
     * @param   {WellKnownFolderName}   name          The name of the contacts folder to bind to.
     * @param   {PropertySet}           propertySet   The set of properties to load.
     * @return  {Promise<ContactsFolder>}      A ContactsFolder instance representing the contacts folder with the specified name :Promise.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName, propertySet: PropertySet): Promise<ContactsFolder>;
    /**
     * Binds to an existing contacts folder and loads its first class properties.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the contacts folder.
     * @param   {WellKnownFolderName}   name          The name of the contacts folder to bind to.
     * @return  {Promise<ContactsFolder>}      A ContactsFolder instance representing the contacts folder with the specified name :Promise.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName): Promise<ContactsFolder>;
    static Bind(service: ExchangeService, idOrName: FolderId | WellKnownFolderName, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<ContactsFolder> {
        if (idOrName instanceof FolderId) {
            return service.BindToFolder<ContactsFolder>(idOrName, propertySet, TypeContainer.ContactsFolder);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder<ContactsFolder>(new FolderId(idOrName), propertySet, TypeContainer.ContactsFolder);
        }
        EwsLogging.Assert(false, "ContactsFolder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.ContactsFolder; }
}

/**
 * Represents a search folder. 
 */
export class SearchFolder extends Folder {

    /**
     * Gets the search parameters associated with the search folder.
     */
    get SearchParameters(): SearchFolderParameters { return this.PropertyBag._getItem(Schemas.SearchFolderSchema.SearchParameters) }

    /**
     * Initializes an unsaved local instance of **SearchFolder**. To bind to an existing contacts folder, use SearchFolder.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the contacts folder will be bound.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * Binds to an existing search folder and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the search folder.
     * @param   {FolderId}          id            The Id of the search folder to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<SearchFolder>}        A SearchFolder instance representing the search folder corresponding to the specified Id.
     */
    static Bind(service: ExchangeService, id: FolderId, propertySet: PropertySet): Promise<SearchFolder>;
    /**
     * Binds to an existing search folder and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the search folder.
     * @param   {FolderId}          id            The Id of the search folder to bind to.
     * @return  {Promise<SearchFolder>}        A SearchFolder instance representing the search folder corresponding to the specified Id.
     */
    static Bind(service: ExchangeService, id: FolderId): Promise<SearchFolder>;
    /**
     * Binds to an existing search folder and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the search folder.
     * @param   {WellKnownFolderName}   name          The name of the search folder to bind to.
     * @param   {PropertySet}           propertySet   The set of properties to load.
     * @return  {Promise<SearchFolder>}            A SearchFolder instance representing the search folder with the specified name.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName, propertySet: PropertySet): Promise<SearchFolder>;
    /**
     * Binds to an existing search folder and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the search folder.
     * @param   {WellKnownFolderName}   name          The name of the search folder to bind to.
     * @return  {Promise<SearchFolder>}            A SearchFolder instance representing the search folder with the specified name.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName): Promise<SearchFolder>;
    static Bind(service: ExchangeService, idOrName: FolderId | WellKnownFolderName, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<SearchFolder> {
        if (idOrName instanceof FolderId) {
            return service.BindToFolder<SearchFolder>(idOrName, propertySet, TypeContainer.SearchFolder);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder<SearchFolder>(new FolderId(idOrName), propertySet, TypeContainer.SearchFolder);
        }
        EwsLogging.Assert(false, "SearchFolder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    }
    
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.SearchFolderSchema.Instance; }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.SearchFolder; }

    /**
     * @internal Validates this instance.
     */
    Validate(): void {
        super.Validate();

        if (this.SearchParameters != null) {
            this.SearchParameters.Validate();
        }
    }
}

/**
 * Represents a folder containing task items. 
 */
export class TasksFolder extends Folder {

    /**
     * Initializes an unsaved local instance of **SearchFolder**. To bind to an existing contacts folder, use SearchFolder.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the contacts folder will be bound.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * Binds to an existing tasks folder and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the tasks folder.
     * @param   {FolderId}          id            The Id of the tasks folder to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<TasksFolder>}         A TasksFolder instance representing the task folder corresponding to the specified Id.
     */
    static Bind(service: ExchangeService, id: FolderId, propertySet: PropertySet): Promise<TasksFolder>;
    /**
     * Binds to an existing tasks folder and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the tasks folder.
     * @param   {FolderId}          id            The Id of the tasks folder to bind to.
     * @return  {Promise<TasksFolder>}         A TasksFolder instance representing the task folder corresponding to the specified Id.
     */
    static Bind(service: ExchangeService, id: FolderId): Promise<TasksFolder>;
    /**
     * Binds to an existing tasks folder and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the tasks folder.
     * @param   {WellKnownFolderName}   name          The name of the tasks folder to bind to.
     * @param   {PropertySet}           propertySet   The set of properties to load.
     * @return  {Promise<TasksFolder>}         A TasksFolder instance representing the tasks folder with the specified name.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName, propertySet: PropertySet): Promise<TasksFolder>;
    /**
     * Binds to an existing tasks folder and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}       service       The service to use to bind to the tasks folder.
     * @param   {WellKnownFolderName}   name          The name of the tasks folder to bind to.
     * @return  {Promise<TasksFolder>}         A TasksFolder instance representing the tasks folder with the specified name.
     */
    static Bind(service: ExchangeService, name: WellKnownFolderName): Promise<TasksFolder>;
    static Bind(service: ExchangeService, idOrName: FolderId | WellKnownFolderName, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<TasksFolder> {
        if (idOrName instanceof FolderId) {
            return service.BindToFolder<TasksFolder>(idOrName, propertySet, TypeContainer.TasksFolder);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder<TasksFolder>(new FolderId(idOrName), propertySet, TypeContainer.TasksFolder);
        }
        EwsLogging.Assert(false, "TasksFolder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.TasksFolder; }
}

/**
 * Represents a generic **Item**. Properties available on items are defined in the *ItemSchema* class.
 *
 */
export class Item extends ServiceObject {

    /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
    public static get Attachable(): boolean { return (<any>this).name === "Item"; };

    private parentAttachment: ItemAttachment = null;

    /**
     * @internal Gets the parent attachment of this item.
     *
     */
    get ParentAttachment(): ItemAttachment {
        return this.parentAttachment;
    }

    /**
     * @internal Gets Id of the root item for this item.
     *
     */
    get RootItemId(): ItemId {
        if (this.IsAttachment && this.ParentAttachment.Owner !== null) {
            return this.ParentAttachment.Owner.RootItemId;
        }
        return this.Id;
    }

    /**
     * Gets a value indicating whether the item is an attachment.
     *
     */
    get IsAttachment(): boolean { return this.parentAttachment != null && typeof this.parentAttachment !== 'undefined' }

    /**
     * Gets a value indicating whether this object is a real store item, or if it's a local object that has yet to be saved.
     *
     */
    get IsNew(): boolean {
        // Item attachments don't have an Id, need to check whether the
        // parentAttachment is new or not.
        if (this.IsAttachment) {
            return this.ParentAttachment.IsNew;
        }
        else {
            var id = this.GetId();
            return id == null ? true : !id.IsValid;
        }
    }

    /**
     * Gets the Id of this item.
     *
     */
    get Id(): ItemId { return this.PropertyBag._getItem(this.GetIdPropertyDefinition()); }


    /**
     * Get or sets the MIME content of this item.
     *
     */
    get MimeContent(): MimeContent {
        return <MimeContent>this.PropertyBag._getItem(Schemas.ItemSchema.MimeContent);
    }
    set MimeContent(value: MimeContent) {
        this.PropertyBag._setItem(Schemas.ItemSchema.MimeContent, value);
    }

    /**
     * Gets the Id of the parent folder of this item.
     *
     */
    get ParentFolderId(): FolderId {
        return <FolderId>this.PropertyBag._getItem(Schemas.ItemSchema.ParentFolderId);
    }

    /**
     * Gets or sets the sensitivity of this item.
     *
     */
    get Sensitivity(): Sensitivity {
        return <Sensitivity>this.PropertyBag._getItem(Schemas.ItemSchema.Sensitivity);
    }
    set Sensitivity(value: Sensitivity) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Sensitivity, value);
    }

    /**
     * Gets a list of the attachments to this item.
     *
     */
    get Attachments(): AttachmentCollection {
        return <AttachmentCollection>this.PropertyBag._getItem(Schemas.ItemSchema.Attachments);
    }

    /**
     * Gets the time when this item was received.
     *
     */
    get DateTimeReceived(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ItemSchema.DateTimeReceived);
    }

    /**
     * Gets the size of this item.
     *
     */
    get Size(): number {
        return <number>this.PropertyBag._getItem(Schemas.ItemSchema.Size);
    }

    /**
     * Gets or sets the list of categories associated with this item.
     *
     */
    get Categories(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.ItemSchema.Categories);
    }
    set Categories(value: StringList) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Categories, value);
    }

    /**
     * Gets or sets the culture associated with this item.
     *
     */
    get Culture(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.Culture);
    }
    set Culture(value: string) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Culture, value);
    }

    /**
     * Gets or sets the importance of this item.
     *
     */
    get Importance(): Importance {
        return <Importance>this.PropertyBag._getItem(Schemas.ItemSchema.Importance);
    }
    set Importance(value: Importance) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Importance, value);
    }

    /**
     * Gets or sets the In-Reply-To reference of this item.
     *
     */
    get InReplyTo(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.InReplyTo);
    }
    set InReplyTo(value: string) {
        this.PropertyBag._setItem(Schemas.ItemSchema.InReplyTo, value);
    }

    /**
     * Gets a value indicating whether the message has been submitted to be sent.
     *
     */
    get IsSubmitted(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ItemSchema.IsSubmitted);
    }

    /**
     * Gets a value indicating whether this is an associated item.
     *
     */
    get IsAssociated(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ItemSchema.IsAssociated);
    }

    /**
     * Gets a value indicating whether the item is is a draft. An item is a draft when it has not yet been sent.
     *
     */
    get IsDraft(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ItemSchema.IsDraft);
    }

    /**
     * Gets a value indicating whether the item has been sent by the current authenticated user.
     *
     */
    get IsFromMe(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ItemSchema.IsFromMe);
    }

    /**
     * Gets a value indicating whether the item is a resend of another item.
     *
     */
    get IsResend(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ItemSchema.IsResend);
    }

    /**
     * Gets a value indicating whether the item has been modified since it was created.
     *
     */
    get IsUnmodified(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ItemSchema.IsUnmodified);
    }

    /**
     * Gets a list of Internet headers for this item.
     *
     */
    get InternetMessageHeaders(): InternetMessageHeaderCollection {
        return <InternetMessageHeaderCollection>this.PropertyBag._getItem(Schemas.ItemSchema.InternetMessageHeaders);
    }

    /**
     * Gets the date and time this item was sent.
     *
     */
    get DateTimeSent(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ItemSchema.DateTimeSent);
    }

    /**
     * Gets the date and time this item was created.
     *
     */
    get DateTimeCreated(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ItemSchema.DateTimeCreated);
    }

    /**
     * Gets a value indicating which response actions are allowed on this item. Examples of response actions are Reply and Forward.
     *
     */
    get AllowedResponseActions(): ResponseActions {
        return <ResponseActions>this.PropertyBag._getItem(Schemas.ItemSchema.AllowedResponseActions);
    }

    /**
     * Gets or sets the date and time when the reminder is due for this item.
     *
     */
    get ReminderDueBy(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ItemSchema.ReminderDueBy);
    }
    set ReminderDueBy(value: DateTime) {
        this.PropertyBag._setItem(Schemas.ItemSchema.ReminderDueBy, value);
    }

    /**
     * Gets or sets a value indicating whether a reminder is set for this item.
     *
     */
    get IsReminderSet(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ItemSchema.IsReminderSet);
    }
    set IsReminderSet(value: boolean) {
        this.PropertyBag._setItem(Schemas.ItemSchema.IsReminderSet, value);
    }

    /**
     * Gets or sets the number of minutes before the start of this item when the reminder should be triggered.
     *
     */
    get ReminderMinutesBeforeStart(): number {
        return <number>this.PropertyBag._getItem(Schemas.ItemSchema.ReminderMinutesBeforeStart);
    }
    set ReminderMinutesBeforeStart(value: number) {
        this.PropertyBag._setItem(Schemas.ItemSchema.ReminderMinutesBeforeStart, value);
    }

    /**
     * Gets a text summarizing the Cc receipients of this item.
     *
     */
    get DisplayCc(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.DisplayCc);
    }

    /**
     * Gets a text summarizing the To recipients of this item.
     *
     */
    get DisplayTo(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.DisplayTo);
    }

    /**
     * Gets a value indicating whether the item has attachments.
     *
     */
    get HasAttachments(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ItemSchema.HasAttachments);
    }

    /**
     * Gets or sets the body of this item.
     *
     */
    get Body(): MessageBody {
        return <MessageBody>this.PropertyBag._getItem(Schemas.ItemSchema.Body);
    }
    set Body(value: MessageBody) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Body, value);
    }

    /**
     * Gets or sets the custom class name of this item.
     *
     */
    get ItemClass(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.ItemClass);
    }
    set ItemClass(value: string) {
        this.PropertyBag._setItem(Schemas.ItemSchema.ItemClass, value);
    }

    /**
     * Gets or sets the subject of this item.
     *
     */
    get Subject(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.Subject);
    }
    set Subject(value: string) {
        this.SetSubject(value);
    }

    /**
     * Gets the query string that should be appended to the Exchange Web client URL to open this item using the appropriate read form in a web browser.
     *
     */
    get WebClientReadFormQueryString(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.WebClientReadFormQueryString);
    }

    /**
     * Gets the query string that should be appended to the Exchange Web client URL to open this item using the appropriate edit form in a web browser.
     *
     */
    get WebClientEditFormQueryString(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.WebClientEditFormQueryString);
    }

    /**
     * Gets a list of extended properties defined on this item.
     *
     */
    get ExtendedProperties(): ExtendedPropertyCollection {
        return <ExtendedPropertyCollection>this.PropertyBag._getItem(ServiceObjectSchema.ExtendedProperties);
    }

    /**
     * Gets a value indicating the effective rights the current authenticated user has on this item.
     *
     */
    get EffectiveRights(): EffectiveRights {
        return <EffectiveRights>this.PropertyBag._getItem(Schemas.ItemSchema.EffectiveRights);
    }

    /**
     * Gets the name of the user who last modified this item.
     *
     */
    get LastModifiedName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.LastModifiedName);
    }

    /**
     * Gets the date and time this item was last modified.
     *
     */
    get LastModifiedTime(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ItemSchema.LastModifiedTime);
    }

    /**
     * Gets the Id of the conversation this item is part of.
     *
     */
    get ConversationId(): ConversationId {
        return <ConversationId>this.PropertyBag._getItem(Schemas.ItemSchema.ConversationId);
    }

    /**
     * Gets the body part that is unique to the conversation this item is part of.
     *
     */
    get UniqueBody(): UniqueBody {
        return <UniqueBody>this.PropertyBag._getItem(Schemas.ItemSchema.UniqueBody);
    }

    /**
     * Gets the store entry id.
     *
     */
    get StoreEntryId(): number[] {
        return <number[]>this.PropertyBag._getItem(Schemas.ItemSchema.StoreEntryId);
    }

    /**
     * Gets the item instance key.
     *
     */
    get InstanceKey(): number[] {
        return <number[]>this.PropertyBag._getItem(Schemas.ItemSchema.InstanceKey);
    }

    /**
     * Get or set the Flag value for this item.
     *
     */
    get Flag(): Flag {
        return <Flag>this.PropertyBag._getItem(Schemas.ItemSchema.Flag);
    }
    set Flag(value: Flag) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Flag, value);
    }

    /**
     * Gets the normalized body of the item.
     *
     */
    get NormalizedBody(): NormalizedBody {
        return <NormalizedBody>this.PropertyBag._getItem(Schemas.ItemSchema.NormalizedBody);
    }

    /**
     * Gets the EntityExtractionResult of the item.
     *
     */
    get EntityExtractionResult(): EntityExtractionResult {
        return <EntityExtractionResult>this.PropertyBag._getItem(Schemas.ItemSchema.EntityExtractionResult);
    }

    /**
     * Gets or sets the policy tag.
     *
     */
    get PolicyTag(): PolicyTag {
        return <PolicyTag>this.PropertyBag._getItem(Schemas.ItemSchema.PolicyTag);
    }
    set PolicyTag(value: PolicyTag) {
        this.PropertyBag._setItem(Schemas.ItemSchema.PolicyTag, value);
    }

    /**
     * Gets or sets the archive tag.
     *
     */
    get ArchiveTag(): ArchiveTag {
        return <ArchiveTag>this.PropertyBag._getItem(Schemas.ItemSchema.ArchiveTag);
    }
    set ArchiveTag(value: ArchiveTag) {
        this.PropertyBag._setItem(Schemas.ItemSchema.ArchiveTag, value);
    }

    /**
     * Gets the retention date.
     *
     */
    get RetentionDate(): DateTime { //Nullable
        return <DateTime>this.PropertyBag._getItem(Schemas.ItemSchema.RetentionDate);
    }

    /**
     * Gets the item Preview.
     *
     */
    get Preview(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.Preview);
    }

    /**
     * Gets the text body of the item.
     *
     */
    get TextBody(): TextBody {
        return <TextBody>this.PropertyBag._getItem(Schemas.ItemSchema.TextBody);
    }

    /**
     * Gets the icon index.
     *
     */
    get IconIndex(): IconIndex {
        return <IconIndex>this.PropertyBag._getItem(Schemas.ItemSchema.IconIndex);
    }

    /**
     * @internal Gets the default setting for how to treat affected task occurrences on Delete.
     * Subclasses will override this for different default behavior.
     *
     */
    get DefaultAffectedTaskOccurrences(): AffectedTaskOccurrence { //nullable
        return null;
    }

    /**
     * @internal Gets the default setting for sending cancellations on Delete.
     * Subclasses will override this for different default behavior.
     *
     */
    get DefaultSendCancellationsMode(): SendCancellationsMode {//nullable
        return null;
    }

    /**
     * @internal Gets the default settings for sending invitations on Save.
     * Subclasses will override this for different default behavior.
     *
     */
    get DefaultSendInvitationsMode(): SendInvitationsMode {//nullable
        return null;
    }

    /**
     * @internal Gets the default settings for sending invitations or cancellations on Update.
     * Subclasses will override this for different default behavior.
     *
     */
    get DefaultSendInvitationsOrCancellationsMode(): SendInvitationsOrCancellationsMode {//nullable
        return null;
    }

    /**
     * @internal Initializes an unsaved local instance of *Item*. To bind to an existing item, use **Item.Bind()** instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the item will be bound.
     */
    constructor(svc: ExchangeService);
    /**
     * @internal Initializes a new instance of the  *Item* class. To bind to an existing item, use **Item.Bind()** instead
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    /**
     * @internal ~~**used for super call, easier to manage, do not use in Actual code. //todo:fix - [ ] remove from d.ts file**~~.
     */
    constructor(obj: ExchangeService | ItemAttachment)
    constructor(obj: ExchangeService | ItemAttachment) {
        super(obj instanceof TypeContainer.ExchangeService ? <ExchangeService>obj : obj instanceof TypeContainer.ItemAttachment ? (<ItemAttachment>obj).Service : null);//info: cannot check instanceof to avoid circular dependency in js. TypeContainer is workaround 

        if (obj instanceof TypeContainer.ItemAttachment) {
            var parentAttachment = obj;
            EwsLogging.Assert(
                parentAttachment != null,
                "Item.ctor",
                "parentAttachment is null");

            this.parentAttachment = <ItemAttachment>parentAttachment;
        }
    }

    /**
     * Binds to an existing item, whatever its actual type is, and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service         The service to use to bind to the item.
     * @param   {ItemId}            id              The Id of the item to bind to.
     * @return  {Promise<Item>}                    An Item instance representing the item corresponding to the specified Id :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId): Promise<Item>;
    /**
     * Binds to an existing item, whatever its actual type is, and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service         The service to use to bind to the item.
     * @param   {ItemId}            id              The Id of the item to bind to.
     * @param   {PropertySet}       propertySet     The set of properties to load.
     * @return  {Promise<Item>}                    An Item instance representing the item corresponding to the specified Id :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<Item>;
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<Item> {
        return service.BindToItem<Item>(id, propertySet, Item);
    }

    /**
     * Creates a copy of this item in the specified folder. Calling this method results in a call to EWS.
     * 
     * Copy returns null if the copy operation is across two mailboxes or between a mailbox and a public folder.
     *
     * @param   {WellKnownFolderName}   destinationFolderName   The name of the folder in which to create a copy of this item.
     * @return  {Promise<Item>}                                The copy of this item :Promise.
     */
    Copy(destinationFolderName: WellKnownFolderName): Promise<Item>;
    /**
     * Creates a copy of this item in the specified folder. Calling this method results in a call to EWS.
     *
     *  Copy returns null if the copy operation is across two mailboxes or between a mailbox and a public folder.
     *
     * @param   {FolderId}          destinationFolderId   The Id of the folder in which to create a copy of this item.
     * @return  {Promise<Item>}                          The copy of this item :Promise.
     */
    Copy(destinationFolderId: FolderId): Promise<Item>;
    Copy(destinationFolderIdOrName: FolderId | WellKnownFolderName): Promise<Item> {
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();

        var folderId: FolderId = null;
        if (destinationFolderIdOrName instanceof FolderId) {
            folderId = destinationFolderIdOrName;
        }
        else {
            folderId = new FolderId(<WellKnownFolderName>destinationFolderIdOrName);
        }
        //todo: EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");

        return this.Service.CopyItem(this.Id, folderId);
    }

    /**
     * Deletes the item. Calling this method results in a call to EWS.
     *
     * @param   {DeleteMode}   deleteMode             The deletion mode.
     */
    Delete(deleteMode: DeleteMode): Promise<void>
    /**
     * Deletes the item. Calling this method results in a call to EWS.
     *
     * @param   {DeleteMode}   deleteMode             The deletion mode.
     * @param   {boolean}   suppressReadReceipts   Whether to suppress read receipts
     */
    Delete(deleteMode: DeleteMode, suppressReadReceipts: boolean): Promise<void>
    Delete(deleteMode: DeleteMode, suppressReadReceipts: boolean = false): Promise<void> { return this.InternalDelete(deleteMode, null, null, suppressReadReceipts); }

    /**
     * @internal Gets a list of extended properties defined on this object.
     *
     * @return  {ExtendedPropertyCollection}      Extended properties collection.
     */
    GetExtendedProperties(): ExtendedPropertyCollection { return this.ExtendedProperties; }

    /**
     * @inrtnal The property definition for the Id of this object.
     *
     * @return  {PropertyDefinition}      A PropertyDefinition instance.
     */
    GetIdPropertyDefinition(): PropertyDefinition { return Schemas.ItemSchema.Id; }

    /**
     * Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}   isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}                       true if a time zone SOAP header should be emitted; otherwise, false.
     */
    GetIsTimeZoneHeaderRequired(isUpdateOperation: boolean): boolean {
        // Starting E14SP2, attachment will be sent along with CreateItem requests. 
        // if the attachment used to require the Timezone header, CreateItem request should do so too.
        //
        //debugger;//todo: filtering of specific type needed.
        if (!isUpdateOperation &&
            (this.Service.RequestedServerVersion >= ExchangeVersion.Exchange2010_SP2)) {
            for (var itemAttachment of ArrayHelper.OfType<Attachment, ItemAttachment>(this.Attachments.Items, (a) => a instanceof TypeContainer.ItemAttachment))//.OfType<ItemAttachment>()) //info: cannot check instanceof to avoid circular dependency in js. TypeContainer is workaround
            {
                if ((itemAttachment.Item != null) && itemAttachment.Item.GetIsTimeZoneHeaderRequired(false /* isUpdateOperation */)) {
                    return true;
                }
            }
        }

        return super.GetIsTimeZoneHeaderRequired(isUpdateOperation);
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.ItemSchema.Instance; }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.Item; }

    /**
     * @internal Gets a value indicating whether this instance has unprocessed attachment collection changes.
     *
     * @return  {boolean}      true or false.
     * 
     */
    HasUnprocessedAttachmentChanges(): boolean { return this.Attachments.HasUnprocessedChanges(); }

    /**
     * @internal Create item.
     *
     * @param   {FolderId}              parentFolderId        The parent folder id.
     * @param   {MessageDisposition}    messageDisposition    The message disposition.
     * @param   {SendInvitationsMode}   sendInvitationsMode   The send invitations mode.
     */
    InternalCreate(parentFolderId: FolderId, messageDisposition: MessageDisposition, sendInvitationsMode: SendInvitationsMode): Promise<void> {
        this.ThrowIfThisIsNotNew();
        this.ThrowIfThisIsAttachment();

        if (this.IsNew || this.IsDirty) {
            return this.Service.CreateItem(
                this,
                parentFolderId,
                messageDisposition,
                sendInvitationsMode !== null ? sendInvitationsMode : this.DefaultSendInvitationsMode)
                .then<void>((response) => {
                    return this.Attachments.Save();
                });
        }
        return;
    }

    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    InternalDelete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence): Promise<void>;
    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     * @param   {boolean}                   suppressReadReceipts      Whether to suppress read receipts
     */
    InternalDelete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence, suppressReadReceipts: boolean): Promise<void>;
    InternalDelete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode = this.DefaultSendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence = this.DefaultAffectedTaskOccurrences, suppressReadReceipts: boolean = false): Promise<void> {
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();

        // If sendCancellationsMode is null, use the default value that's appropriate for item type.
        // if (!sendCancellationsMode)
        // {
        //     sendCancellationsMode = this.DefaultSendCancellationsMode;
        // }

        // If affectedTaskOccurrences is null, use the default value that's appropriate for item type.
        // if (!affectedTaskOccurrences)
        // {
        //     affectedTaskOccurrences = this.DefaultAffectedTaskOccurrences;
        // }

        return this.Service.DeleteItem(
            this.Id,
            deleteMode,
            sendCancellationsMode,
            affectedTaskOccurrences,
            suppressReadReceipts);
    }

    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    InternalLoad(propertySet: PropertySet): Promise<void> {
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();

        return <any>this.Service.InternalLoadPropertiesForItems(
            [this],//new Item[] { this },
            propertySet,
            ServiceErrorHandling.ThrowOnError);
    }

    /**
     * @internal Update item.
     *
     * @param   {FolderId}                              parentFolderId                       The parent folder id.
     * @param   {ConflictResolutionMode}                conflictResolutionMode               The conflict resolution mode.
     * @param   {MessageDisposition}                    messageDisposition                   The message disposition.
     * @param   {SendInvitationsOrCancellationsMode}    sendInvitationsOrCancellationsMode   The send invitations or cancellations mode.
     * @return  {Promise<Item>}                        Updated item :Promise.
     */
    InternalUpdate(parentFolderId: FolderId, conflictResolutionMode: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode): Promise<Item>;
    /**
     * @internal Update item.
     *
     * @param   {FolderId}                              parentFolderId                       The parent folder id.
     * @param   {ConflictResolutionMode}                conflictResolutionMode               The conflict resolution mode.
     * @param   {MessageDisposition}                    messageDisposition                   The message disposition.
     * @param   {SendInvitationsOrCancellationsMode}    sendInvitationsOrCancellationsMode   The send invitations or cancellations mode.
     * @param   {boolean}                               suppressReadReceipts                 Whether to suppress read receipts
     * @return  {Promise<Item>}                        Updated item :Promise.
     */
    InternalUpdate(parentFolderId: FolderId, conflictResolutionMode: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode, suppressReadReceipts: boolean): Promise<Item>;
    InternalUpdate(parentFolderId: FolderId, conflictResolutionMode: ConflictResolutionMode, messageDisposition: MessageDisposition, sendInvitationsOrCancellationsMode: SendInvitationsOrCancellationsMode, suppressReadReceipts: boolean = false): Promise<Item> {
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();

        var returnedPromise: Promise<Item> = null;
        var returnedItem: Item = null;

        if (this.IsDirty && this.PropertyBag.GetIsUpdateCallNecessary()) {
            returnedPromise = this.Service.UpdateItem(
                this,
                parentFolderId,
                conflictResolutionMode,
                messageDisposition,
                sendInvitationsOrCancellationsMode !== null ? sendInvitationsOrCancellationsMode : this.DefaultSendInvitationsOrCancellationsMode,
                suppressReadReceipts);
        }

        return Promise.resolve(returnedPromise).then((item: Item) => {
            // Regardless of whether item is dirty or not, if it has unprocessed
            // attachment changes, validate them and process now.
            if (this.HasUnprocessedAttachmentChanges()) {
                this.Attachments.Validate();
                return this.Attachments.Save().then(() => {
                    return item;
                });
            }
            return item;
        });

        //return Promise.resolve(returnedItem);
    }

    /**
     * Moves this item to a the specified folder. Calling this method results in a call to EWS.
     * 
     * Move returns null if the move operation is across two mailboxes or between a mailbox and a public folder.
     *
     * @param   {FolderId}   destinationFolderId    The Id of the folder to which to move this item.
     * @return  {Promise<Item>}                    The moved copy of this item :Promise.
     */
    Move(destinationFolderId: FolderId): Promise<Item>;
    /**
     * Moves this item to a the specified folder. Calling this method results in a call to EWS.
     * 
     * Move returns null if the move operation is across two mailboxes or between a mailbox and a public folder.
     *
     * @param   {WellKnownFolderName}   destinationFolderName   The name of the folder to which to move this item.
     * @return  {Promise<Item>}        The moved copy of this item :Promise.
     */
    Move(destinationFolderName: WellKnownFolderName): Promise<Item>;
    Move(destinationFolderIdOrName: FolderId | WellKnownFolderName): Promise<Item> {
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();

        var folderId: FolderId = null;
        if (destinationFolderIdOrName instanceof FolderId) {
            folderId = destinationFolderIdOrName;
        }
        else {
            folderId = new FolderId(<WellKnownFolderName>destinationFolderIdOrName);
        }
        //EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        return this.Service.MoveItem(this.Id, folderId);

    }

    /**
     * Removes an extended property.
     *
     * @param   {ExtendedPropertyDefinition}    extendedPropertyDefinition   The extended property definition.
     * @return  {boolean}                       True if property was removed.
     */
    RemoveExtendedProperty(extendedPropertyDefinition: ExtendedPropertyDefinition): boolean { return this.ExtendedProperties.RemoveExtendedProperty(extendedPropertyDefinition); }

    /**
     * Saves this item in the default folder based on the item's type (for example, an e-mail message is saved to the Drafts folder).
     * Calling this method results in at least one call to EWS. Mutliple calls to EWS might be made if attachments have been added.
     *
     */
    Save(): Promise<void>;
    /**
     * Saves this item in a specific folder. Calling this method results in at least one call to EWS.
     * Mutliple calls to EWS might be made if attachments have been added.
     *
     * @param   {WellKnownFolderName}   parentFolderName   The name of the folder in which to save this item.
     */
    Save(parentFolderName?: WellKnownFolderName): Promise<void>;
    /**
     * Saves this item in a specific folder. Calling this method results in at least one call to EWS.
     * Mutliple calls to EWS might be made if attachments have been added.
     *
     * @param   {FolderId}   parentFolderId   The Id of the folder in which to save this item.
     */
    Save(parentFolderId?: FolderId): Promise<void>;
    Save(parentFolderIdOrName: FolderId | WellKnownFolderName = null): Promise<void> {
        var parentFolderId: FolderId = null;
        if (parentFolderIdOrName !== null) {
            parentFolderId = <FolderId>parentFolderIdOrName;
            if (typeof parentFolderIdOrName === 'number') {
                parentFolderId = new FolderId(parentFolderIdOrName);
            }
        }
        return this.InternalCreate(
            parentFolderId,
            MessageDisposition.SaveOnly,
            null);
    }

    /**
     * Sets the extended property.
     *
     * @param   {ExtendedPropertyDefinition}    extendedPropertyDefinition   The extended property definition.
     * @param   {value}                         value                        The value.
     */
    SetExtendedProperty(extendedPropertyDefinition: ExtendedPropertyDefinition, value: any): void { this.ExtendedProperties.SetExtendedProperty(extendedPropertyDefinition, value); }

    /**
     * @internal Sets the subject.
     * 
     */
    SetSubject(subject: string): void { this.PropertyBag._setItem(Schemas.ItemSchema.Subject, subject); }

    /**
     * Throws exception if this is attachment.
     *
     */
    ThrowIfThisIsAttachment(): void {
        if (this.IsAttachment) {
            throw new Error(Strings.OperationDoesNotSupportAttachments);//InvalidOperationException
        }
    }

    /**
     * Applies the local changes that have been made to this item. Calling this method results in at least one call to EWS.
     * Mutliple calls to EWS might be made if attachments have been added or removed.
     *
     * @param   {ConflictResolutionMode}   conflictResolutionMode   The conflict resolution mode.
     */
    Update(conflictResolutionMode: ConflictResolutionMode): Promise<void>;
    /**
     * Applies the local changes that have been made to this item. Calling this method results in at least one call to EWS.
     * Mutliple calls to EWS might be made if attachments have been added or removed.
     *
     * @param   {ConflictResolutionMode}   conflictResolutionMode   The conflict resolution mode.
     * @param   {boolean}   suppressReadReceipts     Whether to suppress read receipts
     */
    Update(conflictResolutionMode: ConflictResolutionMode, suppressReadReceipts: boolean): Promise<void>;
    Update(conflictResolutionMode: ConflictResolutionMode, suppressReadReceipts: boolean = false): Promise<void> {
        return <any>this.InternalUpdate(
            null /* parentFolder */,
            conflictResolutionMode,
            MessageDisposition.SaveOnly,
            null,
            suppressReadReceipts);
    }

    /**
     * @internal Validates this instance.
     * 
     */
    Validate(): void {
        super.Validate();

        this.Attachments.Validate();

        // Flag parameter is only valid for Exchange2013 or higher
        //
        var flag: IOutParam<Flag> = { outValue: null };
        if (this.TryGetProperty<Flag>(Schemas.ItemSchema.Flag, flag) && flag.outValue != null) {
            if (this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(
                    StringHelper.Format(
                        Strings.ParameterIncompatibleWithRequestVersion,
                        "Flag",
                        ExchangeVersion[ExchangeVersion.Exchange2013]));
            }

            flag.outValue.Validate();
        }
    }

}

/**
 * Represents an **appointment or a meeting**. Properties available on appointments are defined in the *AppointmentSchema* class.
 */
export class Appointment extends Item implements ICalendarActionProvider {

    /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute.*/
    public static get Attachable(): boolean { return (<any>this).name === "Appointment"; };

    /**
     * @internal Gets the default setting for sending cancellations on Delete.
     *
     * @return  {SendCancellationsMode}      If Delete() is called on Appointment, we want to send cancellations and save a copy.
     */
    get DefaultSendCancellationsMode(): SendCancellationsMode {
        return SendCancellationsMode.SendToAllAndSaveCopy;
    }

    /**
     * @internal Gets the default settings for sending invitations on Save.
     */
    get DefaultSendInvitationsMode(): SendInvitationsMode {
        return SendInvitationsMode.SendToAllAndSaveCopy;
    }

    /**
     * @internal Gets the default settings for sending invitations or cancellations on Update.
     */
    get DefaultSendInvitationsOrCancellationsMode(): SendInvitationsOrCancellationsMode {
        return SendInvitationsOrCancellationsMode.SendToAllAndSaveCopy;
    }

    /**
     * Gets or sets the start time of the appointment.
     */
    get Start(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.Start);
    }
    set Start(value: DateTime) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.Start, value);
    }

    /**
     * Gets or sets the end time of the appointment.
     */
    get End(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.End);
    }
    set End(value: DateTime) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.End, value);
    }

    /**
     * Gets the original start time of this appointment.
     */
    get OriginalStart(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.OriginalStart);
    }

    /**
     * Gets or sets a value indicating whether this appointment is an all day event.
     */
    get IsAllDayEvent(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsAllDayEvent);
    }
    set IsAllDayEvent(value: boolean) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.IsAllDayEvent, value);
    }

    /**
     * Gets or sets a value indicating the free/busy status of the owner of this appointment. 
     */
    get LegacyFreeBusyStatus(): LegacyFreeBusyStatus {
        return <LegacyFreeBusyStatus>this.PropertyBag._getItem(Schemas.AppointmentSchema.LegacyFreeBusyStatus);
    }
    set LegacyFreeBusyStatus(value: LegacyFreeBusyStatus) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.LegacyFreeBusyStatus, value);
    }

    /**
     * Gets or sets the location of this appointment.
     */
    get Location(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.Location);
    }
    set Location(value: string) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.Location, value);
    }

    /**
     * Gets a text indicating when this appointment occurs. 
     * The text returned by When is localized using the Exchange Server culture or using the culture specified in the PreferredCulture property of the ExchangeService object this appointment is bound to.
     */
    get When(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.When);
    }

    /**
     * Gets a value indicating whether the appointment is a meeting.
     */
    get IsMeeting(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsMeeting);
    }

    /**
     * Gets a value indicating whether the appointment has been cancelled.
     */
    get IsCancelled(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsCancelled);
    }

    /**
     * Gets a value indicating whether the appointment is recurring.
     */
    get IsRecurring(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsRecurring);
    }

    /**
     * Gets a value indicating whether the meeting request has already been sent.
     */
    get MeetingRequestWasSent(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.MeetingRequestWasSent);
    }
    set IsResponseRequested(value: boolean) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.IsResponseRequested, value);
    }

    /**
     * Gets or sets a value indicating whether responses are requested when invitations are sent for this meeting.
     */
    get IsResponseRequested(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsResponseRequested);
    }

    /**
     * Gets a value indicating the type of this appointment.
     */
    get AppointmentType(): AppointmentType {
        return <AppointmentType>this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentType);
    }

    /**
     * Gets a value indicating what was the last response of the user that loaded this meeting.
     */
    get MyResponseType(): MeetingResponseType {
        return <MeetingResponseType>this.PropertyBag._getItem(Schemas.AppointmentSchema.MyResponseType);
    }

    /**
     * Gets the organizer of this meeting. The Organizer property is read-only and is only relevant for attendees.
     * The organizer of a meeting is automatically set to the user that created the meeting.
     */
    get Organizer(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.AppointmentSchema.Organizer);
    }

    /**
     * Gets a list of required attendees for this meeting.
     */
    get RequiredAttendees(): AttendeeCollection {
        return <AttendeeCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.RequiredAttendees);
    }

    /**
     * Gets a list of optional attendeed for this meeting.
     */
    get OptionalAttendees(): AttendeeCollection {
        return <AttendeeCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.OptionalAttendees);
    }

    /**
     * Gets a list of resources for this meeting.
     */
    get Resources(): AttendeeCollection {
        return <AttendeeCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.Resources);
    }

    /**
     * Gets the number of calendar entries that conflict with this appointment in the authenticated user's calendar.
     */
    get ConflictingMeetingCount(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.ConflictingMeetingCount);
    }

    /**
     * Gets the number of calendar entries that are adjacent to this appointment in the authenticated user's calendar.
     */
    get AdjacentMeetingCount(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.AdjacentMeetingCount);
    }

    /**
     * Gets a list of meetings that conflict with this appointment in the authenticated user's calendar.
     */
    get ConflictingMeetings(): ItemCollection<Appointment> {
        return <ItemCollection<Appointment>>this.PropertyBag._getItem(Schemas.AppointmentSchema.ConflictingMeetings);
    }

    /**
     * Gets a list of meetings that is adjacent to this appointment in the authenticated user's calendar.
     */
    get AdjacentMeetings(): ItemCollection<Appointment> {
        return <ItemCollection<Appointment>>this.PropertyBag._getItem(Schemas.AppointmentSchema.AdjacentMeetings);
    }

    /**
     * Gets the duration of this appointment.
     */
    get Duration(): TimeSpan {
        return <TimeSpan>this.PropertyBag._getItem(Schemas.AppointmentSchema.Duration);
    }

    /**
     * Gets the name of the time zone this appointment is defined in.
     */
    get TimeZone(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.TimeZone);
    }

    /**
     * Gets the time when the attendee replied to the meeting request.
     */
    get AppointmentReplyTime(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentReplyTime);
    }

    /**
     * Gets the sequence number of this appointment.
     */
    get AppointmentSequenceNumber(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentSequenceNumber);
    }

    /**
     * Gets the state of this appointment.
     */
    get AppointmentState(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentState);
    }

    /**
     * Gets or sets the recurrence pattern for this appointment. Available recurrence pattern classes include
     * Recurrence.DailyPattern, Recurrence.MonthlyPattern and Recurrence.YearlyPattern.
     */
    get Recurrence(): Recurrence {
        return <Recurrence>this.PropertyBag._getItem(Schemas.AppointmentSchema.Recurrence);
    }
    set Recurrence(value: Recurrence) {
        if (value !== null && value.IsRegenerationPattern) {
            throw new ServiceLocalException(Strings.RegenerationPatternsOnlyValidForTasks);
        }
        this.PropertyBag._setItem(Schemas.AppointmentSchema.Recurrence, value);
    }

    /**
     * Gets an OccurrenceInfo identifying the first occurrence of this meeting.
     */
    get FirstOccurrence(): OccurrenceInfo {
        return <OccurrenceInfo>this.PropertyBag._getItem(Schemas.AppointmentSchema.FirstOccurrence);
    }

    /**
     * Gets an OccurrenceInfo identifying the last occurrence of this meeting.
     */
    get LastOccurrence(): OccurrenceInfo {
        return <OccurrenceInfo>this.PropertyBag._getItem(Schemas.AppointmentSchema.LastOccurrence);
    }

    /**
     * Gets a list of modified occurrences for this meeting.
     */
    get ModifiedOccurrences(): OccurrenceInfoCollection {
        return <OccurrenceInfoCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.ModifiedOccurrences);
    }

    /**
     * Gets a list of deleted occurrences for this meeting.
     */
    get DeletedOccurrences(): DeletedOccurrenceInfoCollection {
        return <DeletedOccurrenceInfoCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.DeletedOccurrences);
    }

    /**
     * Gets or sets time zone of the start property of this appointment.
     */
    get StartTimeZone(): TimeZoneInfo {
        return <TimeZoneInfo>this.PropertyBag._getItem(Schemas.AppointmentSchema.StartTimeZone);
    }
    set StartTimeZone(value: TimeZoneInfo) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.StartTimeZone, value);
    }

    /**
     * Gets or sets time zone of the end property of this appointment.
     */
    get EndTimeZone(): TimeZoneInfo {
        return <TimeZoneInfo>this.PropertyBag._getItem(Schemas.AppointmentSchema.EndTimeZone);
    }
    set EndTimeZone(value: TimeZoneInfo) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.EndTimeZone, value);
    }

    /**
     * Gets or sets the type of conferencing that will be used during the meeting.
     */
    get ConferenceType(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.ConferenceType);
    }
    set ConferenceType(value: number) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.ConferenceType, value);
    }

    /**
     * Gets or sets a value indicating whether new time proposals are allowed for attendees of this meeting.
     */
    get AllowNewTimeProposal(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.AllowNewTimeProposal);
    }
    set AllowNewTimeProposal(value: boolean) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.AllowNewTimeProposal, value);
    }

    /**
     * Gets or sets a value indicating whether this is an online meeting.
     */
    get IsOnlineMeeting(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsOnlineMeeting);
    }
    set IsOnlineMeeting(value: boolean) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.IsOnlineMeeting, value);
    }

    /**
     * Gets or sets the URL of the meeting workspace. A meeting workspace is a shared Web site for planning meetings and tracking results.
     */
    get MeetingWorkspaceUrl(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.MeetingWorkspaceUrl);
    }
    set MeetingWorkspaceUrl(value: string) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.MeetingWorkspaceUrl, value);
    }

    /**
     * Gets or sets the URL of the Microsoft NetShow online meeting.
     */
    get NetShowUrl(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.NetShowUrl);
    }
    set NetShowUrl(value: string) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.NetShowUrl, value);
    }

    /**
     * Gets or sets the ICalendar Uid.
     */
    get ICalUid(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.ICalUid);
    }
    set ICalUid(value: string) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.ICalUid, value);
    }

    /**
     * Gets the ICalendar RecurrenceId.
     */
    get ICalRecurrenceId(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.ICalRecurrenceId);
    }

    /**
     * Gets the ICalendar DateTimeStamp.
     */
    get ICalDateTimeStamp(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.ICalDateTimeStamp);
    }

    /**
     * Gets or sets the Enhanced location object.
     */
    get EnhancedLocation(): EnhancedLocation {
        return <EnhancedLocation>this.PropertyBag._getItem(Schemas.AppointmentSchema.EnhancedLocation);
    }
    set EnhancedLocation(value: EnhancedLocation) {
        this.PropertyBag._setItem(Schemas.AppointmentSchema.EnhancedLocation, value);
    }

    /**
     * Gets the Url for joining an online meeting
     */
    get JoinOnlineMeetingUrl(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.JoinOnlineMeetingUrl);
    }

    /**
     * Gets the Online Meeting Settings
     */
    get OnlineMeetingSettings(): OnlineMeetingSettings {
        return <OnlineMeetingSettings>this.PropertyBag._getItem(Schemas.AppointmentSchema.OnlineMeetingSettings);
    }

    /**
     * Initializes an unsaved local instance of . To bind to an existing appointment, use Appointment.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService instance to which this appointmtnt is bound.
     */
    constructor(svc: ExchangeService);
    /**
     * @internal Initializes a new instance of Appointment.
     *
     * @param   {ItemAttachment}  parentAttachment   Parent attachment.
     * @param   {boolean}         isNew              If true, attachment is new.
     */
    constructor(parentAttachment: ItemAttachment, isNew: boolean);
    /**@internal dummy to avoid TypeScript typef Appointment !== typeof Item error*/
    constructor(parentAttachment: ItemAttachment);
    constructor(svcOrAttachment: ExchangeService | ItemAttachment, isNew: boolean = false) {
        super(svcOrAttachment);
        if (svcOrAttachment instanceof ItemAttachment) { //todo:fix -can not user instanceof with exchangeservice, creates circular loop with ewsutility
            let parentAttachment = svcOrAttachment;
            // If we're running against Exchange 2007, we need to explicitly preset
            // the StartTimeZone property since Exchange 2007 will otherwise scope
            // start and end to UTC.
            if (parentAttachment.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
                if (isNew) {
                    this.StartTimeZone = parentAttachment.Service.TimeZone;
                }
            }
        }
    }

    /**
     * Accepts the meeting. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation :Promise.
     */
    Accept(sendResponse: boolean): Promise<CalendarActionResults> {
        return this.InternalAccept(false, sendResponse);
    }
    /**
     * Tentatively accepts the meeting. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation :Promise.
     */
    AcceptTentatively(sendResponse: boolean): Promise<CalendarActionResults> {
        return this.InternalAccept(true, sendResponse);
    }

    /**
     * Binds to an existing appointment and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}     service       The service to use to bind to the appointment.
     * @param   {ItemId}              id            The Id of the appointment to bind to.
     * @return  {Promise<Appointment>}   An Appointment instance representing the appointment corresponding to the specified Id :Promise.
     */
    static Bind(service: ExchangeService, id: ItemId): Promise<Appointment>;
    /**
    * Binds to an existing appointment and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}     service       The service to use to bind to the appointment.
     * @param   {ItemId}              id            The Id of the appointment to bind to.
     * @param   {PropertySet}         propertySet   The set of properties to load.     
     * @return  {Promise<Appointment>}   An Appointment instance representing the appointment corresponding to the specified Id :Promise.
     */
    static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<Appointment>;
    static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<Appointment> {
        return service.BindToItem<Appointment>(id, propertySet, Appointment);
    }

    /**
     * Binds to an occurence of an existing appointment and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}  service             The service to use to bind to the appointment.
     * @param   {ItemId}           recurringMasterId   The Id of the recurring master that the index represents an occurrence of.
     * @param   {number}           occurenceIndex      The index of the occurrence.
     * @return  {Promise<Appointment>}                 An Appointment instance representing the appointment occurence corresponding to the specified occurence index :Promise.
     */
    static BindToOccurrence(service: ExchangeService, recurringMasterId: ItemId, occurenceIndex: number): Promise<Appointment>;
    /**
     * Binds to an occurence of an existing appointment and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}  service             The service to use to bind to the appointment.
     * @param   {ItemId}           recurringMasterId   The Id of the recurring master that the index represents an occurrence of.
     * @param   {number}           occurenceIndex      The index of the occurrence.
     * @param   {PropertySet}      propertySet         The set of properties to load.
     * @return  {Promise<Appointment>}                 An Appointment instance representing the appointment occurence corresponding to the specified occurence index :Promise.
     */
    static BindToOccurrence(service: ExchangeService, recurringMasterId: ItemId, occurenceIndex: number, propertySet: PropertySet): Promise<Appointment>;
    static BindToOccurrence(service: ExchangeService, recurringMasterId: ItemId, occurenceIndex: number, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<Appointment> {
        let occurenceId: AppointmentOccurrenceId = new AppointmentOccurrenceId(recurringMasterId.UniqueId, occurenceIndex);
        return Appointment.Bind(
            service,
            occurenceId,
            propertySet);
    }

    /**
     * Binds to the master appointment of a recurring series and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}     service        The service to use to bind to the appointment.
     * @param   {ItemId}              occurrenceId   The Id of one of the occurrences in the series.
     * @return  {Promise<Appointment>}   An Appointment instance representing the master appointment of the recurring series to which the specified occurrence belongs :Promise.
     */
    static BindToRecurringMaster(service: ExchangeService, occurrenceId: ItemId): Promise<Appointment>;
    /**
     * Binds to the master appointment of a recurring series and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}     service        The service to use to bind to the appointment.
     * @param   {ItemId}              occurrenceId   The Id of one of the occurrences in the series.
     * @param   {PropertySet}         propertySet    The set of properties to load.
     * @return  {Promise<Appointment>}   An Appointment instance representing the master appointment of the recurring series to which the specified occurrence belongs :Promise.
     */
    static BindToRecurringMaster(service: ExchangeService, occurrenceId: ItemId, propertySet: PropertySet): Promise<Appointment>;
    static BindToRecurringMaster(service: ExchangeService, occurrenceId: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<Appointment> {
        let recurringMasterId: RecurringAppointmentMasterId = new RecurringAppointmentMasterId(occurrenceId.UniqueId);
        return Appointment.Bind(
            service,
            recurringMasterId,
            propertySet);
    }

    /**
     * Cancels the meeting and sends cancellation messages to all attendees. Calling this method results in a call to EWS.
     *
     * @return  {Promise<CalendarActionResults>}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation :Promise.
     */
    CancelMeeting(): Promise<CalendarActionResults>;
    /**
     * Cancels the meeting and sends cancellation messages to all attendees. Calling this method results in a call to EWS.
     *
     * @param   {string}   cancellationMessageText   Cancellation message text sent to all attendees.
     * @return  {Promise<CalendarActionResults>}     A CalendarActionResults object containing the various items that were created or modified as a results of this operation :Promise.
     */
    CancelMeeting(cancellationMessageText: string): Promise<CalendarActionResults>;
    CancelMeeting(cancellationMessageText?: string): Promise<CalendarActionResults> {
        if (arguments.length === 0) {
            return this.CreateCancelMeetingMessage().SendAndSaveCopy();
        }

        let cancelMsg: CancelMeetingMessage = this.CreateCancelMeetingMessage();
        cancelMsg.Body = new MessageBody(cancellationMessageText); //todo:fix - cant use implicit operator of c#, using explicit. Assumed HTML body used in c# implicit conversion
        return cancelMsg.SendAndSaveCopy();
    }

    /**
     * Creates a local meeting acceptance message that can be customized and sent.
     *
     * @param   {boolean}   tentative   Specifies whether the meeting will be tentatively accepted.
     * @return  {AcceptMeetingInvitationMessage}  An AcceptMeetingInvitationMessage representing the meeting acceptance message.
     */
    CreateAcceptMessage(tentative: boolean): AcceptMeetingInvitationMessage {
        return new AcceptMeetingInvitationMessage(<any><any>this, tentative);
    }
    /**
     * Creates a local meeting cancellation message that can be customized and sent.
     *
     * @return  {CancelMeetingMessage}    A CancelMeetingMessage representing the meeting cancellation message.
     */
    CreateCancelMeetingMessage(): CancelMeetingMessage {
        return new CancelMeetingMessage(<any><any>this);
    }
    /**
     * Creates a local meeting declination message that can be customized and sent.
     *
     * @return  {DeclineMeetingInvitationMessage}      A DeclineMeetingInvitation representing the meeting declination message.
     */
    CreateDeclineMessage(): DeclineMeetingInvitationMessage {
        return new DeclineMeetingInvitationMessage(<any><any>this);
    }
    /**
     * Creates a forward message from this appointment.
     *
     * @return  {ResponseMessage} A ResponseMessage representing the forward response that can subsequently be modified and sent.
     */
    CreateForward(): ResponseMessage {
        this.ThrowIfThisIsNew();

        return new ResponseMessage(<any><any>this, ResponseMessageType.Forward);
    }

    /**
     * Creates a reply response to the organizer and/or attendees of the meeting.
     *
     * @param   {boolean}   replyAll   Indicates whether the reply should go to the organizer only or to all the attendees.
     * @return  {ResponseMessage} A ResponseMessage representing the reply response that can subsequently be modified and sent.
     */
    CreateReply(replyAll: boolean): ResponseMessage {
        this.ThrowIfThisIsNew();

        return new ResponseMessage(
            <any><any>this,
            replyAll ? ResponseMessageType.ReplyAll : ResponseMessageType.Reply);
    }

    /**
     * Declines the meeting invitation. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}   A CalendarActionResults object containing the various items that were created or modified as aresults of this operation :Promise.
     */
    Decline(sendResponse: boolean): Promise<CalendarActionResults> {
        let decline: DeclineMeetingInvitationMessage = this.CreateDeclineMessage();

        if (sendResponse) {
            return decline.SendAndSaveCopy();
        }
        else {
            return decline.Save();
        }
    }

    /** ## internal - do not use on Appointment class */
    Delete(deleteMode: DeleteMode, suppressReadReceipts?: boolean): Promise<void> //info: signature added to implement workaround @github #52
    /**
     * Deletes this appointment. Calling this method results in a call to EWS.
     *
     * @param   {DeleteMode}   deleteMode              The deletion mode.
     * @param   {SendCancellationsMode}   sendCancellationsMode   Specifies if and how cancellations should be sent if this appointment is a meeting.
     */
    Delete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode): Promise<void>; //info: signature added to implement workaround @github #52 
    Delete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode | any): Promise<void> {
        return this.InternalDelete(
            deleteMode,
            sendCancellationsMode,
            null);
    }

    /**
     * Forwards the appointment. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}     bodyPrefix     The prefix to prepend to the original body of the message.
     * @param   {EmailAddress[]}  toRecipients   The recipients to forward the appointment to.
     */
    Forward(bodyPrefix: MessageBody, toRecipients: EmailAddress[]): void;
    /**
     * Forwards the appointment. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}     bodyPrefix     The prefix to prepend to the original body of the message.
     * @param   {EmailAddress[]}  ...toRecipients   The recipients to forward the appointment to.
     */
    Forward(bodyPrefix: MessageBody, ...toRecipients: EmailAddress[]): void;
    Forward(bodyPrefix: MessageBody, _toRecipients: EmailAddress | EmailAddress[]): Promise<void> {
        let responseMessage: ResponseMessage = this.CreateForward();
        let toRecipients: EmailAddress[] = []
        responseMessage.BodyPrefix = bodyPrefix;
        if (ArrayHelper.isArray(_toRecipients)) {
            toRecipients = _toRecipients;
        }
        else {
            for (var _i = 1; _i < arguments.length; _i++) {
                toRecipients[_i - 1] = arguments[_i];
            }
        }

        responseMessage.ToRecipients.AddRange(toRecipients);

        return responseMessage.SendAndSaveCopy();
    }

    /**
     * @internal Determines whether properties defined with ScopedDateTimePropertyDefinition require custom time zone scoping.
     *
     * @return  {boolean}      true if this item type requires custom scoping for scoped date/time properties; otherwise, false.
     */
    GetIsCustomDateTimeScopingRequired(): boolean {
        return true;
    }

    /**
     * @internal Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}   isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}                       true if a time zone SOAP header should be emitted; otherwise, false.
     */
    GetIsTimeZoneHeaderRequired(isUpdateOperation: boolean): boolean {
        if (isUpdateOperation) {
            return false;
        }
        else {
            let isStartTimeZoneSetOrUpdated: boolean = this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.StartTimeZone);
            let isEndTimeZoneSetOrUpdated: boolean = this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.EndTimeZone);

            if (isStartTimeZoneSetOrUpdated && isEndTimeZoneSetOrUpdated) {
                // If both StartTimeZone and EndTimeZone have been set or updated and are the same as the service's
                // time zone, we emit the time zone header and StartTimeZone and EndTimeZone are not emitted.
                let startTimeZone: IOutParam<TimeZoneInfo> = { outValue: null };
                let endTimeZone: IOutParam<TimeZoneInfo> = { outValue: null };;

                this.PropertyBag.TryGetPropertyAs<TimeZoneInfo>(Schemas.AppointmentSchema.StartTimeZone, startTimeZone);
                this.PropertyBag.TryGetPropertyAs<TimeZoneInfo>(Schemas.AppointmentSchema.EndTimeZone, endTimeZone);

                return startTimeZone.outValue == this.Service.TimeZone || endTimeZone.outValue == this.Service.TimeZone;
            }
            else {
                return true;
            }
        }
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.AppointmentSchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.CalendarItem;
    }

    /**
     * @internal Accepts the meeting.
     *
     * @param   {boolean}   tentative      True if tentative accept.
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}    A CalendarActionResults object containing the various items that were created or modified as aresults of this operation :Promise.
     */
    InternalAccept(tentative: boolean, sendResponse: boolean): Promise<CalendarActionResults> {
        let accept: AcceptMeetingInvitationMessage = this.CreateAcceptMessage(tentative);

        if (sendResponse) {
            return accept.SendAndSaveCopy();
        }
        else {
            return accept.Save();
        }
    }

    /**
     * Replies to the organizer and/or the attendees of the meeting. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}     bodyPrefix   The prefix to prepend to the body of the meeting.
     * @param   {boolean}         replyAll     Indicates whether the reply should go to the organizer only or to all the attendees.
     */
    Reply(bodyPrefix: MessageBody, replyAll: boolean): Promise<void> {
        let responseMessage: ResponseMessage = this.CreateReply(replyAll);

        responseMessage.BodyPrefix = bodyPrefix;

        return responseMessage.SendAndSaveCopy();
    }

    /**
     * Saves this appointment in the Calendar folder. Calling this method results in at least one call to EWS. Mutliple calls to EWS might be made if attachments have been added.
     * ### sendInvitationsMode not optional, see github issue #52
     *
     * @param   {SendInvitationsMode}   sendInvitationsMode   *not Optional* Specifies if and how invitations should be sent if this appointment is a meeting.
     */
    Save(sendInvitationsMode?: SendInvitationsMode): Promise<void>; //info: optional sendInvitationsMode to implement workaround @github #52 
    /**
     * Saves this appointment in the specified folder. Calling this method results in at least one call to EWS. Mutliple calls to EWS might be made if attachments have been added.
     * ### sendInvitationsMode not optional, see github issue #52
     *
     * @param   {WellKnownFolderName}   destinationFolderName   The name of the folder in which to save this appointment.
     * @param   {SendInvitationsMode}   sendInvitationsMode     *not Optional* Specifies if and how invitations should be sent if this appointment is a meeting.
     */
    Save(destinationFolderName: WellKnownFolderName, sendInvitationsMode?: SendInvitationsMode): Promise<void>; //info: optional sendInvitationsMode to implement workaround @github #52 
    /**
     * Saves this appointment in the specified folder. Calling this method results in at least one call to EWS. Mutliple calls to EWS might be made if attachments have been added.
     * ### sendInvitationsMode not optional, see github issue #52
     *
     * @param   {FolderId}                destinationFolderId   The Id of the folder in which to save this appointment.
     * @param   {SendInvitationsMode}     sendInvitationsMode   *not Optional* Specifies if and how invitations should be sent if this appointment is a meeting.
     */
    Save(destinationFolderId: FolderId, sendInvitationsMode?: SendInvitationsMode): Promise<void>; //info: optional sendInvitationsMode to implement workaround @github #52 
    Save(destinationFolderNameOrIdOrSendInvitationMode: FolderId | WellKnownFolderName | SendInvitationsMode,
        sendInvitationsMode?: SendInvitationsMode): Promise<void> {

        let argsLength = arguments.length;
        if (argsLength < 1 || argsLength > 2) {
            throw new Error("Appointment.ts - Save : Invalid number of arguments");
        }
        let simode = sendInvitationsMode;
        if (argsLength === 1) {
            simode = <SendInvitationsMode>destinationFolderNameOrIdOrSendInvitationMode;
            return this.InternalCreate(
                null,
                null,
                simode);
        }
        let destinationFolderId: FolderId = <FolderId>destinationFolderNameOrIdOrSendInvitationMode;
        if (argsLength === 2) {
            if (typeof destinationFolderNameOrIdOrSendInvitationMode === "number") {
                destinationFolderId = new FolderId(<WellKnownFolderName>destinationFolderNameOrIdOrSendInvitationMode);
            }
            return this.InternalCreate(
                destinationFolderId,
                null,
                sendInvitationsMode);
        }
    }

    /** ## internal - do not use on Appointment class */
    Update(conflictResolutionMode: ConflictResolutionMode): Promise<void>; //info: added signature to implement workaround @github #52 
    /**
     * Applies the local changes that have been made to this appointment. Calling this method results in at least one call to EWS. Mutliple calls to EWS might be made if attachments have been added or removed.
     * ### sendInvitationsOrCancellationsMode not optional, see github issue #52
     *
     * @param   {ConflictResolutionMode}   conflictResolutionMode               Specifies how conflicts should be resolved.
     * @param   {SendInvitationsOrCancellationsMode}   sendInvitationsOrCancellationsMode   Specifies if and how invitations or cancellations should be sent if this appointment is a meeting.
     */
    Update(conflictResolutionMode: ConflictResolutionMode, sendInvitationsOrCancellationsMode?: SendInvitationsOrCancellationsMode): Promise<void>;
    Update(conflictResolutionMode: ConflictResolutionMode, sendInvitationsOrCancellationsMode?: SendInvitationsOrCancellationsMode): Promise<void> {
        return <any>this.InternalUpdate(
            null,
            conflictResolutionMode,
            null,
            sendInvitationsOrCancellationsMode);
    }

    /**
     * @internal Validates this instance.
     *
     */
    Validate(): void {
        super.Validate();

        //  Make sure that if we're on the Exchange2007_SP1 schema version, if any of the following
        //  properties are set or updated:
        //      o   Start
        //      o   End
        //      o   IsAllDayEvent
        //      o   Recurrence
        //  ... then, we must send the MeetingTimeZone element (which is generated from StartTimeZone for
        //  Exchange2007_SP1 requests (see StartTimeZonePropertyDefinition.cs).  If the StartTimeZone isn't
        //  in the property bag, then throw, because clients must supply the proper time zone - either by
        //  loading it from a currently-existing appointment, or by setting it directly.  Otherwise, to dirty
        //  the StartTimeZone property, we just set it to its current value.
        if ((this.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) &&
            !this.Service.Exchange2007CompatibilityMode) {
            if (this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.Start) ||
                this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.End) ||
                this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.IsAllDayEvent) ||
                this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.Recurrence)) {
                //  If the property isn't in the property bag, throw....
                if (!this.PropertyBag.Contains(Schemas.AppointmentSchema.StartTimeZone)) {
                    throw new ServiceLocalException(Strings.StartTimeZoneRequired);
                }

                //  Otherwise, set the time zone to its current value to force it to be sent with the request.
                this.StartTimeZone = this.StartTimeZone;
            }
        }
    }
}

/**
 * Represents a **contact**. Properties available on contacts are defined in the *ContactSchema* class.
 * 
 */
export class Contact extends Item {

    /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
    public static get Attachable(): boolean { return (<any>this).name === "Contact"; };

    private static ContactPictureName: string = "ContactPicture.jpg";

    /**
     * Gets or set the name under which this contact is filed as. FileAs can be manually set or can be automatically calculated based on the value of the FileAsMapping property.
     *
     */
    get FileAs(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.FileAs);
    }
    set FileAs(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.FileAs, value);
    }

    /**
     * Gets or sets a value indicating how the FileAs property should be automatically calculated.
     * 
     */
    get FileAsMapping(): FileAsMapping {
        return <FileAsMapping>this.PropertyBag._getItem(Schemas.ContactSchema.FileAsMapping);
    }
    set FileAsMapping(value: FileAsMapping) {
        this.PropertyBag._setItem(Schemas.ContactSchema.FileAsMapping, value);
    }

    /**
     * Gets or sets the display name of the contact.
     * 
     */
    get DisplayName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.DisplayName);
    }
    set DisplayName(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.DisplayName, value);
    }

    /**
     * Gets or sets the given name of the contact.
     * 
     */
    get GivenName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.GivenName);
    }
    set GivenName(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.GivenName, value);
    }

    /**
     * Gets or sets the initials of the contact.
     * 
     */
    get Initials(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.Initials);
    }
    set Initials(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Initials, value);
    }

    /**
     * Gets or sets the middle mame of the contact.
     * 
     */
    get MiddleName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.MiddleName);
    }
    set MiddleName(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.MiddleName, value);
    }

    /**
     * Gets or sets the nick name of the contact.
     * 
     */
    get NickName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.NickName);
    }
    set NickName(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.NickName, value);
    }

    /**
     * Gets the complete name of the contact.
     * 
     */
    get CompleteName(): CompleteName {
        return <CompleteName>this.PropertyBag._getItem(Schemas.ContactSchema.CompleteName);
    }

    /**
     * Gets or sets the compnay name of the contact.
     * 
     */
    get CompanyName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.CompanyName);
    }
    set CompanyName(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.CompanyName, value);
    }

    /**
     * Gets an indexed list of e-mail addresses for the contact. For example, to set the first e-mail address, 
     * use the following syntax: EmailAddresses[EmailAddressKey.EmailAddress1] = "john.doe@contoso.com"
     * 
     */
    get EmailAddresses(): EmailAddressDictionary {
        return <EmailAddressDictionary>this.PropertyBag._getItem(Schemas.ContactSchema.EmailAddresses);
    }

    /**
     * Gets an indexed list of physical addresses for the contact. For example, to set the business address,
     * use the following syntax: PhysicalAddresses[PhysicalAddressKey.Business] = new PhysicalAddressEntry()
     * 
     */
    get PhysicalAddresses(): PhysicalAddressDictionary {
        return <PhysicalAddressDictionary>this.PropertyBag._getItem(Schemas.ContactSchema.PhysicalAddresses);
    }

    /**
     * Gets an indexed list of phone numbers for the contact. For example, to set the home phone number,
     * use the following syntax: PhoneNumbers[PhoneNumberKey.HomePhone] = "phone number"
     * 
     */
    get PhoneNumbers(): PhoneNumberDictionary {
        return <PhoneNumberDictionary>this.PropertyBag._getItem(Schemas.ContactSchema.PhoneNumbers);
    }

    /**
     * Gets or sets the contact's assistant name.
     * 
     */
    get AssistantName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.AssistantName);
    }
    set AssistantName(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.AssistantName, value);
    }

    /**
     * Gets or sets the birthday of the contact.
     * 
     */
    get Birthday(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ContactSchema.Birthday);
    }
    set Birthday(value: DateTime) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Birthday, value);
    }

    /**
     * Gets or sets the business home page of the contact.
     * 
     */
    get BusinessHomePage(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.BusinessHomePage);
    }
    set BusinessHomePage(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.BusinessHomePage, value);
    }

    /**
     * Gets or sets a list of children for the contact.
     * 
     */
    get Children(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.ContactSchema.Children);
    }
    set Children(value: StringList) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Children, value);
    }

    /**
     * Gets or sets a list of companies for the contact.
     * 
     */
    get Companies(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.ContactSchema.Companies);
    }
    set Companies(value: StringList) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Companies, value);
    }

    /**
     * Gets the source of the contact.
     * 
     */
    get ContactSource(): ContactSource {
        return <ContactSource>this.PropertyBag._getItem(Schemas.ContactSchema.ContactSource);
    }

    /**
     * Gets or sets the department of the contact.
     * 
     */
    get Department(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.Department);
    }
    set Department(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Department, value);
    }

    /**
     * Gets or sets the generation of the contact.
     * 
     */
    get Generation(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.Generation);
    }
    set Generation(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Generation, value);
    }

    /**
     * Gets an indexed list of Instant Messaging addresses for the contact. 
     * For example, to set the first IM address, use the following syntax: ImAddresses[ImAddressKey.ImAddress1] = "john.doe@contoso.com"
     * 
     */
    get ImAddresses(): ImAddressDictionary {
        return <ImAddressDictionary>this.PropertyBag._getItem(Schemas.ContactSchema.ImAddresses);
    }

    /**
     * Gets or sets the contact's job title.
     * 
     */
    get JobTitle(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.JobTitle);
    }
    set JobTitle(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.JobTitle, value);
    }

    /**
     * Gets or sets the name of the contact's manager.
     * 
     */
    get Manager(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.Manager);
    }
    set Manager(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Manager, value);
    }

    /**
     * Gets or sets the mileage for the contact.
     * 
     */
    get Mileage(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.Mileage);
    }
    set Mileage(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Mileage, value);
    }

    /**
     * Gets or sets the location of the contact's office.
     * 
     */
    get OfficeLocation(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.OfficeLocation);
    }
    set OfficeLocation(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.OfficeLocation, value);
    }

    /**
     * Gets or sets the index of the contact's postal address. When set, PostalAddressIndex refers to an entry in the PhysicalAddresses indexed list.
     * 
     */
    get PostalAddressIndex(): PhysicalAddressIndex {
        return <PhysicalAddressIndex>this.PropertyBag._getItem(Schemas.ContactSchema.PostalAddressIndex);
    }
    set PostalAddressIndex(value: PhysicalAddressIndex) {
        this.PropertyBag._setItem(Schemas.ContactSchema.PostalAddressIndex, value);
    }

    /**
     * Gets or sets the contact's profession.
     * 
     */
    get Profession(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.Profession);
    }
    set Profession(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Profession, value);
    }

    /**
     * Gets or sets the name of the contact's spouse.
     * 
     */
    get SpouseName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.SpouseName);
    }
    set SpouseName(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.SpouseName, value);
    }

    /**
     * Gets or sets the surname of the contact.
     * 
     */
    get Surname(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.Surname);
    }
    set Surname(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.Surname, value);
    }

    /**
     * Gets or sets the date of the contact's wedding anniversary.
     * 
     */
    get WeddingAnniversary(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ContactSchema.WeddingAnniversary);
    }
    set WeddingAnniversary(value: DateTime) {
        this.PropertyBag._setItem(Schemas.ContactSchema.WeddingAnniversary, value);
    }

    /**
     * Gets a value indicating whether this contact has a picture associated with it.
     * 
     */
    get HasPicture(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ContactSchema.HasPicture);
    }

    /**
     * Gets the full phonetic name from the directory
     * 
     */
    get PhoneticFullName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.PhoneticFullName);
    }

    /**
     * Gets the phonetic first name from the directory
     * 
     */
    get PhoneticFirstName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.PhoneticFirstName);
    }

    /**
     * Gets the phonetic last name from the directory
     * 
     */
    get PhoneticLastName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.PhoneticLastName);
    }

    /**
     * Gets the Alias from the directory
     * 
     */
    get Alias(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.Alias);
    }

    /**
     * Get the Notes from the directory
     * 
     */
    get Notes(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.Notes);
    }

    /**
     * Gets the Photo from the directory **Unstable: needs testing**
     * 
     */
    get DirectoryPhoto(): number[] {
        return <number[]>this.PropertyBag._getItem(Schemas.ContactSchema.Photo);
    }

    /**
     * Gets the User SMIME certificate from the directory **Unstable: needs testing**
     * //ref: cant use bytearray, using base64 decoded string instead -  number[][]
     * 
     */
    get UserSMIMECertificate(): string[] {
        var byteArrayArray: ByteArrayArray = <ByteArrayArray>this.PropertyBag._getItem(Schemas.ContactSchema.UserSMIMECertificate);
        return byteArrayArray.Content;
    }

    /**
     * Gets the MSExchange certificate from the directory **Unstable: needs testing**
     * //ref: cant use bytearray, using base64 decoded string instead -  number[][]
     * 
     */
    get MSExchangeCertificate(): string[] {
        var byteArrayArray: ByteArrayArray = <ByteArrayArray>this.PropertyBag._getItem(Schemas.ContactSchema.MSExchangeCertificate);
        return byteArrayArray.Content;
    }

    /**
     * Gets the DirectoryID as Guid or DN string
     * 
     */
    get DirectoryId(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.DirectoryId);
    }

    /**
     * Gets the manager mailbox information
     * 
     */
    get ManagerMailbox(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.ContactSchema.ManagerMailbox);
    }

    /**
     * Get the direct reports mailbox information
     * 
     */
    get DirectReports(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.ContactSchema.DirectReports);
    }

    /**
     * Initializes an unsaved local instance of . To bind to an existing contact, use Contact.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the contact will be bound.
     */
    constructor(service: ExchangeService);
    /**
     * @internal Initializes a new instance of the **Contact** class.
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    constructor(serviceOrParentAttachment: ExchangeService | ItemAttachment) {
        super(serviceOrParentAttachment instanceof ItemAttachment ? serviceOrParentAttachment.Service : <ExchangeService>serviceOrParentAttachment);//todo:fix -can not user instanceof with exchangeservice, creates circular loop with ewsutility 
    }

    /**
     * Binds to an existing contact and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service         The service to use to bind to the contact.
     * @param   {ItemId}            id              The Id of the contact to bind to.
     * @return  {Promise<Contact>}                 A Contact instance representing the contact corresponding to the specified Id :Promise.
     */
    static Bind(service: ExchangeService, id: ItemId): Promise<Contact>;
    /**
     * Binds to an existing contact and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service         The service to use to bind to the contact.
     * @param   {ItemId}            id              The Id of the contact to bind to.
     * @param   {PropertySet}       propertySet     The set of properties to load.
     * @return  {Promise<Contact>}                 A Contact instance representing the contact corresponding to the specified Id :Promise.
     */
    static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<Contact>;
    // Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<Contact> { //removed
    //     return Contact.Bind(service, id, propertySet);
    // }
    static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<Contact> {
        return service.BindToItem<Contact>(id, propertySet, Contact);
    }

    /**
     * Retrieves the file attachment that holds the contact's picture. **Unstable: needs testing**
     *
     * @return  {FileAttachment}      The file attachment that holds the contact's picture.
     */
    GetContactPictureAttachment(): FileAttachment {
        EwsUtilities.ValidateMethodVersion(this.Service, ExchangeVersion.Exchange2010, "GetContactPictureAttachment");

        if (!this.PropertyBag.IsPropertyLoaded(Schemas.ContactSchema.Attachments)) {
            throw new PropertyException(Strings.AttachmentCollectionNotLoaded);
        }

        for (var attachment of this.Attachments.Items) {
            //todo: implement typecasting
            var fileAttachment = <FileAttachment>attachment;
            if (fileAttachment.IsContactPhoto) {
                return fileAttachment;
            }
        }
        return null;
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.ContactSchema.Instance; }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.Contact; }

    /**
     * Removes the picture from local attachment collection.     *
     */
    private InternalRemoveContactPicture(): void {
        // Iterates in reverse order to remove file attachments that have IsContactPhoto set to true.
        for (var index = this.Attachments.Count - 1; index >= 0; index--) {
            //todo: implement safe typecasting
            var fileAttachment: FileAttachment = <FileAttachment>this.Attachments._getItem(index);
            if (fileAttachment != null) {
                if (fileAttachment.IsContactPhoto) {
                    this.Attachments.Remove(fileAttachment);
                }
            }
        }
    }

    /**
     * Removes the contact's picture.     *
     */
    RemoveContactPicture(): void {
        EwsUtilities.ValidateMethodVersion(this.Service, ExchangeVersion.Exchange2010, "RemoveContactPicture");

        if (!this.PropertyBag.IsPropertyLoaded(Schemas.ContactSchema.Attachments)) {
            throw new PropertyException(Strings.AttachmentCollectionNotLoaded);
        }

        this.InternalRemoveContactPicture();
    }
    //ref: //todo: Not Implemented
    //SetContactPicture(contentStream: any /*System.IO.Stream*/): any { throw new Error("Contact.ts - SetContactPicture : Not implemented."); }
    //SetContactPicture(content: number[] /*System.Byte[]*/): any { throw new Error("Contact.ts - SetContactPicture : Not implemented."); }
    //SetContactPicture(fileName: string): any { throw new Error("Contact.ts - SetContactPicture : Not implemented."); }
    /**
     * Sets the contact's picture using the base64 content of file.
     * 
     * @param   {string}    base64Content       base64 content of picture attachment.
     * @param   {string}    attachmentName      name of the picture attachment.
     * 
     */
    SetContactPicture(base64Content: string, attachmentName: string): void {
        EwsUtilities.ValidateMethodVersion(this.Service, ExchangeVersion.Exchange2010, "SetContactPicture");

        this.InternalRemoveContactPicture();
        let fileAttachment: FileAttachment = this.Attachments.AddFileAttachment(attachmentName, base64Content);
        fileAttachment.IsContactPhoto = true;
    }

    /**
     * @internal Validates this instance.     * 
     */
    Validate(): void {
        super.Validate();

        var fileAsMapping: IOutParam<any> = { outValue: null };
        if (this.TryGetProperty(Schemas.ContactSchema.FileAsMapping, fileAsMapping)) {
            // FileAsMapping is extended by 5 new values in 2010 mode. Validate that they are used according the version.
            EwsUtilities.ValidateEnumVersionValue(FileAsMapping, fileAsMapping.outValue, this.Service.RequestedServerVersion, "FileAsMapping");
        }
    }
}

/**
 * Represents a Contact Group. Properties available on contact groups are defined in the ContactGroupSchema class.
 */
export class ContactGroup extends Item {

    /**
     * Gets the name under which this contact group is filed as.
     * 
     * [RequiredServerVersion(ExchangeVersion.Exchange2010)]
     */
    get FileAs(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.FileAs)
    }

    /**
     * Gets or sets the display name of the contact group.
     */
    get DisplayName(): string {
        return <string>this.PropertyBag._getItem(Schemas.ContactSchema.DisplayName);
    }
    set DisplayName(value: string) {
        this.PropertyBag._setItem(Schemas.ContactSchema.DisplayName, value);
    }

    /**
     * Gets the members of the contact group.
     * 
     * [RequiredServerVersion(ExchangeVersion.Exchange2010)]
     */
    get Members(): GroupMemberCollection {
        return <GroupMemberCollection>this.PropertyBag._getItem(Schemas.ContactGroupSchema.Members);
    }

    /**
     * Initializes an unsaved local instance of the **ContactGroup** class.
     *
     * @param   {ExchangeService}   service   EWS service to which this object belongs.
     */
    constructor(service: ExchangeService);
    /**
     * @internal Initializes an unsaved local instance of the **ContactGroup** class.
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    constructor(serviceOrParentAttachment: ExchangeService | ItemAttachment) {
        super(serviceOrParentAttachment);
    }

    /**
     * Binds to an existing contact group and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the contact group.
     * @param   {ItemId}            id            The Id of the contact group to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<ContactGroup>}    A ContactGroup instance representing the contact group corresponding to the specified Id    :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<ContactGroup>;
    /**
     * Binds to an existing contact group and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the contact group.
     * @param   {ItemId}            id            The Id of the contact group to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<ContactGroup>}    A ContactGroup instance representing the contact group corresponding to the specified Id    :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId): Promise<ContactGroup>;
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<ContactGroup> {
        return service.BindToItem<ContactGroup>(id, propertySet, ContactGroup);
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.ContactGroupSchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.DistributionList;
    }

    /**
     *  @internal Sets the subject.
     *
     * @param   {string}   subject   The subject.
     */
    SetSubject(subject: string): void {
        // Set is disabled in client API even though it is implemented in protocol for Item.Subject.
        // Setting Subject out of sync with DisplayName breaks interop with OLK.
        throw new ServiceObjectPropertyException(Strings.PropertyIsReadOnly, Schemas.ContactGroupSchema.Subject);
    }
}

/**
 * Represents an **e-mail message**. Properties available on e-mail messages are defined in the *EmailMessageSchema* class.
 *
 */
export class EmailMessage extends Item {

    /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
    public static get Attachable(): boolean { return (<any>this).name === "EmailMessage"; };

    /**
     * Gets the list of To recipients for the e-mail message.
     *
     */
    get ToRecipients(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ToRecipients);
    }

    /**
     * Gets the list of Bcc recipients for the e-mail message.
     *
     */
    get BccRecipients(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.BccRecipients);
    }

    /**
     * Gets the list of Cc recipients for the e-mail message.
     *
     */
    get CcRecipients(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.CcRecipients);
    }

    /**
     * Gets the conversation topic of the e-mail message.
     *
     */
    get ConversationTopic(): string {
        return <string>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ConversationTopic);
    }

    /**
     * Gets the conversation index of the e-mail message.
     *
     */
    get ConversationIndex(): number[] {
        return <number[]>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ConversationIndex);
    }

    /**
     * Gets or sets the "on behalf" sender of the e-mail message.
     *
     */
    get From(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.EmailMessageSchema.From);
    }
    set From(value: EmailAddress) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.From, value);
    }

    /**
     * Gets or sets a value indicating whether this is an associated message.
     *
     */
    get IsAssociated(): boolean {
        return this.IsAssociated;
    }
    set IsAssociated(value: boolean) {
        this.PropertyBag._setItem(Schemas.ItemSchema.IsAssociated, value);
    }

    /**
     * Gets or sets a value indicating whether a read receipt is requested for the e-mail message.
     *
     */
    get IsDeliveryReceiptRequested(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
    }
    set IsDeliveryReceiptRequested(value: boolean) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsDeliveryReceiptRequested, value);
    }

    /**
     * Gets or sets a value indicating whether the e-mail message is read.
     *
     */
    get IsRead(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsRead);
    }
    set IsRead(value: boolean) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsRead, value);
    }

    /**
     * Gets or sets a value indicating whether a read receipt is requested for the e-mail message.
     *
     */
    get IsReadReceiptRequested(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsReadReceiptRequested);
    }
    set IsReadReceiptRequested(value: boolean) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsReadReceiptRequested, value);
    }

    /**
     * Gets or sets a value indicating whether a response is requested for the e-mail message.
     *
     */
    get IsResponseRequested(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsResponseRequested);
    }
    set IsResponseRequested(value: boolean) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsResponseRequested, value);
    }

    /**
     * Gets the Internat Message Id of the e-mail message.
     *
     */
    get InternetMessageId(): string {
        return <string>this.PropertyBag._getItem(Schemas.EmailMessageSchema.InternetMessageId);
    }

    /**
     * Gets or sets the references of the e-mail message.
     *
     */
    get References(): string {
        return <string>this.PropertyBag._getItem(Schemas.EmailMessageSchema.References);
    }
    set References(value: string) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.References, value);
    }

    /**
     * Gets a list of e-mail addresses to which replies should be addressed.
     *
     */
    get ReplyTo(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ReplyTo);
    }

    /**
     * Gets or sets the sender of the e-mail message.
     *
     */
    get Sender(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.EmailMessageSchema.Sender);
    }
    set Sender(value: EmailAddress) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.Sender, value);
    }

    /**
     * Gets the ReceivedBy property of the e-mail message.
     *
     */
    get ReceivedBy(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ReceivedBy);
    }

    /**
     * Gets the ReceivedRepresenting property of the e-mail message.
     *
     */
    get ReceivedRepresenting(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ReceivedRepresenting);
    }

    /**
     * Gets the ApprovalRequestData property of the e-mail message.
     *
     */
    get ApprovalRequestData(): ApprovalRequestData {
        return <ApprovalRequestData>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ApprovalRequestData);
    }

    /**
     * Gets the VotingInformation property of the e-mail message.
     *
     */
    get VotingInformation(): VotingInformation {
        return <VotingInformation>this.PropertyBag._getItem(Schemas.EmailMessageSchema.VotingInformation);
    }

    /**
     * Initializes an unsaved local instance of **EmailMessage**. To bind to an existing e-mail message, use EmailMessage.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the e-mail message will be bound.
     */
    constructor(service: ExchangeService);
    /**
     * @internal Initializes a new instance of the **EmailMessage** class.
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    /**
     * @internal ~~**used for super call, easier to manage, do not use in Actual code. //todo:fix - [ ] remove from d.ts file**~~.
     */
    constructor(serviceOrParentAttachment: ExchangeService | ItemAttachment);
    constructor(serviceOrParentAttachment: ExchangeService | ItemAttachment) {
        super(serviceOrParentAttachment);
    }


    /**
     * Binds to an existing e-mail message and loads its first class properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}         service     The service to use to bind to the e-mail message.
     * @param   {ItemId}                  id          The Id of the e-mail message to bind to.
     * @return  {Promise<EmailMessage>}              An EmailMessage instance representing the e-mail message corresponding to the specified Id :Promise. 
     */
    static Bind(service: ExchangeService, id: ItemId): Promise<EmailMessage>;
    /**
     * Binds to an existing e-mail message and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}         service         The service to use to bind to the e-mail message.
     * @param   {ItemId}                  id              The Id of the e-mail message to bind to.
     * @param   {PropertySet}             propertySet     The set of properties to load.
     * @return  {Promise<EmailMessage>}                  An EmailMessage instance representing the e-mail message corresponding to the specified Id :Promise.
     */
    static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<EmailMessage>;
    static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<EmailMessage> {
        return service.BindToItem<EmailMessage>(id, propertySet, EmailMessage);
    }

    /**
     * Creates a forward response to the message.
     *
     * @return  {ResponseMessage}      A ResponseMessage representing the forward response that can subsequently be modified and sent.
     */
    CreateForward(): ResponseMessage {
        this.ThrowIfThisIsNew();
        return new ResponseMessage(this, ResponseMessageType.Forward);
    }

    /**
     * Creates a reply response to the message.
     *
     * @param   {boolean}             replyAll   Indicates whether the reply should go to all of the original recipients of the message.
     * @return  {ResponseMessage}     A ResponseMessage representing the reply response that can subsequently be modified and sent.
     */
    CreateReply(replyAll: boolean): ResponseMessage {
        this.ThrowIfThisIsNew();
        return new ResponseMessage(
            this,
            replyAll ? ResponseMessageType.ReplyAll : ResponseMessageType.Reply);
    }

    //Forward(bodyPrefix: MessageBody, toRecipients: EmailAddress[]): Promise<void> { throw new Error("EmailMessage.ts - Forward : Not implemented."); }
    //Forward(bodyPrefix: MessageBody, toRecipients: System.Collections.Generic.IEnumerable<T>): Promise<void> { throw new Error("EmailMessage.ts - Forward : Not implemented."); }
    /**
     * Forwards the message. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}   bodyPrefix     The prefix to prepend to the original body of the message.
     * @param   {EmailAddress[]}   toRecipients   The recipients to forward the message to.
     */
    Forward(bodyPrefix: MessageBody, toRecipients: EmailAddress[]): Promise<void> {
        var responseMessage: ResponseMessage = this.CreateForward();

        responseMessage.BodyPrefix = bodyPrefix;
        responseMessage.ToRecipients.AddRange(toRecipients);

        return responseMessage.SendAndSaveCopy();
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.EmailMessageSchema.Instance; }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.Message; }

    /**
     * Send message.
     *
     * @param   {FolderId}            parentFolderId       The parent folder id.
     * @param   {MessageDisposition}  messageDisposition   The message disposition.
     */
    private InternalSend(parentFolderId: FolderId, messageDisposition: MessageDisposition): Promise<void> {
        this.ThrowIfThisIsAttachment();

        if (this.IsNew) {
            if ((this.Attachments.Count == 0) || (messageDisposition == MessageDisposition.SaveOnly)) {
                return this.InternalCreate(
                    parentFolderId,
                    messageDisposition,
                    null);
            }
            else {
                // If the message has attachments, save as a draft (and add attachments) before sending.
                return this.InternalCreate(
                    null,                           // null means use the Drafts folder in the mailbox of the authenticated user.
                    MessageDisposition.SaveOnly,
                    null).then<void>(() => {
                        return this.Service.SendItem(this, parentFolderId);
                    });
            }
        }
        else {
            // Regardless of whether item is dirty or not, if it has unprocessed
            // attachment changes, process them now.

            //debugger; //todo: check - check for attachment save() promise. 
            return Promise.resolve(
                // Validate and save attachments before sending.
                this.HasUnprocessedAttachmentChanges() ? this.Attachments.ValidateAndSave() : void 0)
                .then(() => {
                    if (this.PropertyBag.GetIsUpdateCallNecessary()) {
                        return <any>this.InternalUpdate( //ref: //info: <any> to supress cast error, returning promise is required, this time it is not void but no action is taken on this promise. 
                            parentFolderId,
                            ConflictResolutionMode.AutoResolve,
                            messageDisposition,
                            null);
                    }
                    else {
                        return this.Service.SendItem(this, parentFolderId);
                    }
                });
        }
    }

    /**
     * Replies to the message. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}   bodyPrefix   The prefix to prepend to the original body of the message.
     * @param   {boolean}   replyAll     Indicates whether the reply should be sent to all of the original recipients of the message.
     */
    Reply(bodyPrefix: MessageBody, replyAll: boolean): Promise<void> {
        var responseMessage: ResponseMessage = this.CreateReply(replyAll);

        responseMessage.BodyPrefix = bodyPrefix;

        return responseMessage.SendAndSaveCopy();
    }

    /**
     * Sends this e-mail message. Calling this method results in at least one call to EWS.
     */
    Send(): Promise<void> { return this.InternalSend(null, MessageDisposition.SendOnly); }

    /**
     * Sends this e-mail message and saves a copy of it in the Sent Items folder. SendAndSaveCopy does not work if the message has unsaved attachments. In that case, the message must first be saved and then sent. Calling this method results in a call to EWS.
     *
     */
    SendAndSaveCopy(): Promise<void>;
    /**
     * Sends this e-mail message and saves a copy of it in the specified folder. SendAndSaveCopy does not work if the message has unsaved attachments. In that case, the message must first be saved and then sent. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   destinationFolderName   The name of the folder in which to save the copy.
     */
    SendAndSaveCopy(destinationFolderName: WellKnownFolderName): Promise<void>;
    /**
     * Sends this e-mail message and saves a copy of it in the specified folder. SendAndSaveCopy does not work if the
    message has unsaved attachments. In that case, the message must first be saved and then sent. Calling this method
    results in a call to EWS.
     *
     * @param   {FolderId}   destinationFolderId   The Id of the folder in which to save the copy.
     */
    SendAndSaveCopy(destinationFolderId: FolderId): Promise<void>;
    SendAndSaveCopy(destinationFolderIdOrName?: FolderId | WellKnownFolderName): Promise<void> {
        var destinationFolderId: FolderId = new FolderId(WellKnownFolderName.SentItems);
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            } else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return this.InternalSend(destinationFolderId, MessageDisposition.SendAndSaveCopy);
    }

    /**
     * Suppresses the read receipt on the message. Calling this method results in a call to EWS.
     *
     */
    SuppressReadReceipt(): Promise<void> {
        this.ThrowIfThisIsNew();
        return (new SuppressReadReceipt(this)).InternalCreate(null, null);
    }
}

/**
 * Represents a meeting-related message. Properties available on meeting messages are defined in the MeetingMessageSchema class.
 */
export class MeetingMessage extends EmailMessage {

    /**
     * Gets the Id of the appointment associated with the meeting message.
     */
    get AssociatedAppointmentId(): ItemId {
        return <ItemId>this.PropertyBag._getItem(Schemas.MeetingMessageSchema.AssociatedAppointmentId);
    }

    /**
     * Gets a value indicating whether the meeting message is delegated.
     */
    get IsDelegated(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.MeetingMessageSchema.IsDelegated);
    }

    /**
     * Gets a value indicating whether the meeting message is out of date.
     */
    get IsOutOfDate(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.MeetingMessageSchema.IsOutOfDate);
    }

    /**
     * Gets a value indicating whether the meeting message has been processed by Exchange (i.e. Exchange has noted the arrival of a meeting request and has created the associated meeting item in the calendar).
     */
    get HasBeenProcessed(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.MeetingMessageSchema.HasBeenProcessed);
    }

    /**
     * Gets the isorganizer property for this meeting
     * 
     * @Nullable
     */
    get IsOrganizer(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.MeetingMessageSchema.IsOrganizer);
    }

    /**
     * Gets the type of response the meeting message represents.
     */
    get ResponseType(): MeetingResponseType {
        return <MeetingResponseType>this.PropertyBag._getItem(Schemas.MeetingMessageSchema.ResponseType);
    }

    /**
     * Gets the ICalendar Uid.
     */
    get ICalUid(): string {
        return <string>this.PropertyBag._getItem(Schemas.MeetingMessageSchema.ICalUid);
    }

    /**
     * Gets the ICalendar RecurrenceId.
     * 
     * @Nullable
     */
    get ICalRecurrenceId(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.MeetingMessageSchema.ICalRecurrenceId);
    }

    /**
     * Gets the ICalendar DateTimeStamp.
     */
    get ICalDateTimeStamp(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.MeetingMessageSchema.ICalDateTimeStamp);
    }

    /**
     * @internal Initializes a new instance of the **MeetingMessage** class.
     *
     * @param   {ExchangeService}   service   EWS service to which this object belongs.
     */
    constructor(service: ExchangeService);
    /**
     * @internal Initializes a new instance of the **MeetingMessage** class.
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    /**
     * @internal ~~**used for super call, easier to manage, do not use in Actual code. //todo:fix - [ ] remove from d.ts file**~~.
     */
    constructor(obj: ExchangeService | ItemAttachment)
    constructor(serviceOrParentAttachment: ExchangeService | ItemAttachment) {
        super(serviceOrParentAttachment);
    }

    /**
     * Binds to an existing meeting message and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the meeting message.
     * @param   {ItemId}            id            The Id of the meeting message to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<MeetingMessage>}  A MeetingMessage instance representing the meeting message corresponding to the specified Id    :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<MeetingMessage>;
    /**
     * Binds to an existing meeting message and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the meeting message.
     * @param   {ItemId}            id            The Id of the meeting message to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<MeetingMessage>}  A MeetingMessage instance representing the meeting message corresponding to the specified Id    :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId): Promise<MeetingMessage>;
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<MeetingMessage> {
        return service.BindToItem<MeetingMessage>(id, propertySet, MeetingMessage);
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.MeetingMessageSchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.MeetingMessage;
    }
}

/**
 * Represents a meeting cancellation message. Properties available on meeting messages are defined in the MeetingMessageSchema class.
 */
export class MeetingCancellation extends MeetingMessage {

    /**
     * Gets the start time of the appointment.
     */
    get Start(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.MeetingCancellationSchema.Start);
    }

    /**
     * Gets the end time of the appointment.
     */
    get End(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.MeetingCancellationSchema.End);
    }

    /**
     * Gets the location of this appointment.
     */
    get Location(): string {
        return <string>this.PropertyBag._getItem(Schemas.MeetingCancellationSchema.Location);
    }

    /**
     * Gets the recurrence pattern for this meeting request.
     */
    get Recurrence(): Recurrence {
        return <Recurrence>this.PropertyBag._getItem(Schemas.AppointmentSchema.Recurrence);
    }

    /**
     * Gets the Enhanced location object.
     */
    get EnhancedLocation(): EnhancedLocation {
        return <EnhancedLocation>this.PropertyBag._getItem(Schemas.MeetingCancellationSchema.EnhancedLocation);
    }

    /**
     * @internal Initializes a new instance of the **MeetingCancellation** class.
     *
     * @param   {ExchangeService}   service   EWS service to which this object belongs.
     */
    constructor(service: ExchangeService);
    /**
     * @internal Initializes a new instance of the **MeetingCancellation** class.
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    constructor(serviceOrParentAttachment: ExchangeService | ItemAttachment) {
        super(serviceOrParentAttachment);
    }

    /**
     * Binds to an existing meeting cancellation message and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the meeting cancellation message.
     * @param   {ItemId}            id            The Id of the meeting cancellation message to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<MeetingCancellation>}   A MeetingCancellation instance representing the meeting cancellation message corresponding to the specified Id   :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<MeetingCancellation>;
    /**
     * Binds to an existing meeting cancellation message and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the meeting cancellation message.
     * @param   {ItemId}            id            The Id of the meeting cancellation message to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<MeetingCancellation>}   A MeetingCancellation instance representing the meeting cancellation message corresponding to the specified Id   :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId): Promise<MeetingCancellation>;
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<MeetingCancellation> {
        return service.BindToItem<MeetingCancellation>(id, propertySet, MeetingCancellation);
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.MeetingCancellationSchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.MeetingCancellation;
    }

    /**
     * Removes the meeting associated with the cancellation message from the user's calendar.
     *
     * @return  {Promise<CalendarActionResults>}      A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    RemoveMeetingFromCalendar(): Promise<CalendarActionResults> {
        let removeFromCalendar = new RemoveFromCalendar(this);

        return removeFromCalendar.InternalCreate(null, null).then((items: Item[]) => {
            return new CalendarActionResults(items);
        })
    }
}

/**
 * Represents a meeting request that an attendee can accept or decline. Properties available on meeting requests are defined in the MeetingRequestSchema class.
 */
export class MeetingRequest extends MeetingMessage implements ICalendarActionProvider {

    /**
     * Gets the type of this meeting request.
     */
    get MeetingRequestType(): MeetingRequestType {
        return <MeetingRequestType>this.PropertyBag._getItem(Schemas.MeetingRequestSchema.MeetingRequestType);
    }

    /**
     * Gets the a value representing the intended free/busy status of the meeting.
     */
    get IntendedFreeBusyStatus(): LegacyFreeBusyStatus {
        return <LegacyFreeBusyStatus>this.PropertyBag._getItem(Schemas.MeetingRequestSchema.IntendedFreeBusyStatus);
    }

    /**
     * Gets the change highlights of the meeting request.
     */
    get ChangeHighlights(): ChangeHighlights {
        return <ChangeHighlights>this.PropertyBag._getItem(Schemas.MeetingRequestSchema.ChangeHighlights);
    }

    /**
     * Gets the Enhanced location object.
     */
    get EnhancedLocation(): EnhancedLocation {
        return <EnhancedLocation>this.PropertyBag._getItem(Schemas.MeetingRequestSchema.EnhancedLocation);
    }

    /**
     * Gets the start time of the appointment.
     */
    get Start(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.Start);
    }

    /**
     * Gets the end time of the appointment.
     */
    get End(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.End);
    }

    /**
     * Gets the original start time of this appointment.
     */
    get OriginalStart(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.OriginalStart);
    }

    /**
     * Gets a value indicating whether this appointment is an all day event.
     */
    get IsAllDayEvent(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsAllDayEvent);
    }

    /**
     * Gets a value indicating the free/busy status of the owner of this appointment. 
     */
    get LegacyFreeBusyStatus(): LegacyFreeBusyStatus {
        return <LegacyFreeBusyStatus>this.PropertyBag._getItem(Schemas.AppointmentSchema.LegacyFreeBusyStatus);
    }

    /**
     * Gets the location of this appointment.
     */
    get Location(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.Location);
    }

    /**
     * Gets a text indicating when this appointment occurs. 
     * The text returned by When is localized using the Exchange Server culture or using the culture specified in the PreferredCulture property of the ExchangeService object this appointment is bound to.
     */
    get When(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.When);
    }

    /**
     * Gets a value indicating whether the appointment is a meeting.
     */
    get IsMeeting(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsMeeting);
    }

    /**
     * Gets a value indicating whether the appointment has been cancelled.
     */
    get IsCancelled(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsCancelled);
    }

    /**
     * Gets a value indicating whether the appointment is recurring.
     */
    get IsRecurring(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsRecurring);
    }

    /**
     * Gets a value indicating whether the meeting request has already been sent.
     */
    get MeetingRequestWasSent(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.MeetingRequestWasSent);
    }

    /**
     * Gets a value indicating the type of this appointment.
     */
    get AppointmentType(): AppointmentType {
        return <AppointmentType>this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentType);
    }

    /**
     * Gets a value indicating what was the last response of the user that loaded this meeting.
     */
    get MyResponseType(): MeetingResponseType {
        return <MeetingResponseType>this.PropertyBag._getItem(Schemas.AppointmentSchema.MyResponseType);
    }

    /**
     * Gets the organizer of this meeting.
     */
    get Organizer(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.AppointmentSchema.Organizer);
    }

    /**
     * Gets a list of required attendees for this meeting.
     */
    get RequiredAttendees(): AttendeeCollection {
        return <AttendeeCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.RequiredAttendees);
    }

    /**
     * Gets a list of optional attendeed for this meeting.
     */
    get OptionalAttendees(): AttendeeCollection {
        return <AttendeeCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.OptionalAttendees);
    }

    /**
     * Gets a list of resources for this meeting.
     */
    get Resources(): AttendeeCollection {
        return <AttendeeCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.Resources);
    }

    /**
     * Gets the number of calendar entries that conflict with this appointment in the authenticated user's calendar.
     */
    get ConflictingMeetingCount(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.ConflictingMeetingCount);
    }

    /**
     * Gets the number of calendar entries that are adjacent to this appointment in the authenticated user's calendar.
     */
    get AdjacentMeetingCount(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.AdjacentMeetingCount);
    }

    /**
     * Gets a list of meetings that conflict with this appointment in the authenticated user's calendar.
     */
    get ConflictingMeetings(): ItemCollection<Appointment> {
        return <ItemCollection<Appointment>>this.PropertyBag._getItem(Schemas.AppointmentSchema.ConflictingMeetings);
    }

    /**
     * Gets a list of meetings that are adjucent to this appointment in the authenticated user's calendar.
     */
    get AdjacentMeetings(): ItemCollection<Appointment> {
        return <ItemCollection<Appointment>>this.PropertyBag._getItem(Schemas.AppointmentSchema.AdjacentMeetings);
    }

    /**
     * Gets the duration of this appointment.
     */
    get Duration(): TimeSpan {
        return <TimeSpan>this.PropertyBag._getItem(Schemas.AppointmentSchema.Duration);
    }

    /**
     * Gets the name of the time zone this appointment is defined in.
     */
    get TimeZone(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.TimeZone);
    }

    /**
     * Gets the time when the attendee replied to the meeting request.
     */
    get AppointmentReplyTime(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentReplyTime);
    }

    /**
     * Gets the sequence number of this appointment.
     */
    get AppointmentSequenceNumber(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentSequenceNumber);
    }

    /**
     * Gets the state of this appointment.
     */
    get AppointmentState(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentState);
    }

    /**
     * Gets the recurrence pattern for this meeting request.
     */
    get Recurrence(): Recurrence {
        return <Recurrence>this.PropertyBag._getItem(Schemas.AppointmentSchema.Recurrence);
    }

    /**
     * Gets an OccurrenceInfo identifying the first occurrence of this meeting.
     */
    get FirstOccurrence(): OccurrenceInfo {
        return <OccurrenceInfo>this.PropertyBag._getItem(Schemas.AppointmentSchema.FirstOccurrence);
    }

    /**
     * Gets an OccurrenceInfo identifying the last occurrence of this meeting.
     */
    get LastOccurrence(): OccurrenceInfo {
        return <OccurrenceInfo>this.PropertyBag._getItem(Schemas.AppointmentSchema.LastOccurrence);
    }

    /**
     * Gets a list of modified occurrences for this meeting.
     */
    get ModifiedOccurrences(): OccurrenceInfoCollection {
        return <OccurrenceInfoCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.ModifiedOccurrences);
    }

    /**
     * Gets a list of deleted occurrences for this meeting.
     */
    get DeletedOccurrences(): DeletedOccurrenceInfoCollection {
        return <DeletedOccurrenceInfoCollection>this.PropertyBag._getItem(Schemas.AppointmentSchema.DeletedOccurrences);
    }

    /**
     * Gets time zone of the start property of this meeting request.
     */
    get StartTimeZone(): TimeZoneInfo {
        return <TimeZoneInfo>this.PropertyBag._getItem(Schemas.AppointmentSchema.StartTimeZone);
    }

    /**
     * Gets time zone of the end property of this meeting request.
     */
    get EndTimeZone(): TimeZoneInfo {
        return <TimeZoneInfo>this.PropertyBag._getItem(Schemas.AppointmentSchema.EndTimeZone);
    }

    /**
     * Gets the type of conferencing that will be used during the meeting.
     */
    get ConferenceType(): number {
        return <number>this.PropertyBag._getItem(Schemas.AppointmentSchema.ConferenceType);
    }

    /**
     * Gets a value indicating whether new time proposals are allowed for attendees of this meeting.
     */
    get AllowNewTimeProposal(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.AllowNewTimeProposal);
    }

    /**
     * Gets a value indicating whether this is an online meeting.
     */
    get IsOnlineMeeting(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.AppointmentSchema.IsOnlineMeeting);
    }

    /**
     * Gets the URL of the meeting workspace. A meeting workspace is a shared Web site for planning meetings and tracking results.
     */
    get MeetingWorkspaceUrl(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.MeetingWorkspaceUrl);
    }

    /**
     * Gets the URL of the Microsoft NetShow online meeting.
     */
    get NetShowUrl(): string {
        return <string>this.PropertyBag._getItem(Schemas.AppointmentSchema.NetShowUrl);
    }

    /**
     * @internal Initializes a new instance of the **MeetingRequest** class.
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    /**
     * @internal Initializes a new instance of the **MeetingRequest** class.
     *
     * @param   {ExchangeService}   service   EWS service to which this object belongs.
     */
    constructor(service: ExchangeService);
    constructor(parentAttachmentOrService: any) {
        super(parentAttachmentOrService);
    }

    /**
     * Accepts the meeting. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation    :Promise.
     */
    Accept(sendResponse: boolean): Promise<CalendarActionResults> {
        return this.InternalAccept(false, sendResponse);
    }

    /**
     * Tentatively accepts the meeting. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}       A CalendarActionResults object containing the various items that were created or modified as a results of this operation    :Promise.
     */
    AcceptTentatively(sendResponse: boolean): Promise<CalendarActionResults> {
        return this.InternalAccept(true, sendResponse);
    }

    /**
     * Binds to an existing meeting request and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the meeting request.
     * @param   {ItemId}            id            The Id of the meeting request to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<MeetingRequest>}        A MeetingRequest instance representing the meeting request corresponding to the specified Id  :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<MeetingRequest>;
    /**
     * Binds to an existing meeting request and loads its first class properties.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the meeting request.
     * @param   {ItemId}            id            The Id of the meeting request to bind to.
     * @return  {Promise<MeetingRequest>}        A MeetingRequest instance representing the meeting request corresponding to the specified Id  :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId): Promise<MeetingRequest>;
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<MeetingRequest> {
        return service.BindToItem<MeetingRequest>(id, propertySet, MeetingRequest);
    }

    /**
     * Creates a local meeting acceptance message that can be customized and sent.
     *
     * @param   {boolean}   tentative   Specifies whether the meeting will be tentatively accepted.
     * @return  {AcceptMeetingInvitationMessage}        An AcceptMeetingInvitationMessage representing the meeting acceptance message.
     */
    CreateAcceptMessage(tentative: boolean): AcceptMeetingInvitationMessage {
        return new AcceptMeetingInvitationMessage(this, tentative);
    }

    /**
     * Creates a local meeting declination message that can be customized and sent.
     *
     * @return  {DeclineMeetingInvitationMessage}      A DeclineMeetingInvitation representing the meeting declination message.
     */
    CreateDeclineMessage(): DeclineMeetingInvitationMessage {
        return new DeclineMeetingInvitationMessage(this);
    }

    /**
     * Declines the meeting invitation. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}       A CalendarActionResults object containing the various items that were created or modified as a results of this operation    :Promise.
     */
    Decline(sendResponse: boolean): Promise<CalendarActionResults> {
        let decline: DeclineMeetingInvitationMessage = this.CreateDeclineMessage();

        if (sendResponse) {
            return decline.SendAndSaveCopy();
        }
        else {
            return decline.Save();
        }
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.MeetingRequestSchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.MeetingRequest;
    }

    /**
     * @internal Accepts the meeting.
     *
     * @param   {boolean}   tentative      True if tentative accept.
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}       A CalendarActionResults object containing the various items that were created or modified as a results of this operation    :Promise.
     */
    InternalAccept(tentative: boolean, sendResponse: boolean): Promise<CalendarActionResults> {
        let accept: AcceptMeetingInvitationMessage = this.CreateAcceptMessage(tentative);

        if (sendResponse) {
            return accept.SendAndSaveCopy();
        }
        else {
            return accept.Save();
        }
    }
}

/**
 * Represents a response to a meeting request. Properties available on meeting messages are defined in the MeetingMessageSchema class.
 */
export class MeetingResponse extends MeetingMessage {

    /**
     * Gets the start time of the appointment.
     */
    get Start(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.MeetingResponseSchema.Start);
    }

    /**
     * Gets the end time of the appointment.
     */
    get End(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.MeetingResponseSchema.End);
    }

    /**
     * Gets the location of this appointment.
     */
    get Location(): string {
        return <string>this.PropertyBag._getItem(Schemas.MeetingResponseSchema.Location);
    }

    /**
     * Gets the recurrence pattern for this meeting request.
     */
    get Recurrence(): Recurrence {
        return <Recurrence>this.PropertyBag._getItem(Schemas.AppointmentSchema.Recurrence);
    }

    /**
     * Gets the proposed start time of the appointment.
     */
    get ProposedStart(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.MeetingResponseSchema.ProposedStart);
    }

    /**
     * Gets the proposed end time of the appointment.
     */
    get ProposedEnd(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.MeetingResponseSchema.ProposedEnd);
    }

    /**
     * Gets the Enhanced location object.
     */
    get EnhancedLocation(): EnhancedLocation {
        return <EnhancedLocation>this.PropertyBag._getItem(Schemas.MeetingResponseSchema.EnhancedLocation);
    }

    /**
     * @internal Initializes a new instance of the **MeetingResponse** class.
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    /**
     * @internal Initializes a new instance of the **MeetingResponse** class.
     *
     * @param   {ExchangeService}   service   EWS service to which this object belongs.
     */
    constructor(service: ExchangeService);
    constructor(parentAttachmentOrService: any) {
        super(parentAttachmentOrService);
    }

    /**
     * Binds to an existing meeting response and loads the specified set of properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the meeting response.
     * @param   {ItemId}            id            The Id of the meeting response to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<MeetingResponse>}       A MeetingResponse instance representing the meeting response corresponding to the specified Id    :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<MeetingResponse>;
    /**
     * Binds to an existing meeting response and loads its first class properties. Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the meeting response.
     * @param   {ItemId}            id            The Id of the meeting response to bind to.
     * @return  {Promise<MeetingResponse>}       A MeetingResponse instance representing the meeting response corresponding to the specified Id    :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId): Promise<MeetingResponse>;
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<MeetingResponse> {
        return service.BindToItem<MeetingResponse>(id, propertySet, MeetingResponse);
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.MeetingResponseSchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.MeetingResponse; }
}

/**
 * Represents a post item. Properties available on post items are defined in the PostItemSchema class.
 * 
 * @sealed
 */
export class PostItem extends Item {

    /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
    public static get Attachable(): boolean { return (<any>this).name === "PostItem"; };

    /**
     * Gets the conversation index of the post item.
     */
    get ConversationIndex(): number[] {
        return <number[]>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ConversationIndex);
    }

    /**
     * Gets the conversation topic of the post item.
     */
    get ConversationTopic(): string {
        return <string>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ConversationTopic);
    }

    /**
     * Gets or sets the "on behalf" poster of the post item.
     */
    get From(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.EmailMessageSchema.From);
    }
    set From(value: EmailAddress) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.From, value);
    }

    /**
     * Gets the Internet message Id of the post item.
     */
    get InternetMessageId(): string {
        return <string>this.PropertyBag._getItem(Schemas.EmailMessageSchema.InternetMessageId);
    }

    /**
     * Gets or sets a value indicating whether the post item is read.
     */
    get IsRead(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsRead);
    }
    set IsRead(value: boolean) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsRead, value);
    }

    /**
     * Gets the the date and time when the post item was posted.
     */
    get PostedTime(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.PostItemSchema.PostedTime);
    }

    /**
     * Gets or sets the references of the post item.
     */
    get References(): string {
        return <string>this.PropertyBag._getItem(Schemas.EmailMessageSchema.References);
    }
    set References(value: string) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.References, value);
    }

    /**
     * Gets or sets the sender (poster) of the post item.
     */
    get Sender(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.EmailMessageSchema.Sender);
    }
    set Sender(value: EmailAddress) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.Sender, value);
    }

    /**
     * Initializes an unsaved local instance of **PostItem**. To bind to an existing post item, use PostItem.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the e-mail message will be bound.
     */
    constructor(service: ExchangeService);
    /**
     * @internal Initializes a new instance of the **PostItem** class.
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    constructor(serviceOrParentAttachment: any) {
        super(serviceOrParentAttachment);
    }

    /**
     * Binds to an existing post item and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the post item.
     * @param   {ItemId}            id            The Id of the post item to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<PostItem>}              An PostItem instance representing the post item corresponding to the specified Id  :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<PostItem>;
    /**
     * Binds to an existing post item and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the post item.
     * @param   {ItemId}            id            The Id of the post item to bind to.
     * @return  {Promise<PostItem>}              An PostItem instance representing the post item corresponding to the specified Id  :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId): Promise<PostItem>;
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<PostItem> {
        return service.BindToItem<PostItem>(id, propertySet, PostItem);
    }

    /**
     * Creates a forward response to the post item.
     *
     * @return  {ResponseMessage}      A ResponseMessage representing the forward response that can subsequently be modified and sent.
     */
    CreateForward(): ResponseMessage {
        this.ThrowIfThisIsNew();

        return new ResponseMessage(this, ResponseMessageType.Forward);
    }

    /**
     * Creates a post reply to this post item.
     *
     * @return  {PostReply}      A PostReply that can be modified and saved.
     */
    CreatePostReply(): PostReply {
        this.ThrowIfThisIsNew();

        return new PostReply(this);
    }

    /**
     * Creates a e-mail reply response to the post item.
     *
     * @param   {boolean}   replyAll   Indicates whether the reply should go to everyone involved in the thread.
     * @return  {ResponseMessage}      A ResponseMessage representing the e-mail reply response that can subsequently be modified and sent.
     */
    CreateReply(replyAll: boolean): ResponseMessage {
        this.ThrowIfThisIsNew();

        return new ResponseMessage(
            this,
            replyAll ? ResponseMessageType.ReplyAll : ResponseMessageType.Reply);
    }

    /**
     * Forwards the post item. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}           bodyPrefix     The prefix to prepend to the original body of the post item.
     * @param   {...EmailAddress[]}     toRecipients   The recipients to forward the post item to.
     * @return  {Promise<void>}        :Promise.
     */
    Forward(bodyPrefix: MessageBody, ...toRecipients: EmailAddress[]): Promise<void>;
    /**
     * Forwards the post item. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}       bodyPrefix     The prefix to prepend to the original body of the post item.
     * @param   {EmailAddress[]}    toRecipients   The recipients to forward the post item to.
     * @return  {Promise<void>}    :Promise.
     */
    Forward(bodyPrefix: MessageBody, toRecipients: EmailAddress[]): Promise<void>;
    Forward(bodyPrefix: MessageBody, _toRecipients: EmailAddress[] | EmailAddress): Promise<void> {
        let toRecipients: EmailAddress[] = [];
        if (arguments.length <= 2) {
            if (ArrayHelper.isArray(_toRecipients)) {
                toRecipients = _toRecipients;
            }
            else {
                toRecipients.push(arguments[1]);
            }
        }
        else {
            for (var _i = 1; _i < arguments.length; _i++) {
                toRecipients[_i - 1] = arguments[_i];
            }
        }

        let responseMessage: ResponseMessage = this.CreateForward();

        responseMessage.BodyPrefix = bodyPrefix;
        responseMessage.ToRecipients.AddRange(toRecipients);

        return responseMessage.SendAndSaveCopy();
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.PostItemSchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.PostItem;
    }

    /**
     * Posts a reply to this post item. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}   bodyPrefix   Body prefix.
     * @return  {Promise<void>}    :Promise.
     */
    PostReply(bodyPrefix: MessageBody): Promise<void> {
        let postReply: PostReply = this.CreatePostReply();

        postReply.BodyPrefix = bodyPrefix;

        return <any>postReply.Save();
    }

    /**
     * Replies to the post item. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}   bodyPrefix   The prefix to prepend to the original body of the post item.
     * @param   {boolean}       replyAll     Indicates whether the reply should be sent to everyone involved in the thread.
     * @return  {Promise<void>}    :Promise.
     */
    Reply(bodyPrefix: MessageBody, replyAll: boolean): Promise<void> {
        let responseMessage: ResponseMessage = this.CreateReply(replyAll);

        responseMessage.BodyPrefix = bodyPrefix;

        return responseMessage.SendAndSaveCopy();
    }
}

/**
 * Represents a Task item. Properties available on tasks are defined in the TaskSchema class.
 */
export class Task extends Item {

    /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
    public static get Attachable(): boolean { return (<any>this).name === "Task"; };

    /**
     * @nullable Gets or sets the actual amount of time that is spent on the task.
     */
    get ActualWork(): number {
        return <number>this.PropertyBag._getItem(Schemas.TaskSchema.ActualWork);
    }
    set ActualWork(value: number) {
        this.PropertyBag._setItem(Schemas.TaskSchema.ActualWork, value);
    }

    /**
     * @nullable Gets the date and time the task was assigned.
     */
    get AssignedTime(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.TaskSchema.AssignedTime);
    }

    /**
     * Gets or sets the billing information of the task.
     */
    get BillingInformation(): string {
        return <string>this.PropertyBag._getItem(Schemas.TaskSchema.BillingInformation);
    }
    set BillingInformation(value: string) {
        this.PropertyBag._setItem(Schemas.TaskSchema.BillingInformation, value);
    }

    /**
     * Gets the number of times the task has changed since it was created.
     */
    get ChangeCount(): number {
        return <number>this.PropertyBag._getItem(Schemas.TaskSchema.ChangeCount);
    }

    /**
     * Gets or sets a list of companies associated with the task.
     */
    get Companies(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.TaskSchema.Companies);
    }
    set Companies(value: StringList) {
        this.PropertyBag._setItem(Schemas.TaskSchema.Companies, value);
    }

    /**
     * @nullable Gets or sets the date and time on which the task was completed.
     */
    get CompleteDate(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.TaskSchema.CompleteDate);
    }
    set CompleteDate(value: DateTime) {
        this.PropertyBag._setItem(Schemas.TaskSchema.CompleteDate, value);
    }

    /**
     * Gets or sets a list of contacts associated with the task.
     */
    get Contacts(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.TaskSchema.Contacts);
    }
    set Contacts(value: StringList) {
        this.PropertyBag._setItem(Schemas.TaskSchema.Contacts, value);
    }

    /**
     * Gets the current delegation state of the task.
     */
    get DelegationState(): TaskDelegationState {
        return <TaskDelegationState>this.PropertyBag._getItem(Schemas.TaskSchema.DelegationState);
    }

    /**
     * Gets the name of the delegator of this task.
     */
    get Delegator(): string {
        return <string>this.PropertyBag._getItem(Schemas.TaskSchema.Delegator);
    }

    /**
     * @nullable    Gets or sets the date and time on which the task is due.
     */
    get DueDate(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.TaskSchema.DueDate);
    }
    set DueDate(value: DateTime) {
        this.PropertyBag._setItem(Schemas.TaskSchema.DueDate, value);
    }

    /**
     * Gets a value indicating the mode of the task.
     */
    get Mode(): TaskMode {
        return <TaskMode>this.PropertyBag._getItem(Schemas.TaskSchema.Mode);
    }

    /**
     * Gets a value indicating whether the task is complete.
     */
    get IsComplete(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.TaskSchema.IsComplete);
    }

    /**
     * Gets a value indicating whether the task is recurring.
     */
    get IsRecurring(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.TaskSchema.IsRecurring);
    }

    /**
     * Gets a value indicating whether the task is a team task.
     */
    get IsTeamTask(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.TaskSchema.IsTeamTask);
    }

    /**
     * Gets or sets the mileage of the task.
     */
    get Mileage(): string {
        return <string>this.PropertyBag._getItem(Schemas.TaskSchema.Mileage);
    }
    set Mileage(value: string) {
        this.PropertyBag._setItem(Schemas.TaskSchema.Mileage, value);
    }

    /**
     * Gets the name of the owner of the task.
     */
    get Owner(): string {
        return <string>this.PropertyBag._getItem(Schemas.TaskSchema.Owner);
    }

    /**
     * Gets or sets the completeion percentage of the task. PercentComplete must be between 0 and 100.
     */
    get PercentComplete(): number {
        return <number>this.PropertyBag._getItem(Schemas.TaskSchema.PercentComplete);
    }
    set PercentComplete(value: number) {
        this.PropertyBag._setItem(Schemas.TaskSchema.PercentComplete, value);
    }

    /**
     * Gets or sets the recurrence pattern for this task. Available recurrence pattern classes include Recurrence. 
     * DailyPattern, Recurrence.MonthlyPattern and Recurrence.YearlyPattern.
     */
    get Recurrence(): Recurrence {
        return <Recurrence>this.PropertyBag._getItem(Schemas.TaskSchema.Recurrence);
    }
    set Recurrence(value: Recurrence) {
        this.PropertyBag._setItem(Schemas.TaskSchema.Recurrence, value);
    }

    /**
     * @nullable    Gets or sets the date and time on which the task starts.
     */
    get StartDate(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.TaskSchema.StartDate);
    }
    set StartDate(value: DateTime) {
        this.PropertyBag._setItem(Schemas.TaskSchema.StartDate, value);
    }

    /**
     * Gets or sets the status of the task.
     */
    get Status(): TaskStatus {
        return <TaskStatus>this.PropertyBag._getItem(Schemas.TaskSchema.Status);
    }
    set Status(value: TaskStatus) {
        this.PropertyBag._setItem(Schemas.TaskSchema.Status, value);
    }

    /**
     * Gets a string representing the status of the task, localized according to the PreferredCulture property of the ExchangeService object the task is bound to.
     */
    get StatusDescription(): string {
        return <string>this.PropertyBag._getItem(Schemas.TaskSchema.StatusDescription);
    }

    /**
     * @nullable Gets or sets the total amount of work spent on the task.
     */
    get TotalWork(): number {
        return <number>this.PropertyBag._getItem(Schemas.TaskSchema.TotalWork);
    }
    set TotalWork(value: number) {
        this.PropertyBag._setItem(Schemas.TaskSchema.TotalWork, value);
    }

    /**
     * @internal    @nullable   Gets the default setting for how to treat affected task occurrences on Delete.
     */
    get DefaultAffectedTaskOccurrences(): AffectedTaskOccurrence {
        return AffectedTaskOccurrence.AllOccurrences;
    }

    /**
     * Initializes an unsaved local instance of **Task**. To bind to an existing task, use Task.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService instance to which this task is bound.
     */
    constructor(service: ExchangeService);
    /**
     * @internal    Initializes a new instance of the **Task** class.
     *
     * @param   {ItemAttachment}   parentAttachment   The parent attachment.
     */
    constructor(parentAttachment: ItemAttachment);
    constructor(serviceOrParentAttachment: ExchangeService | ItemAttachment) {
        super(serviceOrParentAttachment);
    }

    /**
     * Binds to an existing task and loads the specified set of properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the task.
     * @param   {ItemId}            id            The Id of the task to bind to.
     * @param   {PropertySet}       propertySet   The set of properties to load.
     * @return  {Promise<Task>}    A Task instance representing the task corresponding to the specified Id :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet): Promise<Task>;
    /**
     * Binds to an existing task and loads its first class properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}   service       The service to use to bind to the task.
     * @param   {ItemId}            id            The Id of the task to bind to.
     * @return  {Promise<Task>}    A Task instance representing the task corresponding to the specified Id :Promise.
     */
    public static Bind(service: ExchangeService, id: ItemId): Promise<Task>;
    public static Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<Task> {
        return service.BindToItem<Task>(id, propertySet, Task);
    }

    /**
     * Deletes the current occurrence of a recurring task. After the current occurrence isdeleted, the task represents the next occurrence. 
     * Developers should call Load to retrieve the new property values of the task. 
     * Calling this method results in a call to EWS.
     *
     * @param   {DeleteMode}   deleteMode   The deletion mode.
     * @return  {Promise<void>}            :Promise.
     */
    DeleteCurrentOccurrence(deleteMode: DeleteMode): Promise<void> {
        return this.InternalDelete(
            deleteMode,
            null,
            AffectedTaskOccurrence.SpecifiedOccurrenceOnly);
    }

    /**
     * @internal Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}   isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}   *true* if a time zone SOAP header should be emitted; otherwise, *false*.
     */
    GetIsTimeZoneHeaderRequired(isUpdateOperation: boolean): boolean {
        return true;
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.TaskSchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.Task;
    }

    /**
     * Applies the local changes that have been made to this task. Calling this method results in at least one call to EWS. 
     * Mutliple calls to EWS might be made if attachments have been added or removed.
     *
     * @param   {ConflictResolutionMode}    conflictResolutionMode   Specifies how conflicts should be resolved.
     * @return  {Promise<Task>}            A Task object representing the completed occurrence if the task is recurring and the update marks it as completed; or a Task object representing the current occurrence if the task is recurring and the uypdate changed its recurrence pattern; or null in every other case    :Promise.
     */
    Update(conflictResolutionMode: ConflictResolutionMode): Promise<Task>;
    /** ##internal ~~ workaround GitHub #52 */
    Update(conflictResolutionMode: ConflictResolutionMode): Promise<any>;
    Update(conflictResolutionMode: ConflictResolutionMode): Promise<Task> {
        return <Promise<Task>>this.InternalUpdate(
            null /* parentFolder */,
            conflictResolutionMode,
            MessageDisposition.SaveOnly,
            null);
    }
}

/**
 * Represents a collection of Conversation related properties.
 * Properties available on this object are defined in the ConversationSchema class.
 */
export class Conversation extends ServiceObject {

    /**
     * Gets the Id of this Conversation.
     */
    get Id(): ConversationId {
        return <ConversationId>this.PropertyBag._getItem(this.GetIdPropertyDefinition());
    }

    /**
     * Gets the topic of this Conversation.
     */
    get Topic(): string {
        var returnValue: IOutParam<string> = { outValue: StringHelper.Empty };

        // This property need not be present hence the property bag may not contain it.
        // Check for the presence of this property before accessing it.
        if (this.PropertyBag.Contains(Schemas.ConversationSchema.Topic)) {

            this.PropertyBag.TryGetPropertyAs<string>(Schemas.ConversationSchema.Topic, returnValue);
        }
        return returnValue.outValue;
    }

    /**
     * Gets a list of all the people who have received messages in this conversation in the current folder only.
     */
    get UniqueRecipients(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.ConversationSchema.UniqueRecipients);
    }

    /**
     * Gets a list of all the people who have received messages in this conversation across all folders in the mailbox.
     */
    get GlobalUniqueRecipients(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalUniqueRecipients);
    }

    /**
     * Gets a list of all the people who have sent messages that are currently unread in this conversation in the current folder only.
     */
    get UniqueUnreadSenders(): StringList {
        var unreadSenders: IOutParam<StringList> = { outValue: null };

        // This property need not be present hence the property bag may not contain it.
        // Check for the presence of this property before accessing it.
        if (this.PropertyBag.Contains(Schemas.ConversationSchema.UniqueUnreadSenders)) {
            this.PropertyBag.TryGetPropertyAs<StringList>(Schemas.ConversationSchema.UniqueUnreadSenders, unreadSenders);
        }
        return unreadSenders.outValue;
    }

    /**
     * Gets a list of all the people who have sent messages that are currently unread in this conversation across all folders in the mailbox.
     */
    get GlobalUniqueUnreadSenders(): StringList {

        var unreadSenders: IOutParam<StringList> = { outValue: null };

        // This property need not be present hence the property bag may not contain it.
        // Check for the presence of this property before accessing it.
        if (this.PropertyBag.Contains(Schemas.ConversationSchema.GlobalUniqueUnreadSenders)) {
            this.PropertyBag.TryGetPropertyAs<StringList>(Schemas.ConversationSchema.GlobalUniqueUnreadSenders, unreadSenders);
        }
        return unreadSenders.outValue;
    }

    /**
     * Gets a list of all the people who have sent messages in this conversation in the current folder only.
     */
    get UniqueSenders(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.ConversationSchema.UniqueSenders);
    }

    /**
     * Gets a list of all the people who have sent messages in this conversation across all folders in the mailbox.
     */
    get GlobalUniqueSenders(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalUniqueSenders);
    }

    /**
     * Gets the delivery time of the message that was last received in this conversation in the current folder only.
     */
    get LastDeliveryTime(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ConversationSchema.LastDeliveryTime);
    }

    /**
     * Gets the delivery time of the message that was last received in this conversation across all folders in the mailbox.
     */
    get GlobalLastDeliveryTime(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalLastDeliveryTime);
    }

    /**
     * Gets a list summarizing the categories stamped on messages in this conversation, in the current folder only.
     */
    get Categories(): StringList {
        var returnValue: IOutParam<StringList> = { outValue: null };

        // This property need not be present hence the property bag may not contain it.
        // Check for the presence of this property before accessing it.
        if (this.PropertyBag.Contains(Schemas.ConversationSchema.Categories)) {
            this.PropertyBag.TryGetPropertyAs<StringList>(Schemas.ConversationSchema.Categories, returnValue);
        }
        return returnValue.outValue;
    }

    /**
     * Gets a list summarizing the categories stamped on messages in this conversation, across all folders in the mailbox.
     */
    get GlobalCategories(): StringList {
        var returnValue: IOutParam<StringList> = { outValue: null };

        // This property need not be present hence the property bag may not contain it.
        // Check for the presence of this property before accessing it.
        if (this.PropertyBag.Contains(Schemas.ConversationSchema.GlobalCategories)) {
            this.PropertyBag.TryGetPropertyAs<StringList>(Schemas.ConversationSchema.GlobalCategories, returnValue);
        }
        return returnValue.outValue;
    }

    /**
     * Gets the flag status for this conversation, calculated by aggregating individual messages flag status in the current folder.
     */
    get FlagStatus(): ConversationFlagStatus {
        var returnValue: IOutParam<ConversationFlagStatus> = { outValue: null };

        // This property need not be present hence the property bag may not contain it.
        // Check for the presence of this property before accessing it.
        if (this.PropertyBag.Contains(Schemas.ConversationSchema.FlagStatus)) {
            this.PropertyBag.TryGetPropertyAs<ConversationFlagStatus>(Schemas.ConversationSchema.FlagStatus, returnValue);
        }
        return returnValue.outValue;
    }

    /**
     * Gets the flag status for this conversation, calculated by aggregating individual messages flag status across all folders in the mailbox.
     */
    get GlobalFlagStatus(): ConversationFlagStatus {
        var returnValue: IOutParam<ConversationFlagStatus> = { outValue: null };

        // This property need not be present hence the property bag may not contain it.
        // Check for the presence of this property before accessing it.
        if (this.PropertyBag.Contains(Schemas.ConversationSchema.GlobalFlagStatus)) {
            this.PropertyBag.TryGetPropertyAs<ConversationFlagStatus>(Schemas.ConversationSchema.GlobalFlagStatus, returnValue);
        }
        return returnValue.outValue;
    }

    /**
     * Gets a value indicating if at least one message in this conversation, in the current folder only, has an attachment.
     */
    get HasAttachments(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ConversationSchema.HasAttachments);
    }

    /**
     * Gets a value indicating if at least one message in this conversation, across all folders in the mailbox, has an attachment.
     */
    get GlobalHasAttachments(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalHasAttachments);
    }

    /**
     * Gets the total number of messages in this conversation in the current folder only.
     */
    get MessageCount(): number {
        return <number>this.PropertyBag._getItem(Schemas.ConversationSchema.MessageCount);
    }

    /**
     * Gets the total number of messages in this conversation across all folders in the mailbox.
     */
    get GlobalMessageCount(): number {
        return <number>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalMessageCount);
    }

    /**
     * Gets the total number of unread messages in this conversation in the current folder only.
     */
    get UnreadCount(): number {
        var returnValue: IOutParam<number> = { outValue: 0 };

        // This property need not be present hence the property bag may not contain it.
        // Check for the presence of this property before accessing it.
        if (this.PropertyBag.Contains(Schemas.ConversationSchema.UnreadCount)) {
            this.PropertyBag.TryGetPropertyAs<number>(Schemas.ConversationSchema.UnreadCount, returnValue);
        }
        return returnValue.outValue;
    }

    /**
     * Gets the total number of unread messages in this conversation across all folders in the mailbox.
     */
    get GlobalUnreadCount(): number {
        var returnValue: IOutParam<number> = { outValue: 0 };

        // This property need not be present hence the property bag may not contain it.
        // Check for the presence of this property before accessing it.
        if (this.PropertyBag.Contains(Schemas.ConversationSchema.GlobalUnreadCount)) {
            this.PropertyBag.TryGetPropertyAs<number>(Schemas.ConversationSchema.GlobalUnreadCount, returnValue);
        }
        return returnValue.outValue;
    }

    /**
     * Gets the size of this conversation, calculated by adding the sizes of all messages in the conversation in the current folder only.
     */
    get Size(): number {
        return <number>this.PropertyBag._getItem(Schemas.ConversationSchema.Size);
    }

    /**
     * Gets the size of this conversation, calculated by adding the sizes of all messages in the conversation across all folders in the mailbox.
     */
    get GlobalSize(): number {
        return <number>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalSize);
    }

    /**
     * Gets a list summarizing the classes of the items in this conversation, in the current folder only.
     */
    get ItemClasses(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.ConversationSchema.ItemClasses);
    }

    /**
     * Gets a list summarizing the classes of the items in this conversation, across all folders in the mailbox.
     */
    get GlobalItemClasses(): StringList {
        return <StringList>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalItemClasses);
    }

    /**
     * Gets the importance of this conversation, calculated by aggregating individual messages importance in the current folder only.
     */
    get Importance(): Importance {
        return <Importance>this.PropertyBag._getItem(Schemas.ConversationSchema.Importance);
    }

    /**
     * Gets the importance of this conversation, calculated by aggregating individual messages importance across all folders in the mailbox.
     */
    get GlobalImportance(): Importance {
        return <Importance>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalImportance);
    }

    /**
     * Gets the Ids of the messages in this conversation, in the current folder only.
     */
    get ItemIds(): ItemIdCollection {
        return <ItemIdCollection>this.PropertyBag._getItem(Schemas.ConversationSchema.ItemIds);
    }

    /**
     * Gets the Ids of the messages in this conversation, across all folders in the mailbox.
     */
    get GlobalItemIds(): ItemIdCollection {
        return <ItemIdCollection>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalItemIds);
    }

    /**
     * Gets the date and time this conversation was last modified.
     */
    get LastModifiedTime(): DateTime {
        return <DateTime>this.PropertyBag._getItem(Schemas.ConversationSchema.LastModifiedTime);
    }

    /**
     * Gets the conversation instance key.
     */
    get InstanceKey(): number[] {
        return <number[]>this.PropertyBag._getItem(Schemas.ConversationSchema.InstanceKey);
    }

    /**
     * Gets the conversation Preview.
     */
    get Preview(): string {
        return <string>this.PropertyBag._getItem(Schemas.ConversationSchema.Preview);
    }

    /**
     * Gets the conversation IconIndex.
     */
    get IconIndex(): IconIndex {
        return <IconIndex>this.PropertyBag._getItem(Schemas.ConversationSchema.IconIndex);
    }

    /**
     * Gets the conversation global IconIndex.
     */
    get GlobalIconIndex(): IconIndex {
        return <IconIndex>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalIconIndex);
    }

    /**
     * Gets the draft item ids.
     */
    get DraftItemIds(): ItemIdCollection {
        return <ItemIdCollection>this.PropertyBag._getItem(Schemas.ConversationSchema.DraftItemIds);
    }

    /**
     * Gets a value indicating if at least one message in this conversation, in the current folder only, is an IRM.
     */
    get HasIrm(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ConversationSchema.HasIrm);
    }

    /**
     * Gets a value indicating if at least one message in this conversation, across all folders in the mailbox, is an IRM.
     */
    get GlobalHasIrm(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalHasIrm);
    }

    /**
     * @internal Initializes an unsaved local instance of **Conversation** class.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the item will be bound.
     */
    constructor(service: ExchangeService) {
        super(service);
    }

    /**
     * Clear flags for conversation items. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId   The Id of the folder items must belong to in order to be unflagged. If contextFolderId is null, flags for items in conversation across the entire mailbox are cleared.
     * @return  {Promise<void>}    Promise
     */
    ClearItemFlags(contextFolderId: FolderId): Promise<void> {
        let flag: Flag = new Flag();
        flag.FlagStatus = ItemFlagStatus.NotFlagged;



        return this.Service.SetFlagStatusForItemsInConversations(
            [{ key: this.Id, value: this.GlobalLastDeliveryTime }],
            contextFolderId,
            flag).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Copies items in the specified conversation to a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId       The Id of the folder items must belong to in order to be copied. If contextFolderId is null, items across the entire mailbox are copied.
     * @param   {FolderId}   destinationFolderId   The Id of the destination folder.
     * @return  {Promise<void>}    Promise
     */
    CopyItemsInConversation(contextFolderId: FolderId, destinationFolderId: FolderId): Promise<void> {
        return this.Service.CopyItemsInConversations(
            [{ key: this.Id, value: this.GlobalLastDeliveryTime }],
            contextFolderId,
            destinationFolderId).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Deletes items in the specified conversation.
     * Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      contextFolderId   The Id of the folder items must belong to in order to be deleted. If contextFolderId is null, items across the entire mailbox are deleted.
     * @param   {DeleteMode}    deleteMode        The deletion mode.
     * @return  {Promise<void>}    Promise
     */
    DeleteItems(contextFolderId: FolderId, deleteMode: DeleteMode): Promise<void> {
        return this.Service.DeleteItemsInConversations(
            [{ key: this.Id, value: this.GlobalLastDeliveryTime }],
            contextFolderId,
            deleteMode).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Sets up a conversation so that any item received within that conversation is no longer categorized.
     * Calling this method results in a call to EWS.
     *
     * @param   {boolean}   processSynchronously   **<not used>**Indicates whether the method should return only once disabling this rule and removing the categories from existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    DisableAlwaysCategorizeItems(processSynchronously: boolean): Promise<void> {
        return this.Service.DisableAlwaysCategorizeItemsInConversations(
            [this.Id],
            processSynchronously).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Sets up a conversation so that any item received within that conversation is no longer moved to Deleted Items folder.
     * Calling this method results in a call to EWS.
     *
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once disabling this rule and restoring the items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    DisableAlwaysDeleteItems(processSynchronously: boolean): Promise<void> {
        return this.Service.DisableAlwaysDeleteItemsInConversations(
            [this.Id],
            processSynchronously).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Sets up a conversation so that any item received within that conversation is no longer moved to a specific folder. 
     * Calling this method results in a call to EWS.
     *
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once disabling this rule is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    DisableAlwaysMoveItemsInConversation(processSynchronously: boolean): Promise<void> {
        return this.Service.DisableAlwaysMoveItemsInConversations(
            [this.Id],
            processSynchronously).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Sets up a conversation so that any item received within that conversation is always categorized.
     * Calling this method results in a call to EWS.
     *
     * @param   {string[]}  categories             The categories that should be stamped on items in the conversation.
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once enabling this rule and stamping existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.          
     * @return  {Promise<void>}    Promise
     */
    EnableAlwaysCategorizeItems(categories: string[], processSynchronously: boolean): Promise<void> {
        return this.Service.EnableAlwaysCategorizeItemsInConversations(
            [this.Id],
            categories,
            processSynchronously).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Sets up a conversation so that any item received within that conversation is always moved to Deleted Items folder.
     * Calling this method results in a call to EWS.
     *
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once enabling this rule and deleting existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    EnableAlwaysDeleteItems(processSynchronously: boolean): Promise<void> {
        return this.Service.EnableAlwaysDeleteItemsInConversations(
            [this.Id],
            processSynchronously).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Sets up a conversation so that any item received within that conversation is always moved to a specific folder.
     * Calling this method results in a call to EWS.
     *
     * @param   {FolderId}  destinationFolderId    The Id of the folder to which conversation items should be moved.
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once enabling this rule and moving existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    EnableAlwaysMoveItems(destinationFolderId: FolderId, processSynchronously: boolean): Promise<void> {
        return this.Service.EnableAlwaysMoveItemsInConversations(
            [this.Id],
            destinationFolderId,
            processSynchronously).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Flags conversation items. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId   The Id of the folder items must belong to in order to be flagged. If contextFolderId is null, items in conversation across the entire mailbox are flagged.
     * @param   {DateTime}   startDate         The start date (can be null).
     * @param   {DateTime}   dueDate           The due date (can be null).
     * @return  {Promise<void>}    Promise
     */
    FlagItems(contextFolderId: FolderId, startDate: DateTime, dueDate: DateTime): Promise<void> {
        let flag: Flag = new Flag();

        flag.FlagStatus = ItemFlagStatus.Flagged;

        if (startDate) {
            flag.StartDate = startDate;
        }
        if (dueDate) {
            flag.DueDate = dueDate;
        }

        return this.Service.SetFlagStatusForItemsInConversations(
            [{ key: this.Id, value: this.GlobalLastDeliveryTime }],
            contextFolderId,
            flag).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Flag conversation items as complete. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId   The Id of the folder items must belong to in order to be flagged as complete. If contextFolderId is null, items in conversation across the entire mailbox are marked as complete.
     * @param   {DateTime}   completeDate      The complete date (can be null).
     * @return  {Promise<void>}    Promise
     */
    FlagItemsComplete(contextFolderId: FolderId, completeDate: DateTime): Promise<void> {
        let flag: Flag = new Flag();
        flag.FlagStatus = ItemFlagStatus.Complete;

        if (completeDate) {
            flag.CompleteDate = completeDate;
        }

        return this.Service.SetFlagStatusForItemsInConversations(
            [{ key: this.Id, value: this.GlobalLastDeliveryTime }],
            contextFolderId,
            flag).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * @internal This method is not supported in this object.
     * Gets the name of the change XML element.
     *
     * @return  {string}      XML element name,
     */
    GetChangeXmlElementName(): string {
        throw new NotSupportedException();
    }

    /**
     * @internal This method is not supported in this object.
     * Gets the name of the delete field XML element.
     *
     * @return  {string}      XML element name,
     */
    GetDeleteFieldXmlElementName(): string {
        throw new NotSupportedException();
    }

    /**
     * The property definition for the Id of this object.
     *
     * @return  {PropertyDefinition}      A PropertyDefinition instance.
     */
    GetIdPropertyDefinition(): PropertyDefinition {
        return Schemas.ConversationSchema.Id;
    }

    /**
     * @internal This method is not supported in this object.
     * Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}   isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}                       true if a time zone SOAP header should be emitted; otherwise, false.
     */
    GetIsTimeZoneHeaderRequired(isUpdateOperation: boolean): boolean {
        throw new NotSupportedException();
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2010_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.ConversationSchema.Instance;
    }

    /**
     * @internal This method is not supported in this object.
     * Gets the name of the set field XML element.
     *
     * @return  {string}      XML element name,
     */
    GetSetFieldXmlElementName(): string {
        throw new NotSupportedException();
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.Conversation;
    }

    /**
     * @internal This is not supported in this object.
     * Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    InternalDelete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence): Promise<void> {
        throw new NotSupportedException();
    }

    /**
     * @internal This method is not supported in this object. 
     * Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    InternalLoad(propertySet: PropertySet): Promise<void> {
        throw new NotSupportedException();
    }

    /**
     * Moves items in the specified conversation to a specific folder.
     * Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId       The Id of the folder items must belong to in order to be moved. If contextFolderId is null, items across the entire mailbox are moved.
     * @param   {FolderId}   destinationFolderId   The Id of the destination folder.
     * @return  {Promise<void>}    Promise
     */
    MoveItemsInConversation(contextFolderId: FolderId, destinationFolderId: FolderId): Promise<void> {
        return this.Service.MoveItemsInConversations(
            [{ key: this.Id, value: this.GlobalLastDeliveryTime }],
            contextFolderId,
            destinationFolderId).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Sets the read state of items in the specified conversation. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}  contextFolderId   The Id of the folder items must belong to in order for their read state to be set. If contextFolderId is null, the read states of items across the entire mailbox are set.
     * @param   {boolean}   isRead            if set to true, conversation items are marked as read; otherwise they are marked as unread.
     * @return  {Promise<void>}    Promise
     */
    SetReadStateForItemsInConversation(contextFolderId: FolderId, isRead: boolean): Promise<void>;
    /**
     * Sets the read state of items in the specified conversation. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}  contextFolderId        The Id of the folder items must belong to in order for their read state to be set. If contextFolderId is null, the read states of items across the entire mailbox are set.
     * @param   {boolean}   isRead                 if set to true, conversation items are marked as read; otherwise they are marked as unread.
     * @param   {boolean}   suppressReadReceipts   if set to true read receipts are suppressed.
     * @return  {Promise<void>}    Promise
     */
    SetReadStateForItemsInConversation(contextFolderId: FolderId, isRead: boolean, suppressReadReceipts: boolean): Promise<void>;
    SetReadStateForItemsInConversation(contextFolderId: FolderId, isRead: boolean, suppressReadReceipts: boolean = null): Promise<void> {
        return this.Service.SetReadStateForItemsInConversations(
            [{ key: this.Id, value: this.GlobalLastDeliveryTime }],
            contextFolderId,
            isRead,
            suppressReadReceipts).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }

    /**
     * Sets the retention policy of items in the specified conversation. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}          contextFolderId        The Id of the folder items must belong to in order for their retention policy to be set. If contextFolderId is null, the retention policy of items across the entire mailbox are set.
     * @param   {RetentionType}     retentionPolicyType    Retention policy type.
     * @param   {Guid}              retentionPolicyTagId   Retention policy tag id.  Null will clear the policy.
     * @return  {Promise<void>}    Promise
     */
    SetRetentionPolicyForItemsInConversation(contextFolderId: FolderId, retentionPolicyType: RetentionType, retentionPolicyTagId: Guid): Promise<void> {
        return this.Service.SetRetentionPolicyForItemsInConversations(
            [{ key: this.Id, value: this.GlobalLastDeliveryTime }],
            contextFolderId,
            retentionPolicyType,
            retentionPolicyTagId).then((responses) => {
                responses.__thisIndexer(0).ThrowIfNecessary();
            });
    }
}

/**
 * Represents the base class for all responses that can be sent.
 * 
 * @typeparam   {TMessage}     Type of message.
 */
export abstract class ResponseObject<TMessage extends EmailMessage> extends ServiceObject {

    private referenceItem: Item = null;

    /**
     * Gets or sets a value indicating whether read receipts will be requested from recipients of this response.
     */
    get IsReadReceiptRequested(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsReadReceiptRequested);
    }
    set IsReadReceiptRequested(value: boolean) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsReadReceiptRequested, value);
    }

    /**
     * Gets or sets a value indicating whether delivery receipts should be sent to the sender.
     */
    get IsDeliveryReceiptRequested(): boolean {
        return <boolean>this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
    }
    set IsDeliveryReceiptRequested(value: boolean) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsDeliveryReceiptRequested, value);
    }

    /**
     * @internal Initializes a new instance of the **ResponseObject** class.
     *
     * @param   {type}   referenceItem   The reference item.
     */
    constructor(referenceItem: Item) {
        super(referenceItem.Service);
        EwsLogging.Assert(referenceItem !== null, "ResponseObject.ctor", "referenceItem is null");
        referenceItem.ThrowIfThisIsNew();
        this.referenceItem = referenceItem;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.ResponseObjectSchema.Instance; }

    /**
    * @internal Create the response object.
    *
    * @param   {FolderId}             destinationFolderId   The destination folder id.
    * @param   {MessageDisposition}   messageDisposition    The message disposition.
    * @return  {Promise<Item[]>}               The list of items returned by EWS.
    */
    InternalCreate(destinationFolderId: FolderId, messageDisposition: MessageDisposition): Promise<Item[]> {
        (<ItemId>this.PropertyBag._getItem(Schemas.ResponseObjectSchema.ReferenceItemId)).Assign(this.referenceItem.Id);

        return this.Service.InternalCreateResponseObject(
            this,
            destinationFolderId,
            messageDisposition);
    }

    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                  deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}       sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {affectedTaskOccurrences}     affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    InternalDelete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence): Promise<void> {
        throw new NotSupportedException();
    }

    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    InternalLoad(propertySet: PropertySet): Promise<void> {
        throw new NotSupportedException();
    }

    /**
     * Saves the response in the Drafts folder. Calling this method results in a call to EWS.
     *
     * @return  {Promise<TMessage>}      A TMessage that represents the response.
     */
    Save(): Promise<TMessage>;
    /**
     * Saves the response in the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}     destinationFolderName   The name of the folder in which to save the response.
     * @return  {Promise<TMessage>}      A TMessage that represents the response.
     */
    Save(destinationFolderName: WellKnownFolderName): Promise<TMessage>;
    /**
     * Saves the response in the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   destinationFolderId   The Id of the folder in which to save the response.
     * @return  {Promise<TMessage>}                         A TMessage that represents the response.
     */
    Save(destinationFolderId: FolderId): Promise<TMessage>;
    Save(destinationFolderIdOrName?: FolderId | WellKnownFolderName): Promise<TMessage> {
        var destinationFolderId: FolderId = null;
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            } else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return this.InternalCreate(destinationFolderId, MessageDisposition.SaveOnly).then((result) => {
            return <TMessage>result[0];
        });
    }

    /**
     * Sends this response without saving a copy. Calling this method results in a call to EWS.
     */
    Send(): Promise<void> {
        return <any>this.InternalCreate(null, MessageDisposition.SendOnly);
    }

    /**
     * Sends this response and saves a copy in the Sent Items folder. Calling this method results in a call to EWS.
     */
    SendAndSaveCopy(): Promise<void>;
    /**
     * Sends this response and saves a copy in the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   destinationFolderName   The name of the folder in which to save the copy of the message.
     */
    SendAndSaveCopy(destinationFolderName: WellKnownFolderName): Promise<void>;
    /**
     * Sends this response and saves a copy in the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   destinationFolderId   The Id of the folder in which to save the copy of the message.
     */
    SendAndSaveCopy(destinationFolderId: FolderId): Promise<void>;
    SendAndSaveCopy(destinationFolderIdOrName?: FolderId | WellKnownFolderName): Promise<void> {
        var destinationFolderId: FolderId = null;
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            } else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return <any>this.InternalCreate(destinationFolderId, MessageDisposition.SendAndSaveCopy);
    }
}

/**
 * Represents the base class for all calendar-related response messages.
 * 
 * @typeparam   {TMessage}     The type of message that is created when this response message is saved.
 */
export abstract class CalendarResponseMessageBase<TMessage extends EmailMessage> extends ResponseObject<TMessage> {
    /**
    * @internal Initializes a new instance of the **CalendarResponseMessageBase** class.
    *
    * @param   {Item}   referenceItem   The reference item.
    */
    constructor(referenceItem: Item) {
        super(referenceItem);
    }

    /**
     * Saves the response in the Drafts folder. Calling this method results in a call to EWS.
     *
     * @return  {CalendarActionResults}      A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    Save(): Promise<CalendarActionResults | any>;  //info: added extra "any" for workaround @github #52 
    /**
     * Saves the response in the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}     destinationFolderName   The name of the folder in which to save the response.
     * @return  {CalendarActionResults}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    Save(destinationFolderName: WellKnownFolderName): Promise<CalendarActionResults | any>;  //info: added extra "any" for workaround @github #52
    /**
     * Saves the response in the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}                destinationFolderId   The Id of the folder in which to save the response.
     * @return  {CalendarActionResults}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    Save(destinationFolderId: FolderId): Promise<CalendarActionResults | any>;  //info: added extra "any" for workaround @github #52
    Save(destinationFolderIdOrName?: FolderId | WellKnownFolderName): Promise<CalendarActionResults> {
        var destinationFolderId: FolderId = null;
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            } else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return this.InternalCreate(destinationFolderId, MessageDisposition.SaveOnly).then((results) => {
            return new CalendarActionResults(results);
        });
    }

    /**
     * Sends this response without saving a copy. Calling this method results in a call to EWS.
     *
     * @return  {CalendarActionResults}      A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    Send(): Promise<CalendarActionResults | any> {   //info: added extra any for workaround @github #52
        return this.InternalCreate(null, MessageDisposition.SendOnly).then((results) => {
            return new CalendarActionResults(results);
        });
    }

    /**
     * Sends this response ans saves a copy in the Sent Items folder. Calling this method results in a call to EWS.
     *
     * @return  {CalendarActionResults}      A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    SendAndSaveCopy(): Promise<CalendarActionResults | any>;  //info: added extra "any"" for workaround @github #52
    /**
     * Sends this response and saves a copy in the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}     destinationFolderName   The name of the folder in which to save the copy of the message.
     * @return  {CalendarActionResults}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    SendAndSaveCopy(destinationFolderName: WellKnownFolderName): Promise<CalendarActionResults | any>;  //info: added extra "any" for workaround @github #52
    /**
     * Sends this response ans saves a copy in the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}                destinationFolderId   The Id of the folder in which to save the copy of the message.
     * @return  {CalendarActionResults}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    SendAndSaveCopy(destinationFolderId: FolderId): Promise<CalendarActionResults | any>;  //info: added extra "any" for workaround @github #52
    SendAndSaveCopy(destinationFolderIdOrName?: FolderId | WellKnownFolderName): Promise<CalendarActionResults> {
        var destinationFolderId: FolderId = null;
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            } else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return this.InternalCreate(destinationFolderId, MessageDisposition.SendAndSaveCopy)
            .then((results) => {
                return new CalendarActionResults(results);
            });
    }
}

/**
 * Represents the base class for accept, tentatively accept and decline response messages.
 * 
 * @typeparam   {TMessage}     The type of message that is created when this response message is saved.
 */
export abstract class CalendarResponseMessage<TMessage extends EmailMessage> extends CalendarResponseMessageBase<TMessage> {
    /**
     * Gets or sets the body of the response.
     */
    get Body(): MessageBody {
        return <MessageBody>this.PropertyBag._getItem(Schemas.ItemSchema.Body);
    }
    set Body(value: MessageBody) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Body, value);
    }
    /**
     * Gets a list of recipients the response will be sent to.
     */
    get ToRecipients(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ToRecipients);
    }
    /**
     * Gets a list of recipients the response will be sent to as Cc.
     */
    get CcRecipients(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.CcRecipients);
    }
    /**
     * Gets a list of recipients this response will be sent to as Bcc.
     */
    get BccRecipients(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.BccRecipients);
    }
    get ItemClass(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.ItemClass);
    }
    set ItemClass(value: string) {
        this.PropertyBag._setItem(Schemas.ItemSchema.ItemClass, value);
    }
    /**
     * Gets or sets the sensitivity of this response.
     */
    get Sensitivity(): Sensitivity {
        return <Sensitivity>this.PropertyBag._getItem(Schemas.ItemSchema.Sensitivity);
    }
    set Sensitivity(value: Sensitivity) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Sensitivity, value);
    }
    /**
     * Gets a list of attachments to this response.
     */
    get Attachments(): AttachmentCollection {
        return <AttachmentCollection>this.PropertyBag._getItem(Schemas.ItemSchema.Attachments);
    }
    get InternetMessageHeaders(): InternetMessageHeaderCollection {
        return <InternetMessageHeaderCollection>this.PropertyBag._getItem(Schemas.ItemSchema.InternetMessageHeaders);
    }
    /**
     * Gets or sets the sender of this response.
     */
    get Sender(): EmailAddress {
        return <EmailAddress>this.PropertyBag._getItem(Schemas.EmailMessageSchema.Sender);
    }
    set Sender(value: EmailAddress) {
        this.PropertyBag._setItem(Schemas.EmailMessageSchema.Sender, value);
    }
    /**
     * @internal Initializes a new instance of the **CalendarResponseMessage** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    constructor(referenceItem: Item) {
        super(referenceItem);
    }
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.CalendarResponseObjectSchema.Instance; }
}

/**
 * Represents a meeting acceptance message.
 *
 */
export class AcceptMeetingInvitationMessage extends CalendarResponseMessage<MeetingResponse> {
        private tentative: boolean = false;
        /**
         * Gets a value indicating whether the associated meeting is tentatively accepted.
         *
         */
        get Tentative(): boolean {
                return this.tentative;
        }
        /**
         * Initializes a new instance of the **AcceptMeetingInvitationMessage** class.
         *
         * @param   {Item}            referenceItem   The reference item.
         * @param   {boolean}         tentative       if set to true accept invitation tentatively.
         */
        constructor(referenceItem: Item, tentative: boolean) {
                super(referenceItem);
                this.tentative = tentative;
        }
        /**
         * @internal Gets the minimum required server version.
         *
         * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
         */
        GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
        /**
         * @internal This methods lets subclasses of ServiceObject override the default mechanism by which the XML element name associated with their type is retrieved.
         *
         * @return  {string}      The XML element name associated with this type. If this method returns null or empty, the XML element name associated with this type is determined by the EwsObjectDefinition attribute that decorates the type, if present.
         */
        GetXmlElementNameOverride(): string {
                if (this.tentative) {
                        return XmlElementNames.TentativelyAcceptItem;
                }
                else {
                        return XmlElementNames.AcceptItem;
                }
        }
        /**
         * @internal Gets the element name of item in XML
         *
         * @return  {string} name of elelment
         */
        GetXmlElementName(): string { return this.GetXmlElementNameOverride(); }
}


/**
 * Represents a meeting cancellation message.
 *
 */
export class CancelMeetingMessage extends CalendarResponseMessageBase<MeetingCancellation> {
    /**
     * Gets or sets the body of the response.
     *
     */
    get Body(): MessageBody {
        return <MessageBody>this.PropertyBag._getItem(Schemas.CancelMeetingMessageSchema.Body);
    }
    set Body(value: MessageBody) {
        this.PropertyBag._setItem(Schemas.CancelMeetingMessageSchema.Body, value);
    }
    /**
     * Initializes a new instance of the **CancelMeetingMessage** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    constructor(referenceItem: Item) {
        super(referenceItem);
    }
    /**
     * Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    /**
     * Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.CancelMeetingMessageSchema.Instance; }
    /**
     * Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.CancelCalendarItem; }
}

/**
 * Represents a meeting declination message.
 */
export class DeclineMeetingInvitationMessage extends CalendarResponseMessage<MeetingResponse> {

    /**
     * Initializes a new instance of the **DeclineMeetingInvitationMessage** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    constructor(referenceItem: Item) {
        super(referenceItem);
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string { return XmlElementNames.DeclineItem; }
}

/**
 * Represents the base class for e-mail related responses (Reply, Reply all and Forward).
 *
 */
export class ResponseMessage extends ResponseObject<EmailMessage> {
    private responseType: ResponseMessageType = ResponseMessageType.Reply;
    /**
     * Gets a value indicating the type of response this object represents.
     *
     */
    get ResponseType(): ResponseMessageType {
        return this.responseType;
    }
    /**
     * Gets or sets the body of the response.
     *
     */
    get Body(): MessageBody {
        return <MessageBody>this.PropertyBag._getItem(Schemas.ItemSchema.Body);
    }
    set Body(value: MessageBody) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Body, value);
    }
    /**
     * Gets a list of recipients the response will be sent to.
     *
     */
    get ToRecipients(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.ToRecipients);
    }
    /**
     * Gets a list of recipients the response will be sent to as Cc.
     *
     */
    get CcRecipients(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.CcRecipients);
    }
    /**
     * Gets a list of recipients this response will be sent to as Bcc.
     *
     */
    get BccRecipients(): EmailAddressCollection {
        return <EmailAddressCollection>this.PropertyBag._getItem(Schemas.EmailMessageSchema.BccRecipients);
    }
    /**
     * Gets or sets the subject of this response.
     *
     */
    get Subject(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.Subject);
    }
    set Subject(value: string) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Subject, value);
    }
    /**
     * Gets or sets the body prefix of this response. The body prefix will be prepended to the original
    message's body when the response is created.
     *
     */
    get BodyPrefix(): MessageBody {
        return <MessageBody>this.PropertyBag._getItem(Schemas.ResponseObjectSchema.BodyPrefix);
    }
    set BodyPrefix(value: MessageBody) {
        this.PropertyBag._setItem(Schemas.ResponseObjectSchema.BodyPrefix, value);
    }
        
    /**
     * Initializes a new instance of the **ResponseMessage** class.
     *
     * @param   {Item}                    referenceItem   The reference item.
     * @param   {ResponseMessageType}     responseType    Type of the response.
     */
    constructor(referenceItem: Item, responseType: ResponseMessageType) {
        super(referenceItem);
        this.responseType = responseType;
    }
    /**
     * Gets the minimum required server version.
     *
     * @return  {type}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    /**
     * Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.ResponseMessageSchema.Instance; }
    /**
     * Get XML Element Name - workaround for c# attributes
     */
    GetXmlElementName(): string { return this.GetXmlElementNameOverride(); }
    /**
     * This methods lets subclasses of ServiceObject override the default mechanism by which the XML element name associated with their type is retrieved.
     *
     * @return  {string}      The XML element name associated with this type. If this method returns null or empty, the XML element name associated with this type is determined by the EwsObjectDefinition attribute that decorates the type, if present.
     */
    GetXmlElementNameOverride(): string {
        switch (this.responseType) {
            case ResponseMessageType.Reply:
                return XmlElementNames.ReplyToItem;
            case ResponseMessageType.ReplyAll:
                return XmlElementNames.ReplyAllToItem;
            case ResponseMessageType.Forward:
                return XmlElementNames.ForwardItem;
            default:
                EwsLogging.Assert(
                    false,
                    "ResponseMessage.GetXmlElementNameOverride",
                    "An unexpected value for responseType could not be handled.");
                return null; // Because the compiler wants it
        }
    }
}

/**
 * Represents a reply to a post item.
 * 
 * @sealed
 */
export class PostReply extends ServiceObject {

    private referenceItem: Item = null;

    /**
     * Gets or sets the subject of the post reply.
     */
    get Subject(): string {
        return <string>this.PropertyBag._getItem(Schemas.ItemSchema.Subject);
    }
    set Subject(value: string) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Subject, value);
    }

    /**
     * Gets or sets the body of the post reply.
     */
    get Body(): MessageBody {
        return <MessageBody>this.PropertyBag._getItem(Schemas.ItemSchema.Body);
    }
    set Body(value: MessageBody) {
        this.PropertyBag._setItem(Schemas.ItemSchema.Body, value);
    }

    /**
     * Gets or sets the body prefix that should be prepended to the original post item's body.
     */
    get BodyPrefix(): MessageBody {
        return <MessageBody>this.PropertyBag._getItem(Schemas.ResponseObjectSchema.BodyPrefix);
    }
    set BodyPrefix(value: MessageBody) {
        this.PropertyBag._setItem(Schemas.ResponseObjectSchema.BodyPrefix, value);
    }

    /**
     * @internal Initializes a new instance of the **PostReply** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    constructor(referenceItem: Item) {
        super(referenceItem.Service);
        EwsLogging.Assert(
            referenceItem != null,
            "PostReply.ctor",
            "referenceItem is null");

        referenceItem.ThrowIfThisIsNew();

        this.referenceItem = referenceItem;
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.PostReplySchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.PostReplyItem;
    }

    /**
     * @internal Create a PostItem response.
     *
     * @param   {FolderId}              parentFolderId       The parent folder id.
     * @param   {MessageDisposition}    messageDisposition   The message disposition.
     * @return  {Promise<PostItem>}    Created PostItem    :Promise.
     */
    InternalCreate(parentFolderId: FolderId, messageDisposition: MessageDisposition): Promise<PostItem> {
        (<ItemId>this.PropertyBag._getItem(Schemas.ResponseObjectSchema.ReferenceItemId)).Assign(this.referenceItem.Id);

        return this.Service.InternalCreateResponseObject(
            this,
            parentFolderId,
            messageDisposition).then((items: Item[]) => {

                let postItem: PostItem = EwsUtilities.FindFirstItemOfType<PostItem>(items, PostItem);

                // This should never happen. If it does, we have a bug.
                EwsLogging.Assert(
                    postItem != null,
                    "PostReply.InternalCreate",
                    "postItem is null. The CreateItem call did not return the expected PostItem.");

                return postItem;
            });
    }

    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     * @return  {Promise<void>}    :Promise.
     */
    InternalDelete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence): Promise<void> {
        throw new InvalidOperationException(Strings.DeletingThisObjectTypeNotAuthorized);
    }

    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     * @return  {Promise<void>}    :Promise.
     */
    InternalLoad(propertySet: PropertySet): Promise<void> {
        throw new InvalidOperationException(Strings.LoadingThisObjectTypeNotSupported);
    }

    /**
     * Saves the post reply in the same folder as the original post item. Calling this method results in a call to EWS.
     *
     * @return  {Promise<PostItem>}    A PostItem representing the posted reply :Promise.
     */
    Save(): Promise<PostItem>;
    /**
     * Saves the post reply in the specified folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   destinationFolderId   The Id of the folder in which to save the post reply.
     * @return  {Promise<PostItem>}    A PostItem representing the posted reply :Promise.
     */
    Save(destinationFolderId: FolderId): Promise<PostItem>;
    /**
     * Saves the post reply in a specified folder. Calling this method results in a call to EWS.
     *
     * @param   {WellKnownFolderName}   destinationFolderName   The name of the folder in which to save the post reply.
     * @return  {Promise<PostItem>}    A PostItem representing the posted reply :Promise.
     */
    Save(destinationFolderName: WellKnownFolderName): Promise<PostItem>;
    Save(destinationFolderIdOrFolderName: FolderId | WellKnownFolderName = null): Promise<PostItem> {
        let destinationFolderId: FolderId = <any>destinationFolderIdOrFolderName;
        if (arguments.length > 0) {

            EwsUtilities.ValidateParam(destinationFolderIdOrFolderName, "destinationFolderId");
        }
        if (typeof destinationFolderIdOrFolderName === 'number') {
            destinationFolderId = new FolderId(destinationFolderIdOrFolderName);
        }
        return this.InternalCreate(destinationFolderId, null);
    }
}

/**
 * @internal Represents a response object created to remove a calendar item from a meeting cancellation.
 * 
 * @sealed
 */
export class RemoveFromCalendar extends ServiceObject {

    private referenceItem: Item;

    /**
     * Initializes a new instance of the **RemoveFromCalendar** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    constructor(referenceItem: Item) {
        super(referenceItem.Service);
        EwsLogging.Assert(
            referenceItem != null,
            "RemoveFromCalendar.ctor",
            "referenceItem is null");

        referenceItem.ThrowIfThisIsNew();

        this.referenceItem = referenceItem;
    }

    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion {
        return ExchangeVersion.Exchange2007_SP1;
    }

    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema {
        return Schemas.ResponseObjectSchema.Instance;
    }

    /**
     * @internal Gets the element name of item in XML
     * 
     * @return  {string} name of elelment
     */
    GetXmlElementName(): string {
        return XmlElementNames.RemoveItem;
    }

    /**
     * @internal Create response object.
     *
     * @param   {FolderId}              parentFolderId       The parent folder id.
     * @param   {MessageDisposition}    messageDisposition   The message disposition.
     * @return  {Item[]}                A list of items that were created or modified as a results of this operation.
     */
    InternalCreate(parentFolderId: FolderId, messageDisposition: MessageDisposition): Promise<Item[]>/*System.Collections.Generic.List<Item>*/ {
        (<ItemId>this.PropertyBag._getItem(Schemas.ResponseObjectSchema.ReferenceItemId)).Assign(this.referenceItem.Id);

        return this.Service.InternalCreateResponseObject(
            this,
            parentFolderId,
            messageDisposition);
    }

    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     * @return  {Promise<void>}            :Promise.
     */
    InternalDelete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence): Promise<void> {
        throw new NotSupportedException();
    }

    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     * @return  {Promise<void>}              :Promise.
     */
    InternalLoad(propertySet: PropertySet): Promise<void> {
        throw new NotSupportedException();
    }
}

/**
 * Represents a response object created to supress read receipts for an item.
 *
 */
export class SuppressReadReceipt extends ServiceObject {
    private referenceItem: Item = null;
    /**
     * Initializes a new instance of the **SuppressReadReceipt** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    constructor(referenceItem: Item) {
        super(referenceItem.Service);
        EwsLogging.Assert(referenceItem !== null, "SuppressReadReceipt.ctor", "referenceItem is null");
        referenceItem.ThrowIfThisIsNew();
        this.referenceItem = referenceItem;
    }
    /**
     * Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    GetMinimumRequiredServerVersion(): ExchangeVersion { return ExchangeVersion.Exchange2007_SP1; }
    /**
     * Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    GetSchema(): ServiceObjectSchema { return Schemas.ResponseObjectSchema.Instance; }
    GetXmlElementName(): string { return XmlElementNames.SuppressReadReceipt; }
    /**
     * Create the response object.
     *
     * @param   {FolderId}            parentFolderId       The parent folder id.
     * @param   {MessageDisposition}  messageDisposition   The message disposition.
     */
    InternalCreate(parentFolderId: FolderId, messageDisposition: MessageDisposition): Promise<void> {
        (<ItemId>this.PropertyBag._getItem(Schemas.ResponseObjectSchema.ReferenceItemId)).Assign(this.referenceItem.Id);

        return <any>this.Service.InternalCreateResponseObject(
            this,
            parentFolderId,
            messageDisposition);
    }
    /**
     * Deletes the object.
     *
     * @param   {DeleteMode}              deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}   sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}  affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    InternalDelete(deleteMode: DeleteMode, sendCancellationsMode: SendCancellationsMode, affectedTaskOccurrences: AffectedTaskOccurrence): Promise<void> {
        throw new NotSupportedException();
    }
    /**
     * Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    InternalLoad(propertySet: PropertySet): Promise<void> {
        throw new NotSupportedException();
    }
}


// /**
//  * FieldURIs for persona.
//  */
// module FieldUris {
//     export var PersonaId: string = "persona:PersonaId";
//     export var PersonaType: string = "persona:PersonaType";
//     export var CreationTime: string = "persona:CreationTime";
//     export var DisplayNameFirstLastHeader: string = "persona:DisplayNameFirstLastHeader";
//     export var DisplayNameLastFirstHeader: string = "persona:DisplayNameLastFirstHeader";
//     export var DisplayName: string = "persona:DisplayName";
//     export var DisplayNameFirstLast: string = "persona:DisplayNameFirstLast";
//     export var DisplayNameLastFirst: string = "persona:DisplayNameLastFirst";
//     export var FileAs: string = "persona:FileAs";
//     export var Generation: string = "persona:Generation";
//     export var DisplayNamePrefix: string = "persona:DisplayNamePrefix";
//     export var GivenName: string = "persona:GivenName";
//     export var Surname: string = "persona:Surname";
//     export var Title: string = "persona:Title";
//     export var CompanyName: string = "persona:CompanyName";
//     export var EmailAddress: string = "persona:EmailAddress";
//     export var EmailAddresses: string = "persona:EmailAddresses";
//     export var ImAddress: string = "persona:ImAddress";
//     export var HomeCity: string = "persona:HomeCity";
//     export var WorkCity: string = "persona:WorkCity";
//     export var Alias: string = "persona:Alias";
//     export var RelevanceScore: string = "persona:RelevanceScore";
//     export var Attributions: string = "persona:Attributions";
//     export var OfficeLocations: string = "persona:OfficeLocations";
//     export var ImAddresses: string = "persona:ImAddresses";
//     export var Departments: string = "persona:Departments";
//     export var ThirdPartyPhotoUrls: string = "persona:ThirdPartyPhotoUrls";
// }

// /**
//  * Represents the schema for persona.
//  */
// export class PersonaSchema extends ItemSchema {

//     public PersonaId: PropertyDefinition;

//     public PersonaType: PropertyDefinition;

//     public CreationTime: PropertyDefinition;

//     public DisplayNameFirstLastHeader: PropertyDefinition;

//     public DisplayNameLastFirstHeader: PropertyDefinition;

//     public DisplayName: PropertyDefinition;

//     public DisplayNameFirstLast: PropertyDefinition;

//     public DisplayNameLastFirst: PropertyDefinition;

//     public FileAs: PropertyDefinition;

//     public Generation: PropertyDefinition;

//     public DisplayNamePrefix: PropertyDefinition;

//     public GivenName: PropertyDefinition;

//     public Surname: PropertyDefinition;

//     public Title: PropertyDefinition;

//     public CompanyName: PropertyDefinition;

//     public EmailAddress: PropertyDefinition;

//     public EmailAddresses: PropertyDefinition;

//     public ImAddress: PropertyDefinition;

//     public HomeCity: PropertyDefinition;

//     public WorkCity: PropertyDefinition;

//     public Alias: PropertyDefinition;

//     public RelevanceScore: PropertyDefinition;

//     public Attributions: PropertyDefinition;

//     public OfficeLocations: PropertyDefinition;

//     public ImAddresses: PropertyDefinition;

//     public Departments: PropertyDefinition;

//     public ThirdPartyPhotoUrls: PropertyDefinition;

//     /**
//      * @internal Instance of **PostItemSchema** 
//      */
//     static Instance: PersonaSchema = new PersonaSchema();

//     /**
//      * Registers properties.
//      * 
//      * /remarks/ IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
//      */
//     RegisterProperties(): void {
//         super.RegisterProperties();
//         this.RegisterProperty(this.PersonaId);
//         this.RegisterProperty(this.PersonaType);
//         this.RegisterProperty(this.CreationTime);
//         this.RegisterProperty(this.DisplayNameFirstLastHeader);
//         this.RegisterProperty(this.DisplayNameLastFirstHeader);
//         this.RegisterProperty(this.DisplayName);
//         this.RegisterProperty(this.DisplayNameFirstLast);
//         this.RegisterProperty(this.DisplayNameLastFirst);
//         this.RegisterProperty(this.FileAs);
//         this.RegisterProperty(this.Generation);
//         this.RegisterProperty(this.DisplayNamePrefix);
//         this.RegisterProperty(this.GivenName);
//         this.RegisterProperty(this.Surname);
//         this.RegisterProperty(this.Title);
//         this.RegisterProperty(this.CompanyName);
//         this.RegisterProperty(this.EmailAddress);
//         this.RegisterProperty(this.EmailAddresses);
//         this.RegisterProperty(this.ImAddress);
//         this.RegisterProperty(this.HomeCity);
//         this.RegisterProperty(this.WorkCity);
//         this.RegisterProperty(this.Alias);
//         this.RegisterProperty(this.RelevanceScore);
//         this.RegisterProperty(this.Attributions);
//         this.RegisterProperty(this.OfficeLocations);
//         this.RegisterProperty(this.ImAddresses);
//         this.RegisterProperty(this.Departments);
//         this.RegisterProperty(this.ThirdPartyPhotoUrls);
//     }

//     protected init() {
//         super.init();

//         this.PersonaId =
//             new ComplexPropertyDefinition<ItemId>(
//                 "PersonaId",
//                 XmlElementNames.PersonaId,
//                 FieldUris.PersonaId,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new ItemId(); });


//         this.PersonaType =
//             new StringPropertyDefinition(
//                 "PersonaType",
//                 XmlElementNames.PersonaType,
//                 FieldUris.PersonaType,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.CreationTime =
//             new DateTimePropertyDefinition(
//                 "CreationTime",
//                 XmlElementNames.CreationTime,
//                 FieldUris.CreationTime,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.DisplayNameFirstLastHeader =
//             new StringPropertyDefinition(
//                 "DisplayNameFirstLastHeader",
//                 XmlElementNames.DisplayNameFirstLastHeader,
//                 FieldUris.DisplayNameFirstLastHeader,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.DisplayNameLastFirstHeader =
//             new StringPropertyDefinition(
//                 "DisplayNameLastFirstHeader",
//                 XmlElementNames.DisplayNameLastFirstHeader,
//                 FieldUris.DisplayNameLastFirstHeader,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.DisplayName =
//             new StringPropertyDefinition(
//                 "DisplayName",
//                 XmlElementNames.DisplayName,
//                 FieldUris.DisplayName,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.DisplayNameFirstLast =
//             new StringPropertyDefinition(
//                 "DisplayNameFirstLast",
//                 XmlElementNames.DisplayNameFirstLast,
//                 FieldUris.DisplayNameFirstLast,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.DisplayNameLastFirst =
//             new StringPropertyDefinition(
//                 "DisplayNameLastFirst",
//                 XmlElementNames.DisplayNameLastFirst,
//                 FieldUris.DisplayNameLastFirst,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.FileAs =
//             new StringPropertyDefinition(
//                 "FileAs",
//                 XmlElementNames.FileAs,
//                 FieldUris.FileAs,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.Generation =
//             new StringPropertyDefinition(
//                 "Generation",
//                 XmlElementNames.Generation,
//                 FieldUris.Generation,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.DisplayNamePrefix =
//             new StringPropertyDefinition(
//                 "DisplayNamePrefix",
//                 XmlElementNames.DisplayNamePrefix,
//                 FieldUris.DisplayNamePrefix,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.GivenName =
//             new StringPropertyDefinition(
//                 "GivenName",
//                 XmlElementNames.GivenName,
//                 FieldUris.GivenName,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.Surname =
//             new StringPropertyDefinition(
//                 "Surname",
//                 XmlElementNames.Surname,
//                 FieldUris.Surname,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.Title =
//             new StringPropertyDefinition(
//                 "Title",
//                 XmlElementNames.Title,
//                 FieldUris.Title,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.CompanyName =
//             new StringPropertyDefinition(
//                 "CompanyName",
//                 XmlElementNames.CompanyName,
//                 FieldUris.CompanyName,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.EmailAddress =
//             new ComplexPropertyDefinition<PersonaEmailAddress>(
//                 "EmailAddress",
//                 XmlElementNames.EmailAddress,
//                 FieldUris.EmailAddress,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new PersonaEmailAddress(); });


//         this.EmailAddresses =
//             new ComplexPropertyDefinition<PersonaEmailAddressCollection>(
//                 "EmailAddresses",
//                 XmlElementNames.EmailAddresses,
//                 FieldUris.EmailAddresses,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new PersonaEmailAddressCollection(); });


//         this.ImAddress =
//             new StringPropertyDefinition(
//                 "ImAddress",
//                 XmlElementNames.ImAddress,
//                 FieldUris.ImAddress,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.HomeCity =
//             new StringPropertyDefinition(
//                 "HomeCity",
//                 XmlElementNames.HomeCity,
//                 FieldUris.HomeCity,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.WorkCity =
//             new StringPropertyDefinition(
//                 "WorkCity",
//                 XmlElementNames.WorkCity,
//                 FieldUris.WorkCity,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.Alias =
//             new StringPropertyDefinition(
//                 "Alias",
//                 XmlElementNames.Alias,
//                 FieldUris.Alias,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);


//         this.RelevanceScore =
//             new IntPropertyDefinition(
//                 "RelevanceScore",
//                 XmlElementNames.RelevanceScore,
//                 FieldUris.RelevanceScore,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 true);


//         this.Attributions =
//             new ComplexPropertyDefinition<AttributionCollection>(
//                 "Attributions",
//                 XmlElementNames.Attributions,
//                 FieldUris.Attributions,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributionCollection(); });


//         this.OfficeLocations =
//             new ComplexPropertyDefinition<AttributedStringCollection>(
//                 "OfficeLocations",
//                 XmlElementNames.OfficeLocations,
//                 FieldUris.OfficeLocations,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributedStringCollection(); });


//         this.ImAddresses =
//             new ComplexPropertyDefinition<AttributedStringCollection>(
//                 "ImAddresses",
//                 XmlElementNames.ImAddresses,
//                 FieldUris.ImAddresses,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributedStringCollection(); });


//         this.Departments =
//             new ComplexPropertyDefinition<AttributedStringCollection>(
//                 "Departments",
//                 XmlElementNames.Departments,
//                 FieldUris.Departments,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributedStringCollection(); });


//         this.ThirdPartyPhotoUrls =
//             new ComplexPropertyDefinition<AttributedStringCollection>(
//                 "ThirdPartyPhotoUrls",
//                 XmlElementNames.ThirdPartyPhotoUrls,
//                 FieldUris.ThirdPartyPhotoUrls,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributedStringCollection(); });

//     }
// }

/**
 * Schemas - container for all schema objects
 */
export class Schemas {
    static AppointmentSchema: AppointmentSchema;
    static CalendarResponseObjectSchema: CalendarResponseObjectSchema;
    static CancelMeetingMessageSchema: CancelMeetingMessageSchema;
    static ContactGroupSchema: ContactGroupSchema;
    static ContactSchema: ContactSchema;
    static ConversationSchema: ConversationSchema;
    static EmailMessageSchema: EmailMessageSchema;
    static FolderSchema: FolderSchema;
    static ItemSchema: ItemSchema;
    static MeetingCancellationSchema: MeetingCancellationSchema;
    static MeetingMessageSchema: MeetingMessageSchema;
    static MeetingRequestSchema: MeetingRequestSchema;
    static MeetingResponseSchema: MeetingResponseSchema;
    static PostItemSchema: PostItemSchema;
    static PostReplySchema: PostReplySchema;
    static ResponseMessageSchema: ResponseMessageSchema;
    static ResponseObjectSchema: ResponseObjectSchema;
    static SearchFolderSchema: SearchFolderSchema;
    static ServiceObjectSchema: ServiceObjectSchema;
    static TaskSchema: TaskSchema;
    private static throwError(): any {
        throw "Bootstrapcode not initiated this Schema";
    }
}

/**
 * Represents the base class for all item and folder schemas.
 */
export abstract class ServiceObjectSchema implements IEnumerable<PropertyDefinition> {
    //todo: fixing difficulties with following c# code. - ref: added as delegate PropertyDefinitionDictionary in AltDictionary
    //using PropertyDefinitionDictionary = LazyMember < System.Collections.Generic.Dictionary<string, PropertyDefinitionBase>>;
    //type SchemaTypeList = LazyMember <string[]>;

    private properties: Dictionary<string, PropertyDefinition> = new Dictionary<string, PropertyDefinition>((key) => key);// System.Collections.Generic.Dictionary<TKey, TValue>;
    private visibleProperties: PropertyDefinition[] = [];//System.Collections.Generic.List<PropertyDefinition>;
    private firstClassProperties: PropertyDefinition[] = [];//System.Collections.Generic.List<PropertyDefinition>;
    private firstClassSummaryProperties: PropertyDefinition[] = [];//System.Collections.Generic.List<PropertyDefinition>;
    private indexedProperties: IndexedPropertyDefinition[] = [];//System.Collections.Generic.List<IndexedPropertyDefinition>;
    //static appointmentSchema: AppointmentSchema; - moved to Schemas

    /**
     * @internal Gets the list of first class properties for this service object type.
     */
    get FirstClassProperties(): PropertyDefinition[] { return this.firstClassProperties; }//System.Collections.Generic.List<PropertyDefinition>;

    /**
     * @internal Gets the list of first class summary properties for this service object type.
     */
    get FirstClassSummaryProperties(): PropertyDefinition[] { return this.firstClassSummaryProperties; }//System.Collections.Generic.List<PropertyDefinition>;

    /**
     * @internal Gets the list of indexed properties for this service object type.
     */
    get IndexedProperties(): IndexedPropertyDefinition[] { return this.indexedProperties; }//System.Collections.Generic.List<IndexedPropertyDefinition>;

    /**
     * Defines the **ExtendedProperties** property.
     */
    static ExtendedProperties: PropertyDefinition = new ComplexPropertyDefinition<ExtendedPropertyCollection>(
        "ExtendedProperties",
        XmlElementNames.ExtendedProperty,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.ReuseInstance | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new ExtendedPropertyCollection(); }
    );


    private static allSchemaProperties = new PropertyDefinitionDictionary((s) => s);

    //    private static lockObject: any = {};
    //    private static allSchemaTypes: LazyMember<string[]> = new LazyMember<string[]>(() => { //SchemaTypeList - LazyMember<T>; - using typenames[] temporarily
    //        var typeList: string[] = [];
    //        return typeList;
    //        typeList.push("AppointmentSchema");
    //        typeList.push("CalendarResponseObjectSchema");
    //        typeList.push("CancelMeetingMessageSchema");
    //        typeList.push("ContactGroupSchema");
    //        typeList.push("ContactSchema");
    //        typeList.push("ConversationSchema");
    //        typeList.push("EmailMessageSchema");
    //        typeList.push("FolderSchema");
    //        typeList.push("ItemSchema");
    //        typeList.push("MeetingMessageSchema");
    //        typeList.push("MeetingRequestSchema");
    //        typeList.push("MeetingCancellationSchema");
    //        typeList.push("MeetingResponseSchema");
    //        typeList.push("PostItemSchema");
    //        typeList.push("PostReplySchema");
    //        typeList.push("ResponseMessageSchema");
    //        typeList.push("ResponseObjectSchema");
    //        typeList.push("ServiceObjectSchema");
    //        typeList.push("SearchFolderSchema");
    //        typeList.push("TaskSchema");
    //
    //        return typeList;
    //    });
    //    
    ////    private static allSchemaTypes: LazyMember<any[]> = new LazyMember<any[]>(() => { //SchemaTypeList - LazyMember<T>; - using typenames[] temporarily
    ////        var typeList: any[] = [];
    ////        return typeList;
    ////        typeList.push(AppointmentSchema);
    ////        typeList.push(CalendarResponseObjectSchema);
    ////        typeList.push(CancelMeetingMessageSchema);
    ////        typeList.push(ContactGroupSchema);
    ////        typeList.push(ContactSchema);
    ////        typeList.push(ConversationSchema);
    ////        typeList.push(EmailMessageSchema);
    ////        typeList.push(FolderSchema);
    ////        typeList.push(ItemSchema);
    ////        typeList.push(MeetingMessageSchema);
    ////        typeList.push(MeetingRequestSchema);
    ////        typeList.push(MeetingCancellationSchema);
    ////        typeList.push(MeetingResponseSchema);
    ////        typeList.push(PostItemSchema);
    ////        typeList.push(PostReplySchema);
    ////        typeList.push(ResponseMessageSchema);
    ////        typeList.push(ResponseObjectSchema);
    ////        typeList.push(ServiceObjectSchema);
    ////        typeList.push(SearchFolderSchema);
    ////        typeList.push(TaskSchema);
    ////
    ////        return typeList;
    ////    });
    //    private static allSchemaProperties = new LazyMember<StringPropertyDefinitionBaseDictionary<string, PropertyDefinitionBase>>(()=> {// string[] //LazyMember<T>;PropertyDefinitionDictionary => LazyMember<System.Collections.Generic.Dictionary<string, PropertyDefinitionBase>>;
    //        var propDefDictionary: StringPropertyDefinitionBaseDictionary<string, PropertyDefinitionBase> = new StringPropertyDefinitionBaseDictionary<string, PropertyDefinitionBase>();
    //        for (var type of ServiceObjectSchema.allSchemaTypes.Member) {
    //            //var type: string = item;
    //            ServiceObjectSchema.AddSchemaPropertiesToDictionary(type, propDefDictionary);
    //        }
    //        
    //        return propDefDictionary;
    //    });
    //    static AddSchemaPropertiesToDictionary(type: string /*System.Type*/, propDefDictionary: StringPropertyDefinitionBaseDictionary<string, PropertyDefinitionBase> /*System.Collections.Generic.Dictionary<TKey, TValue>*/): void {
    //        ServiceObjectSchema.ForeachPublicStaticPropertyFieldInType(
    //            type,
    //            (propertyDefinition: PropertyDefinition, fieldName: string) => {
    //                // Some property definitions descend from ServiceObjectPropertyDefinition but don't have
    //                // a Uri, like ExtendedProperties. Ignore them.
    //                if (!StringHelper.IsNullOrEmpty(propertyDefinition.Uri)) {
    //                    var existingPropertyDefinition: IOutParam<PropertyDefinitionBase> = { outValue: null };
    //                    if (propDefDictionary.tryGetValue(propertyDefinition.Uri, existingPropertyDefinition)) {
    //                        EwsLogging.Assert(
    //                            existingPropertyDefinition == propertyDefinition,
    //                            "Schema.allSchemaProperties.delegate",
    //                            StringHelper.Format("There are at least two distinct property definitions with the following URI: {0}", propertyDefinition.Uri));
    //                    }
    //                    else {
    //                        propDefDictionary.add(propertyDefinition.Uri, propertyDefinition);
    //
    //                        // The following is a "generic hack" to register properties that are not public and
    //                        // thus not returned by the above GetFields call. It is currently solely used to register
    //                        // the MeetingTimeZone property.
    //                        var associatedInternalProperties: PropertyDefinition[] = propertyDefinition.GetAssociatedInternalProperties();
    //
    //                        for (var associatedInternalProperty of associatedInternalProperties) {
    //                            //var associatedInternalProperty: PropertyDefinition = item;
    //                            propDefDictionary.add(associatedInternalProperty.Uri, associatedInternalProperty);
    //                        }
    //                    }
    //                }
    //            });
    //    }
    //    private static AddSchemaPropertyNamesToDictionary(type: string /*System.Type*/, propertyNameDictionary: PropDictionary<PropertyDefinition, string>  /*System.Collections.Generic.Dictionary<TKey, TValue>*/): void {
    //        ServiceObjectSchema.ForeachPublicStaticPropertyFieldInType(
    //            type,
    //            (propertyDefinition: PropertyDefinition, fieldName: string) =>
    //            { propertyNameDictionary.add(propertyDefinition, fieldName); });
    //    }

    /**
     * @internal Finds the property definition.
     *
     * @param   {string}   uri   The URI.
     * @return  {PropertyDefinitionBase}    Property definition.
     */
    static FindPropertyDefinition(uri: string): PropertyDefinitionBase {
        return ServiceObjectSchema.allSchemaProperties.get(uri);
    }

    //    static ForeachPublicStaticPropertyFieldInType(type: string /*System.Type*/, propFieldDelegate: (propertyDefinition: PropertyDefinition, fieldInfo: any /*FieldInfo*/) => void /*ServiceObjectSchema.PropertyFieldInfoDelegate*/): void {
    //        
    //        var keys = Object.keys(type);
    //        keys.forEach((s) => {
    //            if (typeof (type[s]) != "function" && type[s] instanceof (PropertyDefinition)) {
    //                var propertyDefinition = <PropertyDefinition> type[s];
    //                propFieldDelegate(propertyDefinition, s);
    //            }
    //        });
    //        //var staticfields = TypeSystem.GetObjectStaticPropertiesByClassName("Microsoft.Exchange.WebServices.Data." + type);
    //
    //        //for (var field in staticfields) {
    //        //    if (fieldInfo.FieldType == typeof (PropertyDefinition) || fieldInfo.FieldType.IsSubclassOf(typeof (PropertyDefinition))) {
    //        //        PropertyDefinition propertyDefinition = (PropertyDefinition) fieldInfo.GetValue(null);
    //        //        propFieldDelegate(propertyDefinition, fieldInfo);
    //        //    }
    //        //}
    //    }
    //    static InitializeSchemaPropertyNames(): void {
    //        
    //        //lock(lockObject)
    //        //{
    //        for (var type of ServiceObjectSchema.allSchemaTypes.Member) {
    //            //var type: string = item;
    //            ServiceObjectSchema.ForeachPublicStaticPropertyFieldInType(
    //                type,
    //                (propDef: PropertyDefinition, fieldName: string) => { propDef.Name = fieldName; });
    //        }
    //        //}
    //    }

    /**
     * @internal Initializes a new instance of the **ServiceObjectSchema** class.
     */
    constructor() {
        this.RegisterProperties();
    }

    /**
     *  Returns an enumerator that iterates through the collection. this case this.visibleProperties
     */
    GetEnumerator(): PropertyDefinition[] {
        return this.visibleProperties;
    }

    protected init() { }

    /**
     * @internal Registers an indexed property.
     *
     * @param   {IndexedPropertyDefinition}   indexedProperty   The indexed property to register.
     */
    RegisterIndexedProperty(indexedProperty: IndexedPropertyDefinition): void { this.indexedProperties.push(indexedProperty); }

    /**
     * @internal Registers an internal schema property.
     *
     * @param   {any}                   registeringSchemaClass     SchemaClass calling this method - workaround for fieldUri registration oterhwise it registers super/parent class static properties as well. TypeScript does not provide a way to detect inherited property, hasOwnProperty returns true for parent static property
     * @param   {PropertyDefinition}   property   The property to register.
     */
    RegisterInternalProperty(registeringSchemaClass: any, property: PropertyDefinition): void { this.RegisterProperty(registeringSchemaClass, property, true); }

    /**
     * @internal Registers properties.
     * 
     * /remarks/ IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {/** Virtual */ }

    /**
     * @internal Registers a schema property. - workaround for fieldUri registration oterhwise it registers super/parent class static properties as well. TypeScript does not provide a way to detect inherited property, hasOwnProperty returns true
     *
     * @param   {any}                   registeringSchemaClass     SchemaClass calling this method - workaround for fieldUri registration oterhwise it registers super/parent class static properties as well. TypeScript does not provide a way to detect inherited property, hasOwnProperty returns true for parent static property
     * @param   {PropertyDefinition}    property     The property to register.
     */
    RegisterProperty(registeringSchemaClass: any, property: PropertyDefinition): void;
    /**
     * @private Registers a schema property.
     *
     * @param   {any}                   registeringSchemaClass     SchemaClass calling this method - workaround for fieldUri registration oterhwise it registers super/parent class static properties as well. TypeScript does not provide a way to detect inherited property, hasOwnProperty returns true for parent static property
     * @param   {PropertyDefinition}   property     The property to register.
     * @param   {boolean}   isInternal   Indicates whether the property is internal or should be visible to developers.
     */
    RegisterProperty(registeringSchemaClass: any, property: PropertyDefinition, isInternal: boolean): void;
    RegisterProperty(registeringSchemaClass: any, property: PropertyDefinition, isInternal: boolean = false): void {
        this.properties.Add(property.XmlElementName, property);
        if (!StringHelper.IsNullOrEmpty(property.Uri) && registeringSchemaClass === this.constructor) {
            if (ServiceObjectSchema.allSchemaProperties.containsKey(property.Uri)) {
                EwsLogging.Assert(
                    ServiceObjectSchema.allSchemaProperties.get(property.Uri) == property,
                    "Schema.allSchemaProperties.delegate",
                    StringHelper.Format("There are at least two distinct property definitions with the following URI: {0}", property.Uri));
            }
            else {
                ServiceObjectSchema.allSchemaProperties.Add(property.Uri, property);
            }
        }
        if (!isInternal) {
            this.visibleProperties.push(property);
        }

        // If this property does not have to be requested explicitly, add
        // it to the list of firstClassProperties.
        if (!property.HasFlag(PropertyDefinitionFlags.MustBeExplicitlyLoaded)) {
            this.firstClassProperties.push(property);
        }

        // If this property can be found, add it to the list of firstClassSummaryProperties
        if (property.HasFlag(PropertyDefinitionFlags.CanFind)) {
            this.firstClassSummaryProperties.push(property);
        }
    }

    /**
     * @internal Tries to get property definition.
     *
     * @param   {string}   xmlElementName           Name of the XML element.
     * @param   {IOutParam<PropertyDefinition>}     propertyDefinition   The property definition.
     * @return  {boolean}                           True if property definition exists.
     */
    TryGetPropertyDefinition(xmlElementName: string, propertyDefinition: IOutParam<PropertyDefinition>): boolean {
        return this.properties.tryGetValue(xmlElementName, propertyDefinition);
    }
}

/**
 * Represents the base class for all item and folder schemas.
 */
export interface ServiceObjectSchema {

    /**
     * Defines the **ExtendedProperties** property.
     */
    ExtendedProperties: PropertyDefinition;

    /**
     * @internal Finds the property definition.
     *
     * @param   {string}   uri   The URI.
     * @return  {PropertyDefinitionBase}    Property definition.
     */
    FindPropertyDefinition(uri: string): PropertyDefinitionBase;
}

/**
 * Represents the base class for all item and folder schemas.
 */
export interface ServiceObjectSchemaStatic extends ServiceObjectSchema {
}
Schemas.ServiceObjectSchema = <any>ServiceObjectSchema;


/**
 * Field URIs for Conversation.
 */
module FieldUris {
    export var ConversationId: string = "conversation:ConversationId";
    export var ConversationTopic: string = "conversation:ConversationTopic";
    export var UniqueRecipients: string = "conversation:UniqueRecipients";
    export var GlobalUniqueRecipients: string = "conversation:GlobalUniqueRecipients";
    export var UniqueUnreadSenders: string = "conversation:UniqueUnreadSenders";
    export var GlobalUniqueUnreadSenders: string = "conversation:GlobalUniqueUnreadSenders";
    export var UniqueSenders: string = "conversation:UniqueSenders";
    export var GlobalUniqueSenders: string = "conversation:GlobalUniqueSenders";
    export var LastDeliveryTime: string = "conversation:LastDeliveryTime";
    export var GlobalLastDeliveryTime: string = "conversation:GlobalLastDeliveryTime";
    export var Categories: string = "conversation:Categories";
    export var GlobalCategories: string = "conversation:GlobalCategories";
    export var FlagStatus: string = "conversation:FlagStatus";
    export var GlobalFlagStatus: string = "conversation:GlobalFlagStatus";
    export var HasAttachments: string = "conversation:HasAttachments";
    export var GlobalHasAttachments: string = "conversation:GlobalHasAttachments";
    export var MessageCount: string = "conversation:MessageCount";
    export var GlobalMessageCount: string = "conversation:GlobalMessageCount";
    export var UnreadCount: string = "conversation:UnreadCount";
    export var GlobalUnreadCount: string = "conversation:GlobalUnreadCount";
    export var Size: string = "conversation:Size";
    export var GlobalSize: string = "conversation:GlobalSize";
    export var ItemClasses: string = "conversation:ItemClasses";
    export var GlobalItemClasses: string = "conversation:GlobalItemClasses";
    export var Importance: string = "conversation:Importance";
    export var GlobalImportance: string = "conversation:GlobalImportance";
    export var ItemIds: string = "conversation:ItemIds";
    export var GlobalItemIds: string = "conversation:GlobalItemIds";
    export var LastModifiedTime: string = "conversation:LastModifiedTime";
    export var InstanceKey: string = "conversation:InstanceKey";
    export var Preview: string = "conversation:Preview";
    export var IconIndex: string = "conversation:IconIndex";
    export var GlobalIconIndex: string = "conversation:GlobalIconIndex";
    export var DraftItemIds: string = "conversation:DraftItemIds";
    export var HasIrm: string = "conversation:HasIrm";
    export var GlobalHasIrm: string = "conversation:GlobalHasIrm";
}

/**
 * Represents the schema for Conversation.
 */
export class ConversationSchema extends ServiceObjectSchema {

    /**
     * Defines the **Id** property.
     */
    public static Id: PropertyDefinition = new ComplexPropertyDefinition<ConversationId>(
        "ConversationId",
        XmlElementNames.ConversationId,
        FieldUris.ConversationId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new ConversationId(); }
    );

    /**
     * Defines the **Topic** property.
     */
    public static Topic: PropertyDefinition = new StringPropertyDefinition(
        "ConversationTopic",
        XmlElementNames.ConversationTopic,
        FieldUris.ConversationTopic,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **UniqueRecipients** property.
     */
    public static UniqueRecipients: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "UniqueRecipients",
        XmlElementNames.UniqueRecipients,
        FieldUris.UniqueRecipients,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **GlobalUniqueRecipients** property.
     */
    public static GlobalUniqueRecipients: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "GlobalUniqueRecipients",
        XmlElementNames.GlobalUniqueRecipients,
        FieldUris.GlobalUniqueRecipients,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **UniqueUnreadSenders** property.
     */
    public static UniqueUnreadSenders: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "UniqueUnreadSenders",
        XmlElementNames.UniqueUnreadSenders,
        FieldUris.UniqueUnreadSenders,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **GlobalUniqueUnreadSenders** property.
     */
    public static GlobalUniqueUnreadSenders: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "GlobalUniqueUnreadSenders",
        XmlElementNames.GlobalUniqueUnreadSenders,
        FieldUris.GlobalUniqueUnreadSenders,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **UniqueSenders** property.
     */
    public static UniqueSenders: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "UniqueSenders",
        XmlElementNames.UniqueSenders,
        FieldUris.UniqueSenders,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **GlobalUniqueSenders** property.
     */
    public static GlobalUniqueSenders: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "GlobalUniqueSenders",
        XmlElementNames.GlobalUniqueSenders,
        FieldUris.GlobalUniqueSenders,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **LastDeliveryTime** property.
     */
    public static LastDeliveryTime: PropertyDefinition = new DateTimePropertyDefinition(
        "LastDeliveryTime",
        XmlElementNames.LastDeliveryTime,
        FieldUris.LastDeliveryTime,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **GlobalLastDeliveryTime** property.
     */
    public static GlobalLastDeliveryTime: PropertyDefinition = new DateTimePropertyDefinition(
        "GlobalLastDeliveryTime",
        XmlElementNames.GlobalLastDeliveryTime,
        FieldUris.GlobalLastDeliveryTime,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **Categories** property.
     */
    public static Categories: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "Categories",
        XmlElementNames.Categories,
        FieldUris.Categories,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **GlobalCategories** property.
     */
    public static GlobalCategories: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "GlobalCategories",
        XmlElementNames.GlobalCategories,
        FieldUris.GlobalCategories,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **FlagStatus** property.
     */
    public static FlagStatus: PropertyDefinition = new GenericPropertyDefinition<ConversationFlagStatus>(
        "FlagStatus",
        XmlElementNames.FlagStatus,
        FieldUris.FlagStatus,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        ConversationFlagStatus
    );

    /**
     * Defines the **GlobalFlagStatus** property.
     */
    public static GlobalFlagStatus: PropertyDefinition = new GenericPropertyDefinition<ConversationFlagStatus>(
        "GlobalFlagStatus",
        XmlElementNames.GlobalFlagStatus,
        FieldUris.GlobalFlagStatus,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        ConversationFlagStatus
    );

    /**
     * Defines the **HasAttachments** property.
     */
    public static HasAttachments: PropertyDefinition = new BoolPropertyDefinition(
        "HasAttachments",
        XmlElementNames.HasAttachments,
        FieldUris.HasAttachments,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **GlobalHasAttachments** property.
     */
    public static GlobalHasAttachments: PropertyDefinition = new BoolPropertyDefinition(
        "GlobalHasAttachments",
        XmlElementNames.GlobalHasAttachments,
        FieldUris.GlobalHasAttachments,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **MessageCount** property.
     */
    public static MessageCount: PropertyDefinition = new IntPropertyDefinition(
        "MessageCount",
        XmlElementNames.MessageCount,
        FieldUris.MessageCount,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **GlobalMessageCount** property.
     */
    public static GlobalMessageCount: PropertyDefinition = new IntPropertyDefinition(
        "GlobalMessageCount",
        XmlElementNames.GlobalMessageCount,
        FieldUris.GlobalMessageCount,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **UnreadCount** property.
     */
    public static UnreadCount: PropertyDefinition = new IntPropertyDefinition(
        "UnreadCount",
        XmlElementNames.UnreadCount,
        FieldUris.UnreadCount,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **GlobalUnreadCount** property.
     */
    public static GlobalUnreadCount: PropertyDefinition = new IntPropertyDefinition(
        "GlobalUnreadCount",
        XmlElementNames.GlobalUnreadCount,
        FieldUris.GlobalUnreadCount,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **Size** property.
     */
    public static Size: PropertyDefinition = new IntPropertyDefinition(
        "Size",
        XmlElementNames.Size,
        FieldUris.Size,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **GlobalSize** property.
     */
    public static GlobalSize: PropertyDefinition = new IntPropertyDefinition(
        "GlobalSize",
        XmlElementNames.GlobalSize,
        FieldUris.GlobalSize,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **ItemClasses** property.
     */
    public static ItemClasses: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "ItemClasses",
        XmlElementNames.ItemClasses,
        FieldUris.ItemClasses,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList("ItemClass"); }
    );

    /**
     * Defines the **GlobalItemClasses** property.
     */
    public static GlobalItemClasses: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "GlobalItemClasses",
        XmlElementNames.GlobalItemClasses,
        FieldUris.GlobalItemClasses,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new StringList("ItemClass"); }
    );

    /**
     * Defines the **Importance** property.
     */
    public static Importance: PropertyDefinition = new GenericPropertyDefinition<Importance>(
        "Importance",
        XmlElementNames.Importance,
        FieldUris.Importance,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        Importance
    );

    /**
     * Defines the **GlobalImportance** property.
     */
    public static GlobalImportance: PropertyDefinition = new GenericPropertyDefinition<Importance>(
        "GlobalImportance",
        XmlElementNames.GlobalImportance,
        FieldUris.GlobalImportance,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        Importance
    );

    /**
     * Defines the **ItemIds** property.
     */
    public static ItemIds: PropertyDefinition = new ComplexPropertyDefinition<ItemIdCollection>(
        "ItemIds",
        XmlElementNames.ItemIds,
        FieldUris.ItemIds,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new ItemIdCollection(); }
    );

    /**
     * Defines the **GlobalItemIds** property.
     */
    public static GlobalItemIds: PropertyDefinition = new ComplexPropertyDefinition<ItemIdCollection>(
        "GlobalItemIds",
        XmlElementNames.GlobalItemIds,
        FieldUris.GlobalItemIds,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new ItemIdCollection(); }
    );

    /**
     * Defines the **LastModifiedTime** property.
     */
    public static LastModifiedTime: PropertyDefinition = new DateTimePropertyDefinition(
        "LastModifiedTime",
        XmlElementNames.LastModifiedTime,
        FieldUris.LastModifiedTime,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013
    );

    /**
     * Defines the **InstanceKey** property.
     */
    public static InstanceKey: PropertyDefinition = new ByteArrayPropertyDefinition(
        "InstanceKey",
        XmlElementNames.InstanceKey,
        FieldUris.InstanceKey,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013
    );

    /**
     * Defines the **Preview** property.
     */
    public static Preview: PropertyDefinition = new StringPropertyDefinition(
        "Preview",
        XmlElementNames.Preview,
        FieldUris.Preview,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013
    );

    /**
     * Defines the **IconIndex** property.
     */
    public static IconIndex: PropertyDefinition = new GenericPropertyDefinition<IconIndex>(
        "IconIndex",
        XmlElementNames.IconIndex,
        FieldUris.IconIndex,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        IconIndex
    );

    /**
     * Defines the **GlobalIconIndex** property.
     */
    public static GlobalIconIndex: PropertyDefinition = new GenericPropertyDefinition<IconIndex>(
        "GlobalIconIndex",
        XmlElementNames.GlobalIconIndex,
        FieldUris.GlobalIconIndex,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        IconIndex
    );

    /**
     * Defines the **DraftItemIds** property.
     */
    public static DraftItemIds: PropertyDefinition = new ComplexPropertyDefinition<ItemIdCollection>(
        "DraftItemIds",
        XmlElementNames.DraftItemIds,
        FieldUris.DraftItemIds,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        () => { return new ItemIdCollection(); }
    );

    /**
     * Defines the **HasIrm** property.
     */
    public static HasIrm: PropertyDefinition = new BoolPropertyDefinition(
        "HasIrm",
        XmlElementNames.HasIrm,
        FieldUris.HasIrm,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013
    );

    /**
     * Defines the **GlobalHasIrm** property.
     */
    public static GlobalHasIrm: PropertyDefinition = new BoolPropertyDefinition(
        "GlobalHasIrm",
        XmlElementNames.GlobalHasIrm,
        FieldUris.GlobalHasIrm,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013
    );

    /**
     * @internal Instance of **ConversationSchema** 
     */
    static Instance: ConversationSchema = new ConversationSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(ConversationSchema, ConversationSchema.Id);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Topic);
        this.RegisterProperty(ConversationSchema, ConversationSchema.UniqueRecipients);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalUniqueRecipients);
        this.RegisterProperty(ConversationSchema, ConversationSchema.UniqueUnreadSenders);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalUniqueUnreadSenders);
        this.RegisterProperty(ConversationSchema, ConversationSchema.UniqueSenders);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalUniqueSenders);
        this.RegisterProperty(ConversationSchema, ConversationSchema.LastDeliveryTime);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalLastDeliveryTime);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Categories);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalCategories);
        this.RegisterProperty(ConversationSchema, ConversationSchema.FlagStatus);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalFlagStatus);
        this.RegisterProperty(ConversationSchema, ConversationSchema.HasAttachments);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalHasAttachments);
        this.RegisterProperty(ConversationSchema, ConversationSchema.MessageCount);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalMessageCount);
        this.RegisterProperty(ConversationSchema, ConversationSchema.UnreadCount);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalUnreadCount);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Size);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalSize);
        this.RegisterProperty(ConversationSchema, ConversationSchema.ItemClasses);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalItemClasses);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Importance);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalImportance);
        this.RegisterProperty(ConversationSchema, ConversationSchema.ItemIds);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalItemIds);
        this.RegisterProperty(ConversationSchema, ConversationSchema.LastModifiedTime);
        this.RegisterProperty(ConversationSchema, ConversationSchema.InstanceKey);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Preview);
        this.RegisterProperty(ConversationSchema, ConversationSchema.IconIndex);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalIconIndex);
        this.RegisterProperty(ConversationSchema, ConversationSchema.DraftItemIds);
        this.RegisterProperty(ConversationSchema, ConversationSchema.HasIrm);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalHasIrm);
    }
}

/**
 * Represents the schema for Conversation.
 */
export interface ConversationSchema {
    /**
     * Defines the **Id** property.
     */
    Id: PropertyDefinition;
    /**
     * Defines the **Topic** property.
     */
    Topic: PropertyDefinition;
    /**
     * Defines the **UniqueRecipients** property.
     */
    UniqueRecipients: PropertyDefinition;
    /**
     * Defines the **GlobalUniqueRecipients** property.
     */
    GlobalUniqueRecipients: PropertyDefinition;
    /**
     * Defines the **UniqueUnreadSenders** property.
     */
    UniqueUnreadSenders: PropertyDefinition;
    /**
     * Defines the **GlobalUniqueUnreadSenders** property.
     */
    GlobalUniqueUnreadSenders: PropertyDefinition;
    /**
     * Defines the **UniqueSenders** property.
     */
    UniqueSenders: PropertyDefinition;
    /**
     * Defines the **GlobalUniqueSenders** property.
     */
    GlobalUniqueSenders: PropertyDefinition;
    /**
     * Defines the **LastDeliveryTime** property.
     */
    LastDeliveryTime: PropertyDefinition;
    /**
     * Defines the **GlobalLastDeliveryTime** property.
     */
    GlobalLastDeliveryTime: PropertyDefinition;
    /**
     * Defines the **Categories** property.
     */
    Categories: PropertyDefinition;
    /**
     * Defines the **GlobalCategories** property.
     */
    GlobalCategories: PropertyDefinition;
    /**
     * Defines the **FlagStatus** property.
     */
    FlagStatus: PropertyDefinition;
    /**
     * Defines the **GlobalFlagStatus** property.
     */
    GlobalFlagStatus: PropertyDefinition;
    /**
     * Defines the **HasAttachments** property.
     */
    HasAttachments: PropertyDefinition;
    /**
     * Defines the **GlobalHasAttachments** property.
     */
    GlobalHasAttachments: PropertyDefinition;
    /**
     * Defines the **MessageCount** property.
     */
    MessageCount: PropertyDefinition;
    /**
     * Defines the **GlobalMessageCount** property.
     */
    GlobalMessageCount: PropertyDefinition;
    /**
     * Defines the **UnreadCount** property.
     */
    UnreadCount: PropertyDefinition;
    /**
     * Defines the **GlobalUnreadCount** property.
     */
    GlobalUnreadCount: PropertyDefinition;
    /**
     * Defines the **Size** property.
     */
    Size: PropertyDefinition;
    /**
     * Defines the **GlobalSize** property.
     */
    GlobalSize: PropertyDefinition;
    /**
     * Defines the **ItemClasses** property.
     */
    ItemClasses: PropertyDefinition;
    /**
     * Defines the **GlobalItemClasses** property.
     */
    GlobalItemClasses: PropertyDefinition;
    /**
     * Defines the **Importance** property.
     */
    Importance: PropertyDefinition;
    /**
     * Defines the **GlobalImportance** property.
     */
    GlobalImportance: PropertyDefinition;
    /**
     * Defines the **ItemIds** property.
     */
    ItemIds: PropertyDefinition;
    /**
     * Defines the **GlobalItemIds** property.
     */
    GlobalItemIds: PropertyDefinition;
    /**
     * Defines the **LastModifiedTime** property.
     */
    LastModifiedTime: PropertyDefinition;
    /**
     * Defines the **InstanceKey** property.
     */
    InstanceKey: PropertyDefinition;
    /**
     * Defines the **Preview** property.
     */
    Preview: PropertyDefinition;
    /**
     * Defines the **IconIndex** property.
     */
    IconIndex: PropertyDefinition;
    /**
     * Defines the **GlobalIconIndex** property.
     */
    GlobalIconIndex: PropertyDefinition;
    /**
     * Defines the **DraftItemIds** property.
     */
    DraftItemIds: PropertyDefinition;
    /**
     * Defines the **HasIrm** property.
     */
    HasIrm: PropertyDefinition;
    /**
     * Defines the **GlobalHasIrm** property.
     */
    GlobalHasIrm: PropertyDefinition;
    /**
     * @internal Instance of **ConversationSchema**
     */
    Instance: ConversationSchema;
}

/**
 * Represents the schema for Conversation.
 */
export interface ConversationSchemaStatic extends ConversationSchema {
}
Schemas.ConversationSchema = <any>ConversationSchema;


/**
 * Field URIs for folders.
 */
module FieldUris {
    export var FolderId: string = "folder:FolderId";
    export var ParentFolderId: string = "folder:ParentFolderId";
    export var DisplayName: string = "folder:DisplayName";
    export var UnreadCount: string = "folder:UnreadCount";
    export var TotalCount: string = "folder:TotalCount";
    export var ChildFolderCount: string = "folder:ChildFolderCount";
    export var FolderClass: string = "folder:FolderClass";
    export var ManagedFolderInformation: string = "folder:ManagedFolderInformation";
    export var EffectiveRights: string = "folder:EffectiveRights";
    export var PermissionSet: string = "folder:PermissionSet";
    export var PolicyTag: string = "folder:PolicyTag";
    export var ArchiveTag: string = "folder:ArchiveTag";
    export var DistinguishedFolderId: string = "folder:DistinguishedFolderId";
}

/**
 * Represents the schema for folders.
 */
export class FolderSchema extends ServiceObjectSchema {

    /**
     * Defines the **Id** property.
     */
    public static Id: PropertyDefinition = new ComplexPropertyDefinition<FolderId>(
        "Id",
        XmlElementNames.FolderId,
        FieldUris.FolderId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new FolderId(); }
    );

    /**
     * Defines the **FolderClass** property.
     */
    public static FolderClass: PropertyDefinition = new StringPropertyDefinition(
        "FolderClass",
        XmlElementNames.FolderClass,
        FieldUris.FolderClass,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ParentFolderId** property.
     */
    public static ParentFolderId: PropertyDefinition = new ComplexPropertyDefinition<FolderId>(
        "ParentFolderId",
        XmlElementNames.ParentFolderId,
        FieldUris.ParentFolderId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new FolderId(); }
    );

    /**
     * Defines the **ChildFolderCount** property.
     */
    public static ChildFolderCount: PropertyDefinition = new IntPropertyDefinition(
        "ChildFolderCount",
        XmlElementNames.ChildFolderCount,
        FieldUris.ChildFolderCount,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **DisplayName** property.
     */
    public static DisplayName: PropertyDefinition = new StringPropertyDefinition(
        "DisplayName",
        XmlElementNames.DisplayName,
        FieldUris.DisplayName,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **UnreadCount** property.
     */
    public static UnreadCount: PropertyDefinition = new IntPropertyDefinition(
        "UnreadCount",
        XmlElementNames.UnreadCount,
        FieldUris.UnreadCount,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **TotalCount** property.
     */
    public static TotalCount: PropertyDefinition = new IntPropertyDefinition(
        "TotalCount",
        XmlElementNames.TotalCount,
        FieldUris.TotalCount,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ManagedFolderInformation** property.
     */
    public static ManagedFolderInformation: PropertyDefinition = new ComplexPropertyDefinition<ManagedFolderInformation>(
        "ManagedFolderInformation",
        XmlElementNames.ManagedFolderInformation,
        FieldUris.ManagedFolderInformation,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new ManagedFolderInformation(); }
    );

    /**
     * Defines the **EffectiveRights** property.
     */
    public static EffectiveRights: PropertyDefinition = new EffectiveRightsPropertyDefinition(
        "EffectiveRights",
        XmlElementNames.EffectiveRights,
        FieldUris.EffectiveRights,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Permissions** property.
     */
    public static Permissions: PropertyDefinition = new PermissionSetPropertyDefinition(
        "Permissions",
        XmlElementNames.PermissionSet,
        FieldUris.PermissionSet,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.MustBeExplicitlyLoaded,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **WellKnownFolderName** property.
     */
    public static WellKnownFolderName: PropertyDefinition = new GenericPropertyDefinition<WellKnownFolderName>(
        "WellKnownFolderName",
        XmlElementNames.DistinguishedFolderId,
        FieldUris.DistinguishedFolderId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        WellKnownFolderName
    );

    /**
     * Defines the **PolicyTag** property.
     */
    public static PolicyTag: PropertyDefinition = new ComplexPropertyDefinition<PolicyTag>(
        "PolicyTag",
        XmlElementNames.PolicyTag,
        FieldUris.PolicyTag,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        () => { return new PolicyTag(); }
    );

    /**
     * Defines the **ArchiveTag** property.
     */
    public static ArchiveTag: PropertyDefinition = new ComplexPropertyDefinition<ArchiveTag>(
        "ArchiveTag",
        XmlElementNames.ArchiveTag,
        FieldUris.ArchiveTag,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        () => { return new ArchiveTag(); }
    );

    /**
     * @internal Instance of **FolderSchema** 
     */
    static Instance: FolderSchema = new FolderSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(FolderSchema, FolderSchema.Id);
        this.RegisterProperty(FolderSchema, FolderSchema.ParentFolderId);
        this.RegisterProperty(FolderSchema, FolderSchema.FolderClass);
        this.RegisterProperty(FolderSchema, FolderSchema.DisplayName);
        this.RegisterProperty(FolderSchema, FolderSchema.TotalCount);
        this.RegisterProperty(FolderSchema, FolderSchema.ChildFolderCount);
        this.RegisterProperty(FolderSchema, ServiceObjectSchema.ExtendedProperties);
        this.RegisterProperty(FolderSchema, FolderSchema.ManagedFolderInformation);
        this.RegisterProperty(FolderSchema, FolderSchema.EffectiveRights);
        this.RegisterProperty(FolderSchema, FolderSchema.Permissions);
        this.RegisterProperty(FolderSchema, FolderSchema.UnreadCount);
        this.RegisterProperty(FolderSchema, FolderSchema.WellKnownFolderName);
        this.RegisterProperty(FolderSchema, FolderSchema.PolicyTag);
        this.RegisterProperty(FolderSchema, FolderSchema.ArchiveTag);
    }
}

/**
 * Represents the schema for folders.
 */
export interface FolderSchema {
    /**
     * Defines the **Id** property.
     */
    Id: PropertyDefinition;
    /**
     * Defines the **FolderClass** property.
     */
    FolderClass: PropertyDefinition;
    /**
     * Defines the **ParentFolderId** property.
     */
    ParentFolderId: PropertyDefinition;
    /**
     * Defines the **ChildFolderCount** property.
     */
    ChildFolderCount: PropertyDefinition;
    /**
     * Defines the **DisplayName** property.
     */
    DisplayName: PropertyDefinition;
    /**
     * Defines the **UnreadCount** property.
     */
    UnreadCount: PropertyDefinition;
    /**
     * Defines the **TotalCount** property.
     */
    TotalCount: PropertyDefinition;
    /**
     * Defines the **ManagedFolderInformation** property.
     */
    ManagedFolderInformation: PropertyDefinition;
    /**
     * Defines the **EffectiveRights** property.
     */
    EffectiveRights: PropertyDefinition;
    /**
     * Defines the **Permissions** property.
     */
    Permissions: PropertyDefinition;
    /**
     * Defines the **WellKnownFolderName** property.
     */
    WellKnownFolderName: PropertyDefinition;
    /**
     * Defines the **PolicyTag** property.
     */
    PolicyTag: PropertyDefinition;
    /**
     * Defines the **ArchiveTag** property.
     */
    ArchiveTag: PropertyDefinition;
    /**
     * @internal Instance of **FolderSchema**
     */
    Instance: FolderSchema;
}

/**
 * Represents the schema for folders.
 */
export interface FolderSchemaStatic extends FolderSchema {
}
Schemas.FolderSchema = <any>FolderSchema;


/**
 * Field URIs for search folders.
 */
module FieldUris {
    export var SearchParameters: string = "folder:SearchParameters";
}

/**
 * Represents the schema for search folders.
 */
export class SearchFolderSchema extends FolderSchema {

    /**
     * Defines the **SearchParameters** property.
     */
    public static SearchParameters: PropertyDefinition = new ComplexPropertyDefinition<SearchFolderParameters>(
        "SearchParameters",
        XmlElementNames.SearchParameters,
        FieldUris.SearchParameters,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new SearchFolderParameters(); }
    );

    /**
     * @internal Instance of **SearchFolderSchema** 
     */
    static Instance: SearchFolderSchema = new SearchFolderSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(SearchFolderSchema, SearchFolderSchema.SearchParameters);
    }
}

/**
 * Represents the schema for search folders.
 */
export interface SearchFolderSchema {
    /**
     * Defines the **SearchParameters** property.
     */
    SearchParameters: PropertyDefinition;
    /**
     * @internal Instance of **SearchFolderSchema**
     */
    Instance: SearchFolderSchema;
}

/**
 * Represents the schema for search folders.
 */
export interface SearchFolderSchemaStatic extends SearchFolderSchema {
}
Schemas.SearchFolderSchema = <any>SearchFolderSchema;


/**
 * Field URIs for Item.
 */
module FieldUris {
    export var ArchiveTag: string = "item:ArchiveTag";
    export var Attachments: string = "item:Attachments";
    export var Body: string = "item:Body";
    export var Categories: string = "item:Categories";
    export var ConversationId: string = "item:ConversationId";
    export var Culture: string = "item:Culture";
    export var DateTimeCreated: string = "item:DateTimeCreated";
    export var DateTimeReceived: string = "item:DateTimeReceived";
    export var DateTimeSent: string = "item:DateTimeSent";
    export var DisplayCc: string = "item:DisplayCc";
    export var DisplayTo: string = "item:DisplayTo";
    export var EffectiveRights: string = "item:EffectiveRights";
    export var EntityExtractionResult: string = "item:EntityExtractionResult";
    export var Flag: string = "item:Flag";
    export var HasAttachments: string = "item:HasAttachments";
    export var IconIndex: string = "item:IconIndex";
    export var Importance: string = "item:Importance";
    export var InReplyTo: string = "item:InReplyTo";
    export var InstanceKey: string = "item:InstanceKey";
    export var InternetMessageHeaders: string = "item:InternetMessageHeaders";
    export var IsAssociated: string = "item:IsAssociated";
    export var IsDraft: string = "item:IsDraft";
    export var IsFromMe: string = "item:IsFromMe";
    export var IsResend: string = "item:IsResend";
    export var IsSubmitted: string = "item:IsSubmitted";
    export var IsUnmodified: string = "item:IsUnmodified";
    export var ItemClass: string = "item:ItemClass";
    export var ItemId: string = "item:ItemId";
    export var LastModifiedName: string = "item:LastModifiedName";
    export var LastModifiedTime: string = "item:LastModifiedTime";
    export var MimeContent: string = "item:MimeContent";
    export var NormalizedBody: string = "item:NormalizedBody";
    export var ParentFolderId: string = "item:ParentFolderId";
    export var PolicyTag: string = "item:PolicyTag";
    export var Preview: string = "item:Preview";
    export var ReminderDueBy: string = "item:ReminderDueBy";
    export var ReminderIsSet: string = "item:ReminderIsSet";
    export var ReminderMinutesBeforeStart: string = "item:ReminderMinutesBeforeStart";
    export var ResponseObjects: string = "item:ResponseObjects";
    export var RetentionDate: string = "item:RetentionDate";
    export var Sensitivity: string = "item:Sensitivity";
    export var Size: string = "item:Size";
    export var StoreEntryId: string = "item:StoreEntryId";
    export var Subject: string = "item:Subject";
    export var TextBody: string = "item:TextBody";
    export var UniqueBody: string = "item:UniqueBody";
    export var WebClientEditFormQueryString: string = "item:WebClientEditFormQueryString";
    export var WebClientReadFormQueryString: string = "item:WebClientReadFormQueryString";
}

/**
 * Represents the schema for generic items.
 */
export class ItemSchema extends ServiceObjectSchema {

    /**
     * Defines the **Id** property.
     */
    public static Id: PropertyDefinition = new ComplexPropertyDefinition<ItemId>(
        "Id",
        XmlElementNames.ItemId,
        FieldUris.ItemId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new ItemId(); }
    );

    /**
     * Defines the **Body** property.
     */
    public static Body: PropertyDefinition = new ComplexPropertyDefinition<MessageBody>(
        "Body",
        XmlElementNames.Body,
        FieldUris.Body,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new MessageBody(); }
    );

    /**
     * Defines the **ItemClass** property.
     */
    public static ItemClass: PropertyDefinition = new StringPropertyDefinition(
        "ItemClass",
        XmlElementNames.ItemClass,
        FieldUris.ItemClass,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Subject** property.
     */
    public static Subject: PropertyDefinition = new StringPropertyDefinition(
        "Subject",
        XmlElementNames.Subject,
        FieldUris.Subject,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **MimeContent** property.
     */
    public static MimeContent: PropertyDefinition = new ComplexPropertyDefinition<MimeContent>(
        "MimeContent",
        XmlElementNames.MimeContent,
        FieldUris.MimeContent,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.MustBeExplicitlyLoaded,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new MimeContent(); }
    );

    /**
     * Defines the **ParentFolderId** property.
     */
    public static ParentFolderId: PropertyDefinition = new ComplexPropertyDefinition<FolderId>(
        "ParentFolderId",
        XmlElementNames.ParentFolderId,
        FieldUris.ParentFolderId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new FolderId(); }
    );

    /**
     * Defines the **Sensitivity** property.
     */
    public static Sensitivity: PropertyDefinition = new GenericPropertyDefinition<Sensitivity>(
        "Sensitivity",
        XmlElementNames.Sensitivity,
        FieldUris.Sensitivity,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        Sensitivity
    );

    /**
     * Defines the **Attachments** property.
     */
    public static Attachments: PropertyDefinition = new AttachmentsPropertyDefinition("Attachments");

    /**
     * Defines the **DateTimeReceived** property.
     */
    public static DateTimeReceived: PropertyDefinition = new DateTimePropertyDefinition(
        "DateTimeReceived",
        XmlElementNames.DateTimeReceived,
        FieldUris.DateTimeReceived,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Size** property.
     */
    public static Size: PropertyDefinition = new IntPropertyDefinition(
        "Size",
        XmlElementNames.Size,
        FieldUris.Size,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Categories** property.
     */
    public static Categories: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "Categories",
        XmlElementNames.Categories,
        FieldUris.Categories,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **Importance** property.
     */
    public static Importance: PropertyDefinition = new GenericPropertyDefinition<Importance>(
        "Importance",
        XmlElementNames.Importance,
        FieldUris.Importance,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        Importance
    );

    /**
     * Defines the **InReplyTo** property.
     */
    public static InReplyTo: PropertyDefinition = new StringPropertyDefinition(
        "InReplyTo",
        XmlElementNames.InReplyTo,
        FieldUris.InReplyTo,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsSubmitted** property.
     */
    public static IsSubmitted: PropertyDefinition = new BoolPropertyDefinition(
        "IsSubmitted",
        XmlElementNames.IsSubmitted,
        FieldUris.IsSubmitted,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsAssociated** property.
     */
    public static IsAssociated: PropertyDefinition = new BoolPropertyDefinition(
        "IsAssociated",
        XmlElementNames.IsAssociated,
        FieldUris.IsAssociated,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010
    );

    /**
     * Defines the **IsDraft** property.
     */
    public static IsDraft: PropertyDefinition = new BoolPropertyDefinition(
        "IsDraft",
        XmlElementNames.IsDraft,
        FieldUris.IsDraft,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsFromMe** property.
     */
    public static IsFromMe: PropertyDefinition = new BoolPropertyDefinition(
        "IsFromMe",
        XmlElementNames.IsFromMe,
        FieldUris.IsFromMe,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsResend** property.
     */
    public static IsResend: PropertyDefinition = new BoolPropertyDefinition(
        "IsResend",
        XmlElementNames.IsResend,
        FieldUris.IsResend,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsUnmodified** property.
     */
    public static IsUnmodified: PropertyDefinition = new BoolPropertyDefinition(
        "IsUnmodified",
        XmlElementNames.IsUnmodified,
        FieldUris.IsUnmodified,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **InternetMessageHeaders** property.
     */
    public static InternetMessageHeaders: PropertyDefinition = new ComplexPropertyDefinition<InternetMessageHeaderCollection>(
        "InternetMessageHeaders",
        XmlElementNames.InternetMessageHeaders,
        FieldUris.InternetMessageHeaders,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new InternetMessageHeaderCollection(); }
    );

    /**
     * Defines the **DateTimeSent** property.
     */
    public static DateTimeSent: PropertyDefinition = new DateTimePropertyDefinition(
        "DateTimeSent",
        XmlElementNames.DateTimeSent,
        FieldUris.DateTimeSent,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **DateTimeCreated** property.
     */
    public static DateTimeCreated: PropertyDefinition = new DateTimePropertyDefinition(
        "DateTimeCreated",
        XmlElementNames.DateTimeCreated,
        FieldUris.DateTimeCreated,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **AllowedResponseActions** property.
     */
    public static AllowedResponseActions: PropertyDefinition = new ResponseObjectsPropertyDefinition(
        "ResponseObjects",
        XmlElementNames.ResponseObjects,
        FieldUris.ResponseObjects,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ReminderDueBy** property.
     */
    public static ReminderDueBy: PropertyDefinition = new ScopedDateTimePropertyDefinition(
        "ReminderDueBy",
        XmlElementNames.ReminderDueBy,
        FieldUris.ReminderDueBy,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        (version: ExchangeVersion) => { debugger; return Schemas.AppointmentSchema.StartTimeZone; }
    );

    /**
     * Defines the **IsReminderSet** property.
     */
    public static IsReminderSet: PropertyDefinition = new BoolPropertyDefinition(
        "ReminderIsSet",
        XmlElementNames.ReminderIsSet,
        FieldUris.ReminderIsSet,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ReminderMinutesBeforeStart** property.
     */
    public static ReminderMinutesBeforeStart: PropertyDefinition = new IntPropertyDefinition(
        "ReminderMinutesBeforeStart",
        XmlElementNames.ReminderMinutesBeforeStart,
        FieldUris.ReminderMinutesBeforeStart,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **DisplayCc** property.
     */
    public static DisplayCc: PropertyDefinition = new StringPropertyDefinition(
        "DisplayCc",
        XmlElementNames.DisplayCc,
        FieldUris.DisplayCc,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **DisplayTo** property.
     */
    public static DisplayTo: PropertyDefinition = new StringPropertyDefinition(
        "DisplayTo",
        XmlElementNames.DisplayTo,
        FieldUris.DisplayTo,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **HasAttachments** property.
     */
    public static HasAttachments: PropertyDefinition = new BoolPropertyDefinition(
        "HasAttachments",
        XmlElementNames.HasAttachments,
        FieldUris.HasAttachments,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Culture** property.
     */
    public static Culture: PropertyDefinition = new StringPropertyDefinition(
        "Culture",
        XmlElementNames.Culture,
        FieldUris.Culture,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **EffectiveRights** property.
     */
    public static EffectiveRights: PropertyDefinition = new EffectiveRightsPropertyDefinition(
        "EffectiveRights",
        XmlElementNames.EffectiveRights,
        FieldUris.EffectiveRights,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **LastModifiedName** property.
     */
    public static LastModifiedName: PropertyDefinition = new StringPropertyDefinition(
        "LastModifiedName",
        XmlElementNames.LastModifiedName,
        FieldUris.LastModifiedName,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **LastModifiedTime** property.
     */
    public static LastModifiedTime: PropertyDefinition = new DateTimePropertyDefinition(
        "LastModifiedTime",
        XmlElementNames.LastModifiedTime,
        FieldUris.LastModifiedTime,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **WebClientReadFormQueryString** property.
     */
    public static WebClientReadFormQueryString: PropertyDefinition = new StringPropertyDefinition(
        "WebClientReadFormQueryString",
        XmlElementNames.WebClientReadFormQueryString,
        FieldUris.WebClientReadFormQueryString,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010
    );

    /**
     * Defines the **WebClientEditFormQueryString** property.
     */
    public static WebClientEditFormQueryString: PropertyDefinition = new StringPropertyDefinition(
        "WebClientEditFormQueryString",
        XmlElementNames.WebClientEditFormQueryString,
        FieldUris.WebClientEditFormQueryString,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010
    );

    /**
     * Defines the **ConversationId** property.
     */
    public static ConversationId: PropertyDefinition = new ComplexPropertyDefinition<ConversationId>(
        "ConversationId",
        XmlElementNames.ConversationId,
        FieldUris.ConversationId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010,
        () => { return new ConversationId(); }
    );

    /**
     * Defines the **UniqueBody** property.
     */
    public static UniqueBody: PropertyDefinition = new ComplexPropertyDefinition<UniqueBody>(
        "UniqueBody",
        XmlElementNames.UniqueBody,
        FieldUris.UniqueBody,
        PropertyDefinitionFlags.MustBeExplicitlyLoaded,
        ExchangeVersion.Exchange2010,
        () => { return new UniqueBody(); }
    );

    /**
     * Defines the **StoreEntryId** property.
     */
    public static StoreEntryId: PropertyDefinition = new ByteArrayPropertyDefinition(
        "StoreEntryId",
        XmlElementNames.StoreEntryId,
        FieldUris.StoreEntryId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP2
    );

    /**
     * Defines the **InstanceKey** property.
     */
    public static InstanceKey: PropertyDefinition = new ByteArrayPropertyDefinition(
        "InstanceKey",
        XmlElementNames.InstanceKey,
        FieldUris.InstanceKey,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013
    );

    /**
     * Defines the **NormalizedBody** property.
     */
    public static NormalizedBody: PropertyDefinition = new ComplexPropertyDefinition<NormalizedBody>(
        "NormalizedBody",
        XmlElementNames.NormalizedBody,
        FieldUris.NormalizedBody,
        PropertyDefinitionFlags.MustBeExplicitlyLoaded,
        ExchangeVersion.Exchange2013,
        () => { return new NormalizedBody(); }
    );

    /**
     * Defines the **EntityExtractionResult** property.
     */
    public static EntityExtractionResult: PropertyDefinition = new ComplexPropertyDefinition<EntityExtractionResult>(
        "EntityExtractionResult",
        XmlElementNames.NlgEntityExtractionResult,
        FieldUris.EntityExtractionResult,
        PropertyDefinitionFlags.MustBeExplicitlyLoaded,
        ExchangeVersion.Exchange2013,
        () => { return new EntityExtractionResult(); }
    );

    /**
     * Defines the **Flag** property.
     */
    public static Flag: PropertyDefinition = new ComplexPropertyDefinition<Flag>(
        "Flag",
        XmlElementNames.Flag,
        FieldUris.Flag,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        () => { return new Flag(); }
    );

    /**
     * Defines the **PolicyTag** property.
     */
    public static PolicyTag: PropertyDefinition = new ComplexPropertyDefinition<PolicyTag>(
        "PolicyTag",
        XmlElementNames.PolicyTag,
        FieldUris.PolicyTag,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        () => { return new PolicyTag(); }
    );

    /**
     * Defines the **ArchiveTag** property.
     */
    public static ArchiveTag: PropertyDefinition = new ComplexPropertyDefinition<ArchiveTag>(
        "ArchiveTag",
        XmlElementNames.ArchiveTag,
        FieldUris.ArchiveTag,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        () => { return new ArchiveTag(); }
    );

    /**
     * Defines the **RetentionDate** property.
     */
    public static RetentionDate: PropertyDefinition = new DateTimePropertyDefinition(
        "RetentionDate",
        XmlElementNames.RetentionDate,
        FieldUris.RetentionDate,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        true
    );

    /**
     * Defines the **Preview** property.
     */
    public static Preview: PropertyDefinition = new StringPropertyDefinition(
        "Preview",
        XmlElementNames.Preview,
        FieldUris.Preview,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013
    );

    /**
     * Defines the **TextBody** property.
     */
    public static TextBody: PropertyDefinition = new ComplexPropertyDefinition<TextBody>(
        "TextBody",
        XmlElementNames.TextBody,
        FieldUris.TextBody,
        PropertyDefinitionFlags.MustBeExplicitlyLoaded,
        ExchangeVersion.Exchange2013,
        () => { return new TextBody(); }
    );

    /**
     * Defines the **IconIndex** property.
     */
    public static IconIndex: PropertyDefinition = new GenericPropertyDefinition<IconIndex>(
        "IconIndex",
        XmlElementNames.IconIndex,
        FieldUris.IconIndex,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        IconIndex
    );

    /**
     * @internal Instance of **ItemSchema** 
     */
    static Instance: ItemSchema = new ItemSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(ItemSchema, ItemSchema.MimeContent);
        this.RegisterProperty(ItemSchema, ItemSchema.Id);
        this.RegisterProperty(ItemSchema, ItemSchema.ParentFolderId);
        this.RegisterProperty(ItemSchema, ItemSchema.ItemClass);
        this.RegisterProperty(ItemSchema, ItemSchema.Subject);
        this.RegisterProperty(ItemSchema, ItemSchema.Sensitivity);
        this.RegisterProperty(ItemSchema, ItemSchema.Body);
        this.RegisterProperty(ItemSchema, ItemSchema.Attachments);
        this.RegisterProperty(ItemSchema, ItemSchema.DateTimeReceived);
        this.RegisterProperty(ItemSchema, ItemSchema.Size);
        this.RegisterProperty(ItemSchema, ItemSchema.Categories);
        this.RegisterProperty(ItemSchema, ItemSchema.Importance);
        this.RegisterProperty(ItemSchema, ItemSchema.InReplyTo);
        this.RegisterProperty(ItemSchema, ItemSchema.IsSubmitted);
        this.RegisterProperty(ItemSchema, ItemSchema.IsDraft);
        this.RegisterProperty(ItemSchema, ItemSchema.IsFromMe);
        this.RegisterProperty(ItemSchema, ItemSchema.IsResend);
        this.RegisterProperty(ItemSchema, ItemSchema.IsUnmodified);
        this.RegisterProperty(ItemSchema, ItemSchema.InternetMessageHeaders);
        this.RegisterProperty(ItemSchema, ItemSchema.DateTimeSent);
        this.RegisterProperty(ItemSchema, ItemSchema.DateTimeCreated);
        this.RegisterProperty(ItemSchema, ItemSchema.AllowedResponseActions);
        this.RegisterProperty(ItemSchema, ItemSchema.ReminderDueBy);
        this.RegisterProperty(ItemSchema, ItemSchema.IsReminderSet);
        this.RegisterProperty(ItemSchema, ItemSchema.ReminderMinutesBeforeStart);
        this.RegisterProperty(ItemSchema, ItemSchema.DisplayCc);
        this.RegisterProperty(ItemSchema, ItemSchema.DisplayTo);
        this.RegisterProperty(ItemSchema, ItemSchema.HasAttachments);
        this.RegisterProperty(ItemSchema, ServiceObjectSchema.ExtendedProperties);
        this.RegisterProperty(ItemSchema, ItemSchema.Culture);
        this.RegisterProperty(ItemSchema, ItemSchema.EffectiveRights);
        this.RegisterProperty(ItemSchema, ItemSchema.LastModifiedName);
        this.RegisterProperty(ItemSchema, ItemSchema.LastModifiedTime);
        this.RegisterProperty(ItemSchema, ItemSchema.IsAssociated);
        this.RegisterProperty(ItemSchema, ItemSchema.WebClientReadFormQueryString);
        this.RegisterProperty(ItemSchema, ItemSchema.WebClientEditFormQueryString);
        this.RegisterProperty(ItemSchema, ItemSchema.ConversationId);
        this.RegisterProperty(ItemSchema, ItemSchema.UniqueBody);
        this.RegisterProperty(ItemSchema, ItemSchema.Flag);
        this.RegisterProperty(ItemSchema, ItemSchema.StoreEntryId);
        this.RegisterProperty(ItemSchema, ItemSchema.InstanceKey);
        this.RegisterProperty(ItemSchema, ItemSchema.NormalizedBody);
        this.RegisterProperty(ItemSchema, ItemSchema.EntityExtractionResult);
        this.RegisterProperty(ItemSchema, ItemSchema.PolicyTag);
        this.RegisterProperty(ItemSchema, ItemSchema.ArchiveTag);
        this.RegisterProperty(ItemSchema, ItemSchema.RetentionDate);
        this.RegisterProperty(ItemSchema, ItemSchema.Preview);
        this.RegisterProperty(ItemSchema, ItemSchema.TextBody);
        this.RegisterProperty(ItemSchema, ItemSchema.IconIndex);
    }
}

/**
 * Represents the schema for generic items.
 */
export interface ItemSchema {
    /**
     * Defines the **Id** property.
     */
    Id: PropertyDefinition;
    /**
     * Defines the **Body** property.
     */
    Body: PropertyDefinition;
    /**
     * Defines the **ItemClass** property.
     */
    ItemClass: PropertyDefinition;
    /**
     * Defines the **Subject** property.
     */
    Subject: PropertyDefinition;
    /**
     * Defines the **MimeContent** property.
     */
    MimeContent: PropertyDefinition;
    /**
     * Defines the **ParentFolderId** property.
     */
    ParentFolderId: PropertyDefinition;
    /**
     * Defines the **Sensitivity** property.
     */
    Sensitivity: PropertyDefinition;
    /**
     * Defines the **Attachments** property.
     */
    Attachments: PropertyDefinition;
    /**
     * Defines the **DateTimeReceived** property.
     */
    DateTimeReceived: PropertyDefinition;
    /**
     * Defines the **Size** property.
     */
    Size: PropertyDefinition;
    /**
     * Defines the **Categories** property.
     */
    Categories: PropertyDefinition;
    /**
     * Defines the **Importance** property.
     */
    Importance: PropertyDefinition;
    /**
     * Defines the **InReplyTo** property.
     */
    InReplyTo: PropertyDefinition;
    /**
     * Defines the **IsSubmitted** property.
     */
    IsSubmitted: PropertyDefinition;
    /**
     * Defines the **IsAssociated** property.
     */
    IsAssociated: PropertyDefinition;
    /**
     * Defines the **IsDraft** property.
     */
    IsDraft: PropertyDefinition;
    /**
     * Defines the **IsFromMe** property.
     */
    IsFromMe: PropertyDefinition;
    /**
     * Defines the **IsResend** property.
     */
    IsResend: PropertyDefinition;
    /**
     * Defines the **IsUnmodified** property.
     */
    IsUnmodified: PropertyDefinition;
    /**
     * Defines the **InternetMessageHeaders** property.
     */
    InternetMessageHeaders: PropertyDefinition;
    /**
     * Defines the **DateTimeSent** property.
     */
    DateTimeSent: PropertyDefinition;
    /**
     * Defines the **DateTimeCreated** property.
     */
    DateTimeCreated: PropertyDefinition;
    /**
     * Defines the **AllowedResponseActions** property.
     */
    AllowedResponseActions: PropertyDefinition;
    /**
     * Defines the **ReminderDueBy** property.
     */
    ReminderDueBy: PropertyDefinition;
    /**
     * Defines the **IsReminderSet** property.
     */
    IsReminderSet: PropertyDefinition;
    /**
     * Defines the **ReminderMinutesBeforeStart** property.
     */
    ReminderMinutesBeforeStart: PropertyDefinition;
    /**
     * Defines the **DisplayCc** property.
     */
    DisplayCc: PropertyDefinition;
    /**
     * Defines the **DisplayTo** property.
     */
    DisplayTo: PropertyDefinition;
    /**
     * Defines the **HasAttachments** property.
     */
    HasAttachments: PropertyDefinition;
    /**
     * Defines the **Culture** property.
     */
    Culture: PropertyDefinition;
    /**
     * Defines the **EffectiveRights** property.
     */
    EffectiveRights: PropertyDefinition;
    /**
     * Defines the **LastModifiedName** property.
     */
    LastModifiedName: PropertyDefinition;
    /**
     * Defines the **LastModifiedTime** property.
     */
    LastModifiedTime: PropertyDefinition;
    /**
     * Defines the **WebClientReadFormQueryString** property.
     */
    WebClientReadFormQueryString: PropertyDefinition;
    /**
     * Defines the **WebClientEditFormQueryString** property.
     */
    WebClientEditFormQueryString: PropertyDefinition;
    /**
     * Defines the **ConversationId** property.
     */
    ConversationId: PropertyDefinition;
    /**
     * Defines the **UniqueBody** property.
     */
    UniqueBody: PropertyDefinition;
    /**
     * Defines the **StoreEntryId** property.
     */
    StoreEntryId: PropertyDefinition;
    /**
     * Defines the **InstanceKey** property.
     */
    InstanceKey: PropertyDefinition;
    /**
     * Defines the **NormalizedBody** property.
     */
    NormalizedBody: PropertyDefinition;
    /**
     * Defines the **EntityExtractionResult** property.
     */
    EntityExtractionResult: PropertyDefinition;
    /**
     * Defines the **Flag** property.
     */
    Flag: PropertyDefinition;
    /**
     * Defines the **PolicyTag** property.
     */
    PolicyTag: PropertyDefinition;
    /**
     * Defines the **ArchiveTag** property.
     */
    ArchiveTag: PropertyDefinition;
    /**
     * Defines the **RetentionDate** property.
     */
    RetentionDate: PropertyDefinition;
    /**
     * Defines the **Preview** property.
     */
    Preview: PropertyDefinition;
    /**
     * Defines the **TextBody** property.
     */
    TextBody: PropertyDefinition;
    /**
     * Defines the **IconIndex** property.
     */
    IconIndex: PropertyDefinition;
    /**
     * @internal Instance of **ItemSchema**
     */
    Instance: ItemSchema;
}

/**
 * Represents the schema for generic items.
 */
export interface ItemSchemaStatic extends ItemSchema {
}
Schemas.ItemSchema = <any>ItemSchema;


/**
 * Field URIs for Appointment.
 */
module FieldUris {
    export var Start: string = "calendar:Start";
    export var End: string = "calendar:End";
    export var OriginalStart: string = "calendar:OriginalStart";
    export var IsAllDayEvent: string = "calendar:IsAllDayEvent";
    export var LegacyFreeBusyStatus: string = "calendar:LegacyFreeBusyStatus";
    export var Location: string = "calendar:Location";
    export var When: string = "calendar:When";
    export var IsMeeting: string = "calendar:IsMeeting";
    export var IsCancelled: string = "calendar:IsCancelled";
    export var IsRecurring: string = "calendar:IsRecurring";
    export var MeetingRequestWasSent: string = "calendar:MeetingRequestWasSent";
    export var IsResponseRequested: string = "calendar:IsResponseRequested";
    export var CalendarItemType: string = "calendar:CalendarItemType";
    export var MyResponseType: string = "calendar:MyResponseType";
    export var Organizer: string = "calendar:Organizer";
    export var RequiredAttendees: string = "calendar:RequiredAttendees";
    export var OptionalAttendees: string = "calendar:OptionalAttendees";
    export var Resources: string = "calendar:Resources";
    export var ConflictingMeetingCount: string = "calendar:ConflictingMeetingCount";
    export var AdjacentMeetingCount: string = "calendar:AdjacentMeetingCount";
    export var ConflictingMeetings: string = "calendar:ConflictingMeetings";
    export var AdjacentMeetings: string = "calendar:AdjacentMeetings";
    export var Duration: string = "calendar:Duration";
    export var TimeZone: string = "calendar:TimeZone";
    export var AppointmentReplyTime: string = "calendar:AppointmentReplyTime";
    export var AppointmentSequenceNumber: string = "calendar:AppointmentSequenceNumber";
    export var AppointmentState: string = "calendar:AppointmentState";
    export var Recurrence: string = "calendar:Recurrence";
    export var FirstOccurrence: string = "calendar:FirstOccurrence";
    export var LastOccurrence: string = "calendar:LastOccurrence";
    export var ModifiedOccurrences: string = "calendar:ModifiedOccurrences";
    export var DeletedOccurrences: string = "calendar:DeletedOccurrences";
    export var MeetingTimeZone: string = "calendar:MeetingTimeZone";
    export var StartTimeZone: string = "calendar:StartTimeZone";
    export var EndTimeZone: string = "calendar:EndTimeZone";
    export var ConferenceType: string = "calendar:ConferenceType";
    export var AllowNewTimeProposal: string = "calendar:AllowNewTimeProposal";
    export var IsOnlineMeeting: string = "calendar:IsOnlineMeeting";
    export var MeetingWorkspaceUrl: string = "calendar:MeetingWorkspaceUrl";
    export var NetShowUrl: string = "calendar:NetShowUrl";
    export var Uid: string = "calendar:UID";
    export var RecurrenceId: string = "calendar:RecurrenceId";
    export var DateTimeStamp: string = "calendar:DateTimeStamp";
    export var EnhancedLocation: string = "calendar:EnhancedLocation";
    export var JoinOnlineMeetingUrl: string = "calendar:JoinOnlineMeetingUrl";
    export var OnlineMeetingSettings: string = "calendar:OnlineMeetingSettings";
}

/**
 * Represents the schema for appointment and meeting requests.
 */
export class AppointmentSchema extends ItemSchema {

    /**
     * Defines the **StartTimeZone** property.
     */
    public static StartTimeZone: PropertyDefinition = new StartTimeZonePropertyDefinition(
        "StartTimeZone",
        XmlElementNames.StartTimeZone,
        FieldUris.StartTimeZone,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **EndTimeZone** property.
     */
    public static EndTimeZone: PropertyDefinition = new TimeZonePropertyDefinition(
        "EndTimeZone",
        XmlElementNames.EndTimeZone,
        FieldUris.EndTimeZone,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010
    );

    /**
     * Defines the **Start** property.
     */
    public static Start: PropertyDefinition = new ScopedDateTimePropertyDefinition(
        "Start",
        XmlElementNames.Start,
        FieldUris.Start,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        (version: ExchangeVersion) => { return AppointmentSchema.StartTimeZone; }
    );

    /**
     * Defines the **End** property.
     */
    public static End: PropertyDefinition = new ScopedDateTimePropertyDefinition(
        "End",
        XmlElementNames.End,
        FieldUris.End,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        (version: ExchangeVersion) => {
            if (version !== ExchangeVersion.Exchange2007_SP1) {
                return AppointmentSchema.EndTimeZone;
            }
            return AppointmentSchema.StartTimeZone;
        });
    /**
     * Defines the **OriginalStart** property.
     */
    public static OriginalStart: PropertyDefinition = new DateTimePropertyDefinition(
        "OriginalStart",
        XmlElementNames.OriginalStart,
        FieldUris.OriginalStart,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsAllDayEvent** property.
     */
    public static IsAllDayEvent: PropertyDefinition = new BoolPropertyDefinition(
        "IsAllDayEvent",
        XmlElementNames.IsAllDayEvent,
        FieldUris.IsAllDayEvent,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **LegacyFreeBusyStatus** property.
     */
    public static LegacyFreeBusyStatus: PropertyDefinition = new GenericPropertyDefinition<LegacyFreeBusyStatus>(
        "LegacyFreeBusyStatus",
        XmlElementNames.LegacyFreeBusyStatus,
        FieldUris.LegacyFreeBusyStatus,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        LegacyFreeBusyStatus
    );

    /**
     * Defines the **Location** property.
     */
    public static Location: PropertyDefinition = new StringPropertyDefinition(
        "Location",
        XmlElementNames.Location,
        FieldUris.Location,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **When** property.
     */
    public static When: PropertyDefinition = new StringPropertyDefinition(
        "When",
        XmlElementNames.When,
        FieldUris.When,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsMeeting** property.
     */
    public static IsMeeting: PropertyDefinition = new BoolPropertyDefinition(
        "IsMeeting",
        XmlElementNames.IsMeeting,
        FieldUris.IsMeeting,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsCancelled** property.
     */
    public static IsCancelled: PropertyDefinition = new BoolPropertyDefinition(
        "IsCancelled",
        XmlElementNames.IsCancelled,
        FieldUris.IsCancelled,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsRecurring** property.
     */
    public static IsRecurring: PropertyDefinition = new BoolPropertyDefinition(
        "IsRecurring",
        XmlElementNames.IsRecurring,
        FieldUris.IsRecurring,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **MeetingRequestWasSent** property.
     */
    public static MeetingRequestWasSent: PropertyDefinition = new BoolPropertyDefinition(
        "MeetingRequestWasSent",
        XmlElementNames.MeetingRequestWasSent,
        FieldUris.MeetingRequestWasSent,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsResponseRequested** property.
     */
    public static IsResponseRequested: PropertyDefinition = new BoolPropertyDefinition(
        "IsResponseRequested",
        XmlElementNames.IsResponseRequested,
        FieldUris.IsResponseRequested,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **AppointmentType** property.
     */
    public static AppointmentType: PropertyDefinition = new GenericPropertyDefinition<AppointmentType>(
        "CalendarItemType",
        XmlElementNames.CalendarItemType,
        FieldUris.CalendarItemType,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        AppointmentType
    );

    /**
     * Defines the **MyResponseType** property.
     */
    public static MyResponseType: PropertyDefinition = new GenericPropertyDefinition<MeetingResponseType>(
        "MyResponseType",
        XmlElementNames.MyResponseType,
        FieldUris.MyResponseType,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        MeetingResponseType
    );

    /**
     * Defines the **Organizer** property.
     */
    public static Organizer: PropertyDefinition = new ContainedPropertyDefinition<EmailAddress>(
        "Organizer",
        XmlElementNames.Organizer,
        FieldUris.Organizer,
        XmlElementNames.Mailbox,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddress(); }
    );

    /**
     * Defines the **RequiredAttendees** property.
     */
    public static RequiredAttendees: PropertyDefinition = new ComplexPropertyDefinition<AttendeeCollection>(
        "RequiredAttendees",
        XmlElementNames.RequiredAttendees,
        FieldUris.RequiredAttendees,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new AttendeeCollection(); }
    );

    /**
     * Defines the **OptionalAttendees** property.
     */
    public static OptionalAttendees: PropertyDefinition = new ComplexPropertyDefinition<AttendeeCollection>(
        "OptionalAttendees",
        XmlElementNames.OptionalAttendees,
        FieldUris.OptionalAttendees,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new AttendeeCollection(); }
    );

    /**
     * Defines the **Resources** property.
     */
    public static Resources: PropertyDefinition = new ComplexPropertyDefinition<AttendeeCollection>(
        "Resources",
        XmlElementNames.Resources,
        FieldUris.Resources,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new AttendeeCollection(); }
    );

    /**
     * Defines the **ConflictingMeetingCount** property.
     */
    public static ConflictingMeetingCount: PropertyDefinition = new IntPropertyDefinition(
        "ConflictingMeetingCount",
        XmlElementNames.ConflictingMeetingCount,
        FieldUris.ConflictingMeetingCount,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **AdjacentMeetingCount** property.
     */
    public static AdjacentMeetingCount: PropertyDefinition = new IntPropertyDefinition(
        "AdjacentMeetingCount",
        XmlElementNames.AdjacentMeetingCount,
        FieldUris.AdjacentMeetingCount,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ConflictingMeetings** property.
     */
    public static ConflictingMeetings: PropertyDefinition = new ComplexPropertyDefinition<ItemCollection<Appointment>>(
        "ConflictingMeetings",
        XmlElementNames.ConflictingMeetings,
        FieldUris.ConflictingMeetings,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new ItemCollection<Appointment>(); }
    );

    /**
     * Defines the **AdjacentMeetings** property.
     */
    public static AdjacentMeetings: PropertyDefinition = new ComplexPropertyDefinition<ItemCollection<Appointment>>(
        "AdjacentMeetings",
        XmlElementNames.AdjacentMeetings,
        FieldUris.AdjacentMeetings,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new ItemCollection<Appointment>(); }
    );

    /**
     * Defines the **Duration** property.
     */
    public static Duration: PropertyDefinition = new TimeSpanPropertyDefinition(
        "Duration",
        XmlElementNames.Duration,
        FieldUris.Duration,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **TimeZone** property.
     */
    public static TimeZone: PropertyDefinition = new StringPropertyDefinition(
        "TimeZone",
        XmlElementNames.TimeZone,
        FieldUris.TimeZone,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **AppointmentReplyTime** property.
     */
    public static AppointmentReplyTime: PropertyDefinition = new DateTimePropertyDefinition(
        "AppointmentReplyTime",
        XmlElementNames.AppointmentReplyTime,
        FieldUris.AppointmentReplyTime,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **AppointmentSequenceNumber** property.
     */
    public static AppointmentSequenceNumber: PropertyDefinition = new IntPropertyDefinition(
        "AppointmentSequenceNumber",
        XmlElementNames.AppointmentSequenceNumber,
        FieldUris.AppointmentSequenceNumber,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **AppointmentState** property.
     */
    public static AppointmentState: PropertyDefinition = new IntPropertyDefinition(
        "AppointmentState",
        XmlElementNames.AppointmentState,
        FieldUris.AppointmentState,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Recurrence** property.
     */
    public static Recurrence: PropertyDefinition = new RecurrencePropertyDefinition(
        "Recurrence",
        XmlElementNames.Recurrence,
        FieldUris.Recurrence,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **FirstOccurrence** property.
     */
    public static FirstOccurrence: PropertyDefinition = new ComplexPropertyDefinition<OccurrenceInfo>(
        "FirstOccurrence",
        XmlElementNames.FirstOccurrence,
        FieldUris.FirstOccurrence,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new OccurrenceInfo(); }
    );

    /**
     * Defines the **LastOccurrence** property.
     */
    public static LastOccurrence: PropertyDefinition = new ComplexPropertyDefinition<OccurrenceInfo>(
        "LastOccurrence",
        XmlElementNames.LastOccurrence,
        FieldUris.LastOccurrence,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new OccurrenceInfo(); }
    );

    /**
     * Defines the **ModifiedOccurrences** property.
     */
    public static ModifiedOccurrences: PropertyDefinition = new ComplexPropertyDefinition<OccurrenceInfoCollection>(
        "ModifiedOccurrences",
        XmlElementNames.ModifiedOccurrences,
        FieldUris.ModifiedOccurrences,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new OccurrenceInfoCollection(); }
    );

    /**
     * Defines the **DeletedOccurrences** property.
     */
    public static DeletedOccurrences: PropertyDefinition = new ComplexPropertyDefinition<DeletedOccurrenceInfoCollection>(
        "DeletedOccurrences",
        XmlElementNames.DeletedOccurrences,
        FieldUris.DeletedOccurrences,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new DeletedOccurrenceInfoCollection(); }
    );

    /**
     * Defines the **MeetingTimeZone** property.
     */
    public static MeetingTimeZone: PropertyDefinition = new MeetingTimeZonePropertyDefinition(
        "MeetingTimeZone",
        XmlElementNames.MeetingTimeZone,
        FieldUris.MeetingTimeZone,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ConferenceType** property.
     */
    public static ConferenceType: PropertyDefinition = new IntPropertyDefinition(
        "ConferenceType",
        XmlElementNames.ConferenceType,
        FieldUris.ConferenceType,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **AllowNewTimeProposal** property.
     */
    public static AllowNewTimeProposal: PropertyDefinition = new BoolPropertyDefinition(
        "AllowNewTimeProposal",
        XmlElementNames.AllowNewTimeProposal,
        FieldUris.AllowNewTimeProposal,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsOnlineMeeting** property.
     */
    public static IsOnlineMeeting: PropertyDefinition = new BoolPropertyDefinition(
        "IsOnlineMeeting",
        XmlElementNames.IsOnlineMeeting,
        FieldUris.IsOnlineMeeting,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **MeetingWorkspaceUrl** property.
     */
    public static MeetingWorkspaceUrl: PropertyDefinition = new StringPropertyDefinition(
        "MeetingWorkspaceUrl",
        XmlElementNames.MeetingWorkspaceUrl,
        FieldUris.MeetingWorkspaceUrl,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **NetShowUrl** property.
     */
    public static NetShowUrl: PropertyDefinition = new StringPropertyDefinition(
        "NetShowUrl",
        XmlElementNames.NetShowUrl,
        FieldUris.NetShowUrl,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ICalUid** property.
     */
    public static ICalUid: PropertyDefinition = new StringPropertyDefinition(
        "ICalUid",
        XmlElementNames.Uid,
        FieldUris.Uid,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ICalRecurrenceId** property.
     */
    public static ICalRecurrenceId: PropertyDefinition = new DateTimePropertyDefinition(
        "ICalRecurrenceId",
        XmlElementNames.RecurrenceId,
        FieldUris.RecurrenceId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        true
    );

    /**
     * Defines the **ICalDateTimeStamp** property.
     */
    public static ICalDateTimeStamp: PropertyDefinition = new DateTimePropertyDefinition(
        "ICalDateTimeStamp",
        XmlElementNames.DateTimeStamp,
        FieldUris.DateTimeStamp,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        true
    );

    /**
     * Defines the **EnhancedLocation** property.
     */
    public static EnhancedLocation: PropertyDefinition = new ComplexPropertyDefinition<EnhancedLocation>(
        "EnhancedLocation",
        XmlElementNames.EnhancedLocation,
        FieldUris.EnhancedLocation,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        () => { return new EnhancedLocation(); }
    );

    /**
     * Defines the **JoinOnlineMeetingUrl** property.
     */
    public static JoinOnlineMeetingUrl: PropertyDefinition = new StringPropertyDefinition(
        "JoinOnlineMeetingUrl",
        XmlElementNames.JoinOnlineMeetingUrl,
        FieldUris.JoinOnlineMeetingUrl,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013
    );

    /**
     * Defines the **OnlineMeetingSettings** property.
     */
    public static OnlineMeetingSettings: PropertyDefinition = new ComplexPropertyDefinition<OnlineMeetingSettings>(
        "OnlineMeetingSettings",
        XmlElementNames.OnlineMeetingSettings,
        FieldUris.OnlineMeetingSettings,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        () => { return new OnlineMeetingSettings(); }
    );


    /**
     * @internal Instance of **AppointmentSchema** 
     */
    static Instance: AppointmentSchema = new AppointmentSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ICalUid);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ICalRecurrenceId);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ICalDateTimeStamp);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Start);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.End);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.OriginalStart);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsAllDayEvent);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.LegacyFreeBusyStatus);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Location);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.When);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsMeeting);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsCancelled);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsRecurring);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.MeetingRequestWasSent);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsResponseRequested);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AppointmentType);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.MyResponseType);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Organizer);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.RequiredAttendees);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.OptionalAttendees);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Resources);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ConflictingMeetingCount);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AdjacentMeetingCount);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ConflictingMeetings);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AdjacentMeetings);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Duration);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.TimeZone);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AppointmentReplyTime);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AppointmentSequenceNumber);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AppointmentState);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Recurrence);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.FirstOccurrence);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.LastOccurrence);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ModifiedOccurrences);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.DeletedOccurrences);
        this.RegisterInternalProperty(AppointmentSchema, AppointmentSchema.MeetingTimeZone);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.StartTimeZone);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.EndTimeZone);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ConferenceType);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AllowNewTimeProposal);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsOnlineMeeting);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.MeetingWorkspaceUrl);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.NetShowUrl);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.EnhancedLocation);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.JoinOnlineMeetingUrl);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.OnlineMeetingSettings);
    }
}

/**
 * Represents the schema for appointment and meeting requests.
 */
export interface AppointmentSchema {

    /**
     * Defines the **StartTimeZone** property.
     */
    StartTimeZone: PropertyDefinition;
    /**
     * Defines the **EndTimeZone** property.
     */
    EndTimeZone: PropertyDefinition;
    /**
     * Defines the **Start** property.
     */
    Start: PropertyDefinition;
    /**
     * Defines the **End** property.
     */
    End: PropertyDefinition;
    /**
     * Defines the **OriginalStart** property.
     */
    OriginalStart: PropertyDefinition;
    /**
     * Defines the **IsAllDayEvent** property.
     */
    IsAllDayEvent: PropertyDefinition;
    /**
     * Defines the **LegacyFreeBusyStatus** property.
     */
    LegacyFreeBusyStatus: PropertyDefinition;
    /**
     * Defines the **Location** property.
     */
    Location: PropertyDefinition;
    /**
     * Defines the **When** property.
     */
    When: PropertyDefinition;
    /**
     * Defines the **IsMeeting** property.
     */
    IsMeeting: PropertyDefinition;
    /**
     * Defines the **IsCancelled** property.
     */
    IsCancelled: PropertyDefinition;
    /**
     * Defines the **IsRecurring** property.
     */
    IsRecurring: PropertyDefinition;
    /**
     * Defines the **MeetingRequestWasSent** property.
     */
    MeetingRequestWasSent: PropertyDefinition;
    /**
     * Defines the **IsResponseRequested** property.
     */
    IsResponseRequested: PropertyDefinition;
    /**
     * Defines the **AppointmentType** property.
     */
    AppointmentType: PropertyDefinition;
    /**
     * Defines the **MyResponseType** property.
     */
    MyResponseType: PropertyDefinition;
    /**
     * Defines the **Organizer** property.
     */
    Organizer: PropertyDefinition;
    /**
     * Defines the **RequiredAttendees** property.
     */
    RequiredAttendees: PropertyDefinition;
    /**
     * Defines the **OptionalAttendees** property.
     */
    OptionalAttendees: PropertyDefinition;
    /**
     * Defines the **Resources** property.
     */
    Resources: PropertyDefinition;
    /**
     * Defines the **ConflictingMeetingCount** property.
     */
    ConflictingMeetingCount: PropertyDefinition;
    /**
     * Defines the **AdjacentMeetingCount** property.
     */
    AdjacentMeetingCount: PropertyDefinition;
    /**
     * Defines the **ConflictingMeetings** property.
     */
    ConflictingMeetings: PropertyDefinition;
    /**
     * Defines the **AdjacentMeetings** property.
     */
    AdjacentMeetings: PropertyDefinition;
    /**
     * Defines the **Duration** property.
     */
    Duration: PropertyDefinition;
    /**
     * Defines the **TimeZone** property.
     */
    TimeZone: PropertyDefinition;
    /**
     * Defines the **AppointmentReplyTime** property.
     */
    AppointmentReplyTime: PropertyDefinition;
    /**
     * Defines the **AppointmentSequenceNumber** property.
     */
    AppointmentSequenceNumber: PropertyDefinition;
    /**
     * Defines the **AppointmentState** property.
     */
    AppointmentState: PropertyDefinition;
    /**
     * Defines the **Recurrence** property.
     */
    Recurrence: PropertyDefinition;
    /**
     * Defines the **FirstOccurrence** property.
     */
    FirstOccurrence: PropertyDefinition;
    /**
     * Defines the **LastOccurrence** property.
     */
    LastOccurrence: PropertyDefinition;
    /**
     * Defines the **ModifiedOccurrences** property.
     */
    ModifiedOccurrences: PropertyDefinition;
    /**
     * Defines the **DeletedOccurrences** property.
     */
    DeletedOccurrences: PropertyDefinition;
    /**
     * Defines the **MeetingTimeZone** property.
     */
    MeetingTimeZone: PropertyDefinition;
    /**
     * Defines the **ConferenceType** property.
     */
    ConferenceType: PropertyDefinition;
    /**
     * Defines the **AllowNewTimeProposal** property.
     */
    AllowNewTimeProposal: PropertyDefinition;
    /**
     * Defines the **IsOnlineMeeting** property.
     */
    IsOnlineMeeting: PropertyDefinition;
    /**
     * Defines the **MeetingWorkspaceUrl** property.
     */
    MeetingWorkspaceUrl: PropertyDefinition;
    /**
     * Defines the **NetShowUrl** property.
     */
    NetShowUrl: PropertyDefinition;
    /**
     * Defines the **ICalUid** property.
     */
    ICalUid: PropertyDefinition;
    /**
     * Defines the **ICalRecurrenceId** property.
     */
    ICalRecurrenceId: PropertyDefinition;
    /**
     * Defines the **ICalDateTimeStamp** property.
     */
    ICalDateTimeStamp: PropertyDefinition;
    /**
     * Defines the **EnhancedLocation** property.
     */
    EnhancedLocation: PropertyDefinition;
    /**
     * Defines the **JoinOnlineMeetingUrl** property.
     */
    JoinOnlineMeetingUrl: PropertyDefinition;
    /**
     * Defines the **OnlineMeetingSettings** property.
     */
    OnlineMeetingSettings: PropertyDefinition;
    /**
     * @internal Instance of **AppointmentSchema**
     */
    Instance: AppointmentSchema;

}

/**
 * Represents the schema for appointment and meeting requests.
 */
export interface AppointmentSchemaStatic extends AppointmentSchema {
}
Schemas.AppointmentSchema = <any>AppointmentSchema;


/**
 * FieldURIs for contacts.
 */
module FieldUris {
    export var FileAs: string = "contacts:FileAs";
    export var FileAsMapping: string = "contacts:FileAsMapping";
    export var DisplayName: string = "contacts:DisplayName";
    export var GivenName: string = "contacts:GivenName";
    export var Initials: string = "contacts:Initials";
    export var MiddleName: string = "contacts:MiddleName";
    export var NickName: string = "contacts:Nickname";
    export var CompleteName: string = "contacts:CompleteName";
    export var CompanyName: string = "contacts:CompanyName";
    export var EmailAddress: string = "contacts:EmailAddress";
    export var EmailAddresses: string = "contacts:EmailAddresses";
    export var PhysicalAddresses: string = "contacts:PhysicalAddresses";
    export var PhoneNumber: string = "contacts:PhoneNumber";
    export var PhoneNumbers: string = "contacts:PhoneNumbers";
    export var AssistantName: string = "contacts:AssistantName";
    export var Birthday: string = "contacts:Birthday";
    export var BusinessHomePage: string = "contacts:BusinessHomePage";
    export var Children: string = "contacts:Children";
    export var Companies: string = "contacts:Companies";
    export var ContactSource: string = "contacts:ContactSource";
    export var Department: string = "contacts:Department";
    export var Generation: string = "contacts:Generation";
    export var ImAddress: string = "contacts:ImAddress";
    export var ImAddresses: string = "contacts:ImAddresses";
    export var JobTitle: string = "contacts:JobTitle";
    export var Manager: string = "contacts:Manager";
    export var Mileage: string = "contacts:Mileage";
    export var OfficeLocation: string = "contacts:OfficeLocation";
    export var PhysicalAddressCity: string = "contacts:PhysicalAddress:City";
    export var PhysicalAddressCountryOrRegion: string = "contacts:PhysicalAddress:CountryOrRegion";
    export var PhysicalAddressState: string = "contacts:PhysicalAddress:State";
    export var PhysicalAddressStreet: string = "contacts:PhysicalAddress:Street";
    export var PhysicalAddressPostalCode: string = "contacts:PhysicalAddress:PostalCode";
    export var PostalAddressIndex: string = "contacts:PostalAddressIndex";
    export var Profession: string = "contacts:Profession";
    export var SpouseName: string = "contacts:SpouseName";
    export var Surname: string = "contacts:Surname";
    export var WeddingAnniversary: string = "contacts:WeddingAnniversary";
    export var HasPicture: string = "contacts:HasPicture";
    export var PhoneticFullName: string = "contacts:PhoneticFullName";
    export var PhoneticFirstName: string = "contacts:PhoneticFirstName";
    export var PhoneticLastName: string = "contacts:PhoneticLastName";
    export var Alias: string = "contacts:Alias";
    export var Notes: string = "contacts:Notes";
    export var Photo: string = "contacts:Photo";
    export var UserSMIMECertificate: string = "contacts:UserSMIMECertificate";
    export var MSExchangeCertificate: string = "contacts:MSExchangeCertificate";
    export var DirectoryId: string = "contacts:DirectoryId";
    export var ManagerMailbox: string = "contacts:ManagerMailbox";
    export var DirectReports: string = "contacts:DirectReports";
}

/**
 * Represents the schem for contacts.
 */
export class ContactSchema extends ItemSchema {

    /**
     * Defines the **FileAs** property.
     */
    public static FileAs: PropertyDefinition = new StringPropertyDefinition(
        "FileAs",
        XmlElementNames.FileAs,
        FieldUris.FileAs,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **FileAsMapping** property.
     */
    public static FileAsMapping: PropertyDefinition = new GenericPropertyDefinition<FileAsMapping>(
        "FileAsMapping",
        XmlElementNames.FileAsMapping,
        FieldUris.FileAsMapping,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        FileAsMapping
    );

    /**
     * Defines the **DisplayName** property.
     */
    public static DisplayName: PropertyDefinition = new StringPropertyDefinition(
        "DisplayName",
        XmlElementNames.DisplayName,
        FieldUris.DisplayName,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **GivenName** property.
     */
    public static GivenName: PropertyDefinition = new StringPropertyDefinition(
        "GivenName",
        XmlElementNames.GivenName,
        FieldUris.GivenName,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Initials** property.
     */
    public static Initials: PropertyDefinition = new StringPropertyDefinition(
        "Initials",
        XmlElementNames.Initials,
        FieldUris.Initials,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **MiddleName** property.
     */
    public static MiddleName: PropertyDefinition = new StringPropertyDefinition(
        "MiddleName",
        XmlElementNames.MiddleName,
        FieldUris.MiddleName,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **NickName** property.
     */
    public static NickName: PropertyDefinition = new StringPropertyDefinition(
        "Nickname",
        XmlElementNames.NickName,
        FieldUris.NickName,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **CompleteName** property.
     */
    public static CompleteName: PropertyDefinition = new ComplexPropertyDefinition<CompleteName>(
        "CompleteName",
        XmlElementNames.CompleteName,
        FieldUris.CompleteName,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new CompleteName(); }
    );

    /**
     * Defines the **CompanyName** property.
     */
    public static CompanyName: PropertyDefinition = new StringPropertyDefinition(
        "CompanyName",
        XmlElementNames.CompanyName,
        FieldUris.CompanyName,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **EmailAddresses** property.
     */
    public static EmailAddresses: PropertyDefinition = new ComplexPropertyDefinition<EmailAddressDictionary>(
        "EmailAddresses",
        XmlElementNames.EmailAddresses,
        FieldUris.EmailAddresses,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddressDictionary(); }
    );
    /**
     * Defines the **PhysicalAddresses** property.
     */
    public static PhysicalAddresses: PropertyDefinition = new ComplexPropertyDefinition<PhysicalAddressDictionary>(
        "PhysicalAddresses",
        XmlElementNames.PhysicalAddresses,
        FieldUris.PhysicalAddresses,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new PhysicalAddressDictionary(); }
    );

    /**
     * Defines the **PhoneNumbers** property.
     */
    public static PhoneNumbers: PropertyDefinition = new ComplexPropertyDefinition<PhoneNumberDictionary>(
        "PhoneNumbers",
        XmlElementNames.PhoneNumbers,
        FieldUris.PhoneNumbers,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new PhoneNumberDictionary(); }
    );

    /**
     * Defines the **AssistantName** property.
     */
    public static AssistantName: PropertyDefinition = new StringPropertyDefinition(
        "AssistantName",
        XmlElementNames.AssistantName,
        FieldUris.AssistantName,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Birthday** property.
     */
    public static Birthday: PropertyDefinition = new DateTimePropertyDefinition(
        "Birthday",
        XmlElementNames.Birthday,
        FieldUris.Birthday,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **BusinessHomePage** property.
     */
    public static BusinessHomePage: PropertyDefinition = new StringPropertyDefinition(
        "BusinessHomePage",
        XmlElementNames.BusinessHomePage,
        FieldUris.BusinessHomePage,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Children** property.
     */
    public static Children: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "Children",
        XmlElementNames.Children,
        FieldUris.Children,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **Companies** property.
     */
    public static Companies: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "Companies",
        XmlElementNames.Companies,
        FieldUris.Companies,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **ContactSource** property.
     */
    public static ContactSource: PropertyDefinition = new GenericPropertyDefinition<ContactSource>(
        "ContactSource",
        XmlElementNames.ContactSource,
        FieldUris.ContactSource,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        ContactSource
    );

    /**
     * Defines the **Department** property.
     */
    public static Department: PropertyDefinition = new StringPropertyDefinition(
        "Department",
        XmlElementNames.Department,
        FieldUris.Department,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Generation** property.
     */
    public static Generation: PropertyDefinition = new StringPropertyDefinition(
        "Generation",
        XmlElementNames.Generation,
        FieldUris.Generation,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ImAddresses** property.
     */
    public static ImAddresses: PropertyDefinition = new ComplexPropertyDefinition<ImAddressDictionary>(
        "ImAddresses",
        XmlElementNames.ImAddresses,
        FieldUris.ImAddresses,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new ImAddressDictionary(); }
    );

    /**
     * Defines the **JobTitle** property.
     */
    public static JobTitle: PropertyDefinition = new StringPropertyDefinition(
        "JobTitle",
        XmlElementNames.JobTitle,
        FieldUris.JobTitle,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Manager** property.
     */
    public static Manager: PropertyDefinition = new StringPropertyDefinition(
        "Manager",
        XmlElementNames.Manager,
        FieldUris.Manager,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Mileage** property.
     */
    public static Mileage: PropertyDefinition = new StringPropertyDefinition(
        "Mileage",
        XmlElementNames.Mileage,
        FieldUris.Mileage,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **OfficeLocation** property.
     */
    public static OfficeLocation: PropertyDefinition = new StringPropertyDefinition(
        "OfficeLocation",
        XmlElementNames.OfficeLocation,
        FieldUris.OfficeLocation,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **PostalAddressIndex** property.
     */
    public static PostalAddressIndex: PropertyDefinition = new GenericPropertyDefinition<PhysicalAddressIndex>(
        "PostalAddressIndex",
        XmlElementNames.PostalAddressIndex,
        FieldUris.PostalAddressIndex,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        PhysicalAddressIndex
    );

    /**
     * Defines the **Profession** property.
     */
    public static Profession: PropertyDefinition = new StringPropertyDefinition(
        "Profession",
        XmlElementNames.Profession,
        FieldUris.Profession,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **SpouseName** property.
     */
    public static SpouseName: PropertyDefinition = new StringPropertyDefinition(
        "SpouseName",
        XmlElementNames.SpouseName,
        FieldUris.SpouseName,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Surname** property.
     */
    public static Surname: PropertyDefinition = new StringPropertyDefinition(
        "Surname",
        XmlElementNames.Surname,
        FieldUris.Surname,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **WeddingAnniversary** property.
     */
    public static WeddingAnniversary: PropertyDefinition = new DateTimePropertyDefinition(
        "WeddingAnniversary",
        XmlElementNames.WeddingAnniversary,
        FieldUris.WeddingAnniversary,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **HasPicture** property.
     */
    public static HasPicture: PropertyDefinition = new BoolPropertyDefinition(
        "HasPicture",
        XmlElementNames.HasPicture,
        FieldUris.HasPicture,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010
    );

    /**
     * Defines the **PhoneticFullName** property.
     */
    public static PhoneticFullName: PropertyDefinition = new StringPropertyDefinition(
        "PhoneticFullName",
        XmlElementNames.PhoneticFullName,
        FieldUris.PhoneticFullName,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **PhoneticFirstName** property.
     */
    public static PhoneticFirstName: PropertyDefinition = new StringPropertyDefinition(
        "PhoneticFirstName",
        XmlElementNames.PhoneticFirstName,
        FieldUris.PhoneticFirstName,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **PhoneticLastName** property.
     */
    public static PhoneticLastName: PropertyDefinition = new StringPropertyDefinition(
        "PhoneticLastName",
        XmlElementNames.PhoneticLastName,
        FieldUris.PhoneticLastName,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **Alias** property.
     */
    public static Alias: PropertyDefinition = new StringPropertyDefinition(
        "Alias",
        XmlElementNames.Alias,
        FieldUris.Alias,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **Notes** property.
     */
    public static Notes: PropertyDefinition = new StringPropertyDefinition(
        "Notes",
        XmlElementNames.Notes,
        FieldUris.Notes,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **Photo** property.
     */
    public static Photo: PropertyDefinition = new ByteArrayPropertyDefinition(
        "Photo",
        XmlElementNames.Photo,
        FieldUris.Photo,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **UserSMIMECertificate** property.
     */
    public static UserSMIMECertificate: PropertyDefinition = new ComplexPropertyDefinition<ByteArrayArray>(
        "UserSMIMECertificate",
        XmlElementNames.UserSMIMECertificate,
        FieldUris.UserSMIMECertificate,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new ByteArrayArray(); }
    );

    /**
     * Defines the **MSExchangeCertificate** property.
     */
    public static MSExchangeCertificate: PropertyDefinition = new ComplexPropertyDefinition<ByteArrayArray>(
        "MSExchangeCertificate",
        XmlElementNames.MSExchangeCertificate,
        FieldUris.MSExchangeCertificate,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new ByteArrayArray(); }
    );

    /**
     * Defines the **DirectoryId** property.
     */
    public static DirectoryId: PropertyDefinition = new StringPropertyDefinition(
        "DirectoryId",
        XmlElementNames.DirectoryId,
        FieldUris.DirectoryId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1
    );

    /**
     * Defines the **ManagerMailbox** property.
     */
    public static ManagerMailbox: PropertyDefinition = new ContainedPropertyDefinition<EmailAddress>(
        "ManagerMailbox",
        XmlElementNames.ManagerMailbox,
        FieldUris.ManagerMailbox,
        XmlElementNames.Mailbox,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new EmailAddress(); }
    );

    /**
     * Defines the **DirectReports** property.
     */
    public static DirectReports: PropertyDefinition = new ComplexPropertyDefinition<EmailAddressCollection>(
        "DirectReports",
        XmlElementNames.DirectReports,
        FieldUris.DirectReports,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2010_SP1,
        () => { return new EmailAddressCollection(); }
    );

    /**
     * Defines the **EmailAddress1** property.
     */
    public static EmailAddress1: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.EmailAddress,
        "EmailAddress1"
    );

    /**
     * Defines the **EmailAddress2** property.
     */
    public static EmailAddress2: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.EmailAddress,
        "EmailAddress2"
    );

    /**
     * Defines the **EmailAddress3** property.
     */
    public static EmailAddress3: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.EmailAddress,
        "EmailAddress3"
    );

    /**
     * Defines the **ImAddress1** property.
     */
    public static ImAddress1: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.ImAddress,
        "ImAddress1"
    );

    /**
     * Defines the **ImAddress2** property.
     */
    public static ImAddress2: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.ImAddress,
        "ImAddress2"
    );

    /**
     * Defines the **ImAddress3** property.
     */
    public static ImAddress3: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.ImAddress,
        "ImAddress3"
    );

    /**
     * Defines the **AssistantPhone** property.
     */
    public static AssistantPhone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "AssistantPhone"
    );

    /**
     * Defines the **BusinessFax** property.
     */
    public static BusinessFax: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "BusinessFax"
    );

    /**
     * Defines the **BusinessPhone** property.
     */
    public static BusinessPhone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "BusinessPhone"
    );

    /**
     * Defines the **BusinessPhone2** property.
     */
    public static BusinessPhone2: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "BusinessPhone2"
    );

    /**
     * Defines the **Callback** property.
     */
    public static Callback: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "Callback"
    );

    /**
     * Defines the **CarPhone** property.
     */
    public static CarPhone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "CarPhone"
    );

    /**
     * Defines the **CompanyMainPhone** property.
     */
    public static CompanyMainPhone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "CompanyMainPhone"
    );

    /**
     * Defines the **HomeFax** property.
     */
    public static HomeFax: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "HomeFax"
    );

    /**
     * Defines the **HomePhone** property.
     */
    public static HomePhone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "HomePhone"
    );

    /**
     * Defines the **HomePhone2** property.
     */
    public static HomePhone2: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "HomePhone2"
    );

    /**
     * Defines the **Isdn** property.
     */
    public static Isdn: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "Isdn"
    );

    /**
     * Defines the **MobilePhone** property.
     */
    public static MobilePhone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "MobilePhone"
    );

    /**
     * Defines the **OtherFax** property.
     */
    public static OtherFax: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "OtherFax"
    );

    /**
     * Defines the **OtherTelephone** property.
     */
    public static OtherTelephone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "OtherTelephone"
    );

    /**
     * Defines the **Pager** property.
     */
    public static Pager: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "Pager"
    );

    /**
     * Defines the **PrimaryPhone** property.
     */
    public static PrimaryPhone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "PrimaryPhone"
    );

    /**
     * Defines the **RadioPhone** property.
     */
    public static RadioPhone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "RadioPhone"
    );

    /**
     * Defines the **Telex** property.
     */
    public static Telex: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "Telex"
    );

    /**
     * Defines the **TtyTddPhone** property.
     */
    public static TtyTddPhone: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhoneNumber,
        "TtyTddPhone"
    );

    /**
     * Defines the **BusinessAddressStreet** property.
     */
    public static BusinessAddressStreet: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressStreet,
        "Business"
    );

    /**
     * Defines the **BusinessAddressCity** property.
     */
    public static BusinessAddressCity: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressCity,
        "Business"
    );

    /**
     * Defines the **BusinessAddressState** property.
     */
    public static BusinessAddressState: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressState,
        "Business"
    );

    /**
     * Defines the **BusinessAddressCountryOrRegion** property.
     */
    public static BusinessAddressCountryOrRegion: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressCountryOrRegion,
        "Business"
    );

    /**
     * Defines the **BusinessAddressPostalCode** property.
     */
    public static BusinessAddressPostalCode: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressPostalCode,
        "Business"
    );

    /**
     * Defines the **HomeAddressStreet** property.
     */
    public static HomeAddressStreet: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressStreet,
        "Home"
    );

    /**
     * Defines the **HomeAddressCity** property.
     */
    public static HomeAddressCity: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressCity,
        "Home"
    );

    /**
     * Defines the **HomeAddressState** property.
     */
    public static HomeAddressState: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressState,
        "Home"
    );

    /**
     * Defines the **HomeAddressCountryOrRegion** property.
     */
    public static HomeAddressCountryOrRegion: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressCountryOrRegion,
        "Home"
    );

    /**
     * Defines the **HomeAddressPostalCode** property.
     */
    public static HomeAddressPostalCode: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressPostalCode,
        "Home"
    );

    /**
     * Defines the **OtherAddressStreet** property.
     */
    public static OtherAddressStreet: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressStreet,
        "Other"
    );

    /**
     * Defines the **OtherAddressCity** property.
     */
    public static OtherAddressCity: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressCity,
        "Other"
    );

    /**
     * Defines the **OtherAddressState** property.
     */
    public static OtherAddressState: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressState,
        "Other"
    );

    /**
     * Defines the **OtherAddressCountryOrRegion** property.
     */
    public static OtherAddressCountryOrRegion: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressCountryOrRegion,
        "Other"
    );

    /**
     * Defines the **OtherAddressPostalCode** property.
     */
    public static OtherAddressPostalCode: IndexedPropertyDefinition = new IndexedPropertyDefinition(
        FieldUris.PhysicalAddressPostalCode,
        "Other"
    );

    /**
     * @internal Instance of **ContactSchema** 
     */
    static Instance: ContactSchema = new ContactSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(ContactSchema, ContactSchema.FileAs);
        this.RegisterProperty(ContactSchema, ContactSchema.FileAsMapping);
        this.RegisterProperty(ContactSchema, ContactSchema.DisplayName);
        this.RegisterProperty(ContactSchema, ContactSchema.GivenName);
        this.RegisterProperty(ContactSchema, ContactSchema.Initials);
        this.RegisterProperty(ContactSchema, ContactSchema.MiddleName);
        this.RegisterProperty(ContactSchema, ContactSchema.NickName);
        this.RegisterProperty(ContactSchema, ContactSchema.CompleteName);
        this.RegisterProperty(ContactSchema, ContactSchema.CompanyName);
        this.RegisterProperty(ContactSchema, ContactSchema.EmailAddresses);
        this.RegisterProperty(ContactSchema, ContactSchema.PhysicalAddresses);
        this.RegisterProperty(ContactSchema, ContactSchema.PhoneNumbers);
        this.RegisterProperty(ContactSchema, ContactSchema.AssistantName);
        this.RegisterProperty(ContactSchema, ContactSchema.Birthday);
        this.RegisterProperty(ContactSchema, ContactSchema.BusinessHomePage);
        this.RegisterProperty(ContactSchema, ContactSchema.Children);
        this.RegisterProperty(ContactSchema, ContactSchema.Companies);
        this.RegisterProperty(ContactSchema, ContactSchema.ContactSource);
        this.RegisterProperty(ContactSchema, ContactSchema.Department);
        this.RegisterProperty(ContactSchema, ContactSchema.Generation);
        this.RegisterProperty(ContactSchema, ContactSchema.ImAddresses);
        this.RegisterProperty(ContactSchema, ContactSchema.JobTitle);
        this.RegisterProperty(ContactSchema, ContactSchema.Manager);
        this.RegisterProperty(ContactSchema, ContactSchema.Mileage);
        this.RegisterProperty(ContactSchema, ContactSchema.OfficeLocation);
        this.RegisterProperty(ContactSchema, ContactSchema.PostalAddressIndex);
        this.RegisterProperty(ContactSchema, ContactSchema.Profession);
        this.RegisterProperty(ContactSchema, ContactSchema.SpouseName);
        this.RegisterProperty(ContactSchema, ContactSchema.Surname);
        this.RegisterProperty(ContactSchema, ContactSchema.WeddingAnniversary);
        this.RegisterProperty(ContactSchema, ContactSchema.HasPicture);
        this.RegisterProperty(ContactSchema, ContactSchema.PhoneticFullName);
        this.RegisterProperty(ContactSchema, ContactSchema.PhoneticFirstName);
        this.RegisterProperty(ContactSchema, ContactSchema.PhoneticLastName);
        this.RegisterProperty(ContactSchema, ContactSchema.Alias);
        this.RegisterProperty(ContactSchema, ContactSchema.Notes);
        this.RegisterProperty(ContactSchema, ContactSchema.Photo);
        this.RegisterProperty(ContactSchema, ContactSchema.UserSMIMECertificate);
        this.RegisterProperty(ContactSchema, ContactSchema.MSExchangeCertificate);
        this.RegisterProperty(ContactSchema, ContactSchema.DirectoryId);
        this.RegisterProperty(ContactSchema, ContactSchema.ManagerMailbox);
        this.RegisterProperty(ContactSchema, ContactSchema.DirectReports);
        this.RegisterIndexedProperty(ContactSchema.EmailAddress1);
        this.RegisterIndexedProperty(ContactSchema.EmailAddress2);
        this.RegisterIndexedProperty(ContactSchema.EmailAddress3);
        this.RegisterIndexedProperty(ContactSchema.ImAddress1);
        this.RegisterIndexedProperty(ContactSchema.ImAddress2);
        this.RegisterIndexedProperty(ContactSchema.ImAddress3);
        this.RegisterIndexedProperty(ContactSchema.AssistantPhone);
        this.RegisterIndexedProperty(ContactSchema.BusinessFax);
        this.RegisterIndexedProperty(ContactSchema.BusinessPhone);
        this.RegisterIndexedProperty(ContactSchema.BusinessPhone2);
        this.RegisterIndexedProperty(ContactSchema.Callback);
        this.RegisterIndexedProperty(ContactSchema.CarPhone);
        this.RegisterIndexedProperty(ContactSchema.CompanyMainPhone);
        this.RegisterIndexedProperty(ContactSchema.HomeFax);
        this.RegisterIndexedProperty(ContactSchema.HomePhone);
        this.RegisterIndexedProperty(ContactSchema.HomePhone2);
        this.RegisterIndexedProperty(ContactSchema.Isdn);
        this.RegisterIndexedProperty(ContactSchema.MobilePhone);
        this.RegisterIndexedProperty(ContactSchema.OtherFax);
        this.RegisterIndexedProperty(ContactSchema.OtherTelephone);
        this.RegisterIndexedProperty(ContactSchema.Pager);
        this.RegisterIndexedProperty(ContactSchema.PrimaryPhone);
        this.RegisterIndexedProperty(ContactSchema.RadioPhone);
        this.RegisterIndexedProperty(ContactSchema.Telex);
        this.RegisterIndexedProperty(ContactSchema.TtyTddPhone);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressStreet);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressCity);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressState);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressCountryOrRegion);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressPostalCode);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressStreet);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressCity);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressState);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressCountryOrRegion);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressPostalCode);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressStreet);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressCity);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressState);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressCountryOrRegion);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressPostalCode);
    }
}

/**
 * Represents the schem for contacts.
 */
export interface ContactSchema {
    /**
     * Defines the **FileAs** property.
     */
    FileAs: PropertyDefinition;
    /**
     * Defines the **FileAsMapping** property.
     */
    FileAsMapping: PropertyDefinition;
    /**
     * Defines the **DisplayName** property.
     */
    DisplayName: PropertyDefinition;
    /**
     * Defines the **GivenName** property.
     */
    GivenName: PropertyDefinition;
    /**
     * Defines the **Initials** property.
     */
    Initials: PropertyDefinition;
    /**
     * Defines the **MiddleName** property.
     */
    MiddleName: PropertyDefinition;
    /**
     * Defines the **NickName** property.
     */
    NickName: PropertyDefinition;
    /**
     * Defines the **CompleteName** property.
     */
    CompleteName: PropertyDefinition;
    /**
     * Defines the **CompanyName** property.
     */
    CompanyName: PropertyDefinition;
    /**
     * Defines the **EmailAddresses** property.
     */
    EmailAddresses: PropertyDefinition;
    /**
     * Defines the **PhysicalAddresses** property.
     */
    PhysicalAddresses: PropertyDefinition;
    /**
     * Defines the **PhoneNumbers** property.
     */
    PhoneNumbers: PropertyDefinition;
    /**
     * Defines the **AssistantName** property.
     */
    AssistantName: PropertyDefinition;
    /**
     * Defines the **Birthday** property.
     */
    Birthday: PropertyDefinition;
    /**
     * Defines the **BusinessHomePage** property.
     */
    BusinessHomePage: PropertyDefinition;
    /**
     * Defines the **Children** property.
     */
    Children: PropertyDefinition;
    /**
     * Defines the **Companies** property.
     */
    Companies: PropertyDefinition;
    /**
     * Defines the **ContactSource** property.
     */
    ContactSource: PropertyDefinition;
    /**
     * Defines the **Department** property.
     */
    Department: PropertyDefinition;
    /**
     * Defines the **Generation** property.
     */
    Generation: PropertyDefinition;
    /**
     * Defines the **ImAddresses** property.
     */
    ImAddresses: PropertyDefinition;
    /**
     * Defines the **JobTitle** property.
     */
    JobTitle: PropertyDefinition;
    /**
     * Defines the **Manager** property.
     */
    Manager: PropertyDefinition;
    /**
     * Defines the **Mileage** property.
     */
    Mileage: PropertyDefinition;
    /**
     * Defines the **OfficeLocation** property.
     */
    OfficeLocation: PropertyDefinition;
    /**
     * Defines the **PostalAddressIndex** property.
     */
    PostalAddressIndex: PropertyDefinition;
    /**
     * Defines the **Profession** property.
     */
    Profession: PropertyDefinition;
    /**
     * Defines the **SpouseName** property.
     */
    SpouseName: PropertyDefinition;
    /**
     * Defines the **Surname** property.
     */
    Surname: PropertyDefinition;
    /**
     * Defines the **WeddingAnniversary** property.
     */
    WeddingAnniversary: PropertyDefinition;
    /**
     * Defines the **HasPicture** property.
     */
    HasPicture: PropertyDefinition;
    /**
     * Defines the **PhoneticFullName** property.
     */
    PhoneticFullName: PropertyDefinition;
    /**
     * Defines the **PhoneticFirstName** property.
     */
    PhoneticFirstName: PropertyDefinition;
    /**
     * Defines the **PhoneticLastName** property.
     */
    PhoneticLastName: PropertyDefinition;
    /**
     * Defines the **Alias** property.
     */
    Alias: PropertyDefinition;
    /**
     * Defines the **Notes** property.
     */
    Notes: PropertyDefinition;
    /**
     * Defines the **Photo** property.
     */
    Photo: PropertyDefinition;
    /**
     * Defines the **UserSMIMECertificate** property.
     */
    UserSMIMECertificate: PropertyDefinition;
    /**
     * Defines the **MSExchangeCertificate** property.
     */
    MSExchangeCertificate: PropertyDefinition;
    /**
     * Defines the **DirectoryId** property.
     */
    DirectoryId: PropertyDefinition;
    /**
     * Defines the **ManagerMailbox** property.
     */
    ManagerMailbox: PropertyDefinition;
    /**
     * Defines the **DirectReports** property.
     */
    DirectReports: PropertyDefinition;
    /**
     * Defines the **EmailAddress1** property.
     */
    EmailAddress1: IndexedPropertyDefinition;
    /**
     * Defines the **EmailAddress2** property.
     */
    EmailAddress2: IndexedPropertyDefinition;
    /**
     * Defines the **EmailAddress3** property.
     */
    EmailAddress3: IndexedPropertyDefinition;
    /**
     * Defines the **ImAddress1** property.
     */
    ImAddress1: IndexedPropertyDefinition;
    /**
     * Defines the **ImAddress2** property.
     */
    ImAddress2: IndexedPropertyDefinition;
    /**
     * Defines the **ImAddress3** property.
     */
    ImAddress3: IndexedPropertyDefinition;
    /**
     * Defines the **AssistantPhone** property.
     */
    AssistantPhone: IndexedPropertyDefinition;
    /**
     * Defines the **BusinessFax** property.
     */
    BusinessFax: IndexedPropertyDefinition;
    /**
     * Defines the **BusinessPhone** property.
     */
    BusinessPhone: IndexedPropertyDefinition;
    /**
     * Defines the **BusinessPhone2** property.
     */
    BusinessPhone2: IndexedPropertyDefinition;
    /**
     * Defines the **Callback** property.
     */
    Callback: IndexedPropertyDefinition;
    /**
     * Defines the **CarPhone** property.
     */
    CarPhone: IndexedPropertyDefinition;
    /**
     * Defines the **CompanyMainPhone** property.
     */
    CompanyMainPhone: IndexedPropertyDefinition;
    /**
     * Defines the **HomeFax** property.
     */
    HomeFax: IndexedPropertyDefinition;
    /**
     * Defines the **HomePhone** property.
     */
    HomePhone: IndexedPropertyDefinition;
    /**
     * Defines the **HomePhone2** property.
     */
    HomePhone2: IndexedPropertyDefinition;
    /**
     * Defines the **Isdn** property.
     */
    Isdn: IndexedPropertyDefinition;
    /**
     * Defines the **MobilePhone** property.
     */
    MobilePhone: IndexedPropertyDefinition;
    /**
     * Defines the **OtherFax** property.
     */
    OtherFax: IndexedPropertyDefinition;
    /**
     * Defines the **OtherTelephone** property.
     */
    OtherTelephone: IndexedPropertyDefinition;
    /**
     * Defines the **Pager** property.
     */
    Pager: IndexedPropertyDefinition;
    /**
     * Defines the **PrimaryPhone** property.
     */
    PrimaryPhone: IndexedPropertyDefinition;
    /**
     * Defines the **RadioPhone** property.
     */
    RadioPhone: IndexedPropertyDefinition;
    /**
     * Defines the **Telex** property.
     */
    Telex: IndexedPropertyDefinition;
    /**
     * Defines the **TtyTddPhone** property.
     */
    TtyTddPhone: IndexedPropertyDefinition;
    /**
     * Defines the **BusinessAddressStreet** property.
     */
    BusinessAddressStreet: IndexedPropertyDefinition;
    /**
     * Defines the **BusinessAddressCity** property.
     */
    BusinessAddressCity: IndexedPropertyDefinition;
    /**
     * Defines the **BusinessAddressState** property.
     */
    BusinessAddressState: IndexedPropertyDefinition;
    /**
     * Defines the **BusinessAddressCountryOrRegion** property.
     */
    BusinessAddressCountryOrRegion: IndexedPropertyDefinition;
    /**
     * Defines the **BusinessAddressPostalCode** property.
     */
    BusinessAddressPostalCode: IndexedPropertyDefinition;
    /**
     * Defines the **HomeAddressStreet** property.
     */
    HomeAddressStreet: IndexedPropertyDefinition;
    /**
     * Defines the **HomeAddressCity** property.
     */
    HomeAddressCity: IndexedPropertyDefinition;
    /**
     * Defines the **HomeAddressState** property.
     */
    HomeAddressState: IndexedPropertyDefinition;
    /**
     * Defines the **HomeAddressCountryOrRegion** property.
     */
    HomeAddressCountryOrRegion: IndexedPropertyDefinition;
    /**
     * Defines the **HomeAddressPostalCode** property.
     */
    HomeAddressPostalCode: IndexedPropertyDefinition;
    /**
     * Defines the **OtherAddressStreet** property.
     */
    OtherAddressStreet: IndexedPropertyDefinition;
    /**
     * Defines the **OtherAddressCity** property.
     */
    OtherAddressCity: IndexedPropertyDefinition;
    /**
     * Defines the **OtherAddressState** property.
     */
    OtherAddressState: IndexedPropertyDefinition;
    /**
     * Defines the **OtherAddressCountryOrRegion** property.
     */
    OtherAddressCountryOrRegion: IndexedPropertyDefinition;
    /**
     * Defines the **OtherAddressPostalCode** property.
     */
    OtherAddressPostalCode: IndexedPropertyDefinition;
    /**
     * @internal Instance of **ContactSchema**
     */
    Instance: ContactSchema;
}

/**
 * Represents the schem for contacts.
 */
export interface ContactSchemaStatic extends ContactSchema {
}
Schemas.ContactSchema = <any>ContactSchema;


/**
 * Field URIs for Members.
 */
module FieldUris {
    /**
     * FieldUri for members.
     */
    export var Members: string = "distributionlist:Members";
}

/**
 * Represents the schema for contact groups.
 */
export class ContactGroupSchema extends ItemSchema {

    /**
     * Defines the **DisplayName** property.
     */
    public static DisplayName: PropertyDefinition = Schemas.ContactSchema.DisplayName;

    /**
     * Defines the **FileAs** property.
     */
    public static FileAs: PropertyDefinition = Schemas.ContactSchema.FileAs;

    /**
     * Defines the **Members** property.
     */
    public static Members: PropertyDefinition = new ComplexPropertyDefinition<GroupMemberCollection>(
        "Members",
        XmlElementNames.Members,
        FieldUris.Members,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate,
        ExchangeVersion.Exchange2010,
        () => { return new GroupMemberCollection(); }
    );

    /**
     * @internal Instance of **ContactGroupSchema** 
     */
    static Instance: ContactGroupSchema = new ContactGroupSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(ContactGroupSchema, ContactGroupSchema.DisplayName);
        this.RegisterProperty(ContactGroupSchema, ContactGroupSchema.FileAs);
        this.RegisterProperty(ContactGroupSchema, ContactGroupSchema.Members);
    }
}

/**
 * Represents the schema for contact groups.
 */
export interface ContactGroupSchema {
    /**
     * Defines the **DisplayName** property.
     */
    DisplayName: PropertyDefinition;
    /**
     * Defines the **FileAs** property.
     */
    FileAs: PropertyDefinition;
    /**
     * Defines the **Members** property.
     */
    Members: PropertyDefinition;
    /**
     * @internal Instance of **ContactGroupSchema**
     */
    Instance: ContactGroupSchema;
}

/**
 * Represents the schema for contact groups.
 */
export interface ContactGroupSchemaStatic extends ContactGroupSchema {
}
Schemas.ContactGroupSchema = <any>ContactGroupSchema;


/**
 * Field URIs for EmailMessage.
 */
module FieldUris {
    export var ConversationIndex: string = "message:ConversationIndex";
    export var ConversationTopic: string = "message:ConversationTopic";
    export var InternetMessageId: string = "message:InternetMessageId";
    export var IsRead: string = "message:IsRead";
    export var IsResponseRequested: string = "message:IsResponseRequested";
    export var IsReadReceiptRequested: string = "message:IsReadReceiptRequested";
    export var IsDeliveryReceiptRequested: string = "message:IsDeliveryReceiptRequested";
    export var References: string = "message:References";
    export var ReplyTo: string = "message:ReplyTo";
    export var From: string = "message:From";
    export var Sender: string = "message:Sender";
    export var ToRecipients: string = "message:ToRecipients";
    export var CcRecipients: string = "message:CcRecipients";
    export var BccRecipients: string = "message:BccRecipients";
    export var ReceivedBy: string = "message:ReceivedBy";
    export var ReceivedRepresenting: string = "message:ReceivedRepresenting";
    export var ApprovalRequestData: string = "message:ApprovalRequestData";
    export var VotingInformation: string = "message:VotingInformation";
}

/**
 * Represents the schema for e-mail messages.
 */
export class EmailMessageSchema extends ItemSchema {

    /**
     * Defines the **ToRecipients** property.
     */
    public static ToRecipients: PropertyDefinition = new ComplexPropertyDefinition<EmailAddressCollection>(
        "ToRecipients",
        XmlElementNames.ToRecipients,
        FieldUris.ToRecipients,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddressCollection(); }
    );

    /**
     * Defines the **BccRecipients** property.
     */
    public static BccRecipients: PropertyDefinition = new ComplexPropertyDefinition<EmailAddressCollection>(
        "BccRecipients",
        XmlElementNames.BccRecipients,
        FieldUris.BccRecipients,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddressCollection(); }
    );

    /**
     * Defines the **CcRecipients** property.
     */
    public static CcRecipients: PropertyDefinition = new ComplexPropertyDefinition<EmailAddressCollection>(
        "CcRecipients",
        XmlElementNames.CcRecipients,
        FieldUris.CcRecipients,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddressCollection(); }
    );

    /**
     * Defines the **ConversationIndex** property.
     */
    public static ConversationIndex: PropertyDefinition = new ByteArrayPropertyDefinition(
        "ConversationIndex",
        XmlElementNames.ConversationIndex,
        FieldUris.ConversationIndex,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ConversationTopic** property.
     */
    public static ConversationTopic: PropertyDefinition = new StringPropertyDefinition(
        "ConversationTopic",
        XmlElementNames.ConversationTopic,
        FieldUris.ConversationTopic,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **From** property.
     */
    public static From: PropertyDefinition = new ContainedPropertyDefinition<EmailAddress>(
        "From",
        XmlElementNames.From,
        FieldUris.From,
        XmlElementNames.Mailbox,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddress(); }
    );

    /**
     * Defines the **IsDeliveryReceiptRequested** property.
     */
    public static IsDeliveryReceiptRequested: PropertyDefinition = new BoolPropertyDefinition(
        "IsDeliveryReceiptRequested",
        XmlElementNames.IsDeliveryReceiptRequested,
        FieldUris.IsDeliveryReceiptRequested,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsRead** property.
     */
    public static IsRead: PropertyDefinition = new BoolPropertyDefinition(
        "IsRead",
        XmlElementNames.IsRead,
        FieldUris.IsRead,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsReadReceiptRequested** property.
     */
    public static IsReadReceiptRequested: PropertyDefinition = new BoolPropertyDefinition(
        "IsReadReceiptRequested",
        XmlElementNames.IsReadReceiptRequested,
        FieldUris.IsReadReceiptRequested,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsResponseRequested** property.
     */
    public static IsResponseRequested: PropertyDefinition = new BoolPropertyDefinition(
        "IsResponseRequested",
        XmlElementNames.IsResponseRequested,
        FieldUris.IsResponseRequested,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        true
    );

    /**
     * Defines the **InternetMessageId** property.
     */
    public static InternetMessageId: PropertyDefinition = new StringPropertyDefinition(
        "InternetMessageId",
        XmlElementNames.InternetMessageId,
        FieldUris.InternetMessageId,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **References** property.
     */
    public static References: PropertyDefinition = new StringPropertyDefinition(
        "References",
        XmlElementNames.References,
        FieldUris.References,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ReplyTo** property.
     */
    public static ReplyTo: PropertyDefinition = new ComplexPropertyDefinition<EmailAddressCollection>(
        "ReplyTo",
        XmlElementNames.ReplyTo,
        FieldUris.ReplyTo,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddressCollection(); }
    );

    /**
     * Defines the **Sender** property.
     */
    public static Sender: PropertyDefinition = new ContainedPropertyDefinition<EmailAddress>(
        "Sender",
        XmlElementNames.Sender,
        FieldUris.Sender,
        XmlElementNames.Mailbox,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddress(); }
    );

    /**
     * Defines the **ReceivedBy** property.
     */
    public static ReceivedBy: PropertyDefinition = new ContainedPropertyDefinition<EmailAddress>(
        "ReceivedBy",
        XmlElementNames.ReceivedBy,
        FieldUris.ReceivedBy,
        XmlElementNames.Mailbox,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddress(); }
    );

    /**
     * Defines the **ReceivedRepresenting** property.
     */
    public static ReceivedRepresenting: PropertyDefinition = new ContainedPropertyDefinition<EmailAddress>(
        "ReceivedRepresenting",
        XmlElementNames.ReceivedRepresenting,
        FieldUris.ReceivedRepresenting,
        XmlElementNames.Mailbox,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new EmailAddress(); }
    );

    /**
     * Defines the **ApprovalRequestData** property.
     */
    public static ApprovalRequestData: PropertyDefinition = new ComplexPropertyDefinition<ApprovalRequestData>(
        "ApprovalRequestData",
        XmlElementNames.ApprovalRequestData,
        FieldUris.ApprovalRequestData,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2013,
        () => { return new ApprovalRequestData(); }
    );

    /**
     * Defines the **VotingInformation** property.
     */
    public static VotingInformation: PropertyDefinition = new ComplexPropertyDefinition<VotingInformation>(
        "VotingInformation",
        XmlElementNames.VotingInformation,
        FieldUris.VotingInformation,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2013,
        () => { return new VotingInformation(); }
    );

    /**
     * @internal Instance of **EmailMessageSchema** 
     */
    static Instance: EmailMessageSchema = new EmailMessageSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.Sender);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ToRecipients);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.CcRecipients);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.BccRecipients);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.IsReadReceiptRequested);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.IsDeliveryReceiptRequested);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ConversationIndex);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ConversationTopic);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.From);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.InternetMessageId);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.IsRead);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.IsResponseRequested);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.References);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ReplyTo);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ReceivedBy);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ReceivedRepresenting);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ApprovalRequestData);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.VotingInformation);
    }
}

/**
 * Represents the schema for e-mail messages.
 */
export interface EmailMessageSchema {
    /**
     * Defines the **ToRecipients** property.
     */
    ToRecipients: PropertyDefinition;
    /**
     * Defines the **BccRecipients** property.
     */
    BccRecipients: PropertyDefinition;
    /**
     * Defines the **CcRecipients** property.
     */
    CcRecipients: PropertyDefinition;
    /**
     * Defines the **ConversationIndex** property.
     */
    ConversationIndex: PropertyDefinition;
    /**
     * Defines the **ConversationTopic** property.
     */
    ConversationTopic: PropertyDefinition;
    /**
     * Defines the **From** property.
     */
    From: PropertyDefinition;
    /**
     * Defines the **IsDeliveryReceiptRequested** property.
     */
    IsDeliveryReceiptRequested: PropertyDefinition;
    /**
     * Defines the **IsRead** property.
     */
    IsRead: PropertyDefinition;
    /**
     * Defines the **IsReadReceiptRequested** property.
     */
    IsReadReceiptRequested: PropertyDefinition;
    /**
     * Defines the **IsResponseRequested** property.
     */
    IsResponseRequested: PropertyDefinition;
    /**
     * Defines the **InternetMessageId** property.
     */
    InternetMessageId: PropertyDefinition;
    /**
     * Defines the **References** property.
     */
    References: PropertyDefinition;
    /**
     * Defines the **ReplyTo** property.
     */
    ReplyTo: PropertyDefinition;
    /**
     * Defines the **Sender** property.
     */
    Sender: PropertyDefinition;
    /**
     * Defines the **ReceivedBy** property.
     */
    ReceivedBy: PropertyDefinition;
    /**
     * Defines the **ReceivedRepresenting** property.
     */
    ReceivedRepresenting: PropertyDefinition;
    /**
     * Defines the **ApprovalRequestData** property.
     */
    ApprovalRequestData: PropertyDefinition;
    /**
     * Defines the **VotingInformation** property.
     */
    VotingInformation: PropertyDefinition;
    /**
     * @internal Instance of **EmailMessageSchema**
     */
    Instance: EmailMessageSchema;
}

/**
 * Represents the schema for e-mail messages.
 */
export interface EmailMessageSchemaStatic extends EmailMessageSchema {
}
Schemas.EmailMessageSchema = <any>EmailMessageSchema;


/**
 * Field URIs for MeetingMessage.
 */
module FieldUris {
    export var AssociatedCalendarItemId: string = "meeting:AssociatedCalendarItemId";
    export var IsDelegated: string = "meeting:IsDelegated";
    export var IsOutOfDate: string = "meeting:IsOutOfDate";
    export var HasBeenProcessed: string = "meeting:HasBeenProcessed";
    export var ResponseType: string = "meeting:ResponseType";
    export var IsOrganizer: string = "cal:IsOrganizer";
}

/**
 * Represents the schema for meeting messages.
 */
export class MeetingMessageSchema extends EmailMessageSchema {

    /**
     * Defines the **AssociatedAppointmentId** property.
     */
    public static AssociatedAppointmentId: PropertyDefinition = new ComplexPropertyDefinition<ItemId>(
        "AssociatedCalendarItemId",
        XmlElementNames.AssociatedCalendarItemId,
        FieldUris.AssociatedCalendarItemId,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new ItemId(); }
    );

    /**
     * Defines the **IsDelegated** property.
     */
    public static IsDelegated: PropertyDefinition = new BoolPropertyDefinition(
        "IsDelegated",
        XmlElementNames.IsDelegated,
        FieldUris.IsDelegated,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsOutOfDate** property.
     */
    public static IsOutOfDate: PropertyDefinition = new BoolPropertyDefinition(
        "IsOutOfDate",
        XmlElementNames.IsOutOfDate,
        FieldUris.IsOutOfDate,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **HasBeenProcessed** property.
     */
    public static HasBeenProcessed: PropertyDefinition = new BoolPropertyDefinition(
        "HasBeenProcessed",
        XmlElementNames.HasBeenProcessed,
        FieldUris.HasBeenProcessed,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ResponseType** property.
     */
    public static ResponseType: PropertyDefinition = new GenericPropertyDefinition<MeetingResponseType>(
        "ResponseType",
        XmlElementNames.ResponseType,
        FieldUris.ResponseType,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        MeetingResponseType
    );

    /**
     * Defines the **ICalUid** property.
     */
    public static ICalUid: PropertyDefinition = Schemas.AppointmentSchema.ICalUid;

    /**
     * Defines the **ICalRecurrenceId** property.
     */
    public static ICalRecurrenceId: PropertyDefinition = Schemas.AppointmentSchema.ICalRecurrenceId;

    /**
     * Defines the **ICalDateTimeStamp** property.
     */
    public static ICalDateTimeStamp: PropertyDefinition = Schemas.AppointmentSchema.ICalDateTimeStamp;

    /**
     * Defines the **IsOrganizer** property.
     */
    public static IsOrganizer: PropertyDefinition = new GenericPropertyDefinition<boolean>(
        "IsOrganizer",
        XmlElementNames.IsOrganizer,
        "cal:IsOrganizer",
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        false //isNullable
    );

    /**
     * @internal Instance of **MeetingMessageSchema** 
     */
    static Instance: MeetingMessageSchema = new MeetingMessageSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.AssociatedAppointmentId);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.IsDelegated);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.IsOutOfDate);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.HasBeenProcessed);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.ResponseType);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.ICalUid);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.ICalRecurrenceId);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.ICalDateTimeStamp);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.IsOrganizer);
    }
}

/**
 * Represents the schema for meeting messages.
 */
export interface MeetingMessageSchema {
    /**
     * Defines the **AssociatedAppointmentId** property.
     */
    AssociatedAppointmentId: PropertyDefinition;
    /**
     * Defines the **IsDelegated** property.
     */
    IsDelegated: PropertyDefinition;
    /**
     * Defines the **IsOutOfDate** property.
     */
    IsOutOfDate: PropertyDefinition;
    /**
     * Defines the **HasBeenProcessed** property.
     */
    HasBeenProcessed: PropertyDefinition;
    /**
     * Defines the **ResponseType** property.
     */
    ResponseType: PropertyDefinition;
    /**
     * Defines the **ICalUid** property.
     */
    ICalUid: PropertyDefinition;
    /**
     * Defines the **ICalRecurrenceId** property.
     */
    ICalRecurrenceId: PropertyDefinition;
    /**
     * Defines the **ICalDateTimeStamp** property.
     */
    ICalDateTimeStamp: PropertyDefinition;
    /**
     * Defines the **IsOrganizer** property.
     */
    IsOrganizer: PropertyDefinition;
    /**
     * @internal Instance of **MeetingMessageSchema**
     */
    Instance: MeetingMessageSchema;
}

/**
 * Represents the schema for meeting messages.
 */
export interface MeetingMessageSchemaStatic extends MeetingMessageSchema {
}
Schemas.MeetingMessageSchema = <any>MeetingMessageSchema;

/**
 * Represents the schema for meeting cancellation.
 */
export class MeetingCancellationSchema extends MeetingMessageSchema {

    /**
     * Defines the **Start** property.
     */
    public static Start: PropertyDefinition = Schemas.AppointmentSchema.Start;

    /**
     * Defines the **End** property.
     */
    public static End: PropertyDefinition = Schemas.AppointmentSchema.End;

    /**
     * Defines the **Location** property.
     */
    public static Location: PropertyDefinition = Schemas.AppointmentSchema.Location;

    /**
     * Defines the **AppointmentType** property.
     */
    public static AppointmentType: PropertyDefinition = Schemas.AppointmentSchema.AppointmentType;

    /**
     * Defines the **Recurrence** property.
     */
    public static Recurrence: PropertyDefinition = Schemas.AppointmentSchema.Recurrence;

    /**
     * Defines the **EnhancedLocation** property.
     */
    public static EnhancedLocation: PropertyDefinition = Schemas.AppointmentSchema.EnhancedLocation;

    /**
     * @internal Instance of **MeetingCancellationSchema** 
     */
    static Instance: MeetingCancellationSchema = new MeetingCancellationSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.Start);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.End);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.Location);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.Recurrence);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.AppointmentType);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.EnhancedLocation);
    }
}

/**
 * Represents the schema for meeting cancellation.
 */
export interface MeetingCancellationSchema {
    /**
     * Defines the **Start** property.
     */
    Start: PropertyDefinition;
    /**
     * Defines the **End** property.
     */
    End: PropertyDefinition;
    /**
     * Defines the **Location** property.
     */
    Location: PropertyDefinition;
    /**
     * Defines the **AppointmentType** property.
     */
    AppointmentType: PropertyDefinition;
    /**
     * Defines the **Recurrence** property.
     */
    Recurrence: PropertyDefinition;
    /**
     * Defines the **EnhancedLocation** property.
     */
    EnhancedLocation: PropertyDefinition;
    /**
     * @internal Instance of **MeetingCancellationSchema**
     */
    Instance: MeetingCancellationSchema;
}

/**
 * Represents the schema for meeting cancellation.
 */
export interface MeetingCancellationSchemaStatic extends MeetingCancellationSchema {
}
Schemas.MeetingCancellationSchema = <any>MeetingCancellationSchema;


/**
 * Field URIs for meeting response.
 */
module FieldUris {
    export var ProposedStart: string = "meeting:ProposedStart";
    export var ProposedEnd: string = "meeting:ProposedEnd";
}

/**
 * Represents the schema for meeting response
 */
export class MeetingResponseSchema extends MeetingMessageSchema {

    /**
     * Defines the **Start** property.
     */
    public static Start: PropertyDefinition = Schemas.AppointmentSchema.Start;

    /**
     * Defines the **End** property.
     */
    public static End: PropertyDefinition = Schemas.AppointmentSchema.End;

    /**
     * Defines the **Location** property.
     */
    public static Location: PropertyDefinition = Schemas.AppointmentSchema.Location;

    /**
     * Defines the **AppointmentType** property.
     */
    public static AppointmentType: PropertyDefinition = Schemas.AppointmentSchema.AppointmentType;

    /**
     * Defines the **Recurrence** property.
     */
    public static Recurrence: PropertyDefinition = Schemas.AppointmentSchema.Recurrence;

    /**
     * Defines the **ProposedStart** property.
     */
    public static ProposedStart: PropertyDefinition = new ScopedDateTimePropertyDefinition(
        "ProposedStart",
        XmlElementNames.ProposedStart,
        FieldUris.ProposedStart,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        (version: ExchangeVersion) => { return Schemas.AppointmentSchema.StartTimeZone; }
    );

    /**
     * Defines the **ProposedEnd** property.
     */
    public static ProposedEnd: PropertyDefinition = new ScopedDateTimePropertyDefinition(
        "ProposedEnd",
        XmlElementNames.ProposedEnd,
        FieldUris.ProposedEnd,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2013,
        (version: ExchangeVersion) => { return Schemas.AppointmentSchema.EndTimeZone; }
    );

    /**
     * Defines the **EnhancedLocation** property.
     */
    public static EnhancedLocation: PropertyDefinition = Schemas.AppointmentSchema.EnhancedLocation;

    /**
     * @internal Instance of **MeetingResponseSchema** 
     */
    static Instance: MeetingResponseSchema = new MeetingResponseSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.Start);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.End);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.Location);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.Recurrence);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.AppointmentType);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.ProposedStart);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.ProposedEnd);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.EnhancedLocation);
    }
}

/**
 * Represents the schema for meeting response
 */
export interface MeetingResponseSchema {
    /**
     * Defines the **Start** property.
     */
    Start: PropertyDefinition;
    /**
     * Defines the **End** property.
     */
    End: PropertyDefinition;
    /**
     * Defines the **Location** property.
     */
    Location: PropertyDefinition;
    /**
     * Defines the **AppointmentType** property.
     */
    AppointmentType: PropertyDefinition;
    /**
     * Defines the **Recurrence** property.
     */
    Recurrence: PropertyDefinition;
    /**
     * Defines the **ProposedStart** property.
     */
    ProposedStart: PropertyDefinition;
    /**
     * Defines the **ProposedEnd** property.
     */
    ProposedEnd: PropertyDefinition;
    /**
     * Defines the **EnhancedLocation** property.
     */
    EnhancedLocation: PropertyDefinition;
    /**
     * @internal Instance of **MeetingResponseSchema**
     */
    Instance: MeetingResponseSchema;
}

/**
 * Represents the schema for meeting response
 */
export interface MeetingResponseSchemaStatic extends MeetingResponseSchema {
}
Schemas.MeetingResponseSchema = <any>MeetingResponseSchema;


/**
 * Field URIs for meeting request.
 */
module FieldUris {
    export var MeetingRequestType: string = "meetingRequest:MeetingRequestType";
    export var IntendedFreeBusyStatus: string = "meetingRequest:IntendedFreeBusyStatus";
    export var ChangeHighlights: string = "meetingRequest:ChangeHighlights";
}

/**
 * Represents the schema for meeting requests.
 */
export class MeetingRequestSchema extends MeetingMessageSchema {

    /**
     * Defines the **MeetingRequestType** property.
     */
    public static MeetingRequestType: PropertyDefinition = new GenericPropertyDefinition<MeetingRequestType>(
        "MeetingRequestType",
        XmlElementNames.MeetingRequestType,
        FieldUris.MeetingRequestType,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2007_SP1,
        MeetingRequestType
    );

    /**
     * Defines the **IntendedFreeBusyStatus** property.
     */
    public static IntendedFreeBusyStatus: PropertyDefinition = new GenericPropertyDefinition<LegacyFreeBusyStatus>(
        "IntendedFreeBusyStatus",
        XmlElementNames.IntendedFreeBusyStatus,
        FieldUris.IntendedFreeBusyStatus,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        LegacyFreeBusyStatus
    );

    /**
     * Defines the **ChangeHighlights** property.
     */
    public static ChangeHighlights: PropertyDefinition = new ComplexPropertyDefinition<ChangeHighlights>(
        "ChangeHighlights",
        XmlElementNames.ChangeHighlights,
        FieldUris.ChangeHighlights,
        PropertyDefinitionFlags.None,
        ExchangeVersion.Exchange2013,
        () => { return new ChangeHighlights(); }
    );

    /**
     * Defines the **EnhancedLocation** property.
     */
    public static EnhancedLocation: PropertyDefinition = Schemas.AppointmentSchema.EnhancedLocation;

    /**
     * Defines the **Start** property.
     */
    public static Start: PropertyDefinition = Schemas.AppointmentSchema.Start;

    /**
     * Defines the **End** property.
     */
    public static End: PropertyDefinition = Schemas.AppointmentSchema.End;

    /**
     * Defines the **OriginalStart** property.
     */
    public static OriginalStart: PropertyDefinition = Schemas.AppointmentSchema.OriginalStart;

    /**
     * Defines the **IsAllDayEvent** property.
     */
    public static IsAllDayEvent: PropertyDefinition = Schemas.AppointmentSchema.IsAllDayEvent;

    /**
     * Defines the **LegacyFreeBusyStatus** property.
     */
    public static LegacyFreeBusyStatus: PropertyDefinition = Schemas.AppointmentSchema.LegacyFreeBusyStatus;

    /**
     * Defines the **Location** property.
     */
    public static Location: PropertyDefinition = Schemas.AppointmentSchema.Location;

    /**
     * Defines the **When** property.
     */
    public static When: PropertyDefinition = Schemas.AppointmentSchema.When;

    /**
     * Defines the **IsMeeting** property.
     */
    public static IsMeeting: PropertyDefinition = Schemas.AppointmentSchema.IsMeeting;

    /**
     * Defines the **IsCancelled** property.
     */
    public static IsCancelled: PropertyDefinition = Schemas.AppointmentSchema.IsCancelled;

    /**
     * Defines the **IsRecurring** property.
     */
    public static IsRecurring: PropertyDefinition = Schemas.AppointmentSchema.IsRecurring;

    /**
     * Defines the **MeetingRequestWasSent** property.
     */
    public static MeetingRequestWasSent: PropertyDefinition = Schemas.AppointmentSchema.MeetingRequestWasSent;

    /**
     * Defines the **AppointmentType** property.
     */
    public static AppointmentType: PropertyDefinition = Schemas.AppointmentSchema.AppointmentType;

    /**
     * Defines the **MyResponseType** property.
     */
    public static MyResponseType: PropertyDefinition = Schemas.AppointmentSchema.MyResponseType;

    /**
     * Defines the **Organizer** property.
     */
    public static Organizer: PropertyDefinition = Schemas.AppointmentSchema.Organizer;

    /**
     * Defines the **RequiredAttendees** property.
     */
    public static RequiredAttendees: PropertyDefinition = Schemas.AppointmentSchema.RequiredAttendees;

    /**
     * Defines the **OptionalAttendees** property.
     */
    public static OptionalAttendees: PropertyDefinition = Schemas.AppointmentSchema.OptionalAttendees;

    /**
     * Defines the **Resources** property.
     */
    public static Resources: PropertyDefinition = Schemas.AppointmentSchema.Resources;

    /**
     * Defines the **ConflictingMeetingCount** property.
     */
    public static ConflictingMeetingCount: PropertyDefinition = Schemas.AppointmentSchema.ConflictingMeetingCount;

    /**
     * Defines the **AdjacentMeetingCount** property.
     */
    public static AdjacentMeetingCount: PropertyDefinition = Schemas.AppointmentSchema.AdjacentMeetingCount;

    /**
     * Defines the **ConflictingMeetings** property.
     */
    public static ConflictingMeetings: PropertyDefinition = Schemas.AppointmentSchema.ConflictingMeetings;

    /**
     * Defines the **AdjacentMeetings** property.
     */
    public static AdjacentMeetings: PropertyDefinition = Schemas.AppointmentSchema.AdjacentMeetings;

    /**
     * Defines the **Duration** property.
     */
    public static Duration: PropertyDefinition = Schemas.AppointmentSchema.Duration;

    /**
     * Defines the **TimeZone** property.
     */
    public static TimeZone: PropertyDefinition = Schemas.AppointmentSchema.TimeZone;

    /**
     * Defines the **AppointmentReplyTime** property.
     */
    public static AppointmentReplyTime: PropertyDefinition = Schemas.AppointmentSchema.AppointmentReplyTime;

    /**
     * Defines the **AppointmentSequenceNumber** property.
     */
    public static AppointmentSequenceNumber: PropertyDefinition = Schemas.AppointmentSchema.AppointmentSequenceNumber;

    /**
     * Defines the **AppointmentState** property.
     */
    public static AppointmentState: PropertyDefinition = Schemas.AppointmentSchema.AppointmentState;

    /**
     * Defines the **Recurrence** property.
     */
    public static Recurrence: PropertyDefinition = Schemas.AppointmentSchema.Recurrence;

    /**
     * Defines the **FirstOccurrence** property.
     */
    public static FirstOccurrence: PropertyDefinition = Schemas.AppointmentSchema.FirstOccurrence;

    /**
     * Defines the **LastOccurrence** property.
     */
    public static LastOccurrence: PropertyDefinition = Schemas.AppointmentSchema.LastOccurrence;

    /**
     * Defines the **ModifiedOccurrences** property.
     */
    public static ModifiedOccurrences: PropertyDefinition = Schemas.AppointmentSchema.ModifiedOccurrences;

    /**
     * Defines the **DeletedOccurrences** property.
     */
    public static DeletedOccurrences: PropertyDefinition = Schemas.AppointmentSchema.DeletedOccurrences;

    /**
     * Defines the **MeetingTimeZone** property.
     */
    public static MeetingTimeZone: PropertyDefinition = Schemas.AppointmentSchema.MeetingTimeZone;

    /**
     * Defines the **StartTimeZone** property.
     */
    public static StartTimeZone: PropertyDefinition = Schemas.AppointmentSchema.StartTimeZone;

    /**
     * Defines the **EndTimeZone** property.
     */
    public static EndTimeZone: PropertyDefinition = Schemas.AppointmentSchema.EndTimeZone;

    /**
     * Defines the **ConferenceType** property.
     */
    public static ConferenceType: PropertyDefinition = Schemas.AppointmentSchema.ConferenceType;

    /**
     * Defines the **AllowNewTimeProposal** property.
     */
    public static AllowNewTimeProposal: PropertyDefinition = Schemas.AppointmentSchema.AllowNewTimeProposal;

    /**
     * Defines the **IsOnlineMeeting** property.
     */
    public static IsOnlineMeeting: PropertyDefinition = Schemas.AppointmentSchema.IsOnlineMeeting;

    /**
     * Defines the **MeetingWorkspaceUrl** property.
     */
    public static MeetingWorkspaceUrl: PropertyDefinition = Schemas.AppointmentSchema.MeetingWorkspaceUrl;

    /**
     * Defines the **NetShowUrl** property.
     */
    public static NetShowUrl: PropertyDefinition = Schemas.AppointmentSchema.NetShowUrl;

    /**
     * @internal Instance of **MeetingRequestSchema** 
     */
    static Instance: MeetingRequestSchema = new MeetingRequestSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.MeetingRequestType);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IntendedFreeBusyStatus);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ChangeHighlights);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Start);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.End);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.OriginalStart);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsAllDayEvent);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.LegacyFreeBusyStatus);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Location);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.When);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsMeeting);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsCancelled);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsRecurring);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.MeetingRequestWasSent);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AppointmentType);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.MyResponseType);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Organizer);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.RequiredAttendees);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.OptionalAttendees);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Resources);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ConflictingMeetingCount);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AdjacentMeetingCount);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ConflictingMeetings);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AdjacentMeetings);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Duration);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.TimeZone);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AppointmentReplyTime);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AppointmentSequenceNumber);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AppointmentState);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Recurrence);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.FirstOccurrence);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.LastOccurrence);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ModifiedOccurrences);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.DeletedOccurrences);
        this.RegisterInternalProperty(MeetingRequestSchema, MeetingRequestSchema.MeetingTimeZone);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.StartTimeZone);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.EndTimeZone);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ConferenceType);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AllowNewTimeProposal);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsOnlineMeeting);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.MeetingWorkspaceUrl);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.NetShowUrl);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.EnhancedLocation);
    }
}

/**
 * Represents the schema for meeting requests.
 */
export interface MeetingRequestSchema {
    /**
     * Defines the **MeetingRequestType** property.
     */
    MeetingRequestType: PropertyDefinition;
    /**
     * Defines the **IntendedFreeBusyStatus** property.
     */
    IntendedFreeBusyStatus: PropertyDefinition;
    /**
     * Defines the **ChangeHighlights** property.
     */
    ChangeHighlights: PropertyDefinition;
    /**
     * Defines the **EnhancedLocation** property.
     */
    EnhancedLocation: PropertyDefinition;
    /**
     * Defines the **Start** property.
     */
    Start: PropertyDefinition;
    /**
     * Defines the **End** property.
     */
    End: PropertyDefinition;
    /**
     * Defines the **OriginalStart** property.
     */
    OriginalStart: PropertyDefinition;
    /**
     * Defines the **IsAllDayEvent** property.
     */
    IsAllDayEvent: PropertyDefinition;
    /**
     * Defines the **LegacyFreeBusyStatus** property.
     */
    LegacyFreeBusyStatus: PropertyDefinition;
    /**
     * Defines the **Location** property.
     */
    Location: PropertyDefinition;
    /**
     * Defines the **When** property.
     */
    When: PropertyDefinition;
    /**
     * Defines the **IsMeeting** property.
     */
    IsMeeting: PropertyDefinition;
    /**
     * Defines the **IsCancelled** property.
     */
    IsCancelled: PropertyDefinition;
    /**
     * Defines the **IsRecurring** property.
     */
    IsRecurring: PropertyDefinition;
    /**
     * Defines the **MeetingRequestWasSent** property.
     */
    MeetingRequestWasSent: PropertyDefinition;
    /**
     * Defines the **AppointmentType** property.
     */
    AppointmentType: PropertyDefinition;
    /**
     * Defines the **MyResponseType** property.
     */
    MyResponseType: PropertyDefinition;
    /**
     * Defines the **Organizer** property.
     */
    Organizer: PropertyDefinition;
    /**
     * Defines the **RequiredAttendees** property.
     */
    RequiredAttendees: PropertyDefinition;
    /**
     * Defines the **OptionalAttendees** property.
     */
    OptionalAttendees: PropertyDefinition;
    /**
     * Defines the **Resources** property.
     */
    Resources: PropertyDefinition;
    /**
     * Defines the **ConflictingMeetingCount** property.
     */
    ConflictingMeetingCount: PropertyDefinition;
    /**
     * Defines the **AdjacentMeetingCount** property.
     */
    AdjacentMeetingCount: PropertyDefinition;
    /**
     * Defines the **ConflictingMeetings** property.
     */
    ConflictingMeetings: PropertyDefinition;
    /**
     * Defines the **AdjacentMeetings** property.
     */
    AdjacentMeetings: PropertyDefinition;
    /**
     * Defines the **Duration** property.
     */
    Duration: PropertyDefinition;
    /**
     * Defines the **TimeZone** property.
     */
    TimeZone: PropertyDefinition;
    /**
     * Defines the **AppointmentReplyTime** property.
     */
    AppointmentReplyTime: PropertyDefinition;
    /**
     * Defines the **AppointmentSequenceNumber** property.
     */
    AppointmentSequenceNumber: PropertyDefinition;
    /**
     * Defines the **AppointmentState** property.
     */
    AppointmentState: PropertyDefinition;
    /**
     * Defines the **Recurrence** property.
     */
    Recurrence: PropertyDefinition;
    /**
     * Defines the **FirstOccurrence** property.
     */
    FirstOccurrence: PropertyDefinition;
    /**
     * Defines the **LastOccurrence** property.
     */
    LastOccurrence: PropertyDefinition;
    /**
     * Defines the **ModifiedOccurrences** property.
     */
    ModifiedOccurrences: PropertyDefinition;
    /**
     * Defines the **DeletedOccurrences** property.
     */
    DeletedOccurrences: PropertyDefinition;
    /**
     * Defines the **MeetingTimeZone** property.
     */
    MeetingTimeZone: PropertyDefinition;
    /**
     * Defines the **StartTimeZone** property.
     */
    StartTimeZone: PropertyDefinition;
    /**
     * Defines the **EndTimeZone** property.
     */
    EndTimeZone: PropertyDefinition;
    /**
     * Defines the **ConferenceType** property.
     */
    ConferenceType: PropertyDefinition;
    /**
     * Defines the **AllowNewTimeProposal** property.
     */
    AllowNewTimeProposal: PropertyDefinition;
    /**
     * Defines the **IsOnlineMeeting** property.
     */
    IsOnlineMeeting: PropertyDefinition;
    /**
     * Defines the **MeetingWorkspaceUrl** property.
     */
    MeetingWorkspaceUrl: PropertyDefinition;
    /**
     * Defines the **NetShowUrl** property.
     */
    NetShowUrl: PropertyDefinition;
    /**
     * @internal Instance of **MeetingRequestSchema**
     */
    Instance: MeetingRequestSchema;
}

/**
 * Represents the schema for meeting requests.
 */
export interface MeetingRequestSchemaStatic extends MeetingRequestSchema {
}
Schemas.MeetingRequestSchema = <any>MeetingRequestSchema;


/**
 * Field URIs for PostItem.
 */
module FieldUris {
    export var PostedTime: string = "postitem:PostedTime";
}

/**
 * Represents the schema for post items.
 */
export class PostItemSchema extends ItemSchema {

    /**
     * Defines the **ConversationIndex** property.
     */
    public static ConversationIndex: PropertyDefinition = Schemas.EmailMessageSchema.ConversationIndex;

    /**
     * Defines the **ConversationTopic** property.
     */
    public static ConversationTopic: PropertyDefinition = Schemas.EmailMessageSchema.ConversationTopic;

    /**
     * Defines the **From** property.
     */
    public static From: PropertyDefinition = Schemas.EmailMessageSchema.From;

    /**
     * Defines the **InternetMessageId** property.
     */
    public static InternetMessageId: PropertyDefinition = Schemas.EmailMessageSchema.InternetMessageId;

    /**
     * Defines the **IsRead** property.
     */
    public static IsRead: PropertyDefinition = Schemas.EmailMessageSchema.IsRead;

    /**
     * Defines the **PostedTime** property.
     */
    public static PostedTime: PropertyDefinition = new DateTimePropertyDefinition(
        "PostedTime",
        XmlElementNames.PostedTime,
        FieldUris.PostedTime,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **References** property.
     */
    public static References: PropertyDefinition = Schemas.EmailMessageSchema.References;

    /**
     * Defines the **Sender** property.
     */
    public static Sender: PropertyDefinition = Schemas.EmailMessageSchema.Sender;

    /**
     * @internal Instance of **PostItemSchema** 
     */
    static Instance: PostItemSchema = new PostItemSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(PostItemSchema, PostItemSchema.ConversationIndex);
        this.RegisterProperty(PostItemSchema, PostItemSchema.ConversationTopic);
        this.RegisterProperty(PostItemSchema, PostItemSchema.From);
        this.RegisterProperty(PostItemSchema, PostItemSchema.InternetMessageId);
        this.RegisterProperty(PostItemSchema, PostItemSchema.IsRead);
        this.RegisterProperty(PostItemSchema, PostItemSchema.PostedTime);
        this.RegisterProperty(PostItemSchema, PostItemSchema.References);
        this.RegisterProperty(PostItemSchema, PostItemSchema.Sender);
    }
}

/**
 * Represents the schema for post items.
 */
export interface PostItemSchema {
    /**
     * Defines the **ConversationIndex** property.
     */
    ConversationIndex: PropertyDefinition;
    /**
     * Defines the **ConversationTopic** property.
     */
    ConversationTopic: PropertyDefinition;
    /**
     * Defines the **From** property.
     */
    From: PropertyDefinition;
    /**
     * Defines the **InternetMessageId** property.
     */
    InternetMessageId: PropertyDefinition;
    /**
     * Defines the **IsRead** property.
     */
    IsRead: PropertyDefinition;
    /**
     * Defines the **PostedTime** property.
     */
    PostedTime: PropertyDefinition;
    /**
     * Defines the **References** property.
     */
    References: PropertyDefinition;
    /**
     * Defines the **Sender** property.
     */
    Sender: PropertyDefinition;
    /**
     * @internal Instance of **PostItemSchema**
     */
    Instance: PostItemSchema;
}

/**
 * Represents the schema for post items.
 */
export interface PostItemSchemaStatic extends PostItemSchema {
}
Schemas.PostItemSchema = <any>PostItemSchema;


/**
 * Field URIs for tasks.
 */
module FieldUris {
    export var ActualWork: string = "task:ActualWork";
    export var AssignedTime: string = "task:AssignedTime";
    export var BillingInformation: string = "task:BillingInformation";
    export var ChangeCount: string = "task:ChangeCount";
    export var Companies: string = "task:Companies";
    export var CompleteDate: string = "task:CompleteDate";
    export var Contacts: string = "task:Contacts";
    export var DelegationState: string = "task:DelegationState";
    export var Delegator: string = "task:Delegator";
    export var DueDate: string = "task:DueDate";
    export var IsAssignmentEditable: string = "task:IsAssignmentEditable";
    export var IsComplete: string = "task:IsComplete";
    export var IsRecurring: string = "task:IsRecurring";
    export var IsTeamTask: string = "task:IsTeamTask";
    export var Mileage: string = "task:Mileage";
    export var Owner: string = "task:Owner";
    export var PercentComplete: string = "task:PercentComplete";
    export var Recurrence: string = "task:Recurrence";
    export var StartDate: string = "task:StartDate";
    export var Status: string = "task:Status";
    export var StatusDescription: string = "task:StatusDescription";
    export var TotalWork: string = "task:TotalWork";
}

/**
 * Represents the schema for task items.
 */
export class TaskSchema extends ItemSchema {

    /**
     * Defines the **ActualWork** property.
     */
    public static ActualWork: PropertyDefinition = new IntPropertyDefinition(
        "ActualWork",
        XmlElementNames.ActualWork,
        FieldUris.ActualWork,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        true
    );

    /**
     * Defines the **AssignedTime** property.
     */
    public static AssignedTime: PropertyDefinition = new DateTimePropertyDefinition(
        "AssignedTime",
        XmlElementNames.AssignedTime,
        FieldUris.AssignedTime,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        true
    );

    /**
     * Defines the **BillingInformation** property.
     */
    public static BillingInformation: PropertyDefinition = new StringPropertyDefinition(
        "BillingInformation",
        XmlElementNames.BillingInformation,
        FieldUris.BillingInformation,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **ChangeCount** property.
     */
    public static ChangeCount: PropertyDefinition = new IntPropertyDefinition(
        "ChangeCount",
        XmlElementNames.ChangeCount,
        FieldUris.ChangeCount,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Companies** property.
     */
    public static Companies: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "Companies",
        XmlElementNames.Companies,
        FieldUris.Companies,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **CompleteDate** property.
     */
    public static CompleteDate: PropertyDefinition = new DateTimePropertyDefinition(
        "CompleteDate",
        XmlElementNames.CompleteDate,
        FieldUris.CompleteDate,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        true
    );

    /**
     * Defines the **Contacts** property.
     */
    public static Contacts: PropertyDefinition = new ComplexPropertyDefinition<StringList>(
        "Contacts",
        XmlElementNames.Contacts,
        FieldUris.Contacts,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new StringList(); }
    );

    /**
     * Defines the **DelegationState** property.
     */
    public static DelegationState: PropertyDefinition = new TaskDelegationStatePropertyDefinition(
        "DelegationState",
        XmlElementNames.DelegationState,
        FieldUris.DelegationState,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Delegator** property.
     */
    public static Delegator: PropertyDefinition = new StringPropertyDefinition(
        "Delegator",
        XmlElementNames.Delegator,
        FieldUris.Delegator,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **DueDate** property.
     */
    public static DueDate: PropertyDefinition = new DateTimePropertyDefinition(
        "DueDate",
        XmlElementNames.DueDate,
        FieldUris.DueDate,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        true
    );

    /**
     * Defines the **Mode** property.
     */
    public static Mode: PropertyDefinition = new GenericPropertyDefinition<TaskMode>(
        "IsAssignmentEditable",
        XmlElementNames.IsAssignmentEditable,
        FieldUris.IsAssignmentEditable,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        TaskMode
    );

    /**
     * Defines the **IsComplete** property.
     */
    public static IsComplete: PropertyDefinition = new BoolPropertyDefinition(
        "IsComplete",
        XmlElementNames.IsComplete,
        FieldUris.IsComplete,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsRecurring** property.
     */
    public static IsRecurring: PropertyDefinition = new BoolPropertyDefinition(
        "IsRecurring",
        XmlElementNames.IsRecurring,
        FieldUris.IsRecurring,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **IsTeamTask** property.
     */
    public static IsTeamTask: PropertyDefinition = new BoolPropertyDefinition(
        "IsTeamTask",
        XmlElementNames.IsTeamTask,
        FieldUris.IsTeamTask,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Mileage** property.
     */
    public static Mileage: PropertyDefinition = new StringPropertyDefinition(
        "Mileage",
        XmlElementNames.Mileage,
        FieldUris.Mileage,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Owner** property.
     */
    public static Owner: PropertyDefinition = new StringPropertyDefinition(
        "Owner",
        XmlElementNames.Owner,
        FieldUris.Owner,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **PercentComplete** property.
     */
    public static PercentComplete: PropertyDefinition = new DoublePropertyDefinition(
        "PercentComplete",
        XmlElementNames.PercentComplete,
        FieldUris.PercentComplete,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **Recurrence** property.
     */
    public static Recurrence: PropertyDefinition = new RecurrencePropertyDefinition(
        "Recurrence",
        XmlElementNames.Recurrence,
        FieldUris.Recurrence,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **StartDate** property.
     */
    public static StartDate: PropertyDefinition = new DateTimePropertyDefinition(
        "StartDate",
        XmlElementNames.StartDate,
        FieldUris.StartDate,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        true
    );

    /**
     * Defines the **Status** property.
     */
    public static Status: PropertyDefinition = new GenericPropertyDefinition<TaskStatus>(
        "Status",
        XmlElementNames.Status,
        FieldUris.Status,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        TaskStatus
    );

    /**
     * Defines the **StatusDescription** property.
     */
    public static StatusDescription: PropertyDefinition = new StringPropertyDefinition(
        "StatusDescription",
        XmlElementNames.StatusDescription,
        FieldUris.StatusDescription,
        PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1
    );

    /**
     * Defines the **TotalWork** property.
     */
    public static TotalWork: PropertyDefinition = new IntPropertyDefinition(
        "TotalWork",
        XmlElementNames.TotalWork,
        FieldUris.TotalWork,
        PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
        ExchangeVersion.Exchange2007_SP1,
        true
    );

    /**
     * @internal Instance of **TaskSchema** 
     */
    static Instance: TaskSchema = new TaskSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(TaskSchema, TaskSchema.ActualWork);
        this.RegisterProperty(TaskSchema, TaskSchema.AssignedTime);
        this.RegisterProperty(TaskSchema, TaskSchema.BillingInformation);
        this.RegisterProperty(TaskSchema, TaskSchema.ChangeCount);
        this.RegisterProperty(TaskSchema, TaskSchema.Companies);
        this.RegisterProperty(TaskSchema, TaskSchema.CompleteDate);
        this.RegisterProperty(TaskSchema, TaskSchema.Contacts);
        this.RegisterProperty(TaskSchema, TaskSchema.DelegationState);
        this.RegisterProperty(TaskSchema, TaskSchema.Delegator);
        this.RegisterProperty(TaskSchema, TaskSchema.DueDate);
        this.RegisterProperty(TaskSchema, TaskSchema.Mode);
        this.RegisterProperty(TaskSchema, TaskSchema.IsComplete);
        this.RegisterProperty(TaskSchema, TaskSchema.IsRecurring);
        this.RegisterProperty(TaskSchema, TaskSchema.IsTeamTask);
        this.RegisterProperty(TaskSchema, TaskSchema.Mileage);
        this.RegisterProperty(TaskSchema, TaskSchema.Owner);
        this.RegisterProperty(TaskSchema, TaskSchema.PercentComplete);
        this.RegisterProperty(TaskSchema, TaskSchema.Recurrence);
        this.RegisterProperty(TaskSchema, TaskSchema.StartDate);
        this.RegisterProperty(TaskSchema, TaskSchema.Status);
        this.RegisterProperty(TaskSchema, TaskSchema.StatusDescription);
        this.RegisterProperty(TaskSchema, TaskSchema.TotalWork);
    }
}

/**
 * Represents the schema for task items.
 */
export interface TaskSchema {
    /**
     * Defines the **ActualWork** property.
     */
    ActualWork: PropertyDefinition;
    /**
     * Defines the **AssignedTime** property.
     */
    AssignedTime: PropertyDefinition;
    /**
     * Defines the **BillingInformation** property.
     */
    BillingInformation: PropertyDefinition;
    /**
     * Defines the **ChangeCount** property.
     */
    ChangeCount: PropertyDefinition;
    /**
     * Defines the **Companies** property.
     */
    Companies: PropertyDefinition;
    /**
     * Defines the **CompleteDate** property.
     */
    CompleteDate: PropertyDefinition;
    /**
     * Defines the **Contacts** property.
     */
    Contacts: PropertyDefinition;
    /**
     * Defines the **DelegationState** property.
     */
    DelegationState: PropertyDefinition;
    /**
     * Defines the **Delegator** property.
     */
    Delegator: PropertyDefinition;
    /**
     * Defines the **DueDate** property.
     */
    DueDate: PropertyDefinition;
    /**
     * Defines the **Mode** property.
     */
    Mode: PropertyDefinition;
    /**
     * Defines the **IsComplete** property.
     */
    IsComplete: PropertyDefinition;
    /**
     * Defines the **IsRecurring** property.
     */
    IsRecurring: PropertyDefinition;
    /**
     * Defines the **IsTeamTask** property.
     */
    IsTeamTask: PropertyDefinition;
    /**
     * Defines the **Mileage** property.
     */
    Mileage: PropertyDefinition;
    /**
     * Defines the **Owner** property.
     */
    Owner: PropertyDefinition;
    /**
     * Defines the **PercentComplete** property.
     */
    PercentComplete: PropertyDefinition;
    /**
     * Defines the **Recurrence** property.
     */
    Recurrence: PropertyDefinition;
    /**
     * Defines the **StartDate** property.
     */
    StartDate: PropertyDefinition;
    /**
     * Defines the **Status** property.
     */
    Status: PropertyDefinition;
    /**
     * Defines the **StatusDescription** property.
     */
    StatusDescription: PropertyDefinition;
    /**
     * Defines the **TotalWork** property.
     */
    TotalWork: PropertyDefinition;
    /**
     * @internal Instance of **TaskSchema**
     */
    Instance: TaskSchema;
}

/**
 * Represents the schema for task items.
 */
export interface TaskSchemaStatic extends TaskSchema {
}
Schemas.TaskSchema = <any>TaskSchema;

/**
 * Represents ResponseObject schema definition.
 */
export class ResponseObjectSchema extends ServiceObjectSchema {

    /**
     * Defines the **ReferenceItemId** property.
     */
    public static ReferenceItemId: PropertyDefinition = new ComplexPropertyDefinition<ItemId>(
        "ReferenceItemId",
        XmlElementNames.ReferenceItemId,
        PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new ItemId(); }
    );

    /**
     * Defines the **BodyPrefix** property.
     */
    public static BodyPrefix: PropertyDefinition = new ComplexPropertyDefinition<MessageBody>(
        "NewBodyContent",
        XmlElementNames.NewBodyContent,
        PropertyDefinitionFlags.CanSet,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new MessageBody(); }
    );

    /**
     * @internal Instance of **ResponseObjectSchema** 
     */
    static Instance: ResponseObjectSchema = new ResponseObjectSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(ResponseObjectSchema, ResponseObjectSchema.ReferenceItemId);
    }
}

/**
 * Represents ResponseObject schema definition.
 */
export interface ResponseObjectSchema {
    /**
     * Defines the **ReferenceItemId** property.
     */
    ReferenceItemId: PropertyDefinition;
    /**
     * Defines the **BodyPrefix** property.
     */
    BodyPrefix: PropertyDefinition;
    /**
     * @internal Instance of **ResponseObjectSchema**
     */
    Instance: ResponseObjectSchema;
}

/**
 * Represents ResponseObject schema definition.
 */
export interface ResponseObjectSchemaStatic extends ResponseObjectSchema {
}
Schemas.ResponseObjectSchema = <any>ResponseObjectSchema;

/**
 * Represents PostReply schema definition.
 */
export class PostReplySchema extends ServiceObjectSchema {

    /**
     * @internal Instance of **PostReplySchema** 
     */
    static Instance: PostReplySchema = new PostReplySchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(PostReplySchema, Schemas.ItemSchema.Subject);
        this.RegisterProperty(PostReplySchema, Schemas.ItemSchema.Body);
        this.RegisterProperty(PostReplySchema, Schemas.ResponseObjectSchema.ReferenceItemId);
        this.RegisterProperty(PostReplySchema, Schemas.ResponseObjectSchema.BodyPrefix);
    }
}

/**
 * Represents PostReply schema definition.
 */
export interface PostReplySchema {
    /**
     * @internal Instance of **PostReplySchema**
     */
    Instance: PostReplySchema;
}

/**
 * Represents PostReply schema definition.
 */
export interface PostReplySchemaStatic extends PostReplySchema {
}
Schemas.PostReplySchema = <any>PostReplySchema;

/**
 * Represents ResponseMessage schema definition.
 */
export class ResponseMessageSchema extends ServiceObjectSchema {

    /**
     * @internal Instance of **ResponseMessageSchema** 
     */
    static Instance: ResponseMessageSchema = new ResponseMessageSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(ResponseMessageSchema, Schemas.ItemSchema.Subject);
        this.RegisterProperty(ResponseMessageSchema, Schemas.ItemSchema.Body);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.ToRecipients);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.CcRecipients);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.BccRecipients);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.IsReadReceiptRequested);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
        this.RegisterProperty(ResponseMessageSchema, Schemas.ResponseObjectSchema.ReferenceItemId);
        this.RegisterProperty(ResponseMessageSchema, Schemas.ResponseObjectSchema.BodyPrefix);
    }
}

/**
 * Represents ResponseMessage schema definition.
 */
export interface ResponseMessageSchema {
    /**
     * @internal Instance of **ResponseMessageSchema**
     */
    Instance: ResponseMessageSchema;
}

/**
 * Represents ResponseMessage schema definition.
 */
export interface ResponseMessageSchemaStatic extends ResponseMessageSchema {
}
Schemas.ResponseMessageSchema = <any>ResponseMessageSchema;

/**
 * Represents CancelMeetingMessage schema definition.
 */
export class CancelMeetingMessageSchema extends ServiceObjectSchema {

    /**
     * Defines the **Body** property.
     */
    public static Body: PropertyDefinition = new ComplexPropertyDefinition<MessageBody>(
        "Body",
        XmlElementNames.NewBodyContent,
        PropertyDefinitionFlags.CanSet,
        ExchangeVersion.Exchange2007_SP1,
        () => { return new MessageBody(); }
    );

    /**
     * @internal Instance of **CancelMeetingMessageSchema** 
     */
    static Instance: CancelMeetingMessageSchema = new CancelMeetingMessageSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(CancelMeetingMessageSchema, Schemas.EmailMessageSchema.IsReadReceiptRequested);
        this.RegisterProperty(CancelMeetingMessageSchema, Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
        this.RegisterProperty(CancelMeetingMessageSchema, Schemas.ResponseObjectSchema.ReferenceItemId);
        this.RegisterProperty(CancelMeetingMessageSchema, CancelMeetingMessageSchema.Body);
    }
}

/**
 * Represents CancelMeetingMessage schema definition.
 */
export interface CancelMeetingMessageSchema {
    /**
     * Defines the **Body** property.
     */
    Body: PropertyDefinition;
    /**
     * @internal Instance of **CancelMeetingMessageSchema**
     */
    Instance: CancelMeetingMessageSchema;
}

/**
 * Represents CancelMeetingMessage schema definition.
 */
export interface CancelMeetingMessageSchemaStatic extends CancelMeetingMessageSchema {
}
Schemas.CancelMeetingMessageSchema = <any>CancelMeetingMessageSchema;

/**
 * Represents CalendarResponseObject schema definition.
 */
export class CalendarResponseObjectSchema extends ServiceObjectSchema {

    /**
     * @internal Instance of **CalendarResponseObjectSchema** 
     */
    public static Instance: CalendarResponseObjectSchema = new CalendarResponseObjectSchema();

    /**
     * Registers properties.
     * 
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    RegisterProperties(): void {
        super.RegisterProperties();
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.ItemClass);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.Sensitivity);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.Body);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.Attachments);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.InternetMessageHeaders);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.Sender);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.ToRecipients);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.CcRecipients);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.BccRecipients);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.IsReadReceiptRequested);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ResponseObjectSchema.ReferenceItemId);
    }
}

/**
 * Represents CalendarResponseObject schema definition.
 */

export interface CalendarResponseObjectSchema {
    /**
     * @internal Instance of **CalendarResponseObjectSchema**
     */
    Instance: CalendarResponseObjectSchema;
}

/**
 * Represents CalendarResponseObject schema definition.
 */

export interface CalendarResponseObjectSchemaStatic extends CalendarResponseObjectSchema {
}
Schemas.CalendarResponseObjectSchema = <any>CalendarResponseObjectSchema;
/** @internal */
export class ConfigurationSettingsBase {
    ResponseType: AutodiscoverResponseType;
    RedirectTarget: string;
    Error: AutodiscoverError;
    private error: AutodiscoverError;
    ConvertSettings(smtpAddress: string, requestedSettings: UserSettingName[]): GetUserSettingsResponse { throw new Error("ConfigurationSettingsBase.ts - ConvertSettings : Not implemented."); }
    GetNamespace(): string { throw new Error("ConfigurationSettingsBase.ts - GetNamespace : Not implemented."); }
    //LoadFromXml(reader: EwsXmlReader): any { throw new Error("ConfigurationSettingsBase.ts - LoadFromXml : Not implemented."); }
    MakeRedirectionResponse(redirectUrl: Uri): any { throw new Error("ConfigurationSettingsBase.ts - MakeRedirectionResponse : Not implemented."); }
    //TryReadCurrentXmlElement(reader: EwsXmlReader): boolean { throw new Error("ConfigurationSettingsBase.ts - TryReadCurrentXmlElement : Not implemented."); }
}

/** @internal */
export class OutlookAccount {
    private static Settings: string = "settings";
    private static RedirectAddr: string = "redirectAddr";
    private static RedirectUrl: string = "redirectUrl";
    AccountType: string;
    ResponseType: AutodiscoverResponseType;
    RedirectTarget: string;
    private protocols:any;// System.Collections.Generic.Dictionary<OutlookProtocolType, OutlookProtocol>;
    private alternateMailboxes: AlternateMailboxCollection;
    ConvertToUserSettings(requestedSettings: UserSettingName[], // System.Collections.Generic.List<Microsoft.Exchange.WebServices.Autodiscover.UserSettingName>,
        response: GetUserSettingsResponse): any { throw new Error("OutlookAccount.ts - response: GetUserSettingsResponse): any { throw new Error : Not implemented."); }
    //LoadFromXml(reader: EwsXmlReader): any { throw new Error("OutlookAccount.ts - LoadFromXml : Not implemented."); }
}

/** @internal  */
export class OutlookConfigurationSettings extends ConfigurationSettingsBase {
    ResponseType: AutodiscoverResponseType;
    RedirectTarget: string;
    private user: OutlookUser;
    private account: OutlookAccount;
    private static allOutlookProviderSettings: LazyMember<UserSettingName[]> = new LazyMember(()=>{
        var results:UserSettingName[] = [];//new List<UserSettingName>();
                ArrayHelper.AddRange(results, OutlookUser.AvailableUserSettings);
                ArrayHelper.AddRange(results, OutlookProtocol.AvailableUserSettings);
                results.push(UserSettingName.AlternateMailboxes);
                return results;
    });
    ConvertSettings(smtpAddress: string, requestedSettings: UserSettingName[]): GetUserSettingsResponse { throw new Error("OutlookConfigurationSettings.ts - ConvertSettings : Not implemented."); }
    GetNamespace(): string { throw new Error("OutlookConfigurationSettings.ts - GetNamespace : Not implemented."); }
    IsAvailableUserSetting(setting: UserSettingName): boolean { throw new Error("OutlookConfigurationSettings.ts - IsAvailableUserSetting : Not implemented."); }
    MakeRedirectionResponse(redirectUrl: Uri): any { throw new Error("OutlookConfigurationSettings.ts - MakeRedirectionResponse : Not implemented."); }
    ReportUnsupportedSettings(requestedSettings: UserSettingName[], response: GetUserSettingsResponse): any { throw new Error("OutlookConfigurationSettings.ts - ReportUnsupportedSettings : Not implemented."); }
    //TryReadCurrentXmlElement(reader: EwsXmlReader): boolean { throw new Error("OutlookConfigurationSettings.ts - TryReadCurrentXmlElement : Not implemented."); }
}


/** @internal */
export class OutlookProtocol {
    private static EXPR: string = "EXPR";
    private static EXCH: string = "EXCH";
    private static WEB: string = "WEB";
    ProtocolType: OutlookProtocolType;
    private ConverterDictionary: any;//System.Collections.Generic.Dictionary<UserSettingName, System.Func<OutlookProtocol, any>>;
    static AvailableUserSettings: any;//System.Collections.Generic.List<UserSettingName>;
    private activeDirectoryServer: string;
    private authPackage: string;
    private availabilityServiceUrl: string;
    private ecpUrl: string;
    private ecpUrlAggr: string;
    private ecpUrlMt: string;
    private ecpUrlPublish: string;
    private ecpUrlPhoto: string;
    private ecpUrlConnect: string;
    private ecpUrlRet: string;
    private ecpUrlSms: string;
    private ecpUrlUm: string;
    private ecpUrlTm: string;
    private ecpUrlTmCreating: string;
    private ecpUrlTmEditing: string;
    private ecpUrlTmHiding: string;
    private siteMailboxCreationURL: string;
    private ecpUrlExtInstall: string;
    private exchangeWebServicesUrl: string;
    private exchangeManagementWebServicesUrl: string;
    private mailboxDN: string;
    private offlineAddressBookUrl: string;
    private exchangeRpcUrl: string;
    private exchangeWebServicesPartnerUrl: string;
    private publicFolderServer: string;
    private server: string;
    private serverDN: string;
    private unifiedMessagingUrl: string;
    private sharingEnabled: boolean;
    private sslEnabled: boolean;
    private serverExclusiveConnect: boolean;
    private certPrincipalName: string;
    private groupingInformation: string;
    private MapiHttpEnabled: boolean;
    private externalOutlookWebAccessUrls: WebClientUrlCollection;
    private internalOutlookWebAccessUrls: WebClientUrlCollection;
    private static commonProtocolSettings: LazyMember<any>;
    private static internalProtocolSettings: LazyMember<any>;
    private static externalProtocolSettings: LazyMember<any>;
    private static internalProtocolConverterDictionary: LazyMember<any>;
    private static externalProtocolConverterDictionary: LazyMember<any>;
    private static webProtocolConverterDictionary: LazyMember<any>;
    private static availableUserSettings: LazyMember<any>;
    private static protocolNameToTypeMap: LazyMember<any>;
    ConvertEcpFragmentToUrl(fragment: string): string { throw new Error("OutlookProtocol.ts - ConvertEcpFragmentToUrl : Not implemented."); }
    ConvertToUserSettings(requestedSettings: UserSettingName[], response: GetUserSettingsResponse): any { throw new Error("OutlookProtocol.ts - ConvertToUserSettings : Not implemented."); }
    //LoadFromXml(reader: EwsXmlReader): any { throw new Error("OutlookProtocol.ts - LoadFromXml : Not implemented."); }
    //LoadWebClientUrlsFromXml(reader: EwsXmlReader, webClientUrls: WebClientUrlCollection, elementName: string): any { throw new Error("OutlookProtocol.ts - LoadWebClientUrlsFromXml : Not implemented."); }
    ProtocolNameToType(protocolName: string): OutlookProtocolType { throw new Error("OutlookProtocol.ts - ProtocolNameToType : Not implemented."); }
}
export class OutlookUser {
    static AvailableUserSettings: UserSettingName[];
    private displayName: string;
    private legacyDN: string;
    private deploymentId: string;
    private autodiscoverAMTPAddress: string;
    private static converterDictionary: LazyMember<any>;
    ConvertToUserSettings(requestedSettings: UserSettingName[], response: GetUserSettingsResponse): any { throw new Error("OutlookUser.ts - ConvertToUserSettings : Not implemented."); }
    //LoadFromXml(reader: EwsXmlReader): any { throw new Error("OutlookUser.ts - LoadFromXml : Not implemented."); }
}

export class AutodiscoverRequest {

    get Service(): AutodiscoverService {
        return this.service;
    }
    get Url(): Uri {
        return this.url;
    }

    private service: AutodiscoverService;
    private url: Uri = null;

    constructor(service: AutodiscoverService, url: Uri) {
        this.service = service;
        this.url = url;
    }

    private CreateRedirectionResponse(httpWebResponse: any /*IEwsHttpWebResponse*/): AutodiscoverResponse {
        //string location = httpWebResponse.Headers[System.Net.HttpResponseHeader.Location];
        //    if (!string.IsNullOrEmpty(location)) {
        //        try {
        //            Uri redirectionUri = new Uri(this.Url, location);
        //            if ((redirectionUri.Scheme == Uri.UriSchemeHttp) || (redirectionUri.Scheme == Uri.UriSchemeHttps)) {
        //                AutodiscoverResponse response = this.CreateServiceResponse();
        //                response.ErrorCode = AutodiscoverErrorCode.RedirectUrl;
        //                response.RedirectionUrl = redirectionUri;
        //                return response;
        //            }

        //            this.Service.TraceMessage(
        //                TraceFlags.AutodiscoverConfiguration,
        //                string.Format("Invalid redirection URL '{0}' returned by Autodiscover service.", redirectionUri));
        //        }
        //        catch (UriFormatException) {
        //            this.Service.TraceMessage(
        //                TraceFlags.AutodiscoverConfiguration,
        //                string.Format("Invalid redirection location '{0}' returned by Autodiscover service.", location));
        //        }
        //    }
        //    else {
        //        this.Service.TraceMessage(
        //            TraceFlags.AutodiscoverConfiguration,
        //            "Redirection response returned by Autodiscover service without redirection location.");
        //    }

        return null;
    }
    CreateServiceResponse(): AutodiscoverResponse { throw new Error("AutodiscoverRequest.ts - CreateServiceResponse : Not implemented."); }
    GetRequestXmlElementName(): string { throw new Error("AutodiscoverRequest.ts - GetRequestXmlElementName : Not implemented."); }
    GetResponseStream(response: any /*IEwsHttpWebResponse*/): any { //System.IO.Stream{
        //string contentEncoding = response.ContentEncoding;
        //Stream responseStream = response.GetResponseStream();

        //if (contentEncoding.ToLowerInvariant().Contains("gzip")) {
        //    return new GZipStream(responseStream, CompressionMode.Decompress);
        //}
        //else if (contentEncoding.ToLowerInvariant().Contains("deflate")) {
        //    return new DeflateStream(responseStream, CompressionMode.Decompress);
        //}
        //else {
        //    return responseStream;
        //}
    }
    GetResponseXmlElementName(): string { throw new Error("AutodiscoverRequest.ts - GetResponseXmlElementName : Not implemented."); }
    GetWsAddressingActionName(): string { throw new Error("AutodiscoverRequest.ts - GetWsAddressingActionName : Not implemented."); }
    InternalExecute(): Promise<AutodiscoverResponse> {
        var writer = new EwsServiceXmlWriter(this.service);
        this.WriteSoapRequest(this.url, writer);

        if (!this.service)
            throw new Error("Missing Service");

        //var cred = "Basic " + btoa(this.Service.Credentials.UserName + ":" + this.Service.Credentials.Password);
        var cc = writer.GetXML();
        var xhrOptions: IXHROptions = {
            type: "POST",
            data: cc,
            //url: "https://pod51045.outlook.com/autodiscover/autodiscover.svc",
            url: this.url.ToString(),
            //headers: { "Content-Type": "text/xml", "Authorization": cred },
            headers: { "Content-Type": "text/xml" },
            //customRequestInitializer: function (x) {
            //    var m = x;
            //}
        };

        //If not set, credentials might come from custom XHRApi
        if (this.service.Credentials)
            this.service.Credentials.PrepareWebRequest(xhrOptions);

        return new Promise((successDelegate, errorDelegate) => {
            EwsLogging.DebugLog("sending ews request");
            EwsLogging.DebugLog(xhrOptions, true);
            this.service.XHRApi.xhr(xhrOptions)
                .then((xhrResponse: XMLHttpRequest) => {
                    var ewsXmlReader = new EwsXmlReader(xhrResponse.responseText || xhrResponse.response);
                    //EwsLogging.log(util.inspect(xhrResponse.response, { showHidden: false, depth: null, colors: true }));
                    EwsLogging.DebugLog(ewsXmlReader.JsObject, true);
                    if (xhrResponse.status == 200) {

                        //ewsXmlReader.Read();
                        //if (ewsXmlReader.NodeType == Node.DOCUMENT_NODE /*System.Xml.XmlNodeType.Document*/) {
                        //    ewsXmlReader.ReadStartElement(XmlNamespace.Soap, XmlElementNames.SOAPEnvelopeElementName);
                        //}
                        //else if ((ewsXmlReader.NodeType != Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/) || (ewsXmlReader.LocalName != XmlElementNames.SOAPEnvelopeElementName) || (ewsXmlReader.NamespaceUri != EwsUtilities.GetNamespaceUri(XmlNamespace.Soap))) {
                        //    throw new Error(Strings.InvalidAutodiscoverServiceResponse);
                        //}

                        this.ReadSoapHeaders(ewsXmlReader);

                        var response: AutodiscoverResponse = this.ReadSoapBody(ewsXmlReader);

                        //ewsXmlReader.ReadEndElement(XmlNamespace.Soap, XmlElementNames.SOAPEnvelopeElementName);

                        if (response.ErrorCode == AutodiscoverErrorCode.NoError) {
                            //todo: passon to successDelegate
                            //return response;
                        }
                        else {
                            throw new Error("response error " + response.ErrorCode + response.ErrorMessage);// new AutodiscoverResponseException(response.ErrorCode, response.ErrorMessage);
                        }

                    }
                    else {
                        EwsLogging.Log("status !== 200", true, true);
                        EwsLogging.Log(xhrResponse.response, true, true);
                        EwsLogging.Log(ewsXmlReader, true, true);

                    }

                    if (successDelegate)
                        successDelegate(response || xhrResponse.responseText || xhrResponse.response);

                }, (resperr: XMLHttpRequest) => {
                    var exception: any;
                    try {
                        this.ProcessWebException(resperr);
                    }
                    catch (exc) {
                        exception = exc;
                    }
                    if (errorDelegate) errorDelegate(exception || resperr.responseText || resperr.response);
                });
        });

    }
    static IsRedirectionResponse(httpWebResponse: XMLHttpRequest): boolean {
        return (httpWebResponse.status == 302 /*System.Net.HttpStatusCode.Redirect*/) ||
            (httpWebResponse.status == 301 /*System.Net.HttpStatusCode.Moved*/) ||
            (httpWebResponse.status == 307 /*System.Net.HttpStatusCode.RedirectKeepVerb*/) ||
            (httpWebResponse.status == 303 /*System.Net.HttpStatusCode.RedirectMethod*/);
    }
    /**@internal */
    LoadFromXml(reader: EwsXmlReader): AutodiscoverResponse {
        var elementName = this.GetResponseXmlElementName();
        reader.ReadStartElement(XmlNamespace.Autodiscover, elementName);
        var response = this.CreateServiceResponse();
        response.LoadFromXml(reader, elementName);
        return response;
    }
    LoadFromObject(obj: any): AutodiscoverResponse {
        var elementName = this.GetResponseXmlElementName();
        obj = obj.Body[elementName];
        var response = this.CreateServiceResponse();
        response.LoadFromJson(obj[XmlElementNames.Response]);
        return response;
    }


    ProcessWebException(webException: XMLHttpRequest): void {
        if (webException.response) {
            //IEwsHttpWebResponse httpWebResponse = this.Service.HttpWebRequestFactory.CreateExceptionResponse(webException);
            var soapFaultDetails: SoapFaultDetails = null;

            if (webException.status == 500 /*System.Net.HttpStatusCode.InternalServerError*/) {
                // If tracing is enabled, we read the entire response into a MemoryStream so that we
                // can pass it along to the ITraceListener. Then we parse the response from the
                // MemoryStream.
                //if (this.Service.IsTraceEnabledFor(TraceFlags.AutodiscoverRequest)) {
                //using(MemoryStream memoryStream = new MemoryStream())
                //{
                //    using(Stream serviceResponseStream = AutodiscoverRequest.GetResponseStream(httpWebResponse))
                //    {
                //        // Copy response to in-memory stream and reset position to start.
                //        EwsUtilities.CopyStream(serviceResponseStream, memoryStream);
                //        memoryStream.Position = 0;
                //    }

                //todo implement tracing to base class.
                //this.Service.TraceResponse(httpWebResponse, memoryStream);

                //var reader = new EwsXmlReader(webException.responseText);
                //soapFaultDetails = this.ReadSoapFault(reader);
                //}
                //}
                //else {
                //    using(Stream stream = AutodiscoverRequest.GetResponseStream(httpWebResponse))
                //    {
                //        EwsXmlReader reader = new EwsXmlReader(stream);
                //        soapFaultDetails = this.ReadSoapFault(reader);
                //    }
                //}
                var reader = new EwsXmlReader(webException.responseText || webException.response);
                soapFaultDetails = this.ReadSoapFault(reader);

                if (soapFaultDetails) {
                    //todo: implement soap fault error throw
                    throw new ServiceResponseException(new ServiceResponse(soapFaultDetails));
                }
            }
            else {
                //todo: fix this
                this.Service.ProcessHttpErrorResponse(webException, webException);
            }
        }
    }
    /**@internal */
    ReadServerVersionInfo(reader: EwsXmlReader): ExchangeServerInfo {
        var serverInfo = new ExchangeServerInfo();
        do {
            reader.Read();
            switch (reader.LocalName) {
                case XmlElementNames.MajorVersion:
                    serverInfo.MajorVersion = +(reader.ReadElementValue());
                    break;
                case XmlElementNames.MinorVersion:
                    serverInfo.MinorVersion = +(reader.ReadElementValue());
                    break;
                case XmlElementNames.MajorBuildNumber:
                    serverInfo.MajorBuildNumber = +(reader.ReadElementValue());
                    break;
                case XmlElementNames.MinorBuildNumber:
                    serverInfo.MinorBuildNumber = +(reader.ReadElementValue());
                    break;
                case XmlElementNames.Version:
                    serverInfo.VersionString = reader.ReadElementValue();
                    break;
                default:
                    break;
            }

        }
        while (reader.ParentNode.localName === XmlElementNames.ServerVersionInfo);
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, XmlElementNames.ServerVersionInfo));

        return serverInfo;
    }
    /**@internal */
    ReadSoapBody(reader: EwsXmlReader): AutodiscoverResponse {
        var responses = this.LoadFromObject(reader.JsObject);
        return responses

        reader.ReadStartElement(XmlNamespace.Soap, XmlElementNames.SOAPBodyElementName);
        var responses = this.LoadFromXml(reader);
        //reader.ReadEndElement(XmlNamespace.Soap, XmlElementNames.SOAPBodyElementName);
        return responses;
    }
    /**@internal */
    ReadSoapFault(reader: EwsXmlReader): SoapFaultDetails {
        var soapFaultDetails: SoapFaultDetails = undefined;
        if (reader.JsObject && reader.JsObject[XmlElementNames.SOAPBodyElementName]) {
            var obj = reader.JsObject[XmlElementNames.SOAPBodyElementName];
            if (obj[XmlElementNames.SOAPFaultElementName])
                soapFaultDetails = SoapFaultDetails.Parse(obj[XmlElementNames.SOAPFaultElementName]);
        }

        return soapFaultDetails;
        //skipped xml section, using Json only.
        //////try {
        //////    // WCF may not generate an XML declaration.
        //////    reader.Read();
        //////    //if (reader.NodeType == Node.  System.Xml.XmlNodeType.XmlDeclaration) {
        //////    //    reader.Read();
        //////    //}

        //////    if (reader.LocalName != XmlElementNames.SOAPEnvelopeElementName) {
        //////        return soapFaultDetails;
        //////    }

        //////    // Get the namespace URI from the envelope element and use it for the rest of the parsing.
        //////    // If it's not 1.1 or 1.2, we can't continue.
        //////    var soapNamespace: XmlNamespace = EwsUtilities.GetNamespaceFromUri(reader.NamespaceUri);
        //////    if (soapNamespace == XmlNamespace.NotSpecified) {
        //////        return soapFaultDetails;
        //////    }

        //////    reader.Read();

        //////    // Skip SOAP header.
        //////    if (reader.IsElement(soapNamespace, XmlElementNames.SOAPHeaderElementName)) {
        //////        do {
        //////            reader.Read();
        //////        }
        //////        while (reader.HasRecursiveParent(XmlElementNames.SOAPHeaderElementName));

        //////        // Queue up the next read
        //////        //reader.Read(); - no need with nodeiterator/treewalker as the node is already a body Node
        //////    }

        //////    // Parse the fault element contained within the SOAP body.
        //////    if (reader.IsElement(soapNamespace, XmlElementNames.SOAPBodyElementName)) {
        //////        do {
        //////            reader.Read();

        //////            // Parse Fault element
        //////            if (reader.IsElement(soapNamespace, XmlElementNames.SOAPFaultElementName)) {
        //////                soapFaultDetails = SoapFaultDetails.Parse(reader, soapNamespace);
        //////            }
        //////        }
        //////        while (reader.HasRecursiveParent(XmlElementNames.SOAPBodyElementName));
        //////    }
        //////}
        //////catch (XmlException) {
        //////    // If response doesn't contain a valid SOAP fault, just ignore exception and
        //////    // return null for SOAP fault details.
        //////}

        //////return soapFaultDetails;
    }
    /**@internal */
    ReadSoapHeader(reader: EwsXmlReader): void {
        // Is this the ServerVersionInfo?
        if (reader.IsElement(XmlNamespace.Autodiscover, XmlElementNames.ServerVersionInfo)) {
            this.service.ServerInfo = this.ReadServerVersionInfo(reader);
        }
    }
    /**@internal */
    ReadSoapHeaders(reader: EwsXmlReader): void {

        this.service.ServerInfo = reader.JsObject.Header.ServerVersionInfo;
        //return;
        //reader.ReadStartElement(XmlNamespace.Soap, XmlElementNames.SOAPHeaderElementName);
        //do {
        //    reader.Read();

        //    this.ReadSoapHeader(reader);
        //}
        //while (reader.HasRecursiveParent(XmlElementNames.SOAPHeaderElementName));
    }
    Validate(): void {
        //this.Service.Validate();
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): any { throw new Error("Not implemented. overridden"); }
    /**@internal */
    WriteBodyToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Autodiscover, this.GetRequestXmlElementName());
        this.WriteAttributesToXml(writer);
        this.WriteElementsToXml(writer);

        writer.WriteEndElement(); // m:this.GetXmlElementName()
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any { throw new Error("Not implemented. overridden"); }
    /**@internal */
    WriteExtraCustomSoapHeadersToXml(writer: EwsServiceXmlWriter): void { }
    /**@internal */
    WriteSoapRequest(requestUrl: Uri,
        writer: EwsServiceXmlWriter): void {

        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPEnvelopeElementName);
        writer.WriteAttributeValue("xmlns", EwsUtilities.AutodiscoverSoapNamespacePrefix, EwsUtilities.AutodiscoverSoapNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities.WSAddressingNamespacePrefix, EwsUtilities.WSAddressingNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix, EwsUtilities.EwsXmlSchemaInstanceNamespace);
        if (writer.RequireWSSecurityUtilityNamespace) {
            writer.WriteAttributeValue("xmlns", EwsUtilities.WSSecurityUtilityNamespacePrefix, EwsUtilities.WSSecurityUtilityNamespace);
        }

        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPHeaderElementName);

        //if (this.Service.Credentials != null) {
        //    this.Service.Credentials.EmitExtraSoapHeaderNamespaceAliases(writer.InternalWriter);
        //}

        writer.WriteElementValue(
            XmlNamespace.Autodiscover,
            XmlElementNames.RequestedServerVersion,
            ExchangeVersion[this.Service.RequestedServerVersion]
        );

        writer.WriteElementValue(
            XmlNamespace.WSAddressing,
            XmlElementNames.Action,
            this.GetWsAddressingActionName());

        writer.WriteElementValue(
            XmlNamespace.WSAddressing,
            XmlElementNames.To,
            requestUrl.ToString());//.AbsoluteUri);

        this.WriteExtraCustomSoapHeadersToXml(writer);

        //if (this.Service.Credentials != null) {
        //    this.Service.Credentials.SerializeWSSecurityHeaders(writer.InternalWriter);
        //}

        //this.Service.DoOnSerializeCustomSoapHeaders(writer.InternalWriter);

        writer.WriteEndElement(); // soap:Header

        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPBodyElementName);

        this.WriteBodyToXml(writer);

        writer.WriteEndElement(); // soap:Body
        writer.WriteEndElement(); // soap:Envelope
        writer.Flush();
    }
}





export class GetDomainSettingsRequest extends AutodiscoverRequest {
    private static GetDomainSettingsActionUri: string = EwsUtilities.AutodiscoverSoapNamespace + "/Autodiscover/GetDomainSettings";
    Domains: string[];// System.Collections.Generic.List<string>;
    Settings: DomainSettingName[];// System.Collections.Generic.List<DomainSettingName>;
    RequestedVersion: ExchangeVersion;
    private domains: string;// System.Collections.Generic.List<string>;
    private settings: DomainSettingName[];// System.Collections.Generic.List<DomainSettingName>;
    private requestedVersion: ExchangeVersion;

    constructor(service: AutodiscoverService, url: Uri) {
        super(service, url);
    }

    CreateServiceResponse(): AutodiscoverResponse { return new GetDomainSettingsResponseCollection(); }
    Execute(): Promise<GetDomainSettingsResponseCollection> {
        var responses = <Promise<GetDomainSettingsResponseCollection>>this.InternalExecute();

        //GetDomainSettingsResponseCollection responses = (GetDomainSettingsResponseCollection) this.InternalExecute();
        //if (responses.ErrorCode == AutodiscoverErrorCode.NoError) {
        //    this.PostProcessResponses(responses);
        //}

        return responses;
    }
    GetRequestXmlElementName(): string { return XmlElementNames.GetDomainSettingsRequestMessage; }
    GetResponseXmlElementName(): string { return XmlElementNames.GetDomainSettingsResponseMessage; }
    GetWsAddressingActionName(): string { return GetDomainSettingsRequest.GetDomainSettingsActionUri; }
    PostProcessResponses(responses: GetDomainSettingsResponseCollection): any {
        // Note:The response collection may not include all of the requested domains if the request has been throttled.
        for (var index = 0; index < responses.Count; index++) {
            responses.__thisIndexer(index).Domain = this.Domains[index];
        }
    }
    Validate(): void { super.Validate(); }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(
            "xmlns",
            EwsUtilities.AutodiscoverSoapNamespacePrefix,
            EwsUtilities.AutodiscoverSoapNamespace);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any {
        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.Request);

        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.Domains);

        for (var domain of this.Domains) {

            //if (!string.IsNullOrEmpty(domain)) {
            if (domain != undefined && domain !== "") {
                writer.WriteElementValue(
                    XmlNamespace.Autodiscover,
                    XmlElementNames.Domain,
                    domain);
            }
        }
        writer.WriteEndElement(); //Domains

        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.RequestedSettings);
        for (var setting of this.Settings) {

            writer.WriteElementValue(
                XmlNamespace.Autodiscover,
                XmlElementNames.Setting,
                DomainSettingName[setting]);
        }

        writer.WriteEndElement(); //RequestedSettings

        if (hasValue(this.requestedVersion)) {
            writer.WriteElementValue(XmlNamespace.Autodiscover,
                XmlElementNames.RequestedVersion,
                this.requestedVersion);
        }

        writer.WriteEndElement(); //Request
    }
}






export class GetUserSettingsRequest extends AutodiscoverRequest {
    static GetUserSettingsActionUri: string = EwsUtilities.AutodiscoverSoapNamespace + "/Autodiscover/GetUserSettings";

    SmtpAddresses: string[];//System.Collections.Generic.List<string>;
    Settings: UserSettingName[];//System.Collections.Generic.List<UserSettingName>;
    PartnerToken: string;
    PartnerTokenReference: string;
    private expectPartnerToken: boolean;

    constructor(service: AutodiscoverService, url: Uri) {
        super(service, url);
        this.expectPartnerToken = false;
    }
    CreateServiceResponse(): AutodiscoverResponse {
        return new GetUserSettingsResponseCollection();
    }
    Execute(): Promise<GetUserSettingsResponseCollection> {
        return this.InternalExecute().then((adr: GetUserSettingsResponseCollection) => {
            this.PostProcessResponses(adr)
            return adr;
        });
        //<Promise<>> v
        //if (!responses) return;
        //if (responses.ErrorCode == AutodiscoverErrorCode.NoError) {
        //    this.PostProcessResponses(responses);
        //}
        //return responses;
    }
    GetRequestXmlElementName(): string {
        return XmlElementNames.GetUserSettingsRequestMessage;
    }
    GetResponseXmlElementName(): string {
        return XmlElementNames.GetUserSettingsResponseMessage;
    }
    GetWsAddressingActionName(): string {
        return GetUserSettingsRequest.GetUserSettingsActionUri;// GetUserSettingsActionUri;
    }
    PostProcessResponses(responses: GetUserSettingsResponseCollection): void {
        // Note:The response collection may not include all of the requested users if the request has been throttled.
        for (var index = 0; index < responses.Count; index++) {
            responses.__thisIndexer(index).SmtpAddress = this.SmtpAddresses[index];
        }
    }
    /**@internal */
    ReadSoapHeader(reader: EwsXmlReader): void {
        super.ReadSoapHeader(reader);
        return;
        if (this.expectPartnerToken) {
            if (reader.IsElement(XmlNamespace.Autodiscover, XmlElementNames.PartnerToken)) {
                this.PartnerToken = reader.ReadInnerXml();
            }

            if (reader.IsElement(XmlNamespace.Autodiscover, XmlElementNames.PartnerTokenReference)) {
                this.PartnerTokenReference = reader.ReadInnerXml();
            }
        }
    }
    Validate(): void {
        super.Validate();

        EwsUtilities.ValidateParam(this.SmtpAddresses, "smtpAddresses");
        EwsUtilities.ValidateParam(this.Settings, "settings");

        if (this.Settings.length == 0) {
            throw new ServiceValidationException(
                Strings.InvalidAutodiscoverSettingsCount
                );
        }

        if (this.SmtpAddresses.length == 0) {
            throw new ServiceValidationException(
                Strings.InvalidAutodiscoverSmtpAddressesCount
                );
        }

        for (var s in this.SmtpAddresses) {
            var smtpAddress = this.SmtpAddresses[s];
            //if (string.IsNullOrEmpty(smtpAddress)) {
            if (smtpAddress != undefined && smtpAddress !== "") {
                throw new ServiceValidationException(
                    Strings.InvalidAutodiscoverSmtpAddress
                    );
            }
        }
    }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(
            "xmlns",
            EwsUtilities.AutodiscoverSoapNamespacePrefix,
            EwsUtilities.AutodiscoverSoapNamespace);
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): any {
        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.Request);

        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.Users);

        for (var s in this.SmtpAddresses) {
            var smtpAddress = this.SmtpAddresses[s];
            writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.User);

            //if (!string.IsNullOrEmpty(smtpAddress)) {
            if (smtpAddress != undefined && smtpAddress !== "") {
                writer.WriteElementValue(
                    XmlNamespace.Autodiscover,
                    XmlElementNames.Mailbox,
                    smtpAddress);
            }
            writer.WriteEndElement(); // User
        }
        writer.WriteEndElement(); // Users

        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.RequestedSettings);
        for (var s in this.Settings) {
            var setting = this.Settings[s];

            writer.WriteElementValue(
                XmlNamespace.Autodiscover,
                XmlElementNames.Setting,
                UserSettingName[setting]);
        }

        writer.WriteEndElement(); // RequestedSettings

        writer.WriteEndElement(); // Request
    }
    /**@internal */
    WriteExtraCustomSoapHeadersToXml(writer: EwsServiceXmlWriter): void {

        if (this.expectPartnerToken) {
            debugger;
            // writer.WriteElementValue(
            //    XmlNamespace.Autodiscover,
            //    XmlElementNames.BinarySecret,
            //    btoa(ExchangeServiceBase.SessionKey));
            //    //System.Convert.ToBase64String(ExchangeServiceBase.SessionKey));
        }
    }
}

export class AutodiscoverResponse {
    ErrorCode: AutodiscoverErrorCode;
    ErrorMessage: string;
    RedirectionUrl: Uri;
    //private errorCode: AutodiscoverErrorCode;
    //private errorMessage: string;
    //private redirectionUrl: Uri;
    /**@internal */
    LoadFromXml(reader: EwsXmlReader, endElementName: string): void {
        switch (reader.LocalName) {
            case XmlElementNames.ErrorCode:
                var errorstring = reader.ReadElementValue();
                this.ErrorCode = AutodiscoverErrorCode[errorstring];
                break;
            case XmlElementNames.ErrorMessage:
                this.ErrorMessage = reader.ReadElementValue();
                break;
            default:
                break;
        }
    }
    LoadFromJson(obj: any/*, endElementName: string*/): void {

        var errorstring: string = obj[XmlElementNames.ErrorCode];
        this.ErrorCode = AutodiscoverErrorCode[errorstring];

        var errmsg = obj[XmlElementNames.ErrorMessage]
        this.ErrorMessage = errmsg;

    }
}


export class AutodiscoverResponseCollection<TResponse extends AutodiscoverResponse> extends AutodiscoverResponse { //IEnumerable<TResponse>
    get Count(): number{return this.Responses.length};
    Item: TResponse;
    Responses: TResponse[] = [];//System.Collections.Generic.List<TResponse>;
    //private responses: TResponse[];//System.Collections.Generic.List<TResponse>;

    constructor() {
        super();
    }
    __thisIndexer(index: number): TResponse {
        return this.Responses[index];
    }
    CreateResponseInstance(): TResponse { throw new Error("AutodiscoverResponseCollection.ts - CreateResponseInstance : Not implemented."); }
    GetEnumerator(): any { throw new Error("AutodiscoverResponseCollection.ts - GetEnumerator : Not implemented."); }
    GetResponseCollectionXmlElementName(): string { throw new Error("AutodiscoverResponseCollection.ts - GetResponseCollectionXmlElementName : Not implemented."); }
    GetResponseInstanceXmlElementName(): string { throw new Error("AutodiscoverResponseCollection.ts - GetResponseInstanceXmlElementName : Not implemented."); }
    /**@internal */
    LoadFromXml(reader: EwsXmlReader, endElementName: string): void {
        do {
            reader.Read();

            if (reader.NodeType == 1 /*Node.ELEMENT_NODE*/) {
                if (reader.LocalName == this.GetResponseCollectionXmlElementName()) {
                    this.LoadResponseCollectionFromXml(reader);
                }
                else {
                    super.LoadFromXml(reader, endElementName);
                }
            }
        }

        while (reader.HasRecursiveParent(endElementName));
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, endElementName));
    }

    LoadFromJson(obj: any): void {

        var element = this.GetResponseCollectionXmlElementName()
        super.LoadFromJson(obj);
        this.LoadResponseCollectionFromJson(obj[element]);
    }

    LoadResponseCollectionFromJson(obj: any): void {
        var element = this.GetResponseInstanceXmlElementName()
        var responses:any = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];

        for (var i = 0; i < responses.length; i++) {
            var response: TResponse = this.CreateResponseInstance();
            response.LoadFromJson(responses[i]);
            this.Responses.push(response);
        }
    }

    /**@internal */
    LoadResponseCollectionFromXml(reader: EwsXmlReader): void {
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();
                if ((reader.NodeType == 1 /*Node.ELEMENT_NODE*/ /*System.Xml.XmlNodeType.Element*/) && (reader.LocalName == this.GetResponseInstanceXmlElementName())) {
                    var response: TResponse = this.CreateResponseInstance();
                    response.LoadFromXml(reader, this.GetResponseInstanceXmlElementName());
                    this.Responses.push(response);
                }
            }
            while (reader.HasRecursiveParent(this.GetResponseCollectionXmlElementName()));
            //while (!reader.IsEndElement(XmlNamespace.Autodiscover, this.GetResponseCollectionXmlElementName()));
        }
    }
}





export class GetDomainSettingsResponse extends AutodiscoverResponse {
    Domain: string;
    RedirectTarget: string;
    Settings: { [index: number]: any }; //System.Collections.Generic.IDictionary<DomainSettingName, any>;
    DomainSettingErrors: DomainSettingError[]; //System.Collections.ObjectModel.Collection<DomainSettingError>;
    /**@internal */
    LoadDomainSettingErrorsFromXml(reader: EwsXmlReader): void {
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();

                if ((reader.NodeType == Node.ELEMENT_NODE) && (reader.LocalName == XmlElementNames.DomainSettingError)) {
                    var error = new DomainSettingError();
                    error.LoadFromXml(reader);
                    this.DomainSettingErrors.push(error);
                }
            }
            while (reader.HasRecursiveParent(XmlElementNames.UserSettingErrors));
            reader.SeekLast();// fix xml treewalker to go back last node, next do..while loop will come back to current node.
        }
    }
    /**@internal */
    LoadDomainSettingsFromXml(reader: EwsXmlReader): void {
        var parent: Node = reader.CurrentNode;
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();

                if (reader.Eof || !reader.HasRecursiveParentNode(parent, XmlElementNames.DomainSettings))
                    break;

                if ((reader.NodeType == Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/) && (reader.LocalName == XmlElementNames.DomainSetting)) {
                    var settingClass: string = reader.ReadAttributeValue(XmlNamespace.XmlSchemaInstance, XmlAttributeNames.Type);

                    switch (settingClass) {
                        case XmlElementNames.DomainStringSetting:
                            this.ReadSettingFromXml(reader);
                            break;

                        default:
                            EwsLogging.Assert(
                                false,
                                "GetUserSettingsResponse.LoadUserSettingsFromXml",
                                StringHelper.Format("Invalid setting class '{0}' returned", settingClass));
                            break;
                    }
                }
            }
            while (true);// (reader.HasRecursiveParent(XmlElementNames.UserSettings));
            //while (!reader.IsEndElement(XmlNamespace.Autodiscover, XmlElementNames.UserSettings));
           
        }
    }
    /**@internal */
    LoadFromXml(reader: EwsXmlReader, parentElementName: string): void {
        do {
            reader.Read();

            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.RedirectTarget:
                        this.RedirectTarget = reader.ReadElementValue();
                        break;
                    case XmlElementNames.DomainSettingErrors:
                        this.LoadDomainSettingErrorsFromXml(reader);
                        break;
                    case XmlElementNames.DomainSettings:
                        this.LoadDomainSettingsFromXml(reader);
                        break;
                    default:
                        super.LoadFromXml(reader, parentElementName);
                        break;
                }
            }
        }
        while (reader.HasRecursiveParent(parentElementName));
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, endElementName));
    }
    /**@internal */
    ReadSettingFromXml(reader: EwsXmlReader): void {
        var name: string = null;
        var value: any = null;
        var parent: Node = reader.CurrentNode;
        do {
            reader.Read();

            if (reader.Eof || !reader.HasRecursiveParentNode(parent, XmlElementNames.UserSetting))
                break;

            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.Name:
                        name = reader.ReadElementValue();
                        break;
                    case XmlElementNames.Value:
                        value = reader.ReadElementValue();
                        break;
                }
            }
        }
        while (true);
        reader.SeekLast();// fix xml treewalker to go back last node, next do..while loop will come back to current node.


        // EWS Managed API is broken with AutoDSvc endpoint in RedirectUrl scenario
        var domainSettingName: DomainSettingName = DomainSettingName[name];// EwsUtilities.Parse<UserSettingName>(name);
        if (domainSettingName !== undefined)
            this.Settings[domainSettingName] = value;
        else
            EwsLogging.Assert(false,
                "GetUserSettingsResponse.ReadSettingFromXml",
                "Unexpected or empty name element in user setting");
    }

    LoadDomainSettingErrorsFromJson(obj: any): void {
        var errors:any = undefined;

        if (typeof (obj[XmlElementNames.DomainSettingError]) === 'undefined') return;

        if (Object.prototype.toString.call(obj[XmlElementNames.DomainSettingError]) === "[object Array]")
            errors = obj[XmlElementNames.DomainSettingError];
        else
            errors = [obj[XmlElementNames.DomainSettingError]];

        for (var i = 0; i < errors.length; i++) {
            var error = new DomainSettingError();
            error.LoadFromObject(errors[0]);
            this.DomainSettingErrors.push(error);
        }

    }
    LoadDomainSettingsFromJson(obj: any): void {
        var settings:any = undefined;

        if (typeof (obj[XmlElementNames.DomainSetting]) === 'undefined') return;

        if (Object.prototype.toString.call(obj[XmlElementNames.DomainSetting]) === "[object Array]")
            settings = obj[XmlElementNames.DomainSetting];
        else
            settings = [obj[XmlElementNames.DomainSetting]];

        for (var i = 0; i < settings.length; i++) {
            var setting = settings[i];
            var settingClass = setting["type"];
            switch (settingClass) {
                case XmlElementNames.DomainStringSetting:
                    this.ReadSettingFromJson(setting);
                    break;

                default:
                    EwsLogging.Assert(
                        false,
                        "GetUserSettingsResponse.LoadUserSettingsFromXml",
                        StringHelper.Format("Invalid setting class '{0}' returned", settingClass));
                    break;
            }
        }
    }
    LoadFromJson(obj: any): void {
        super.LoadFromJson(obj);
        var settingscol = obj[XmlElementNames.DomainSettings];
        this.LoadDomainSettingsFromJson(settingscol);
        this.RedirectTarget = obj[XmlElementNames.RedirectTarget];
        this.LoadDomainSettingErrorsFromJson(obj[XmlElementNames.DomainSettingErrors]);
    }
    ReadSettingFromJson(obj: any): void {
        var name: string = obj[XmlElementNames.Name];
        var value: any = obj[XmlElementNames.Value];

        // EWS Managed API is broken with AutoDSvc endpoint in RedirectUrl scenario
        var domainSettingName: DomainSettingName = DomainSettingName[name];// EwsUtilities.Parse<UserSettingName>(name);
        if (domainSettingName !== undefined)
            this.Settings[domainSettingName] = value;
        else
            EwsLogging.Assert(false,
                "GetUserSettingsResponse.ReadSettingFromObject",
                "Unexpected or empty name element in user setting");
    }

}
export class GetDomainSettingsResponseCollection extends AutodiscoverResponseCollection<GetDomainSettingsResponse> {
    CreateResponseInstance(): GetDomainSettingsResponse { return new GetDomainSettingsResponse(); }
    GetResponseCollectionXmlElementName(): string { return XmlElementNames.DomainResponses; }
    GetResponseInstanceXmlElementName(): string { return XmlElementNames.DomainResponse; }
}




export class GetUserSettingsResponse extends AutodiscoverResponse {
    SmtpAddress: string;
    RedirectTarget: string;
    Settings: { [index: number]: any }; //System.Collections.Generic.IDictionary<UserSettingName, any>;
    UserSettingErrors: UserSettingError[];// System.Collections.ObjectModel.Collection<UserSettingError>;

    constructor() {
        super();
        this.SmtpAddress = "";
        this.Settings = {};

        this.UserSettingErrors = new Array<UserSettingError>();
    }
    /**@internal */
    LoadFromXml(reader: EwsXmlReader, parentElementName: string): void {
        do {
            reader.Read();

            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.RedirectTarget:
                        this.RedirectTarget = reader.ReadElementValue();
                        break;
                    case XmlElementNames.UserSettingErrors:
                        this.LoadUserSettingErrorsFromXml(reader);
                        break;
                    case XmlElementNames.UserSettings:
                        this.LoadUserSettingsFromXml(reader);
                        break;
                    default:
                        super.LoadFromXml(reader, parentElementName);
                        break;
                }
            }
        }
        while (reader.HasRecursiveParent(parentElementName));
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, endElementName));
    }
    /**@internal */
    LoadUserSettingErrorsFromXml(reader: EwsXmlReader): void {
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();

                if ((reader.NodeType == Node.ELEMENT_NODE) && (reader.LocalName == XmlElementNames.UserSettingError)) {
                    var error = new UserSettingError();
                    error.LoadFromXml(reader);
                    this.UserSettingErrors.push(error);
                }
            }
            while (reader.HasRecursiveParent(XmlElementNames.UserSettingErrors));
            reader.SeekLast();// fix xml treewalker to go back last node, next do..while loop will come back to current node.
        }
    }
    /**@internal */
    LoadUserSettingsFromXml(reader: EwsXmlReader): void {
        var parent: Node = reader.CurrentNode;
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();

                if (reader.Eof || !reader.HasRecursiveParentNode(parent, XmlElementNames.UserSettings))
                    break;

                if ((reader.NodeType == Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/) && (reader.LocalName == XmlElementNames.UserSetting)) {
                    var settingClass: string = reader.ReadAttributeValue(XmlNamespace.XmlSchemaInstance, XmlAttributeNames.Type);

                    switch (settingClass) {
                        case XmlElementNames.StringSetting:
                        case XmlElementNames.WebClientUrlCollectionSetting:
                        case XmlElementNames.AlternateMailboxCollectionSetting:
                        case XmlElementNames.ProtocolConnectionCollectionSetting:
                        case XmlElementNames.DocumentSharingLocationCollectionSetting:
                            this.ReadSettingFromXml(reader);
                            break;

                        default:
                            EwsLogging.Assert(false,
                                "GetUserSettingsResponse.LoadUserSettingsFromXml",
                                StringHelper.Format("Invalid setting class '{0}' returned", settingClass));
                            break;
                    }
                }
            }
            while (true);// (reader.HasRecursiveParent(XmlElementNames.UserSettings));
            //while (!reader.IsEndElement(XmlNamespace.Autodiscover, XmlElementNames.UserSettings));
        }
    }
    /**@internal */
    ReadSettingFromXml(reader: EwsXmlReader): any {
        var name: string = null;
        var value: any = null;
        var parent: Node = reader.CurrentNode;
        do {
            reader.Read();

            if (reader.Eof || !reader.HasRecursiveParentNode(parent, XmlElementNames.UserSetting))
                break;

            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.Name:
                        name = reader.ReadElementValue();
                        break;
                    case XmlElementNames.Value:
                        value = reader.ReadElementValue();
                        break;
                    case XmlElementNames.WebClientUrls:
                        value = WebClientUrlCollection.LoadFromXml(reader);
                        break;
                    case XmlElementNames.ProtocolConnections:
                        value = ProtocolConnectionCollection.LoadFromXml(reader);
                        break;
                    case XmlElementNames.AlternateMailboxes:
                        value = AlternateMailboxCollection.LoadFromXml(reader);
                        break;
                    case XmlElementNames.DocumentSharingLocations:
                        value = DocumentSharingLocationCollection.LoadFromXml(reader);
                        break;
                }
            }
        }
        while (true);
        //while (reader.HasRecursiveParentNode(parent, XmlElementNames.UserSetting));
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, XmlElementNames.UserSetting));
        reader.SeekLast();// fix xml treewalker to go back last node, next do..while loop will come back to current node.


        // EWS Managed API is broken with AutoDSvc endpoint in RedirectUrl scenario
        var userSettingName: UserSettingName = UserSettingName[name];// EwsUtilities.Parse<UserSettingName>(name);
        if (userSettingName !== undefined)
            this.Settings[userSettingName] = value;
        else
            EwsLogging.Assert(false,
                "GetUserSettingsResponse.ReadSettingFromXml",
                "Unexpected or empty name element in user setting");

        //try {

        //}
        //catch (ArgumentException) {
        //    // ignore unexpected UserSettingName in the response (due to the server-side bugs).
        //    // it'd be better if this is hooked into ITraceListener, but that is unavailable here.
        //    //
        //    // in case "name" is null, EwsUtilities.Parse throws ArgumentNullException
        //    // (which derives from ArgumentException).
        //    //

        //    //EwsUtilities.Assert(
        //    //    false,
        //    //    "GetUserSettingsResponse.ReadSettingFromXml",
        //    //    "Unexpected or empty name element in user setting");
        //}
    }

    LoadFromJson(obj: any/*, parentElementName: string*/): void {
        //debugger;
        super.LoadFromJson(obj/*, parentElementName*/);
        var settingscol = obj[XmlElementNames.UserSettings];
        this.LoadUserSettingsFromJson(settingscol);
        this.RedirectTarget = obj[XmlElementNames.RedirectTarget];
        //var redirecttarget = obj[XmlElementNames.RedirectTarget];
        ////if (redirecttarget["nil"]) redirecttarget = null;
        //this.RedirectTarget = redirecttarget;
        this.LoadUserSettingErrorsFromJson(obj[XmlElementNames.UserSettingErrors]);

    }
    LoadUserSettingErrorsFromJson(obj: any): void {
        var errors: any = undefined;

        if (!obj || typeof (obj[XmlElementNames.UserSettingError]) === 'undefined')
            return;

        if (Object.prototype.toString.call(obj[XmlElementNames.UserSettingError]) === "[object Array]")
            errors = obj[XmlElementNames.UserSettingError];
        else
            errors = [obj[XmlElementNames.UserSettingError]];

        for (var i = 0; i < errors.length; i++) {
            var error = new UserSettingError();
            error.LoadFromJson(errors[0]);
            this.UserSettingErrors.push(error);
        }
    }
    LoadUserSettingsFromJson(obj: any): void {
        var settings: any = undefined;

        if (!obj || typeof (obj[XmlElementNames.UserSetting]) === 'undefined')
            return;

        if (Object.prototype.toString.call(obj[XmlElementNames.UserSetting]) === "[object Array]")
            settings = obj[XmlElementNames.UserSetting];
        else
            settings = [obj[XmlElementNames.UserSetting]];

        for (var i = 0; i < settings.length; i++) {
            var setting = settings[i];
            var settingClass = setting["type"];
            switch (settingClass) {
                case XmlElementNames.StringSetting:
                case XmlElementNames.WebClientUrlCollectionSetting:
                case XmlElementNames.AlternateMailboxCollectionSetting:
                case XmlElementNames.ProtocolConnectionCollectionSetting:
                case XmlElementNames.DocumentSharingLocationCollectionSetting:
                    this.ReadSettingFromJson(setting);
                    break;

                default:
                    EwsLogging.Assert(false,
                        "GetUserSettingsResponse.LoadUserSettingsFromXml",
                        StringHelper.Format("Invalid setting class '{0}' returned", settingClass));
                    break;
            }
        }

    }
    ReadSettingFromJson(obj: any): void {
        var name: string = obj[XmlElementNames.Name];
        var value: any = obj[XmlElementNames.Value];

        switch (obj["type"]) {
            case XmlElementNames.WebClientUrlCollectionSetting://.WebClientUrls:
                value = WebClientUrlCollection.LoadFromJson(obj[XmlElementNames.WebClientUrls]);
                break;
            case XmlElementNames.ProtocolConnectionCollectionSetting://ProtocolConnections:
                value = ProtocolConnectionCollection.LoadFromJson(obj[XmlElementNames.ProtocolConnections]);
                break;
            case XmlElementNames.AlternateMailboxCollectionSetting://AlternateMailboxes:
                value = AlternateMailboxCollection.LoadFromJson(obj[XmlElementNames.AlternateMailboxes]);
                break;
            case XmlElementNames.DocumentSharingLocationCollectionSetting://DocumentSharingLocations:
                //debugger;
                EwsLogging.Log("------------DocumentSharingLocationCollection needs test and fix ----------------", true);
                EwsLogging.Log(obj, true, true);
                value = DocumentSharingLocationCollection.LoadFromJson(obj);
                break;
        }

        // EWS Managed API is broken with AutoDSvc endpoint in RedirectUrl scenario
        var userSettingName: UserSettingName = UserSettingName[name];// EwsUtilities.Parse<UserSettingName>(name);
        if (userSettingName !== undefined)
            this.Settings[userSettingName] = value;
        else
            EwsLogging.Assert(false,
                "GetUserSettingsResponse.ReadSettingFromXml",
                "Unexpected or empty name element in user setting");

        //try {

        //}
        //catch (ArgumentException) {
        //    // ignore unexpected UserSettingName in the response (due to the server-side bugs).
        //    // it'd be better if this is hooked into ITraceListener, but that is unavailable here.
        //    //
        //    // in case "name" is null, EwsUtilities.Parse throws ArgumentNullException
        //    // (which derives from ArgumentException).
        //    //

        //    //EwsUtilities.Assert(
        //    //    false,
        //    //    "GetUserSettingsResponse.ReadSettingFromXml",
        //    //    "Unexpected or empty name element in user setting");
        //}
    }

    GetSettingValue<T>(setting: UserSettingName): T {
        //public bool TryGetSettingValue<T>(UserSettingName setting, out T value)

        return this.Settings[setting];
    }
}

export class GetUserSettingsResponseCollection extends AutodiscoverResponseCollection<GetUserSettingsResponse> {
    CreateResponseInstance(): GetUserSettingsResponse { return new GetUserSettingsResponse(); }
    GetResponseCollectionXmlElementName(): string { return XmlElementNames.UserResponses; }
    GetResponseInstanceXmlElementName(): string { return XmlElementNames.UserResponse; }
}
//todo: fix this - import Xml = require("System.Xml");


export class AlternateMailbox {
    Type: string;
    DisplayName: string;
    LegacyDN: string;
    Server: string;
    SmtpAddress: string;
    OwnerSmtpAddress: string;
    //private type: string;
    //private displayName: string;
    //private legacyDN: string;
    //private server: string;
    //private smtpAddress: string;
    //private ownerSmtpAddress: string;
    /**@internal */
    LoadFromXml(reader: EwsXmlReader): AlternateMailbox {
        var altMailbox: AlternateMailbox = new AlternateMailbox();

        do {
            reader.Read();
            if (reader.NodeType == 1){//todo:  1 = System.Xml.XmlNodeType.Element) {
                switch (reader.LocalName) {
                    case XmlElementNames.Type:
                        altMailbox.Type = reader.ReadElementValue();//  reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.DisplayName:
                        altMailbox.DisplayName = reader.ReadElementValue();//reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.LegacyDN:
                        altMailbox.LegacyDN = reader.ReadElementValue();//reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.Server:
                        altMailbox.Server = reader.ReadElementValue();//reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.SmtpAddress:
                        altMailbox.SmtpAddress = reader.ReadElementValue();//reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.OwnerSmtpAddress:
                        altMailbox.OwnerSmtpAddress = reader.ReadElementValue();//reader.ReadElementValue<string>();
                        break;
                    default:
                        break;
                }
            }
        }
        while (!reader.IsElement(XmlNamespace.Autodiscover, XmlElementNames.AlternateMailbox));
        reader.SeekLast(); // to go back to last one, fix for xmlnode based reader.
        return altMailbox;
    }
    static LoadFromJson(obj: any): AlternateMailbox { throw new Error("this was skipped as not needed at dev time, fix this"); }

}



export class AlternateMailboxCollection {
    Entries: AlternateMailbox[] = []; //System.Collections.Generic.List<AlternateMailbox>;
    /**@internal */
    static LoadFromXml(reader: EwsXmlReader): AlternateMailboxCollection { throw new Error("Not implemented. depricated use LoadFromJson"); }
    static LoadFromJson(obj: any): AlternateMailboxCollection {
        var instance = new AlternateMailboxCollection();

        var element = XmlElementNames.AlternateMailbox;
        var responses = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];

        for (var i = 0; i < responses.length; i++) {
            instance.Entries.push(responses[i]);
            //AlternateMailbox.LoadFromJson(responses[i]);
            //instance.Entries.push(responses);
        }

        return instance;
    }
}


/**@internal */
    export class AutodiscoverDnsClient {
    private service: AutodiscoverService;
    private static randomTieBreakerSelector: any;
    private static AutoDiscoverSrvPrefix: string = "_autodiscover._tcp.";
    private static SslPort: number = 443;
    FindAutodiscoverHostFromSrv(domain: string): string { throw new Error("AutodiscoverDnsClient.ts - FindAutodiscoverHostFromSrv : Not implemented."); }
    FindBestMatchingSrvRecord(domain: string): DnsSrvRecord { throw new Error("AutodiscoverDnsClient.ts - FindBestMatchingSrvRecord : Not implemented."); }
}
export class AutodiscoverError {
    Time: string;
    Id: string;
    ErrorCode: number;
    Message: string;
    DebugData: string;
    private time: string;
    private id: string;
    private errorCode: number;
    private message: string;
    private debugData: string;
    //Parse(reader: EwsXmlReader): AutodiscoverError { throw new Error("AutodiscoverError.ts - Parse : Not implemented."); }
}








export class AutodiscoverService extends ExchangeServiceBase {
    private static AutodiscoverLegacyPath: string = "/autodiscover/autodiscover.xml";
    private static AutodiscoverLegacyUrl: string = "{0}://{1}" + AutodiscoverService.AutodiscoverLegacyPath;
    private static AutodiscoverLegacyHttpsUrl: string = "https://{0}" + AutodiscoverService.AutodiscoverLegacyPath;
    private static AutodiscoverLegacyHttpUrl: string = "http://{0}" + AutodiscoverService.AutodiscoverLegacyPath;
    private static AutodiscoverSoapHttpsUrl: string = "https://{0}/autodiscover/autodiscover.svc";
    private static AutodiscoverSoapWsSecurityHttpsUrl: string = AutodiscoverService.AutodiscoverSoapHttpsUrl + "/wssecurity";
    private static AutodiscoverSoapWsSecuritySymmetricKeyHttpsUrl: string = AutodiscoverService.AutodiscoverSoapHttpsUrl + "/wssecurity/symmetrickey";
    private static AutodiscoverSoapWsSecurityX509CertHttpsUrl: string = AutodiscoverService.AutodiscoverSoapHttpsUrl + "/wssecurity/x509cert";
    private static AutodiscoverRequestNamespace: string = "http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006";
    static AutodiscoverMaxRedirections: number = 10;
    private static AutodiscoverSoapEnabledHeaderName: string = "X-SOAP-Enabled";
    private static AutodiscoverWsSecurityEnabledHeaderName: string = "X-WSSecurity-Enabled";
    private static AutodiscoverWsSecuritySymmetricKeyEnabledHeaderName: string = "X-WSSecurity-SymmetricKey-Enabled";
    private static AutodiscoverWsSecurityX509CertEnabledHeaderName: string = "X-WSSecurity-X509Cert-Enabled";
    private static AutodiscoverOAuthEnabledHeaderName: string = "X-OAuth-Enabled";
    private static LegacyPathRegex: RegExp = new RegExp("\/autodiscover/([^/]+/)*autodiscover.xml");
    private static MinimumRequestVersionForAutoDiscoverSoapService: ExchangeVersion = ExchangeVersion.Exchange2010;


    IsExternal: boolean;
    RedirectionUrlValidationCallback: AutodiscoverRedirectionUrlValidationCallback;
    DnsServerAddress: any;// System.Net.IPAddress;
    EnableScpLookup: boolean;
    GetScpUrlsForDomainCallback: Function;// System.Func<string, System.Collections.Generic.ICollection<string>>;
    private domain: string;
    private url: Uri;
    //private isExternal: boolean;
    //private redirectionUrlValidationCallback: AutodiscoverRedirectionUrlValidationCallback;
    //private dnsClient: AutodiscoverDnsClient;
    //private dnsServerAddress: any;// System.Net.IPAddress;
    //private enableScpLookup: boolean;
    get Domain(): string {
        return this.domain;
    }
    set Domain(value) {
        this.domain = value;
        if (value)
            this.url = undefined;
    }
    get Url(): Uri {
        return this.url;
    }
    set Url(value) {
        if (value)
            this.domain = value.Host;
        this.url = value;
    }


    constructor();
    constructor(domain: string);
    constructor(requestedServerVersion: ExchangeVersion);
    constructor(service: ExchangeServiceBase);
    constructor(url: Uri);
    constructor(domain: string, requestedServerVersion: ExchangeVersion);
    constructor(service: ExchangeServiceBase, requestedServerVersion: ExchangeVersion);
    constructor(url: Uri, domain: string);
    constructor(url: Uri, requestedServerVersion: ExchangeVersion);
    constructor(url: Uri, domain: string, requestedServerVersion: ExchangeVersion);
    constructor(
        domainUrlServiceOrVersion?: string | Uri | ExchangeServiceBase | ExchangeVersion,
        domainOrVersion?: string | ExchangeVersion,
        version: ExchangeVersion = ExchangeVersion.Exchange2010
    ) {
        var argsLength = arguments.length;

        if (argsLength > 3) {
            throw new Error("AutodiscoverService.ts - ctor with " + argsLength + " parameters, invalid number of arguments, check documentation and try again.");
        }
        //EwsUtilities.ValidateDomainNameAllowNull(domainOrVersion, "domain"); 

        var domain: string = null;
        var url: Uri = null;
        var service: ExchangeServiceBase = null;
        var requestedServerVersion: ExchangeVersion = ExchangeVersion.Exchange2010;
        var hasService: boolean = false;
        var hasVersion: boolean = false;

        if (argsLength >= 1) {
            if (domainUrlServiceOrVersion instanceof Uri) {
                url = domainUrlServiceOrVersion;
            }
            else if (domainUrlServiceOrVersion instanceof ExchangeServiceBase) {
                service = domainUrlServiceOrVersion;
                hasService = true;
            }
            else if (typeof domainUrlServiceOrVersion === 'string') {
                domain = domainUrlServiceOrVersion;
            }
            else if (typeof domainUrlServiceOrVersion === 'number') {
                requestedServerVersion = domainUrlServiceOrVersion;
                hasVersion = true;
            }
        }
        if (argsLength >= 2) {
            if (typeof domainOrVersion === 'string') {
                if (!(domainUrlServiceOrVersion instanceof Uri)) {
                    throw new Error("AutodiscoverService.ts - ctor with " + argsLength + " parameters - incorrect uses of parameter at 1st position, it must be Uri when using string at 2nd place");
                }
                domain = domainOrVersion;
            }
            else if (typeof domainOrVersion === 'number') {
                requestedServerVersion = domainOrVersion;
            }
        }
        if (argsLength === 3) {
            requestedServerVersion = version;
        }

        if (service !== null && typeof service !== 'undefined') {
            super(service, requestedServerVersion);
        }
        else {
            super(requestedServerVersion);
            this.url = url;
            this.domain = domain;
        }
    }


    CallRedirectionUrlValidationCallback(redirectionUrl: string): boolean {
        var callback: AutodiscoverRedirectionUrlValidationCallback = (this.RedirectionUrlValidationCallback == null)
            ? this.DefaultAutodiscoverRedirectionUrlValidationCallback
            : this.RedirectionUrlValidationCallback;

        return callback(redirectionUrl);
    }
    DefaultAutodiscoverRedirectionUrlValidationCallback(redirectionUrl: string): boolean {
        throw new AutodiscoverLocalException(StringHelper.Format("Autodiscover redirection is blocked for url: {0}"/*Strings.AutodiscoverRedirectBlocked*/, redirectionUrl));
    }
    //DefaultGetScpUrlsForDomain(domainName: string): string[] { return null; }// System.Collections.Generic.ICollection<string>{ throw new Error("AutodiscoverService.ts - DefaultGetScpUrlsForDomain : Not implemented.");}
    //DisableScpLookupIfDuplicateRedirection(emailAddress: string, redirectionEmailAddresses: string[]): any{ throw new Error("AutodiscoverService.ts - DisableScpLookupIfDuplicateRedirection : Not implemented.");}
    GetAutodiscoverEndpointUrl(host: string): Promise<Uri> {
        var autodiscoverUrlOut: IOutParam<Uri> = { outValue: null };

        return this.TryGetAutodiscoverEndpointUrl(host, autodiscoverUrlOut)
            .then<Uri>((value) => {
                if (value) {
                    return autodiscoverUrlOut.outValue;
                }
                else {
                    throw new AutodiscoverLocalException("no soap or WsSecurity endpoint available"/*Strings.NoSoapOrWsSecurityEndpointAvailable*/);
                }
            }, (err) => {
                throw new AutodiscoverLocalException("no soap or WsSecurity endpoint available"/*Strings.NoSoapOrWsSecurityEndpointAvailable*/);
            });
    }

    //--done
    GetAutodiscoverServiceHosts(domainName: string): string[] {

        var serviceHosts: string[] = [];
        var urls = this.GetAutodiscoverServiceUrls(domainName);
        for (var url of urls) {
            serviceHosts.push(UriHelper.getHost(url));
        }

        return serviceHosts;
    }
    //--done
    GetAutodiscoverServiceUrls(domainName: string): string[] {// System.Collections.Generic.List<T>{
        var urls: string[] = [];

        if (this.EnableScpLookup) {
            // Get SCP URLs
            //Func < string, ICollection <string>> callback = this.GetScpUrlsForDomainCallback ?? this.DefaultGetScpUrlsForDomain;
            //ICollection < string> scpUrls = callback(domainName);
            //foreach(string str in scpUrls)
            //{
            //    urls.Add(new Uri(str));
            //}
        }
        //scpHostCount = urls.length;

        // As a fallback, add autodiscover URLs base on the domain name.
        urls.push(StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, "autodiscover." + domainName));
        urls.push(StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, domainName));

        return urls;
    }
    GetDomainSettings(domains: string[], settings: DomainSettingName[], requestedVersion: ExchangeVersion): Promise<GetDomainSettingsResponseCollection>;
    GetDomainSettings(domains: string[], requestedVersion: ExchangeVersion, ...domainSettingNames: DomainSettingName[]): Promise<GetDomainSettingsResponseCollection>;
    GetDomainSettings(domain: string, requestedVersion: ExchangeVersion, ...domainSettingNames: DomainSettingName[]): Promise<GetDomainSettingsResponse>

    GetDomainSettings(
        domainOrDomainNames: string | string[],
        settingsOrVersion: ExchangeVersion | DomainSettingName[],
        versionOrSettingNames: ExchangeVersion | any //...params DomainSettingName[]
    ): Promise<GetDomainSettingsResponse | GetDomainSettingsResponseCollection> {

        // EwsUtilities.ValidateParam(domains, "domains");
        // EwsUtilities.ValidateParam(settings, "settings");

        var requestedVersion: ExchangeVersion = null;
        var settings: DomainSettingName[] = [];
        if (arguments.length <= 3) {
            if (Array.isArray(settingsOrVersion)) {
                settings = <DomainSettingName[]>settingsOrVersion;
                requestedVersion = versionOrSettingNames;
            }
            else {
                settings.push(arguments[2]);
            }
        }
        else {
            if (settingsOrVersion !== null && typeof settingsOrVersion !== 'number') {
                throw new Error("AutodiscoverService.ts - GetDomainSettings with " + arguments.length + " incorrect uses of parameter at 2nd position, it must be ExchangeVersion or null when using DomainSettingName[] ...params at 3rd place");
            }
            for (var _i = 2; _i < arguments.length; _i++) {
                settings[_i - 2] = arguments[_i];
            }
            requestedVersion = <ExchangeVersion>settingsOrVersion;
        }
        var isCollection: boolean = true;
        var domains: string[] = <string[]>domainOrDomainNames;
        if (!Array.isArray(domainOrDomainNames)) {
            domains = [<string>domainOrDomainNames]
            isCollection = false;
        }


        return this.GetSettings<GetDomainSettingsResponseCollection, DomainSettingName>(
            domains,
            settings,
            requestedVersion,
            this.InternalGetDomainSettings,
            () => { return domains[0]; }).then((value: GetDomainSettingsResponseCollection) => {
                if (isCollection) {
                    return value;
                }
                else {
                    return value.__thisIndexer(0);
                }
            }, (error) => {
                throw error;
            });

        // var request = new GetDomainSettingsRequest(this, this.url);
        // request.Settings = domainSettingNames;
        // request.Domains = [domain];
        // var response = request.Execute();
        // return <any>response;
    }

    //previous name - GetEndpointsFromHttpWebResponse
    private GetEndpointsFromHttpResponse(response: XMLHttpRequest): AutodiscoverEndpoints {
        var endpoints: AutodiscoverEndpoints = AutodiscoverEndpoints.Legacy;
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverSoapEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.Soap;
        }
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverWsSecurityEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.WsSecurity;
        }
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverWsSecuritySymmetricKeyEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.WSSecuritySymmetricKey;
        }
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverWsSecurityX509CertEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.WSSecurityX509Cert;
        }
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverOAuthEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.OAuth;
        }
        return endpoints;
    }
    //GetLegacyUserSettings(emailAddress: string): any{ throw new Error("AutodiscoverService.ts - GetLegacyUserSettings : Not implemented.");}
    //GetLegacyUserSettingsAtUrl(emailAddress: string, url: Uri): any{ throw new Error("AutodiscoverService.ts - GetLegacyUserSettingsAtUrl : Not implemented.");}
    //GetRedirectionUrlFromDnsSrvRecord(domainName: string): Uri{ throw new Error("AutodiscoverService.ts - GetRedirectionUrlFromDnsSrvRecord : Not implemented.");}
    GetRedirectUrl(domainName: string): Promise<Uri> {
        var url: string = StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpUrl, "autodiscover." + domainName);

        this.TraceMessage(
            TraceFlags.AutodiscoverConfiguration,
            StringHelper.Format("Trying to get Autodiscover redirection URL from {0}.", url));

        var xhrOptions: IXHROptions = {
            type: "GET",
            url: url,
        };
        return this.XHRApi.xhr(xhrOptions)
            .then<Uri>((response: XMLHttpRequest) => {
                if (response != null) {

                    this.TraceMessage(TraceFlags.All,
                        "***hard checking for office 365 with node.js http request and presence of header x-federationtrusttokenissueruri= urn:federation:MicrosoftOnline");

                    var redirectUrl: string = null;
                    if (!StringHelper.IsNullOrEmpty(response.getResponseHeader("x-federationtrusttokenissueruri"))) {
                        if (response.getResponseHeader("x-federationtrusttokenissueruri") === "urn:federation:MicrosoftOnline")
                            redirectUrl = "https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc";
                        return new Uri(redirectUrl);
                    }
                    //if (this.TryGetRedirectionResponse(response, redirectUrl)) {
                    //    return redirectUrl;
                    //}
                }

                this.TraceMessage(
                    TraceFlags.AutodiscoverConfiguration,
                    "No Autodiscover redirection URL was returned.");

                return null;

            }, (resperr: XMLHttpRequest) => {
                if (resperr.status === 0) {
                    //catch (IOException ex)
                    this.TraceMessage(
                        TraceFlags.AutodiscoverConfiguration,
                        StringHelper.Format("I/O error: {0}", "unable to connect"));
                } else {
                    //catch (WebException ex)
                    this.TraceMessage(
                        TraceFlags.AutodiscoverConfiguration,
                        StringHelper.Format("--Request error: {0}, {1}", resperr.status, resperr.statusText));

                    //todo: possible?
                    // The exception response factory requires a valid HttpWebResponse,
                    // but there will be no web response if the web request couldn't be
                    // actually be issued (e.g. due to DNS error).
                    //if (ex.Response != null) {
                    //    response = this.HttpWebRequestFactory.CreateExceptionResponse(ex);
                    //}
                }
                if (resperr.status === 401) {//unauthorized in case it was redirected, checking header now
                    this.TraceMessage(TraceFlags.All,
                        "***hard checking for office 365 with node.js http request and presence of header x-federationtrusttokenissueruri= urn:federation:MicrosoftOnline");

                    var redirectUrl: string = null;
                    if (!StringHelper.IsNullOrEmpty(resperr.getResponseHeader("x-federationtrusttokenissueruri"))) {
                        if (resperr.getResponseHeader("x-federationtrusttokenissueruri") === "urn:federation:MicrosoftOnline") {
                            redirectUrl = "https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc";
                            this.TraceMessage(TraceFlags.All,
                                "possible hard match for O365 based on federation header (could be any legitimate 302 redirect - less likely)\r\n trying to connect to O365 multitenent autodiscover url: " + redirectUrl);
                        }
                        return new Uri(redirectUrl);
                    }
                }
                return null;
            });
    }
    GetSettings<TGetSettingsResponseCollection, TSettingName>(
        identities: string[], settings: TSettingName[], requestedVersion: ExchangeVersion,
        getSettingsMethod: GetSettingsMethod<TGetSettingsResponseCollection, TSettingName>,
        getDomainMethod: () => string): Promise<TGetSettingsResponseCollection> {
        // Autodiscover service only exists in E14 or later.
        if (this.RequestedServerVersion < AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.AutodiscoverServiceIncompatibleWithRequestVersion,
                    AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService));
        }

        var response: Promise<TGetSettingsResponseCollection> = null;
        var autodiscoverUrlRef: IRefParam<Uri> = { getValue: () => this.Url, setValue: (url) => this.url = url };

        // If Url is specified, call service directly.
        if (this.Url != null) {

            return getSettingsMethod(
                identities,
                settings,
                requestedVersion,
                autodiscoverUrlRef, this)
                .then((response) => {
                    this.Url = autodiscoverUrlRef.getValue();
                    return response;
                });
        }

        // If Domain is specified, determine endpoint Url and call service.
        else if (!StringHelper.IsNullOrEmpty(this.Domain)) {
            return this.GetAutodiscoverEndpointUrl(this.Domain)
                .then<TGetSettingsResponseCollection>((adsvcurl) => {
                    autodiscoverUrlRef = { getValue: () => adsvcurl };
                    return getSettingsMethod(
                        identities,
                        settings,
                        requestedVersion,
                        autodiscoverUrlRef, this)
                        .then((response) => {
                            // If we got this far, response was successful, set Url.
                            this.Url = autodiscoverUrlRef.getValue();
                            return response;
                        });
                });
        }

        // No Url or Domain specified, need to figure out which endpoint(s) to try.
        else {
            // Assume caller is not inside the Intranet, regardless of whether SCP Urls
            // were returned or not. SCP Urls are only relevent if one of them returns
            // valid Autodiscover settings.

            this.IsExternal = true;

            var autodiscoverOutUrl: IOutParam<Uri> = { outValue: undefined };

            var domainName: string = getDomainMethod();

            var scpHostCount: number;
            var hosts = this.GetAutodiscoverServiceHosts(domainName);//, scpHostCount);

            if (hosts.length == 0) {
                throw new ServiceValidationException("autodiscover service request requires domain or url"
                    /*Strings.AutodiscoverServiceRequestRequiresDomainOrUrl*/);
            }



            return this.GetSettingsRecursiveLookup(identities, settings, requestedVersion, getSettingsMethod, autodiscoverUrlRef, hosts).then((response) => {
                return response;
            }, (err) => {

                this.TraceMessage(TraceFlags.DebugMessage,
                    "--hard checking for office 365 with node.js http request and presence of header x-federationtrusttokenissueruri: urn:federation:MicrosoftOnline. All other redirection wil fail");
                // Next-to-last chance: try unauthenticated GET over HTTP to be redirected to appropriate service endpoint.
                return this.GetRedirectUrl(domainName).then((autodiscoverUrl) => {
                    if ((autodiscoverUrl != null) &&
                        this.CallRedirectionUrlValidationCallback(autodiscoverUrl.ToString())) {
                        return this.TryGetAutodiscoverEndpointUrl(autodiscoverUrl.Host, { outValue: autodiscoverUrl }).then((value) => {
                            if (value) {
                                return getSettingsMethod(
                                    identities,
                                    settings,
                                    requestedVersion,
                                    { getValue: () => autodiscoverUrl }, this).then((response) => {
                                        // If we got this far, response was successful, set Url.
                                        this.Url = autodiscoverUrl;
                                        return response;
                                    });
                            }
                        });
                    }
                }, (err) => {
                    throw new AutodiscoverLocalException("Autodiscover could not be located, skipped srv record lookup, not implement in this js version"/*Strings.AutodiscoverCouldNotBeLocated*/);
                });
            });




            /// ------- SRV record resolution not implemented ------- /// Last Chance: try to read autodiscover SRV Record from DNS. If we find one, use
            ////// the hostname returned to construct an Autodiscover endpoint URL.
            ////autodiscoverUrl = this.GetRedirectionUrlFromDnsSrvRecord(domainName);
            ////if ((autodiscoverUrl != null) &&
            ////    this.CallRedirectionUrlValidationCallback(autodiscoverUrl.ToString()) &&
            ////    this.TryGetAutodiscoverEndpointUrl(autodiscoverUrl.Host, out autodiscoverUrl)) {
            ////    response = getSettingsMethod(
            ////        identities,
            ////        settings,
            ////        requestedVersion,
            ////        ref autodiscoverUrl);

            ////    // If we got this far, the response was successful, set Url.
            ////    this.Url = autodiscoverUrl;

            ////    return response;
            ////}
            ////else {
            ////    throw new AutodiscoverLocalException(Strings.AutodiscoverCouldNotBeLocated);
            ////}
        }
    }

    private GetSettingsRecursiveLookup<TGetSettingsResponseCollection, TSettingName>(
        identities: string[], settings: TSettingName[], requestedVersion: ExchangeVersion,
        getSettingsMethod: GetSettingsMethod<TGetSettingsResponseCollection, TSettingName>,
        autodiscoverUrlRef: IRefParam<Uri>, hosts: string[], currentHostIndex: number = 0): Promise<TGetSettingsResponseCollection> {
        //        for (var currentHostIndex = 0; currentHostIndex < hosts.length; currentHostIndex++) {

        if (currentHostIndex >= hosts.length) throw new AutodiscoverLocalException("***cannot determine based on autodiscover host names");

        var host = hosts[currentHostIndex];
        // var isScpHost:bool = currentHostIndex < scpHostCount;
        var autodiscoverUrlOut: IOutParam<Uri> = { outValue: null };
        return this.TryGetAutodiscoverEndpointUrl(host, autodiscoverUrlOut)
            .then<TGetSettingsResponseCollection>((value) => {
                if (value) {
                    // If we got this far, the response was successful, set Url.
                    this.Url = autodiscoverUrlOut.outValue;

                    return getSettingsMethod(
                        identities,
                        settings,
                        requestedVersion,
                        autodiscoverUrlRef, this).then((response) => {
                            // Not external if Autodiscover endpoint found via SCP returned the settings.
                            //if (isScpHost) {
                            //    this.IsExternal = false;
                            //}
                            return response;
                        });
                } else {
                    currentHostIndex++;
                    return this.GetSettingsRecursiveLookup(identities, settings, requestedVersion, getSettingsMethod, autodiscoverUrlRef, hosts, currentHostIndex);
                }
            }, (err) => {
                currentHostIndex++;
                return this.GetSettingsRecursiveLookup(identities, settings, requestedVersion, getSettingsMethod, autodiscoverUrlRef, hosts, currentHostIndex);
            });
    }

    /**internal method */
    public GetUserSettings(smtpAddresses: string[], settings: UserSettingName[]): Promise<GetUserSettingsResponseCollection>;
    /**
     * Retrieves the specified settings for single SMTP address.
     *
     * @param   {string}   userSmtpAddress    The SMTP addresses of the user.
     * @param   {UserSettingName[]}   userSettingNames   The user setting names.
     * @return  {Promise<GetUserSettingsResponse>} A UserResponse object containing the requested settings for the specified user.
     */
    public GetUserSettings(userSmtpAddress: string, userSettingNames: UserSettingName[]): Promise<GetUserSettingsResponse>;
    public GetUserSettings(userSmtpAddress: string, ...userSettingNames: UserSettingName[]): Promise<GetUserSettingsResponse>;
    public GetUserSettings(smtpAddresses: string | string[], userSettings: any): Promise<GetUserSettingsResponse | GetUserSettingsResponseCollection> {
        var userSettingNames: UserSettingName[] = [];
        if (arguments.length === 2) {
            if (Array.isArray(userSettings)) {
                userSettingNames = userSettings;
            }
            else {
                userSettingNames.push(arguments[1]);
            }
        }
        else {
            for (var _i = 1; _i < arguments.length; _i++) {
                userSettingNames[_i - 1] = arguments[_i];
            }
        }

        if (Array.isArray(smtpAddresses)) {
            //EwsUtilities.ValidateParam(smtpAddresses, "smtpAddresses");
            //EwsUtilities.ValidateParam(settings, "settings");

            return this.GetSettings<GetUserSettingsResponseCollection, UserSettingName>(
                <string[]>smtpAddresses,
                userSettingNames,
                null,
                this.InternalGetUserSettings,
                () => { return EwsUtilities.DomainFromEmailAddress(smtpAddresses[0]); });
        }

        var userSmtpAddress: string = <string>smtpAddresses;
        //List < UserSettingName > requestedSettings = new List<UserSettingName>(userSettingNames);

        if (StringHelper.IsNullOrEmpty(userSmtpAddress)) {
            throw new ServiceValidationException("invalid autodiscover smtp address" /*Strings.InvalidAutodiscoverSmtpAddress*/);
        }
        var requestedSettings = userSettingNames || [];

        if (requestedSettings.length == 0) {
            throw new ServiceValidationException("invalid autodiscover setting count" /*Strings.InvalidAutodiscoverSettingsCount*/);
        }

        if (this.RequestedServerVersion < AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService) {
            return this.InternalGetLegacyUserSettings(userSmtpAddress, requestedSettings);
        }
        else {
            return this.InternalGetSoapUserSettings(userSmtpAddress, requestedSettings);
        }
    }

    public GetUsersSettings(userSmtpAddresses: string[], ...userSettingNames: UserSettingName[]): Promise<GetUserSettingsResponseCollection> {

        if (this.RequestedServerVersion < AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService) {
            throw new ServiceVersionException(
                StringHelper.Format(/*Strings.AutodiscoverServiceIncompatibleWithRequestVersion*/ "autodiscover service is incompatible with requested versio, minimum versi supported is {0}",
                    AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService));
        }

        ////var smtpAddresses: string[] = []// new List<string>(userSmtpAddresses);
        ////if (userSmtpAddresses)
        ////    userSmtpAddresses.forEach((s) => smtpAddresses.push(s));
        ////else throw new Error("invalid input");
        ////var settingNames: UserSettingName[] = [];// List<UserSettingName>(userSettingNames);
        ////if(userSettingNames)
        ////userSettingNames.forEach((s)=> settingNames.push());

        return this.GetUserSettings(userSmtpAddresses, userSettingNames); //calls getsettings
    }
    InternalGetDomainSettings(domains: string[], settings: DomainSettingName[], requestedVersion: ExchangeVersion, autodiscoverUrlRef: IRefParam<Uri>, thisref: AutodiscoverService, currentHop: number = 0): Promise<GetDomainSettingsResponseCollection> {

        // The response to GetDomainSettings can be a redirection. Execute GetDomainSettings until we get back 
        // a valid response or we've followed too many redirections.
        currentHop++;
        if (currentHop > AutodiscoverService.AutodiscoverMaxRedirections) {
            this.TraceMessage(
                TraceFlags.AutodiscoverConfiguration,
                StringHelper.Format("Maximum number of redirection hops {0} exceeded", AutodiscoverService.AutodiscoverMaxRedirections));

            throw new AutodiscoverLocalException(Strings.AutodiscoverCouldNotBeLocated);
        }
        //BUG  - Typescript bug, reference for "this" inside multiple layers of IPromise points to global this object;
        //(may be not) - this functional is called as delegate under Promise chaining, loss poiters to this.
        //var request: GetUserSettingsRequest = new GetUserSettingsRequest(this, autodiscoverUrlRef.refvalue);
        var request = new GetDomainSettingsRequest(thisref, autodiscoverUrlRef.getValue());
        request.Settings = settings;
        request.Domains = domains;
        return <any>request.Execute().then((response) => {
            // Did we get redirected?
            if (response.ErrorCode == AutodiscoverErrorCode.RedirectUrl && response.RedirectionUrl != null) {
                this.TraceMessage(
                    TraceFlags.AutodiscoverConfiguration,
                    StringHelper.Format("Request to {0} returned redirection to {1}", autodiscoverUrlRef.getValue().ToString(), response.RedirectionUrl.ToString()));

                // this url need be brought back to the caller.
                //
                autodiscoverUrlRef.setValue(response.RedirectionUrl);
                return this.InternalGetDomainSettings(domains, settings, requestedVersion, autodiscoverUrlRef, thisref, currentHop);
            }
            else {
                return response;
            }
        }, (err) => {

        });
    }
    private InternalGetLegacyUserSettings(emailAddress: string, requestedSettings: UserSettingName[]): Promise<GetUserSettingsResponse> {
        throw new Error("Not implemented.");
    }
    private InternalGetLegacyUserSettingsPrivate<Tsettings>(
        emailAddress: string, redirectionEmailAddresses: string[],
        currentHop: IRefParam<number>): Tsettings {
        throw new Error("Not implemented.");
    }
    InternalGetSoapUserSettings(smtpAddress: string, requestedSettings: UserSettingName[]): Promise<GetUserSettingsResponse> {
        var smtpAddresses: string[] = [];
        smtpAddresses.push(smtpAddress);

        var redirectionEmailAddresses: string[] = [];
        redirectionEmailAddresses.push(smtpAddress.toLowerCase());
        return this.InternalGetSoapUserSettingsRecursive(smtpAddresses, requestedSettings, redirectionEmailAddresses);
    }
    InternalGetSoapUserSettingsRecursive(smtpAddresses: string[], requestedSettings: UserSettingName[],
        redirectionEmailAddresses: string[] = [], currentHop: number = 0): Promise<GetUserSettingsResponse> {

        currentHop++;
        //if (currentHop > AutodiscoverService.AutodiscoverMaxRedirections)
        //    throw new AutodiscoverLocalException(Strings.AutodiscoverCouldNotBeLocated);

        return this.GetUserSettings(smtpAddresses, requestedSettings)
            .then<GetUserSettingsResponse>((resp) => {
                var response = resp.Responses[0];
                switch (response.ErrorCode) {
                    case AutodiscoverErrorCode.RedirectAddress:
                        this.TraceMessage(
                            TraceFlags.AutodiscoverResponse,
                            StringHelper.Format("Autodiscover service returned redirection email address '{0}'.", response.RedirectTarget));

                        smtpAddresses.splice(0);
                        smtpAddresses.push(response.RedirectTarget.toLowerCase());
                        this.Url = null;
                        this.Domain = null;

                        // If this email address was already tried, we may have a loop
                        // in SCP lookups. Disable consideration of SCP records.
                        this.ThrowIfDuplicateRedirection(response.RedirectTarget, { getValue: () => redirectionEmailAddresses });
                        return this.InternalGetSoapUserSettingsRecursive(smtpAddresses, requestedSettings, redirectionEmailAddresses, currentHop);
                        break;

                    case AutodiscoverErrorCode.RedirectUrl:
                        this.TraceMessage(
                            TraceFlags.AutodiscoverResponse,
                            StringHelper.Format("Autodiscover service returned redirection URL '{0}'.", response.RedirectTarget));

                        this.Url = this.Credentials.AdjustUrl(new Uri(response.RedirectTarget));
                        return this.InternalGetSoapUserSettingsRecursive(smtpAddresses, requestedSettings, redirectionEmailAddresses, currentHop);
                        break;

                    case AutodiscoverErrorCode.NoError:
                    default:
                        return response;
                    //return IPromise.as(response);
                }
            }, (err) => {
                throw err;
            });


    }
    InternalGetUserSettings(smtpAddresses: string[], settings: UserSettingName[],
        requestedVersion: ExchangeVersion, autodiscoverUrlRef: IRefParam<Uri>, thisref: AutodiscoverService, currentHop: number = 0): Promise<GetUserSettingsResponseCollection> {

        // The response to GetUserSettings can be a redirection. Execute GetUserSettings until we get back
        // a valid response or we've followed too many redirections.
        //this function is called recursively for that
        currentHop++;
        if (currentHop > AutodiscoverService.AutodiscoverMaxRedirections) {
            this.TraceMessage(
                TraceFlags.AutodiscoverConfiguration,
                StringHelper.Format("Maximum number of redirection hops {0} exceeded", AutodiscoverService.AutodiscoverMaxRedirections));

            throw new AutodiscoverLocalException("Autodiscover settings could not be located, max redirection reached"/*Strings.AutodiscoverCouldNotBeLocated*/);
        }
        //BUG  - Typescript bug, reference for "this" inside multiple layers of IPromise points to global this object;
        //(may be not) - this functional is called as delegate under Promise chaining, loss poiters to this.
        //var request: GetUserSettingsRequest = new GetUserSettingsRequest(this, autodiscoverUrlRef.refvalue);
        var request: GetUserSettingsRequest = new GetUserSettingsRequest(thisref, autodiscoverUrlRef.getValue());

        request.SmtpAddresses = smtpAddresses;
        request.Settings = settings;
        return <any>request.Execute().then((response) => {
            // Did we get redirected?
            if (response.ErrorCode == AutodiscoverErrorCode.RedirectUrl && response.RedirectionUrl != null) {
                this.TraceMessage(
                    TraceFlags.AutodiscoverConfiguration,
                    StringHelper.Format("Request to {0} returned redirection to {1}", autodiscoverUrlRef.getValue().ToString(), response.RedirectionUrl.ToString()));

                // this url need be brought back to the caller.
                //
                autodiscoverUrlRef.setValue(response.RedirectionUrl);
                return this.InternalGetUserSettings(smtpAddresses, settings, requestedVersion, autodiscoverUrlRef, thisref, currentHop);
            }
            else {
                return response;
            }
        }, (err) => {

        });
    }
    //PrepareHttpWebRequestForUrl(url: Uri): Data.IEwsHttpWebRequest{ throw new Error("AutodiscoverService.ts - PrepareHttpWebRequestForUrl : Not implemented.");}
    //ProcessHttpErrorResponse(httpWebResponse: Data.IEwsHttpWebResponse, webException: any): any{ throw new Error("AutodiscoverService.ts - ProcessHttpErrorResponse : Not implemented.");}
    ProcessHttpErrorResponse(httpWebResponse: XMLHttpRequest, webException: any): any { /*throw new Error("Not implemented.")*/; }
    TraceResponse(response: XMLHttpRequest, memoryStream: any): any {
        //todo: implement tracing

        //this.ProcessHttpResponseHeaders(TraceFlags.AutodiscoverResponseHttpHeaders, response);

        //if (this.TraceEnabled) {
        //    if (!StringHelper.IsNullOrEmpty(response.ContentType) &&
        //        (response.ContentType.StartsWith("text/", StringComparison.OrdinalIgnoreCase) ||
        //        response.ContentType.StartsWith("application/soap", StringComparison.OrdinalIgnoreCase))) {
        //        this.TraceXml(TraceFlags.AutodiscoverResponse, memoryStream);
        //    }
        //    else {
        //        this.TraceMessage(TraceFlags.AutodiscoverResponse, "Non-textual response");
        //    }
        //}
    }
    TryGetAutodiscoverEndpointUrl(host: string, url: IOutParam<Uri>): Promise<boolean> {
        url.outValue = null;

        var endpointsOut: IOutParam<AutodiscoverEndpoints> = { outValue: AutodiscoverEndpoints.None };
        return this.TryGetEnabledEndpointsForHost({ getValue: () => host, setValue: (value) => host = value }, endpointsOut).then((value) => {
            if (value) {
                url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapHttpsUrl, host));
                var endpoints = endpointsOut.outValue;
                // Make sure that at least one of the non-legacy endpoints is available.
                if (((endpoints & AutodiscoverEndpoints.Soap) != AutodiscoverEndpoints.Soap) &&
                    ((endpoints & AutodiscoverEndpoints.WsSecurity) != AutodiscoverEndpoints.WsSecurity) &&
                    ((endpoints & AutodiscoverEndpoints.WSSecuritySymmetricKey) != AutodiscoverEndpoints.WSSecuritySymmetricKey) &&
                    ((endpoints & AutodiscoverEndpoints.WSSecurityX509Cert) != AutodiscoverEndpoints.WSSecurityX509Cert) &&
                    ((endpoints & AutodiscoverEndpoints.OAuth) != AutodiscoverEndpoints.OAuth)) {
                    this.TraceMessage(
                        TraceFlags.AutodiscoverConfiguration,
                        StringHelper.Format("No Autodiscover endpoints are available  for host {0}", host));

                    return false;
                }

                // If we have WLID credentials, make sure that we have a WS-Security endpoint
                return true;
                if (this.Credentials instanceof WindowsLiveCredentials) {
                    if ((endpoints & AutodiscoverEndpoints.WsSecurity) != AutodiscoverEndpoints.WsSecurity) {
                        this.TraceMessage(
                            TraceFlags.AutodiscoverConfiguration,
                            StringHelper.Format("No Autodiscover WS-Security endpoint is available for host {0}", host));

                        return false;
                    }
                    else {
                        url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapWsSecurityHttpsUrl, host));
                    }
                }
                else if (this.Credentials instanceof PartnerTokenCredentials) {
                    if ((endpoints & AutodiscoverEndpoints.WSSecuritySymmetricKey) != AutodiscoverEndpoints.WSSecuritySymmetricKey) {
                        this.TraceMessage(
                            TraceFlags.AutodiscoverConfiguration,
                            StringHelper.Format("No Autodiscover WS-Security/SymmetricKey endpoint is available for host {0}", host));

                        return false;
                    }
                    else {
                        url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapWsSecuritySymmetricKeyHttpsUrl, host));
                    }
                }
                else if (this.Credentials instanceof X509CertificateCredentials) {
                    if ((endpoints & AutodiscoverEndpoints.WSSecurityX509Cert) != AutodiscoverEndpoints.WSSecurityX509Cert) {
                        this.TraceMessage(
                            TraceFlags.AutodiscoverConfiguration,
                            StringHelper.Format("No Autodiscover WS-Security/X509Cert endpoint is available for host {0}", host));

                        return false;
                    }
                    else {
                        url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapWsSecurityX509CertHttpsUrl, host));
                    }
                }
                else if (this.Credentials instanceof OAuthCredentials) {
                    // If the credential is OAuthCredentials, no matter whether we have
                    // the corresponding x-header, we will go with OAuth.
                    url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapHttpsUrl, host));
                }

                return true;
            }
            else {
                this.TraceMessage(
                    TraceFlags.AutodiscoverConfiguration,
                    StringHelper.Format("No Autodiscover endpoints are available for host {0}", host));

                return false;
            }
        }, (err) => { throw err; });
    }

    private TryGetEnabledEndpointsForHost(host: IRefParam<string>, endpoints: IOutParam<AutodiscoverEndpoints>, currentHop: number = 0): Promise<boolean> {

        this.TraceMessage(
            TraceFlags.AutodiscoverConfiguration,
            StringHelper.Format("Determining which endpoints are enabled for host {0}", host.getValue()));
        currentHop++;

        // We may get redirected to another host. And therefore need to limit the number
        // of redirections we'll tolerate.
        if (currentHop > AutodiscoverService.AutodiscoverMaxRedirections) {
            this.TraceMessage(
                TraceFlags.AutodiscoverConfiguration,
                StringHelper.Format("Maximum number of redirection hops {0} exceeded", AutodiscoverService.AutodiscoverMaxRedirections));

            throw new AutodiscoverLocalException("Maximum redirection hop reached"/*Strings.MaximumRedirectionHopsExceeded*/);
        }

        var autoDiscoverUrl: string = StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, host.getValue());

        endpoints.outValue = AutodiscoverEndpoints.None;

        var xhrOptions: IXHROptions = {
            type: "GET",
            url: autoDiscoverUrl,
        };


        //todo - optimize code, need to apply logic in failed errors as 401 go to onerror of xhr;
        return this.XHRApi.xhr(xhrOptions)
            .then<boolean>((response: XMLHttpRequest) => {
                if (response != null) {
                    var redirectUrl: any = null;;
                    if ( /*"returns false aleways"*/ this.TryGetRedirectionResponse(response, { outValue: redirectUrl })) {
                        this.TraceMessage(
                            TraceFlags.AutodiscoverConfiguration,
                            StringHelper.Format("Host returned redirection to host '{0}'", redirectUrl.Host));

                        host.setValue(UriHelper.getHost(redirectUrl));
                    } else {
                        endpoints.outValue = this.GetEndpointsFromHttpResponse(response);

                        this.TraceMessage(
                            TraceFlags.AutodiscoverConfiguration,
                            StringHelper.Format("Host returned enabled endpoint flags: {0}", EnumHelper.ToString(AutodiscoverEndpoints, endpoints.outValue)));
                        return true;
                    }
                } else {
                    return false;
                }

            }, (resperr: XMLHttpRequest) => {

                if (resperr.status === 0) {
                    //catch (IOException ex)
                    this.TraceMessage(
                        TraceFlags.AutodiscoverConfiguration,
                        StringHelper.Format("I/O error: {0}", "unable to connect"));
                } else if (resperr.status === 401) {
                    endpoints.outValue = this.GetEndpointsFromHttpResponse(resperr);

                    this.TraceMessage(
                        TraceFlags.AutodiscoverConfiguration,
                        StringHelper.Format("Host returned enabled endpoint flags: {0}", EnumHelper.ToString(AutodiscoverEndpoints, endpoints.outValue)));
                    return true;
                } else {
                    //catch (WebException ex)
                    this.TraceMessage(
                        TraceFlags.AutodiscoverConfiguration,
                        StringHelper.Format("Request error: {0}, {1}", resperr.status, resperr.statusText));

                    //todo: possible?
                    // The exception response factory requires a valid HttpWebResponse,
                    // but there will be no web response if the web request couldn't be
                    // actually be issued (e.g. due to DNS error).
                    //if (ex.Response != null) {
                    //    response = this.HttpWebRequestFactory.CreateExceptionResponse(ex);
                    //}
                }
                return false;
            });

    }
    ThrowIfDuplicateRedirection(emailAddress: string, redirectionEmailAddresses: IRefParam<string[]>): void {

        // SMTP addresses are case-insensitive so entries are converted to lower-case.
        emailAddress = emailAddress.toLowerCase();

        if (redirectionEmailAddresses.getValue().indexOf(emailAddress) >= 0) {
            //this.EnableScpLookup = false;
            throw new AutodiscoverLocalException("Detected redirection loop, Redirection address already tried");
        }
        else {
            var oldcount = redirectionEmailAddresses.getValue().length;
            redirectionEmailAddresses.getValue().push(emailAddress);
            if (oldcount === redirectionEmailAddresses.getValue().length) {
                throw new Error("AutodiscoverService.ts - error in ref param logic, need to fix array type getter");
            }
            EwsLogging.Assert(false,
                "AutodiscoverService.ts - ThrowIfDuplicateRedirection",
                "AutodiscoverService.ts - array getter worked:), remove this message and throw statement");
        }

    }

    //TryGetPartnerAccess(targetTenantDomain: string, partnerAccessCredentials: any, targetTenantAutodiscoverUrl: any): boolean{ throw new Error("AutodiscoverService.ts - TryGetPartnerAccess : Not implemented.");}
    TryGetRedirectionResponse(response: XMLHttpRequest, redirectUrl: IOutParam<Uri>): boolean {
        this.TraceMessage(TraceFlags.DebugMessage,
            "cant determine redirectionResponse, 302 redirect code does not work in browser xhr and in Node.js http response");


        //redirectUrl.outValue = null;
        //if (AutodiscoverRequest.IsRedirectionResponse(response)) {
        //    // Get the redirect location and verify that it's valid.
        //    var location = response.getResponseHeader("Location");//. [HttpResponseHeader.Location];

        //    if (!StringHelper.IsNullOrEmpty(location)) {
        //        try
        //        {
        //            redirectUrl.outValue = location;

        //            // Check if URL is SSL and that the path matches.
        //            var match =  LegacyPathRegex.Match(redirectUrl.AbsolutePath);
        //            if ((redirectUrl.Scheme == UriHelper.UriSchemeHttps) &&
        //                match.Success) {
        //                this.TraceMessage(
        //                    TraceFlags.AutodiscoverConfiguration,
        //                    StringHelper.Format("Redirection URL found: '{0}'", redirectUrl));

        //                return true;
        //            }
        //        }
        //        catch (UriFormatException) {
        //            this.TraceMessage(
        //                TraceFlags.AutodiscoverConfiguration,
        //                StringHelper.Format("Invalid redirection URL was returned: '{0}'", location));
        //            return false;
        //        }
        //    }
        //}

        return false;
    }
    //TryLastChanceHostRedirection(emailAddress: string, redirectionUrl: string, settings: any): boolean{ throw new Error("AutodiscoverService.ts - TryLastChanceHostRedirection : Not implemented.");}
    //WriteLegacyAutodiscoverRequest(emailAddress: string, settings: ConfigurationSettingsBase, writer: any): any{ throw new Error("AutodiscoverService.ts - WriteLegacyAutodiscoverRequest : Not implemented.");}
}

//ref: converted to delegate type interface
export interface GetSettingsMethod<TGetSettingsResponseCollection, TSettingName> {
    (smtpAddresses: string[], settings: TSettingName[], requestedVersion: ExchangeVersion, autodiscoverUrl: IRefParam<Uri>, thisref: AutodiscoverService): Promise<TGetSettingsResponseCollection>
}
//class GetSettingsMethod<TGetSettingsResponseCollection, TSettingName> extends System.MulticastDelegate {
//    BeginInvoke(smtpAddresses: System.Collections.Generic.List<string>, settings: System.Collections.Generic.List<T>, requestedVersion: Data.ExchangeVersion, autodiscoverUrl: any, callback: System.AsyncCallback, object: any): System.IAsyncResult { throw new Error("AutodiscoverService.ts - BeginInvoke : Not implemented."); }
//    EndInvoke(autodiscoverUrl: any, result: System.IAsyncResult): TGetSettingsResponseCollection { throw new Error("AutodiscoverService.ts - EndInvoke : Not implemented."); }
//    Invoke(smtpAddresses: System.Collections.Generic.List<string>, settings: System.Collections.Generic.List<T>, requestedVersion: Data.ExchangeVersion, autodiscoverUrl: any): TGetSettingsResponseCollection { throw new Error("AutodiscoverService.ts - Invoke : Not implemented."); }
//}


export interface AutodiscoverRedirectionUrlValidationCallback {
    (redirectionUrl: string): boolean;
}
//class AutodiscoverRedirectionUrlValidationCallback extends System.MulticastDelegate {
//    BeginInvoke(redirectionUrl: string, callback: System.AsyncCallback, object: any): System.IAsyncResult { throw new Error("AutodiscoverServiceDelegates.ts - BeginInvoke : Not implemented."); }
//    EndInvoke(result: System.IAsyncResult): boolean { throw new Error("AutodiscoverServiceDelegates.ts - EndInvoke : Not implemented."); }
//    Invoke(redirectionUrl: string): boolean { throw new Error("AutodiscoverServiceDelegates.ts - Invoke : Not implemented."); }
//}
export class ComparisonHelpers {
    CaseInsensitiveContains(collection: any[] /*System.Collections.ICollection*/, match: string): boolean { throw new Error("ComparisonHelpers.ts - CaseInsensitiveContains : Not implemented."); }
}



export class DirectoryHelper {
    Service: ExchangeServiceBase;
    //private service: ExchangeServiceBase;
    private static AutodiscoverMaxScpHops: number = 10;
    private static ScpUrlGuidString: string = "77378F46-2C66-4aa9-A6A6-3E7A48B19596";
    private static ScpPtrGuidString: string = "67661d7F-8FC4-4fa7-BFAC-E1D7794C1F68";
    private static ScpFilterString: string = "(&(objectClass=serviceConnectionPoint)(|(keywords=67661d7F-8FC4-4fa7-BFAC-E1D7794C1F68)(keywords=77378F46-2C66-4aa9-A6A6-3E7A48B19596)))";

    GetAutodiscoverScpUrlsForDomain(domainName: string): string[] { throw new Error("DirectoryHelper.ts - GetAutodiscoverScpUrlsForDomain : Not implemented."); }
    GetScpUrlList(domainName: string, ldapPath: string, maxHops: any): string[] { throw new Error("DirectoryHelper.ts - GetScpUrlList : Not implemented."); }
    GetSiteName(): string { throw new Error("DirectoryHelper.ts - GetSiteName : Not implemented."); }
    TraceMessage(message: string): any { throw new Error("DirectoryHelper.ts - TraceMessage : Not implemented."); }
}




export class DocumentSharingLocation {
    ServiceUrl: string;
    LocationUrl: string;
    DisplayName: string;
    SupportedFileExtensions: string[];// System.Collections.Generic.IEnumerable<string>;
    ExternalAccessAllowed: boolean;
    AnonymousAccessAllowed: boolean;
    CanModifyPermissions: boolean;
    IsDefault: boolean;
    private serviceUrl: string;
    private locationUrl: string;
    private displayName: string;
    private supportedFileExtensions: string[];// System.Collections.Generic.IEnumerable<string>;
    private externalAccessAllowed: boolean;
    private anonymousAccessAllowed: boolean;
    private canModifyPermissions: boolean;
    private isDefault: boolean;
    //LoadFromXml(reader: EwsXmlReader): DocumentSharingLocation { throw new Error("DocumentSharingLocation.ts - LoadFromXml : Not implemented."); }
    static LoadFromJson(obj: any): DocumentSharingLocation { throw new Error("this was skipped at dev time, fix this"); }

}

export class DocumentSharingLocationCollection {
    Entries: DocumentSharingLocation[] = [];//System.Collections.Generic.List<DocumentSharingLocation>;
    /**@internal */
    static LoadFromXml(reader: EwsXmlReader): DocumentSharingLocationCollection { throw new Error("Not implemented. Depricated, use LoadFromJson"); }
    static LoadFromJson(obj: any): DocumentSharingLocationCollection {
        var instance = new DocumentSharingLocationCollection();

        var element = XmlElementNames.AlternateMailbox;
        var responses = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];

        for (var i = 0; i < responses.length; i++) {
            instance.Entries.push(responses[i]); //skipped processing individual objects in collection against DocumentSharingLocation, fix if there is parsing error later
            //DocumentSharingLocation.LoadFromJson(responses[i]);
            //instance.Entries.push(responses);
        }

        return instance;

    }
}

export class DomainSettingError {
    ErrorCode: AutodiscoverErrorCode;
    ErrorMessage: string;
    SettingName: string;
    //private errorCode: AutodiscoverErrorCode;
    //private errorMessage: string;
    //private settingName: string;
    LoadFromObject(obj: any): void {
        var errorstring: string = obj[XmlElementNames.ErrorCode];
        this.ErrorCode = AutodiscoverErrorCode[errorstring];
        this.ErrorMessage = obj[XmlElementNames.ErrorMessage];
        this.SettingName = obj[XmlElementNames.SettingName];
    }
    /**@internal */
    LoadFromXml(reader: EwsXmlReader): void {
        var parent = reader.CurrentNode;
        do {
            reader.Read();

            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.ErrorCode:
                        var errorstring = reader.ReadElementValue();
                        this.ErrorCode = AutodiscoverErrorCode[errorstring];
                        break;
                    case XmlElementNames.ErrorMessage:
                        this.ErrorMessage = reader.ReadElementValue();
                        break;
                    case XmlElementNames.SettingName:
                        this.SettingName = reader.ReadElementValue();
                        break;
                }
            }
        }
        while (reader.HasRecursiveParentNode(parent, parent.localName));
        reader.SeekLast();// fix xml treewalker to go back last node, next do..while loop will come back to current node.
    }

}

export class ProtocolConnection {
    EncryptionMethod: string;
    Hostname: string;
    Port: number;
    //private encryptionMethod: string;
    //private hostname: string;
    //private port: number;
    //LoadFromXml(reader: EwsXmlReader): ProtocolConnection { throw new Error("ProtocolConnection.ts - LoadFromXml : Not implemented."); }
}

export class ProtocolConnectionCollection {
    Connections: ProtocolConnection[] = [];//System.Collections.Generic.List<ProtocolConnection>;
    //private connections: ProtocolConnection[];//System.Collections.Generic.List<ProtocolConnection>;
    constructor() { }
    /**@internal */
    static LoadFromXml(reader: EwsXmlReader): ProtocolConnectionCollection { throw new Error("Not implemented. - depricated for JS api, use LoadFromJson"); }
    static LoadFromJson(obj: any): ProtocolConnectionCollection {
        var instance = new ProtocolConnectionCollection();

        var element = XmlElementNames.ProtocolConnection;
        var responses = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];

        for (var i = 0; i < responses.length; i++) {
            instance.Connections.push(responses[i]);
            //var response: = this.CreateResponseInstance();
            //response.LoadFromObject(responses[i], this.GetResponseInstanceXmlElementName());
            //instance.Urls.push(responses);
        }

        return instance;
    }

}

export class UserSettingError {
    ErrorCode: AutodiscoverErrorCode;
    ErrorMessage: string;
    SettingName: string;
    /**@internal */
    LoadFromXml(reader: EwsXmlReader): any {
        var parent = reader.CurrentNode;
        do {
            reader.Read();

            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.ErrorCode:
                        var errorstring = reader.ReadElementValue();
                        this.ErrorCode = AutodiscoverErrorCode[errorstring];
                        break;
                    case XmlElementNames.ErrorMessage:
                        this.ErrorMessage = reader.ReadElementValue();
                        break;
                    case XmlElementNames.SettingName:
                        this.SettingName = reader.ReadElementValue();
                        break;
                }
            }
        }
        while (reader.HasRecursiveParentNode(parent, parent.localName));
        reader.SeekLast();// fix xml treewalker to go back last node, next do..while loop will come back to current node.
    }

    LoadFromJson(obj: any): any {
        var errorstring: string = obj[XmlElementNames.ErrorCode];
        this.ErrorCode = AutodiscoverErrorCode[errorstring];
        this.ErrorMessage = obj[XmlElementNames.ErrorMessage];
        this.SettingName = obj[XmlElementNames.SettingName];
    }
}

export class WebClientUrl {
    AuthenticationMethods: string;
    Url: string;
    //private authenticationMethods: string;
    //private url: string;
    static LoadFromJson(obj: any): WebClientUrl {
        var webClientUrl = new WebClientUrl();
        webClientUrl.AuthenticationMethods = obj[XmlElementNames.AuthenticationMethods];
        webClientUrl.Url = obj[XmlElementNames.Url];
        return webClientUrl;
    }
    /**@internal */
    static LoadFromXml(reader: EwsXmlReader): WebClientUrl {
        var webClientUrl = new WebClientUrl();
        var parent = reader.CurrentNode;
        do {
            reader.Read();

            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.AuthenticationMethods:
                        webClientUrl.AuthenticationMethods = reader.ReadElementValue();
                        break;
                    case XmlElementNames.Url:
                        webClientUrl.Url = reader.ReadElementValue();
                        break;
                }
            }
        }
        while (reader.HasRecursiveParentNode(parent, parent.localName));
        //reader.SeekLast();// fix xml treewalker to go back last node, next do..while loop will come back to current node.

        return webClientUrl;
    }
}

export class WebClientUrlCollection {
    Urls: WebClientUrl[] = [];// new Array<WebClientUrl>();// System.Collections.Generic.List<WebClientUrl>;
    //private urls: WebClientUrl[];// System.Collections.Generic.List<WebClientUrl>;
    static LoadFromJson(obj: any): WebClientUrlCollection {
        var instance = new WebClientUrlCollection();

        var element = XmlElementNames.WebClientUrl;
        var responses = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];

        for (var i = 0; i < responses.length; i++) {
            instance.Urls.push(responses[i]);
            //var response: = this.CreateResponseInstance();
            //response.LoadFromObject(responses[i], this.GetResponseInstanceXmlElementName());
            //instance.Urls.push(responses);
        }

        return instance;
    }
    /**@internal */
    static LoadFromXml(reader: EwsXmlReader): WebClientUrlCollection {
        var instance = new WebClientUrlCollection();
        var parent = reader.CurrentNode;
        do {
            reader.Read();

            if ((reader.NodeType == 1/*Node.ELEMENT_NODE*/) && (reader.LocalName == XmlElementNames.WebClientUrl)) {
                instance.Urls.push(WebClientUrl.LoadFromXml(reader));
            }
        }
        while (reader.HasRecursiveParentNode(parent, parent.localName));
        reader.SeekLast();// fix xml treewalker to go back last node, next do..while loop will come back to current node.

        return instance;
    }
}


//todo: not converted initially - pending
//export = BasicAuthModuleForUTF8;


export abstract class ExchangeCredentials {
    //NeedSignature: boolean;
    static WsSecurityPathSuffix: string = "/wssecurity";

    UserName: string = null;
    /** Hiding password field from console.log */
    getPassword: () => string;
    setPassword: (value: string) => void;

    get Password(): string { return this.getPassword(); }
    set Password(value: string) { this.setPassword(value); }

    constructor();
    constructor(userName: string, password: string)
    constructor(userName: string = null, password: string = null) {
        if (arguments.length > 0 && (StringHelper.IsNullOrEmpty(userName) || StringHelper.IsNullOrEmpty(password))) {
            throw new Error("ExchangeCredentials.ctor, must provide username and password value.")
        }
        this.UserName = userName;
        var pwd = password;
        this.setPassword = (value) => { pwd = value; };
        this.getPassword = () => { return pwd; }
        //this.Password = password;
    }

    AdjustUrl(url: Uri): Uri { return new Uri(ExchangeCredentials.GetUriWithoutSuffix(url)); }
    EmitExtraSoapHeaderNamespaceAliases(writer: any /*System.Xml.XmlWriter*/): void { /*implemented by derived classes*/ }
    static GetUriWithoutSuffix(url: Uri): string {
        var absoluteUri: string = url.AbsoluteUri;
        //ref: can not use WSSecurityBasedCredentials.WsSecurityPathSuffix, creates circular reference.
        var index = absoluteUri.toUpperCase().indexOf(/*WSSecurityBasedCredentials*/ExchangeCredentials.WsSecurityPathSuffix.toUpperCase());//, StringComparison.OrdinalIgnoreCase);
        if (index != -1) {
            return absoluteUri.substring(0, index);
        }

        return absoluteUri;
    }
    //PreAuthenticate(): any{ throw new Error("ExchangeCredentials.ts - PreAuthenticate : Not implemented.");}
    PrepareWebRequest(request: IXHROptions /*IEwsHttpWebRequest*/): void {
        request.headers["Authorization"] = "Basic " + base64Helper.btoa(this.UserName + ":" + this.Password);
    }
    SerializeExtraSoapHeaders(writer: any /*System.Xml.XmlWriter*/, webMethodName: string): void { /*implemented by derived classes*/ }
    //SerializeWSSecurityHeaders(writer: System.Xml.XmlWriter): any{ throw new Error("ExchangeCredentials.ts - SerializeWSSecurityHeaders : Not implemented.");}
    //Sign(memoryStream: any): any{ throw new Error("ExchangeCredentials.ts - Sign : Not implemented.");}
}
export class ClientCertificateCredentials extends ExchangeCredentials {
    ClientCertificates: /*System.Security.Cryptography.X509Certificates.X509CertificateCollection*/any;
    private clientCertificates: /*System.Security.Cryptography.X509Certificates.X509CertificateCollection*/any;
    PrepareWebRequest(request: /*IEwsHttpWebRequest*/any): any { throw new Error("ClientCertificateCredentials.ts - PrepareWebRequest : Not implemented."); }
}
export class OAuthCredentials extends ExchangeCredentials {
    private static BearerAuthenticationType: string = "Bearer";
    private token: string = null;
    private credentials: any = null; /*System.Net.ICredentials*/
    private static validTokenPattern: RegExp = new RegExp("^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$");

    constructor(token: string);
    constructor(token: string, verbatim: boolean);
    constructor(token: string, verbatim: boolean = false) {
        super();

        EwsUtilities.ValidateParam(token, "token");

        var rawToken: string;
        if (verbatim) {
            rawToken = token;
        }
        else {
            var whiteSpacePosition: number = token.indexOf(' ');
            if (whiteSpacePosition == -1) {
                rawToken = token;
            }
            else {
                var authType: string = token.substring(0, whiteSpacePosition);
                if (StringHelper.Compare(authType, OAuthCredentials.BearerAuthenticationType, true) != 0) {
                    throw new Error(Strings.InvalidAuthScheme);//ArgumentException
                }

                rawToken = token.substring(whiteSpacePosition + 1);
            }

            if (!OAuthCredentials.validTokenPattern.test(rawToken)) {
                throw new Error(Strings.InvalidOAuthToken);//ArgumentException
            }
        }

        this.token = OAuthCredentials.BearerAuthenticationType + " " + rawToken;
    }

    PrepareWebRequest(request: IXHROptions /*IEwsHttpWebRequest*/): void {
        request.headers["Authorization"] = this.token;
    }
}
export class WebCredentials extends ExchangeCredentials {
    // taken care by ExchangeCredentials
    //Credentials: /*System.Net.ICredentials*/any;
    //private credentials: /*System.Net.ICredentials*/any;
    //AdjustUrl(url: Uri): Uri { throw new Error("WebCredentials.ts - AdjustUrl : Not implemented."); }
    //PrepareWebRequest(request: IEwsHttpWebRequest): any { throw new Error("WebCredentials.ts - PrepareWebRequest : Not implemented.");}
}
export class WSSecurityBasedCredentials extends ExchangeCredentials {
    static WsAddressingHeadersFormat: string = "<wsa:Action soap:mustUnderstand='1'>http://schemas.microsoft.com/exchange/services/2006/messages/{0}</wsa:Action><wsa:ReplyTo><wsa:Address>http://www.w3.org/2005/08/addressing/anonymous</wsa:Address></wsa:ReplyTo><wsa:To soap:mustUnderstand='1'>{1}</wsa:To>";
    static WsSecurityHeaderFormat: string = "<wsse:Security soap:mustUnderstand='1'>  {0}</wsse:Security>";
    static WsuTimeStampFormat: string = "<wsu:Timestamp><wsu:Created>{0:yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'}</wsu:Created><wsu:Expires>{1:yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'}</wsu:Expires></wsu:Timestamp>";
    //static WsSecurityPathSuffix: string = "/wssecurity"; //ref: ----imp--- Moved to ExchangeCredentials to close cyclic dependency.

    SecurityToken: string;
    EwsUrl: Uri;
    static NamespaceManager: any;// System.Xml.XmlNamespaceManager;
    private addTimestamp: boolean;
    private securityToken: string;
    private ewsUrl: Uri;
    private static namespaceManager: any;//System.Xml.XmlNamespaceManager;
    AdjustUrl(url: Uri): Uri { throw new Error("WSSecurityBasedCredentials.ts - AdjustUrl : Not implemented."); }
    EmitExtraSoapHeaderNamespaceAliases(writer: any /*System.Xml.XmlWriter*/): any { throw new Error("WSSecurityBasedCredentials.ts - EmitExtraSoapHeaderNamespaceAliases : Not implemented."); }
    PreAuthenticate(): any { throw new Error("WSSecurityBasedCredentials.ts - PreAuthenticate : Not implemented."); }
    SerializeExtraSoapHeaders(writer: any/*System.Xml.XmlWriter*/, webMethodName: string): any { throw new Error("WSSecurityBasedCredentials.ts - SerializeExtraSoapHeaders : Not implemented."); }
    SerializeWSAddressingHeaders(xmlWriter: any /*System.Xml.XmlWriter*/, webMethodName: string): any { throw new Error("WSSecurityBasedCredentials.ts - SerializeWSAddressingHeaders : Not implemented."); }
    SerializeWSSecurityHeaders(xmlWriter: any /*System.Xml.XmlWriter*/): any { throw new Error("WSSecurityBasedCredentials.ts - SerializeWSSecurityHeaders : Not implemented."); }

}
export class PartnerTokenCredentials extends WSSecurityBasedCredentials {
    private static WsSecuritySymmetricKeyPathSuffix: string = "/wssecurity/symmetrickey";
    NeedSignature: boolean;
    private keyInfoNode: any;
    AdjustUrl(url: Uri): Uri { throw new Error("PartnerTokenCredentials.ts - AdjustUrl : Not implemented."); }
    //PrepareWebRequest(request: IEwsHttpWebRequest): any { throw new Error("PartnerTokenCredentials.ts - PrepareWebRequest : Not implemented.");}
    Sign(memoryStream: any): any { throw new Error("PartnerTokenCredentials.ts - Sign : Not implemented."); }
}
export class TokenCredentials extends WSSecurityBasedCredentials {
    //PrepareWebRequest(request: IEwsHttpWebRequest): any { throw new Error("TokenCredentials.ts - PrepareWebRequest : Not implemented.");}
}
export class WindowsLiveCredentials extends WSSecurityBasedCredentials {
    static XmlEncNamespace: string = "http://www.w3.org/2001/04/xmlenc#";
    static WindowsLiveSoapNamespacePrefix: string = "S";
    static RequestSecurityTokenResponseCollectionElementName: string = "RequestSecurityTokenResponseCollection";
    static RequestSecurityTokenResponseElementName: string = "RequestSecurityTokenResponse";
    static EncryptedDataElementName: string = "EncryptedData";
    static PpElementName: string = "pp";
    static ReqstatusElementName: string = "reqstatus";
    static SuccessfulReqstatus: string = "0x0";
    static XmlSignatureReference: string = "_EWSTKREF";
    TraceEnabled: boolean;
    TraceListener: ITraceListener;
    WindowsLiveUrl: Uri;
    IsAuthenticated: boolean;
    private windowsLiveId: string;
    private password: string;
    private windowsLiveUrl: Uri;
    private isAuthenticated: boolean;
    private traceEnabled: boolean;
    private traceListener: ITraceListener;
    static DefaultWindowsLiveUrl: Uri;
    EmitTokenRequest(uriForTokenEndpointReference: Uri): any { throw new Error("WindowsLiveCredentials.ts - EmitTokenRequest : Not implemented."); }
    MakeTokenRequestToWindowsLive(uriForTokenEndpointReference: Uri): any { throw new Error("WindowsLiveCredentials.ts - MakeTokenRequestToWindowsLive : Not implemented."); }
    //ParseWindowsLiveRSTResponseBody(rstResponse: EwsXmlReader): any { throw new Error("WindowsLiveCredentials.ts - ParseWindowsLiveRSTResponseBody : Not implemented."); }
    //PrepareWebRequest(request: IEwsHttpWebRequest): any { throw new Error("WindowsLiveCredentials.ts - PrepareWebRequest : Not implemented.");}
    ProcessTokenResponse(response: any): any { throw new Error("WindowsLiveCredentials.ts - ProcessTokenResponse : Not implemented."); }
    //ReadWindowsLiveRSTResponseHeaders(rstResponse: EwsXmlReader): any { throw new Error("WindowsLiveCredentials.ts - ReadWindowsLiveRSTResponseHeaders : Not implemented."); }
    TraceResponse(response: any, memoryStream: any): any { throw new Error("WindowsLiveCredentials.ts - TraceResponse : Not implemented."); }
    TraceWebException(e: any): any { throw new Error("WindowsLiveCredentials.ts - TraceWebException : Not implemented."); }
}
export class X509CertificateCredentials extends WSSecurityBasedCredentials {
    private static BinarySecurityTokenFormat: string = "<wsse:BinarySecurityToken EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary' ValueType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3' wsu:Id='{0}'>{1}</wsse:BinarySecurityToken>";
    private static KeyInfoClauseFormat: string = "<wsse:SecurityTokenReference xmlns:wsse='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd' ><wsse:Reference URI='#{0}' ValueType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3' /></wsse:SecurityTokenReference>";
    private static WsSecurityX509CertPathSuffix: string = "/wssecurity/x509cert";
    NeedSignature: boolean;
    private certificate: any;
    private keyInfoClause: any;
    AdjustUrl(url: Uri): Uri { throw new Error("X509CertificateCredentials.ts - AdjustUrl : Not implemented."); }
    //PrepareWebRequest(request: IEwsHttpWebRequest): any { throw new Error("X509CertificateCredentials.ts - PrepareWebRequest : Not implemented.");}
    Sign(memoryStream: any): any { throw new Error("X509CertificateCredentials.ts - Sign : Not implemented."); }
    ToString(): string { throw new Error("X509CertificateCredentials.ts - ToString : Not implemented."); }
}

export class WSSecurityUtilityIdSignedXml /*extends System.Security.Cryptography.Xml.SignedXml*/ {
    private document: /*System.Xml.XmlDocument*/any;
    private ids: /*System.Collections.Generic.Dictionary<TKey, TValue>*/any;
    private static nextId: number;
    private static commonPrefix: string;
    AddReference(xpath: string): any { throw new Error("WSSecurityUtilityIdSignedXml.ts - AddReference : Not implemented."); }
    GetIdElement(document: /*System.Xml.XmlDocument*/any, idValue: string): /*System.Xml.XmlElement*/any { throw new Error("WSSecurityUtilityIdSignedXml.ts - GetIdElement : Not implemented."); }
    GetUniqueId(): string { throw new Error("WSSecurityUtilityIdSignedXml.ts - GetUniqueId : Not implemented."); }
}
export class DnsClient {
	 private static Win32Success: number = 0;
	private static typeToDnsTypeMap: any /*LazyMember<System.Collections.Generic.Dictionary<System.Type, DnsRecordType>>*/;
	DnsQuer<T>(domain: string, dnsServerAddress: any /*System.Net.IPAddress*/): T[] /*System.Collections.Generic.List<T>*/{ throw new Error("DnsClient.ts - DnsQuer<T> : Not implemented.");}
}



//------------modulename->Microsoft.Exchange.WebServices.Dns------------


			
// export class DnsNativeMethods {
// 	 private static DNSAPI: string = "dnsapi.dll";
// 	AllocDnsServerList(dnsServerAddress: any /*System.Net.IPAddress*/): number{ throw new Error("DnsNativeMethods.ts - AllocDnsServerList : Not implemented.");}
// 	DnsQuery(pszName: string, wType: DnsRecordType, options: DnsQueryOptions, aipServers: number, ppQueryResults: number /*System.IntPtr&*/, pReserved: number): number{ throw new Error("DnsNativeMethods.ts - DnsQuery : Not implemented.");}
// 	//DnsQuery(domain: string, dnsServerAddress: any /*System.Net.IPAddress*/, recordType: DnsRecordType, ppQueryResults: number /*System.IntPtr&*/): number{ throw new Error("DnsNativeMethods.ts - DnsQuery : Not implemented.");}
// 	DnsRecordListFree(ptrRecords: number, freeType: FreeType): void{ throw new Error("DnsNativeMethods.ts - DnsRecordListFree : Not implemented.");}
// 	FreeDnsQueryResults(ptrRecords: number): void{ throw new Error("DnsNativeMethods.ts - FreeDnsQueryResults : Not implemented.");}
// }



// //------------modulename->Microsoft.Exchange.WebServices.Dns------------


			

/** @internal */
export class DnsRecordHeader {
	NextRecord: number;
	Name: string;
	RecordType: DnsRecordType;
	DataLength: number;
	Flags: number;
	Ttl: number;
	Reserved: number;
}



//------------modulename->Microsoft.Exchange.WebServices.Dns------------


			

/**@internal */
export class DnsRecord {
	RecordType: DnsRecordType;
	Name: string;
	TimeToLive: any /*System.TimeSpan*/;
	private name: string;
	private timeToLive: number;
	Load(header: DnsRecordHeader, dataPointer: number): void{ throw new Error("DnsRecord.ts - Load : Not implemented.");}
}



//------------modulename->Microsoft.Exchange.WebServices.Dns------------


			

/** @internal */
export class DnsSrvRecord extends DnsRecord {
	RecordType: DnsRecordType;
	NameTarget: string;
	Priority: number;
	Weight: number;
	Port: number;
	private target: string;
	private priority: number;
	private weight: number;
	private port: number;
	Load(header: DnsRecordHeader, dataPointer: number): void{ throw new Error("DnsSrvRecord.ts - Load : Not implemented.");}
}



//------------modulename->Microsoft.Exchange.WebServices.Dns------------


			


/**
 * Represents retention policy tag object.
 * 
 * @sealed
 */
export class RetentionPolicyTag {

	/**
	 * Retention policy tag display name.
	 */
	DisplayName: string = null;

	/**
	 * Retention Id.
	 */
	RetentionId: Guid = null;

	/**
	 * Retention period in time span.
	 */
	RetentionPeriod: number = 0;

	/**
	 * Retention type.
	 */
	Type: ElcFolderType = ElcFolderType.Calendar;

	/**
	 * Retention action.
	 */
	RetentionAction: RetentionActionType = RetentionActionType.None;

	/**
	 * Retention policy tag description.
	 */
	Description: string = null;

	/**
	 * Is this a visible tag?
	 */
	IsVisible: boolean = false;

	/**
	 * Is this a opted into tag?
	 */
	OptedInto: boolean = false;

	/**
	 * Is this an archive tag?
	 */
	IsArchive: boolean = false;

	/**
	 * Constructor
	 */
	constructor();
	/**
	 * Constructor for retention policy tag.
	 *
	 * @param   {string}   displayName       Display name.
	 * @param   {Guid}   retentionId       Retention id.
	 * @param   {number}   retentionPeriod   Retention period.
	 * @param   {ElcFolderType}   type              Retention folder type.
	 * @param   {RetentionActionType}   retentionAction   Retention action.
	 * @param   {boolean}   isVisible         Is visible.
	 * @param   {boolean}   optedInto         Opted into.
	 * @param   {boolean}   isArchive         Is archive tag.
	 */
	constructor(displayName: string, retentionId: Guid, retentionPeriod: number, type: ElcFolderType, retentionAction: RetentionActionType, isVisible: boolean, optedInto: boolean, isArchive: boolean);
	constructor(displayName?: string, retentionId?: Guid, retentionPeriod?: number, type?: ElcFolderType, retentionAction?: RetentionActionType, isVisible?: boolean, optedInto?: boolean, isArchive?: boolean) {

		if (arguments.length > 0) {
			this.DisplayName = displayName;
            this.RetentionId = retentionId;
            this.RetentionPeriod = retentionPeriod;
            this.Type = type;
            this.RetentionAction = retentionAction;
            this.IsVisible = isVisible;
            this.OptedInto = optedInto;
            this.IsArchive = isArchive;
		}
	}

	/**
     * @internal Loads object from XML.
     *
     * @param   {any}	jsObject		Json Object converted from XML.
     */
    static LoadFromXmlJsObject(jsObject: any): RetentionPolicyTag {
		let retentionPolicyTag: RetentionPolicyTag = new RetentionPolicyTag();

		for (let key in jsObject) {
			switch (key) {
				case XmlElementNames.DisplayName:
					retentionPolicyTag.DisplayName = jsObject[XmlElementNames.DisplayName];
					break;
				case XmlElementNames.RetentionId:
					retentionPolicyTag.RetentionId = new Guid(jsObject[XmlElementNames.RetentionId]);
					break;
				case XmlElementNames.RetentionPeriod:
					retentionPolicyTag.RetentionPeriod = Convert.toNumber(jsObject[XmlElementNames.RetentionPeriod]);
					break;
				case XmlElementNames.Type:
					retentionPolicyTag.Type = ElcFolderType[<string>jsObject[XmlElementNames.Type]];
					break;
				case XmlElementNames.RetentionAction:
					retentionPolicyTag.RetentionAction = RetentionActionType[<string>jsObject[XmlElementNames.RetentionAction]];
					break;
				case XmlElementNames.Description:
					retentionPolicyTag.Description = jsObject[XmlElementNames.Description];
					break;
				case XmlElementNames.IsVisible:
					retentionPolicyTag.IsVisible = Convert.toBool(jsObject[XmlElementNames.IsVisible]);
					break;
				case XmlElementNames.OptedInto:
					retentionPolicyTag.OptedInto = Convert.toBool(jsObject[XmlElementNames.OptedInto]);
					break;
				case XmlElementNames.IsArchive:
					retentionPolicyTag.IsArchive = Convert.toBool(jsObject[XmlElementNames.IsArchive]);
					break;
				default:
					break;
			}
		}

		return retentionPolicyTag;
	}
}
//make necessary changes if needed
//ref: 0.9 - extending Error as BlueBird throws error if promise is rejected without an Error object
export class Exception {//} extends Error { //ref: can not extend from Error. Typescript 1.8+ can not extend builtin objects property, it swallows inheriting properties see  https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work

    /** @internal  */
    message: string = '';
    //todo: implement stacktrace and source if needed - stack trace implemented by calling Error.captureStack
    stack: string = null;
    InnerException: Exception = null;

    get Message(): string {
        return this.message
    }
    /** @internal  needed for bluebird to work when rejected without inheriting from Error object. BlueBird checks for Error like object not Error subclass itself. */
    get name(): string {
        return 'Exception';
    }


    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string = "", innerException: Exception = null) {
        this.InnerException = innerException;
        this.message = message || "";

        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, this.constructor);
        } else {
            this.stack = (new Error(message)).stack;
        }

        //this.name = this.constructor.name; - no need to capture Name, can be infered by checking instance of Exception (or inheriting class)
    }

    /**
     * @override user JSON.stringify for now, todo: impelemtn real Exception tostring
     */
    toString() {
        let result = this.stack;
        try {
            result = result || JSON.stringify(this);
        }
        catch (e) { }

        return result;
    }
    ToString() {
        return this.toString();
    }
}
export class ArgumentException extends Exception {
    ParamName: string = null;
    constructor();
    constructor(message: string);
    constructor(message: string, paramName: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, paramName: string, innerException: Exception);
    constructor(message: string = null, paramNameOrInnerException: string | Exception = null, innerException: Exception = null) {
        super(message, innerException || (paramNameOrInnerException instanceof Exception ? paramNameOrInnerException : null));
        if (typeof paramNameOrInnerException === 'string') {
            this.ParamName = message
        }
    }
}

export class ArgumentNullException extends ArgumentException {
    constructor();
    constructor(paramName: string);
    constructor(paramName: string, message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, paramName: string, innerException: Exception);
    constructor(paramNameOrMessage: string = null, paramNameOrInnerException: string | Exception = null, innerException: Exception = null) {
        var argsLength = arguments.length;
        switch (argsLength) {
            case 1:
                super("Argument is Null", paramNameOrMessage);
                break;
            case 2:
                if (typeof paramNameOrInnerException === 'string') {
                    super(paramNameOrInnerException, paramNameOrMessage);
                }
                else {
                    super(paramNameOrMessage, paramNameOrInnerException);
                }
                break;
            default:
                super("Argument is Null");
                break;
        }
    }
}

export class ArgumentOutOfRangeException extends ArgumentException {
    actualValue: any;
    /**
     * Gets the value of the argument that caused the exception.
     */
    get ActualValue(): any { return this.actualValue; }
    constructor();
    constructor(paramName: string);
    constructor(paramName: string, message: string);
    constructor(message: string, innerException: Exception);
    constructor(paramName: string, actualValue: any, message: string);
    constructor(paramNameOrMessage?: string, messageOrActualValueOrException?: string | Exception, message: string = null) {
        //super((message || messageOrObjValueOrException instanceof Exception ? paramNameOrMessage : null);
        var argsLength = arguments.length;
        switch (argsLength) {
            case 0:
                super("ArgumentOutOfRangeException");
                break;
            case 1:
                super("ArgumentOutOfRangeException", paramNameOrMessage);
                break;
            case 2:
                if (typeof messageOrActualValueOrException === 'string') {
                    super(messageOrActualValueOrException, paramNameOrMessage);
                }
                else {
                    super(paramNameOrMessage, messageOrActualValueOrException);
                }
                break;
            case 3:
                super(message, paramNameOrMessage);
                this.actualValue = messageOrActualValueOrException;
                break;
            default:
                super("ArgumentOutOfRangeException");
                break;
        }
    }
}
export class InvalidOperationException extends Exception {
    ParamName: string = null;
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string = null, innerException: Exception = null) {
        super(message, innerException);        
    }
}
export class JsonSerializationNotImplementedException extends Exception { //System.Exception {
}
export class NotSupportedException extends Exception {
    ParamName: string = null;
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string = null, innerException: Exception = null) {
        super(message, innerException);        
    }
}
//class DnsException extends System.ComponentModel.Win32Exception {
//}
/**
 * Represents an error that occurs when a service operation fails locally (e.g. validation error).
 */
export class ServiceLocalException extends Exception {// extends System.Exception {

    /**
     * Initializes a new instance of **ServiceVersionException**.
     */
    constructor();
    /**
     * Initializes a new instance of **ServiceVersionException**.
     *
     * @param   {string}   message            The message that describes the error.
     */
    constructor(message: string);
    /**
     * Initializes a new instance of **ServiceVersionException**.
     *
     * @param   {string}   message            The message that describes the error.
     * @param   {Exception}   innerException     The exception that is the cause of the current exception.
     */
    constructor(message: string, innerException: Exception);
    constructor(message: string = null, innerException: Exception = null) {
        super(message, innerException);
    }
}
export class AutodiscoverLocalException extends ServiceLocalException {

    /**
     * Initializes a new instance of **AutodiscoverLocalException**.
     */
    constructor();
    /**
     * Initializes a new instance of **AutodiscoverLocalException**.
     *
     * @param   {string}   message            The message that describes the error.
     */
    constructor(message: string);
    /**
     * Initializes a new instance of **AutodiscoverLocalException**.
     *
     * @param   {string}   message            The message that describes the error.
     * @param   {Exception}   innerException     The exception that is the cause of the current exception.
     */
    constructor(message: string, innerException: Exception);
    constructor(message: string = null, innerException: Exception = null) {
        super(message, innerException);
    }
}
export class JsonDeserializationNotImplementedException extends ServiceLocalException {
}
export class ServiceJsonDeserializationException extends ServiceLocalException {
}

/**
 * Represents an error that occurs when a validation check fails.
 * 
 * @sealed
 */
export class ServiceValidationException extends ServiceLocalException {

    /**
     * Initializes a new instance of **ServiceValidationException**.
     */
    constructor();
    /**
     * Initializes a new instance of **ServiceValidationException**.
     *
     * @param   {string}   message            The message that describes the error.
     */
    constructor(message: string);
    /**
     * Initializes a new instance of **ServiceValidationException**.
     *
     * @param   {string}   message            The message that describes the error.
     * @param   {Exception}   innerException     The exception that is the cause of the current exception.
     */
    constructor(message: string, innerException: Exception);
    constructor(message: string = null, innerException: Exception = null) {
        super(message, innerException);
    }
}

/**
 * Represents an error that occurs when a request cannot be handled due to a service version mismatch.
 * 
 * @sealed
 */
export class ServiceVersionException extends ServiceLocalException {

    /**
     * Initializes a new instance of **ServiceVersionException**.
     */
    constructor();
    /**
     * Initializes a new instance of **ServiceVersionException**.
     *
     * @param   {string}   message            The message that describes the error.
     */
    constructor(message: string);
    /**
     * Initializes a new instance of **ServiceVersionException**.
     *
     * @param   {string}   message            The message that describes the error.
     * @param   {Exception}   innerException     The exception that is the cause of the current exception.
     */
    constructor(message: string, innerException: Exception);
    constructor(message: string = null, innerException: Exception = null) {
        super(message, innerException);
    }
}

export class ServiceXmlDeserializationException extends ServiceLocalException {
}
export class ServiceXmlSerializationException extends ServiceLocalException {

    /**
     * Initializes a new instance of **ServiceXmlSerializationException**.
     */
    constructor();
    /**
     * Initializes a new instance of **ServiceXmlSerializationException**.
     *
     * @param   {string}   message            The message that describes the error.
     */
    constructor(message: string);
    /**
     * Initializes a new instance of **ServiceXmlSerializationException**.
     *
     * @param   {string}   message            The message that describes the error.
     * @param   {Exception}   innerException     The exception that is the cause of the current exception.
     */
    constructor(message: string, innerException: Exception);
    constructor(message: string = null, innerException: Exception = null) {
        super(message, innerException);
    }
}
export class TimeZoneConversionException extends ServiceLocalException {
}
export class PropertyException extends ServiceLocalException {
    Name: string;
    //private name: string;
    constructor(message: string, name: string = null, innerException: Exception = null) {
        super(message, innerException);
        this.Name = name;
    }
}
export class ServiceObjectPropertyException extends PropertyException {
    PropertyDefinition: PropertyDefinitionBase;
    //private propertyDefinition: PropertyDefinitionBase;
    constructor(message: string, propertyDefinition: PropertyDefinitionBase, innerException?: Exception) {
        super(message, propertyDefinition.GetPrintableName(), innerException);
        this.PropertyDefinition = propertyDefinition;
    }
}
/**
 * Represents an error that occurs when a service operation fails remotely.
 */
export class ServiceRemoteException extends Exception {
    /**
     * ServiceRemoteException Constructor.
     */
    constructor();
    /**
     * ServiceRemoteException Constructor.
     *
     * @param   {string}    message          Error message text.
     */
    constructor(message: string);
    /**
     * ServiceRemoteException Constructor.
     *
     * @param   {string}        message          Error message text.
     * @param   {Exception}     innerException   Inner exception.
     */
    constructor(message: string, innerException: Exception);
    constructor(message: string = null, innerException: Exception = null) {
        super(message, innerException);
    }
}

/**
 * Represents an error that occurs when the account that is being accessed is locked and requires user interaction to be unlocked.
 */
export class AccountIsLockedException extends ServiceRemoteException {

    /**
     * Gets the URL of a web page where the user can navigate to unlock his or her account.
     * 
     * internal set
     */
    AccountUnlockUrl: Uri = null;

    /**
     * Initializes a new instance of the **AccountIsLockedException** class.
     *
     * @param   {string}        message            Error message text.
     * @param   {Uri}           accountUnlockUrl   URL for client to visit to unlock account.
     * @param   {Exception}     innerException     Inner exception.
     */
    constructor(message: string, accountUnlockUrl: Uri, innerException: Exception) {
        super(message, innerException);
        this.AccountUnlockUrl = accountUnlockUrl;
    }
}
export class AutodiscoverRemoteException extends ServiceRemoteException {
    Error: AutodiscoverError;
    //private error: AutodiscoverError;
}
export class AutodiscoverResponseException extends ServiceRemoteException {
    ErrorCode: AutodiscoverErrorCode;
    private errorCode: AutodiscoverErrorCode;
}

/**
 * Represents an exception thrown when an error occurs as a result of calling the UpdateInboxRules operation.
 * 
 * @sealed
 */
export class UpdateInboxRulesException extends ServiceRemoteException {

    /**
     * ServiceResponse when service operation failed remotely.
     */
    private serviceResponse: ServiceResponse = null;

    /**
     * Rule operation error collection.
     */
    private errors: RuleOperationErrorCollection = null;

    /**
     * Gets the ServiceResponse for the exception.
     */
    get ServiceResponse(): ServiceResponse {
        return this.serviceResponse;
    }

    /**
     * Gets the rule operation error collection.
     */
    get Errors(): RuleOperationErrorCollection {
        return this.errors;
    }

    /**
     * Gets the rule operation error code.
     */
    get ErrorCode(): ServiceError {
        return this.serviceResponse.ErrorCode;
    }

    /**
     * Gets the rule operation error message.
     */
    get ErrorMessage(): string {
        return this.serviceResponse.ErrorMessage;
    }

    /**
     * @internal Initializes a new instance of the **UpdateInboxRulesException** class.
     *
     * @param   {UpdateInboxRulesResponse}  serviceResponse   The rule operation service response.
     * @param   {RuleOperation[]}           ruleOperations    The original operations.
     */
    constructor(serviceResponse: UpdateInboxRulesResponse, ruleOperations: RuleOperation[]) {
        super(serviceResponse && serviceResponse.ErrorMessage ? serviceResponse.ErrorMessage : "" || "");
        this.serviceResponse = serviceResponse;
        this.errors = serviceResponse.Errors;
        for (let error of this.errors.Items) {
            error.SetOperationByIndex(ruleOperations);
        }
    }
}

/**
 * Represents a remote service exception that can have multiple service responses.
 * 
 * @type {TResponse}       The type of the response.
 */
export class BatchServiceResponseException<TResponse extends ServiceResponse> extends ServiceRemoteException {
    /**
     * The list of responses returned by the web method.
     */
    private responses: ServiceResponseCollection<TResponse>;
    /**
     * Gets a list of responses returned by the web method.
     */
    get ServiceResponses(): ServiceResponseCollection<TResponse> { return this.ServiceResponses; }
    
    /**
     * Initializes a new instance of **BatchServiceResponseException**.
     *
     * @param   {ServiceResponseCollection<DeleteAttachmentResponse>}   serviceResponses   The list of responses to be associated with this exception.
     * @param   {string}   message            The message that describes the error.
     */
    constructor(serviceResponses: ServiceResponseCollection<TResponse>, message: string);
    /**
     * Initializes a new instance of **BatchServiceResponseException**.
     *
     * @param   {ServiceResponseCollection<TResponse>}   serviceResponses   The list of responses to be associated with this exception.
     * @param   {string}   message            The message that describes the error.
     * @param   {Exception}   innerException     The exception that is the cause of the current exception.
     */
    constructor(serviceResponses: ServiceResponseCollection<TResponse>, message: string, innerException: Exception);
    constructor(serviceResponses: ServiceResponseCollection<TResponse>, message: string, innerException?: Exception) {
        if (arguments.length == 2) {
            super(message);
        }
        else {
            super(message, innerException);
        }

        EwsLogging.Assert(
            serviceResponses != null,
            "BatchServiceResponseException.ctor",
            "serviceResponses is null");
            this.responses = serviceResponses;
    }
}
export class CreateAttachmentException extends BatchServiceResponseException<CreateAttachmentResponse> {
}

/**
 * Represents an error that occurs when a call to the DeleteAttachment web method fails.
 */
export class DeleteAttachmentException extends BatchServiceResponseException<DeleteAttachmentResponse> {
    /**
     * Initializes a new instance of **DeleteAttachmentException**.
     *
     * @param   {ServiceResponseCollection<DeleteAttachmentResponse>}   serviceResponses   The list of responses to be associated with this exception.
     * @param   {string}   message            The message that describes the error.
     */
    constructor(serviceResponses: ServiceResponseCollection<DeleteAttachmentResponse>, message: string);
    /**
     * Initializes a new instance of **DeleteAttachmentException**.
     *
     * @param   {ServiceResponseCollection<DeleteAttachmentResponse>}   serviceResponses   The list of responses to be associated with this exception.
     * @param   {string}   message            The message that describes the error.
     * @param   {Exception}   innerException     The exception that is the cause of the current exception.
     */
    constructor(serviceResponses: ServiceResponseCollection<DeleteAttachmentResponse>, message: string, innerException: Exception);
    constructor(serviceResponses: ServiceResponseCollection<DeleteAttachmentResponse>, message: string, innerException?: Exception) {
        if (arguments.length == 2)
            super(serviceResponses, message);
        else
            super(serviceResponses, message, innerException);
    }
}
export class ServiceRequestException extends ServiceRemoteException {	
}
export class ServiceRequestUnauthorizedException extends ServiceRequestException {	
}

/**
 * Represents a remote service exception that has a single response.
 */
export class ServiceResponseException extends ServiceRemoteException {

    /**
     * Error details Value keys
     */
    private static ExceptionClassKey: string = "ExceptionClass";
    private static ExceptionMessageKey: string = "ExceptionMessage";
    private static StackTraceKey: string = "StackTrace";

    /**
     * ServiceResponse when service operation failed remotely.
     */
    private response: ServiceResponse;

    /**
     * Gets the ServiceResponse for the exception.
     */
    get Response(): ServiceResponse {
        return this.response;
    }

    /**
     * Gets the service error code.
     */
    get ErrorCode(): ServiceError {
        return this.response ? this.response.ErrorCode : null;
    }

    /**
     * Gets a message that describes the current exception.
     * 
     * @returns The error message that explains the reason for the exception.
     */
    get Message(): string {
        // Special case for Internal Server Error. If the server returned
        // stack trace information, include it in the exception message.
        if (this.Response.ErrorCode == ServiceError.ErrorInternalServerError) {
            var exceptionClass = this.Response.ErrorDetails.get(ServiceResponseException.ExceptionClassKey);
            var exceptionMessage = this.Response.ErrorDetails.get(ServiceResponseException.ExceptionMessageKey);
            var stackTrace = this.Response.ErrorDetails.get(ServiceResponseException.StackTraceKey);

            if (!StringHelper.IsNullOrEmpty(exceptionClass) && !StringHelper.IsNullOrEmpty(exceptionMessage) && !StringHelper.IsNullOrEmpty(stackTrace)) {
                return StringHelper.Format(
                    Strings.ServerErrorAndStackTraceDetails,
                    this.Response.ErrorMessage,
                    exceptionClass,
                    exceptionMessage,
                    stackTrace);
            }
        }

        return this.Response.ErrorMessage;
    }

    /**
     * @internal Initializes a new instance of the **ServiceResponseException** class.
     *
     * @param   {ServiceResponse}   response   The ServiceResponse when service operation failed remotely.
     */
    constructor(response: ServiceResponse) {
        super(response && response.ErrorMessage ? response.ErrorMessage : "");
        this.response = response;
    }
}

export class ServerBusyException extends ServiceResponseException {
    private static BackOffMillisecondsKey: string = "BackOffMilliseconds";
    BackOffMilliseconds: number;
    private backOffMilliseconds: number;
}

/**
 * Represents mailbox query object.
 * 
 * @sealed
 */
export class DiscoverySearchConfiguration {

    /**
     * Search Id
     */
    SearchId: string = null;

    /**
     * Search query
     */
    SearchQuery: string = null;

    /**
     * Set of mailbox and scope pair
     */
    SearchableMailboxes: SearchableMailbox[] = null;

    /**
     * In-Place hold identity
     */
    InPlaceHoldIdentity: string = null;

    /**
     * Managed by organization
     */
    ManagedByOrganization: string = null;

    /**
     * Language
     */
    Language: string = null;

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {DiscoverySearchConfiguration}              Discovery search configuration object.
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): DiscoverySearchConfiguration {
        let mailboxes: SearchableMailbox[] = [];
        let configuration: DiscoverySearchConfiguration = new DiscoverySearchConfiguration();

        if (jsObject[XmlElementNames.SearchId]) {
            configuration.SearchId = jsObject[XmlElementNames.SearchId];
        }

        if (jsObject[XmlElementNames.InPlaceHoldIdentity]) {
            configuration.InPlaceHoldIdentity = jsObject[XmlElementNames.InPlaceHoldIdentity];
        }

        if (jsObject[XmlElementNames.ManagedByOrganization]) {
            configuration.ManagedByOrganization = jsObject[XmlElementNames.ManagedByOrganization];
        }

        if (jsObject[XmlElementNames.SearchQuery]) {
            configuration.SearchQuery = jsObject[XmlElementNames.SearchQuery];
        }

        if (jsObject[XmlElementNames.SearchableMailboxes]) {
            for (let searchableMailboxObject of EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.SearchableMailboxes], XmlElementNames.SearchableMailbox)) {
                mailboxes.push(SearchableMailbox.LoadFromXmlJsObject(searchableMailboxObject, service));
            }
        }

        if (jsObject[XmlElementNames.Language]) {
            configuration.Language = jsObject[XmlElementNames.Language];
        }

        configuration.SearchableMailboxes = mailboxes.length == 0 ? null : mailboxes;

        return configuration;
    }
}

/**
 * Class ExtendedAttribute
 * 
 * @sealed
 */
export class ExtendedAttribute {

    /**
     * Gets or sets the name.
     * 
     * @value The name.
     */
    Name: string = null;

    /**
     * Gets or sets the value.
     * 
     * @value The value.
     */
    Value: string = null;

    /**
     * Initializes a new instance of the **ExtendedAttribute** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **ExtendedAttribute** class.
     *
     * @param   {string}   name    The name.
     * @param   {string}   value   The value.
     */
    constructor(name: string, value: string);
    constructor(name: string = null, value: string = null) {
        this.Name = name;
        this.Value = value;
    }
}

// export class ExtendedAttributes extends Array<ExtendedAttribute> {
// }

/**
 * Represents failed mailbox to be searched
 * 
 * @sealed
 */
export class FailedSearchMailbox {


    Mailbox: string = null;
    ErrorCode: number = 0;
    ErrorMessage: string = null;
    IsArchive: boolean = false;

    /**
     * Constructor
     *
     * @param   {string}    mailbox        Mailbox identifier
     * @param   {number}    errorCode      Error code
     * @param   {string}    errorMessage   Error message
     */
    constructor(mailbox: string, errorCode: number, errorMessage: string);
    /**
     * Constructor
     *
     * @param   {string}    mailbox        Mailbox identifier
     * @param   {number}    errorCode      Error code
     * @param   {string}    errorMessage   Error message
     * @param   {boolean}   isArchive      True if it is mailbox archive
     */
    constructor(mailbox: string, errorCode: number, errorMessage: string, isArchive: boolean);
    constructor(mailbox: string, errorCode: number, errorMessage: string, isArchive: boolean = false) {
        this.Mailbox = mailbox;
        this.ErrorCode = errorCode;
        this.ErrorMessage = errorMessage;
        this.IsArchive = isArchive;
    }


    /**
     * @internal Load failed mailboxes xml
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {FailedSearchMailbox[]}       Failed search mailboxes.
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): FailedSearchMailbox[] {

        let failedMailboxes: FailedSearchMailbox[] = [];
        for (let failedMailboxObject of EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.FailedMailbox)) {

            let mailbox: string = null, errorCode: number = 0, errorMessage: string = null, isArchive: boolean = false;

            if (failedMailboxObject[XmlElementNames.Mailbox]) {
                mailbox = failedMailboxObject[XmlElementNames.Mailbox];
            }

            if (failedMailboxObject[XmlElementNames.ErrorCode]) {
                errorCode = Convert.toNumber(failedMailboxObject[XmlElementNames.ErrorCode]);
            }

            if (failedMailboxObject[XmlElementNames.ErrorMessage]) {
                errorMessage = failedMailboxObject[XmlElementNames.ErrorMessage];
            }

            if (failedMailboxObject[XmlElementNames.IsArchive]) {
                isArchive = Convert.toBool(failedMailboxObject[XmlElementNames.IsArchive]);
            }

            failedMailboxes.push(new FailedSearchMailbox(mailbox, errorCode, errorMessage, isArchive));
        }
        return failedMailboxes.length === 0 ? null : failedMailboxes;
    }
}
/**
 * Represents the keyword statistics result.
 * 
 * @sealed
 */
export class KeywordStatisticsSearchResult {

    /**
     * Keyword string
     */
    Keyword: string;

    /**
     * Number of item hits
     */
    ItemHits: number;

    /**
     * Total size
     * [CLSCompliant(false)]
     */
    Size: number;
}

/**
 * Represents mailbox hold result
 * 
 * @sealed
 */
export class MailboxHoldResult {

    /**
     * Hold id
     */
    HoldId: string = null;

    /**
     * Query
     */
    Query: string = null;

    /**
     * Collection of mailbox status
     */
    Statuses: MailboxHoldStatus[] = null;

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {MailboxHoldResult}              Mailbox hold object
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): MailboxHoldResult {
        let statuses: MailboxHoldStatus[] = [];
        let holdResult: MailboxHoldResult = new MailboxHoldResult();

        if (jsObject[XmlElementNames.HoldId]) {
            holdResult.HoldId = jsObject[XmlElementNames.HoldId];
        }

        if (jsObject[XmlElementNames.Query]) {
            holdResult.Query = jsObject[XmlElementNames.Query];
        }

        if (jsObject[XmlElementNames.MailboxHoldStatuses]) {
            for (let statusObject of EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.MailboxHoldStatuses], XmlElementNames.MailboxHoldStatus)) {

                let status: MailboxHoldStatus = new MailboxHoldStatus();

                if (statusObject[XmlElementNames.Mailbox]) {
                    status.Mailbox = statusObject[XmlElementNames.Mailbox];
                }
                if (statusObject[XmlElementNames.Status]) {
                    status.Status = HoldStatus[<string>statusObject[XmlElementNames.Status]];
                }

                if (statusObject[XmlElementNames.AdditionalInfo]) {
                    status.AdditionalInfo = statusObject[XmlElementNames.AdditionalInfo];
                }

                statuses.push(status);
            }
        }

        holdResult.Statuses = statuses.length == 0 ? null : statuses;

        return holdResult;
    }
}

/**
 * Represents mailbox hold status
 * 
 * @sealed
 */
export class MailboxHoldStatus {

    /**
     * Mailbox
     */
    Mailbox: string;

    /**
     * Hold Status
     */
    Status: HoldStatus;

    /**
     * Additional Info
     */
    AdditionalInfo: string;

    /**
     * Constructor
     */
    constructor();
    /**
     * Constructor
     *
     * @param   {string}        mailbox          Mailbox
     * @param   {HoldStatus}    status           Hold status
     * @param   {string}        additionalInfo   Additional info
     */
    constructor(mailbox: string, status: HoldStatus, additionalInfo: string);
    constructor(mailbox: string = null, status: HoldStatus = HoldStatus.NotOnHold, additionalInfo: string = null) {
        this.Mailbox = mailbox;
        this.Status = status;
        this.AdditionalInfo = additionalInfo;
    }
}

/**
 * Represents mailbox query object.
 * 
 * @sealed
 */
export class MailboxQuery {

    /**
     * Search query
     */
    Query: string = null;

    /**
     * Set of mailbox and scope pair
     */
    MailboxSearchScopes: MailboxSearchScope[] = null;

    /**
     * Constructor
     *
     * @param   {string}                query          Search query
     * @param   {MailboxSearchScope[]}  searchScopes   Set of mailbox and scope pair
     */
    constructor(query: string, searchScopes: MailboxSearchScope[]) {
        this.Query = query;
        this.MailboxSearchScopes = searchScopes;
    }
}

/**
 * Represents mailbox search scope object.
 */
export class MailboxSearchScope {

    private searchScope: MailboxSearchLocation = MailboxSearchLocation.All;
    private scopeType: MailboxSearchScopeType = MailboxSearchScopeType.LegacyExchangeDN;

    /**
     * Mailbox
     */
    Mailbox: string = null;

    /**
     * Search scope
     */
    get SearchScope(): MailboxSearchLocation {
        return this.searchScope;
    }
    set SearchScope(value: MailboxSearchLocation) {
        this.searchScope = value;
    }

    /**
     * @internal Search scope type
     */
    get SearchScopeType(): MailboxSearchScopeType {
        return this.scopeType;
    }
    set SearchScopeType(value: MailboxSearchScopeType) {
        this.scopeType = value;
    }

    /**
     * Gets the extended data.
     * 
     * @value The extended data.
     */
    ExtendedAttributes: ExtendedAttribute[] = null;

    /**
     * Constructor
     *
     * @param   {string}   mailbox       Mailbox
     * @param   {MailboxSearchLocation}   searchScope   Search scope
     */
    constructor(mailbox: string, searchScope: MailboxSearchLocation) {
        this.Mailbox = mailbox;
        this.searchScope = searchScope;
        this.ExtendedAttributes = [];
    }
}

/**
 * Mailbox statistics item
 * 
 * @sealed
 */
export class MailboxStatisticsItem {

    /**
     * Mailbox id
     */
    MailboxId: string = null;

    /**
     * Display name
     */
    DisplayName: string = null;

    /**
     * Item count
     */
    ItemCount: number = 0;

    /**
     * Total size
     * [CLSCompliant(false)]
     */
    Size: number = 0;

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {SearchRefinerItem}
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): MailboxStatisticsItem {
        let msi: MailboxStatisticsItem = new MailboxStatisticsItem();
        msi.MailboxId = jsObject[XmlElementNames.MailboxId];
        msi.DisplayName = jsObject[XmlElementNames.DisplayName];
        msi.ItemCount = Convert.toNumber(jsObject[XmlElementNames.ItemCount]);
        msi.Size = Convert.toNumber(jsObject[XmlElementNames.Size]);
        return msi;
    }
}

/**
 * Represents non indexable item.
 * 
 * @sealed
 */
export class NonIndexableItem {

    /**
     * Item Identity
     */
    ItemId: ItemId = null;

    /**
     * Error code
     */
    ErrorCode: ItemIndexError = ItemIndexError.None;

    /**
     * Error description
     */
    ErrorDescription: string = null;

    /**
     * Is partially indexed
     */
    IsPartiallyIndexed: boolean = false;

    /**
     * Is permanent failure
     */
    IsPermanentFailure: boolean = false;

    /**
     * Attempt count
     */
    AttemptCount: number = 0;

    /**
     * Last attempt time
     */
    LastAttemptTime: DateTime = null;

    /**
     * Additional info
     */
    AdditionalInfo: string = null;

    /**
     * Sort value
     */
    SortValue: string = null;

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {NonIndexableItemDetailsResult}       Non indexable item details result object
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): NonIndexableItem {
        let result: NonIndexableItem = new NonIndexableItem();

        if (jsObject[XmlElementNames.ItemId]) {
            result.ItemId = new ItemId();
            result.ItemId.LoadFromXmlJsObject(jsObject[XmlElementNames.ItemId], service);
        }

        if (jsObject[XmlElementNames.ErrorDescription]) {
            result.ErrorDescription = jsObject[XmlElementNames.ErrorDescription];
        }

        if (jsObject[XmlElementNames.IsPartiallyIndexed]) {
            result.IsPartiallyIndexed = Convert.toBool(jsObject[XmlElementNames.IsPartiallyIndexed]);
        }

        if (jsObject[XmlElementNames.IsPermanentFailure]) {
            result.IsPermanentFailure = Convert.toBool(jsObject[XmlElementNames.IsPermanentFailure]);
        }

        if (jsObject[XmlElementNames.AttemptCount]) {
            result.AttemptCount = Convert.toNumber(jsObject[XmlElementNames.AttemptCount]);
        }

        if (jsObject[XmlElementNames.LastAttemptTime]) {
            result.LastAttemptTime = DateTime.Parse(jsObject[XmlElementNames.LastAttemptTime]);
        }

        if (jsObject[XmlElementNames.AdditionalInfo]) {
            result.AdditionalInfo = jsObject[XmlElementNames.AdditionalInfo];
        }

        if (jsObject[XmlElementNames.SortValue]) {
            result.SortValue = jsObject[XmlElementNames.SortValue];
        }

        return result;
    }
}

/**
 * Represents non indexable item details result.
 * 
 * @sealed
 */
export class NonIndexableItemDetailsResult {

    /**
     * Collection of items
     */
    Items: NonIndexableItem[] = null;

    /**
     * Failed mailboxes
     */
    FailedMailboxes: FailedSearchMailbox[] = null;

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {NonIndexableItemDetailsResult}       Non indexable item details result object
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): NonIndexableItemDetailsResult {
        let nonIndexableItemDetailsResult: NonIndexableItemDetailsResult = new NonIndexableItemDetailsResult();
        if (jsObject[XmlElementNames.Items]) {
            nonIndexableItemDetailsResult.Items = [];
            for (let nonIndexableItem of EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.Items], XmlElementNames.NonIndexableItemDetail)) {
                nonIndexableItemDetailsResult.Items.push(NonIndexableItem.LoadFromXmlJsObject(nonIndexableItem, service));
            }
            if (nonIndexableItemDetailsResult.Items.length === 0) {
                nonIndexableItemDetailsResult.Items = null;
            }
        }
        if (jsObject[XmlElementNames.FailedMailboxes]) {
            nonIndexableItemDetailsResult.FailedMailboxes = FailedSearchMailbox.LoadFromXmlJsObject(jsObject[XmlElementNames.FailedMailboxes], service);
        }
        return nonIndexableItemDetailsResult;
    }
}

/**
 * Represents non indexable item parameters base class
 */
export abstract class NonIndexableItemParameters {

    /**
     * List of mailboxes (in legacy DN format)
     */
    Mailboxes: string[] = null;

    /**
     * Search archive only
     */
    SearchArchiveOnly: boolean = false;
}

/**
 * Represents get non indexable item statistics parameters.
 * 
 * @sealed
 */
export class GetNonIndexableItemStatisticsParameters extends NonIndexableItemParameters {
}

/**
 * Represents get non indexable item details parameters.
 * 
 * @sealed
 */
export class GetNonIndexableItemDetailsParameters extends NonIndexableItemParameters {

    /**
     * @Nullable Page size
     */
    PageSize: number = null; //Nullable

    /**
     * Page item reference
     */
    PageItemReference: string = null;

    /**
     * @Nullable Search page direction 
     */
    PageDirection: SearchPageDirection = null; //Nullable
}

/**
 * Represents non indexable item statistic.
 * 
 * @sealed
 */
export class NonIndexableItemStatistic {

    /**
     * Mailbox legacy DN
     */
    Mailbox: string = null;

    /**
     * Item count
     */
    ItemCount: number = 0;

    /**
     * Error message
     */
    ErrorMessage: string = null;

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {NonIndexableItemStatistic}       non indexable item statistic object
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): NonIndexableItemStatistic {
        let result: NonIndexableItemStatistic = new NonIndexableItemStatistic();

        if (jsObject[XmlElementNames.Mailbox]) {
            result.Mailbox = jsObject[XmlElementNames.Mailbox];
        }

        if (jsObject[XmlElementNames.ItemCount]) {
            result.ItemCount = Convert.toNumber(jsObject[XmlElementNames.ItemCount]);
        }

        if (jsObject[XmlElementNames.ErrorMessage]) {
            result.ErrorMessage = jsObject[XmlElementNames.ErrorMessage];
        }

        return result;
    }
}

/**
 * Represents mailbox object for preview item.
 * 
 * @sealed
 */
export class PreviewItemMailbox {

    /**
     * Mailbox id
     */
    MailboxId: string = null;

    /**
     * Primary smtp address
     */
    PrimarySmtpAddress: string = null;

    /**
     * Constructor
     */
    constructor();
    /**
     * Constructor
     *
     * @param   {string}   mailboxId            Mailbox id
     * @param   {string}   primarySmtpAddress   Primary smtp address
     */
    constructor(mailboxId: string, primarySmtpAddress: string);
    constructor(mailboxId: string = null, primarySmtpAddress: string = null) {
        this.MailboxId = mailboxId;
        this.PrimarySmtpAddress = primarySmtpAddress;
    }
}

/**
 * Represents preview item response shape
 * 
 * @sealed
 */
export class PreviewItemResponseShape {

    /**
     * Mailbox identifier
     */
    BaseShape: PreviewItemBaseShape = PreviewItemBaseShape.Default;

    /**
     * Additional properties (must be in form of extended properties)
     */
    AdditionalProperties: ExtendedPropertyDefinition[] = null;

    /**
     * Constructor
     */
    constructor();
    /**
     * Constructor
     *
     * @param   {PreviewItemBaseShape}          baseShape              Preview item base shape
     * @param   {ExtendedPropertyDefinition[]}  additionalProperties   Additional properties (must be in form of extended properties)
     */
    constructor(baseShape: PreviewItemBaseShape, additionalProperties: ExtendedPropertyDefinition[]);
    constructor(baseShape: PreviewItemBaseShape = PreviewItemBaseShape.Default, additionalProperties: ExtendedPropertyDefinition[] = null) {
        this.BaseShape = baseShape;
        this.AdditionalProperties = additionalProperties;
    }
}

/**
 * Represents searchable mailbox object
 * 
 * @sealed
 */
export class SearchableMailbox {

    /**
     * Guid
     */
    Guid: Guid = null;

    /**
     * Smtp address
     */
    SmtpAddress: string = null;

    /**
     * If true, this is an external mailbox
     */
    IsExternalMailbox: boolean = false;

    /**
     * External email address for the mailbox
     */
    ExternalEmailAddress: string = null;

    /**
     * Display name
     */
    DisplayName: string = null;

    /**
     * Is a membership group
     */
    IsMembershipGroup: boolean = false;

    /**
     * Reference id
     */
    ReferenceId: string = null;

    /**
     * Constructor
     */
    constructor();
    /**
     * Constructor
     *
     * @param   {Guid}      guid                   Guid
     * @param   {string}    smtpAddress            Smtp address
     * @param   {boolean}   isExternalMailbox      If true, this is an external mailbox
     * @param   {string}    externalEmailAddress   External email address
     * @param   {string}    displayName            Display name
     * @param   {boolean}   isMembershipGroup      Is a membership group
     * @param   {string}    referenceId            Reference id
     */
    constructor(guid: Guid, smtpAddress: string, isExternalMailbox: boolean, externalEmailAddress: string, displayName: string, isMembershipGroup: boolean, referenceId: string);
    constructor(guid: Guid = null, smtpAddress: string = null, isExternalMailbox: boolean = false, externalEmailAddress: string = null, displayName: string = null, isMembershipGroup: boolean = false, referenceId: string = null) {
        this.Guid = guid;
        this.SmtpAddress = smtpAddress;
        this.IsExternalMailbox = isExternalMailbox;
        this.ExternalEmailAddress = externalEmailAddress;
        this.DisplayName = displayName;
        this.IsMembershipGroup = isMembershipGroup;
        this.ReferenceId = referenceId;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {SearchableMailbox}              Searchable mailbox object
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): SearchableMailbox {
        let searchableMailbox: SearchableMailbox = new SearchableMailbox();

        if (jsObject[XmlElementNames.Guid]) {
            searchableMailbox.Guid = new Guid(jsObject[XmlElementNames.Guid]);
        }

        if (jsObject[XmlElementNames.DisplayName]) {
            searchableMailbox.DisplayName = jsObject[XmlElementNames.DisplayName];
        }

        if (jsObject[XmlElementNames.PrimarySmtpAddress]) {
            searchableMailbox.SmtpAddress = jsObject[XmlElementNames.PrimarySmtpAddress];
        }

        if (jsObject[XmlElementNames.IsExternalMailbox]) {
            searchableMailbox.IsExternalMailbox = Convert.toBool(jsObject[XmlElementNames.IsExternalMailbox]);
        }

        if (jsObject[XmlElementNames.ExternalEmailAddress]) {
            searchableMailbox.ExternalEmailAddress = jsObject[XmlElementNames.ExternalEmailAddress];
        }

        if (jsObject[XmlElementNames.IsMembershipGroup]) {
            searchableMailbox.IsMembershipGroup = Convert.toBool(jsObject[XmlElementNames.IsMembershipGroup]);
        }

        if (jsObject[XmlElementNames.ReferenceId]) {
            searchableMailbox.ReferenceId = jsObject[XmlElementNames.ReferenceId];
        }

        return searchableMailbox;
    }
}

/**
 * Represents search mailbox parameters.
 * 
 * @sealed
 */
export class SearchMailboxesParameters {

    /**
     * Search queries
     */
    SearchQueries: MailboxQuery[] = null;

    /**
     * Result type
     */
    ResultType: SearchResultType = SearchResultType.PreviewOnly;

    /**
     * Sort by property
     */
    SortBy: string = null;

    /**
     * Sort direction
     */
    SortOrder: SortDirection = SortDirection.Ascending;

    /**
     * Perform deduplication
     */
    PerformDeduplication: boolean = false;

    /**
     * Page size
     */
    PageSize: number = 0;

    /**
     * Search page direction
     */
    PageDirection: SearchPageDirection = SearchPageDirection.Next;

    /**
     * Page item reference
     */
    PageItemReference: string = null;

    /**
     * Preview item response shape
     */
    PreviewItemResponseShape: PreviewItemResponseShape = null;

    /**
     * Query language
     */
    Language: string = null;
}

/**
 * Represents search mailbox result.
 * 
 * @sealed
 */
export class SearchMailboxesResult {

    /**
     * Search queries
     */
    SearchQueries: MailboxQuery[] = null;

    /**
     * Result type
     */
    ResultType: SearchResultType = SearchResultType.StatisticsOnly;

    /**
     * Item count
     */
    ItemCount: number = 0;

    /**
     * Total size
     * [CLSCompliant(false)]
     */
    Size: number = 0;

    /**
     * Page item count
     */
    PageItemCount: number = 0;

    /**
     * Total page item size
     * [CLSCompliant(false)]
     */
    PageItemSize: number = 0;

    /**
     * Keyword statistics search result
     */
    KeywordStats: KeywordStatisticsSearchResult[] = null;

    /**
     * Search preview items
     */
    PreviewItems: SearchPreviewItem[] = null;

    /**
     * Failed mailboxes
     */
    FailedMailboxes: FailedSearchMailbox[] = null;

    /**
     * Refiners
     */
    Refiners: SearchRefinerItem[] = null;

    /**
     * Mailbox statistics
     */
    MailboxStats: MailboxStatisticsItem[] = null;

    /**
     * Get collection of recipients
     *
     * @param   {any}   jsObject	Json Object converted from XML.
     * @return  {string[]}          Array of recipients
     */
    private static GetRecipients(jsObject: any): string[] {
        let recipients: string[] = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.SmtpAddress)
        return recipients.length === 0 ? null : recipients;
    }

    /**
     * Load extended properties from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {ExtendedPropertyCollection}     Extended properties collection
     */
    private static LoadExtendedPropertiesXmlJsObject(jsObject: any, service: ExchangeService): ExtendedPropertyCollection {
        let extendedProperties: ExtendedPropertyCollection = new ExtendedPropertyCollection();
        for (let extendedProperty of EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.ExtendedProperty)) {
            extendedProperties.LoadFromXmlJsObject(extendedProperty, service);
        }
        return extendedProperties.Count === 0 ? null : extendedProperties;
    }

    /**
     * Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {SearchMailboxesResult}     Search result object
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): SearchMailboxesResult {
        let searchResult: SearchMailboxesResult = new SearchMailboxesResult();

        if (jsObject[XmlElementNames.SearchQueries]) {
            searchResult.SearchQueries = [];
            for (let searchQuery of EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.SearchQueries], XmlElementNames.SearchQuery)) {
                let query: string = searchQuery[XmlElementNames.Query];
                let mailboxSearchScopes: MailboxSearchScope[] = [];
                if (searchQuery[XmlElementNames.MailboxSearchScopes]) {
                    for (let mailboxSearchScope of EwsServiceJsonReader.ReadAsArray(searchQuery[XmlElementNames.MailboxSearchScopes], XmlElementNames.MailboxSearchScope)) {
                        let mailbox: string = mailboxSearchScope[XmlElementNames.Mailbox];
                        let searchScope: MailboxSearchLocation = MailboxSearchLocation[<string>mailboxSearchScope[XmlElementNames.SearchScope]];
                        mailboxSearchScopes.push(new MailboxSearchScope(mailbox, searchScope));
                    }
                }
                searchResult.SearchQueries.push(new MailboxQuery(query, mailboxSearchScopes));
            }
        }

        if (jsObject[XmlElementNames.ResultType]) {
            searchResult.ResultType = SearchResultType[<string>jsObject[XmlElementNames.ResultType]]
        }

        if (jsObject[XmlElementNames.ItemCount]) {
            searchResult.ItemCount = Convert.toNumber(jsObject[XmlElementNames.ItemCount]);
        }

        if (jsObject[XmlElementNames.Size]) {
            searchResult.Size = Convert.toNumber(jsObject[XmlElementNames.Size]);
        }

        if (jsObject[XmlElementNames.PageItemCount]) {
            searchResult.PageItemCount = Convert.toNumber(jsObject[XmlElementNames.PageItemCount]);
        }

        if (jsObject[XmlElementNames.PageItemSize]) {
            searchResult.PageItemSize = Convert.toNumber(jsObject[XmlElementNames.PageItemSize]);
        }

        if (jsObject[XmlElementNames.KeywordStats]) {
            searchResult.KeywordStats = this.LoadKeywordStatsXmlJsObject(jsObject[XmlElementNames.KeywordStats]);
        }

        if (jsObject[XmlElementNames.Items]) {
            searchResult.PreviewItems = this.LoadPreviewItemsXmlJsObject(jsObject[XmlElementNames.Items], service);
        }

        if (jsObject[XmlElementNames.FailedMailboxes]) {
            searchResult.FailedMailboxes = FailedSearchMailbox.LoadFromXmlJsObject(jsObject[XmlElementNames.FailedMailboxes], service);
        }

        if (jsObject[XmlElementNames.Refiners]) {
            let refiners: SearchRefinerItem[] = [];
            for (let refiner of EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.Refiners], XmlElementNames.Refiner)) {
                refiners.push(SearchRefinerItem.LoadFromXmlJsObject(refiner, service));
            }
            if (refiners.length > 0) {
                searchResult.Refiners = refiners;
            }
        }

        if (jsObject[XmlElementNames.MailboxStats]) {
            let mailboxStats: MailboxStatisticsItem[] = [];
            for (let mailboxStat of EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.MailboxStats], XmlElementNames.MailboxStat)) {
                mailboxStats.push(MailboxStatisticsItem.LoadFromXmlJsObject(mailboxStat, service));
            }
            if (mailboxStats.length > 0) {
                searchResult.MailboxStats = mailboxStats;
            }
        }

        return searchResult;
    }

    /**
     * Load keyword stats from XML.
     *
     * @param   {any}   jsObject	Json Object converted from XML.
     * @return  {KeywordStatisticsSearchResult[]}       Array of keyword statistics
     */
    private static LoadKeywordStatsXmlJsObject(jsObject: any): KeywordStatisticsSearchResult[] {
        let keywordStats: KeywordStatisticsSearchResult[] = [];
        for (let keywordStatObj of EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.KeywordStat)) {
            let keywordStat: KeywordStatisticsSearchResult = new KeywordStatisticsSearchResult();
            keywordStat.Keyword = jsObject[XmlElementNames.Keyword];
            keywordStat.ItemHits = Convert.toNumber(jsObject[XmlElementNames.ItemHits]);
            keywordStat.Size = Convert.toNumber(jsObject[XmlElementNames.Size]);
            keywordStats.push(keywordStat);
        }
        return keywordStats.length === 0 ? null : keywordStats;
    }

    /**
     * Load preview items from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {SearchPreviewItem[]}     Array of preview items
     */
    private static LoadPreviewItemsXmlJsObject(jsObject: any, service: ExchangeService): SearchPreviewItem[] {
        let previewItems: SearchPreviewItem[] = [];
        for (let searchPreviewItem of EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.SearchPreviewItem)) {
            let previewItem: SearchPreviewItem = new SearchPreviewItem();

            if (searchPreviewItem[XmlElementNames.Id]) {
                previewItem.Id = new ItemId();
                previewItem.Id.LoadFromXmlJsObject(searchPreviewItem[XmlElementNames.Id], service);
            }

            if (searchPreviewItem[XmlElementNames.ParentId]) {
                previewItem.ParentId = new ItemId();
                previewItem.ParentId.LoadFromXmlJsObject(searchPreviewItem[XmlElementNames.ParentId], service);
            }

            if (searchPreviewItem[XmlElementNames.Mailbox]) {
                previewItem.Mailbox = new PreviewItemMailbox();
                previewItem.Mailbox.MailboxId = searchPreviewItem[XmlElementNames.Mailbox][XmlElementNames.MailboxId];
                previewItem.Mailbox.PrimarySmtpAddress = searchPreviewItem[XmlElementNames.Mailbox][XmlElementNames.PrimarySmtpAddress];
            }

            //missing in official repo
            if (searchPreviewItem[XmlElementNames.ItemClass]) {
                previewItem.ItemClass = searchPreviewItem[XmlElementNames.ItemClass];
            }

            if (searchPreviewItem[XmlElementNames.UniqueHash]) {
                previewItem.UniqueHash = searchPreviewItem[XmlElementNames.UniqueHash];
            }

            if (searchPreviewItem[XmlElementNames.SortValue]) {
                previewItem.SortValue = searchPreviewItem[XmlElementNames.SortValue];
            }

            if (searchPreviewItem[XmlElementNames.OwaLink]) {
                previewItem.OwaLink = searchPreviewItem[XmlElementNames.OwaLink];
            }

            if (searchPreviewItem[XmlElementNames.Sender]) {
                previewItem.Sender = searchPreviewItem[XmlElementNames.Sender];
            }

            if (searchPreviewItem[XmlElementNames.ToRecipients]) {
                previewItem.ToRecipients = this.GetRecipients(searchPreviewItem[XmlElementNames.ToRecipients]);
            }

            if (searchPreviewItem[XmlElementNames.CcRecipients]) {
                previewItem.CcRecipients = this.GetRecipients(searchPreviewItem[XmlElementNames.CcRecipients]);
            }

            if (searchPreviewItem[XmlElementNames.BccRecipients]) {
                previewItem.BccRecipients = this.GetRecipients(searchPreviewItem[XmlElementNames.BccRecipients]);
            }

            if (searchPreviewItem[XmlElementNames.CreatedTime]) {
                previewItem.CreatedTime = DateTime.Parse(searchPreviewItem[XmlElementNames.CreatedTime]);
            }

            if (searchPreviewItem[XmlElementNames.ReceivedTime]) {
                previewItem.ReceivedTime = DateTime.Parse(searchPreviewItem[XmlElementNames.ReceivedTime]);
            }

            if (searchPreviewItem[XmlElementNames.SentTime]) {
                previewItem.SentTime = DateTime.Parse(searchPreviewItem[XmlElementNames.SentTime]);
            }

            if (searchPreviewItem[XmlElementNames.Subject]) {
                previewItem.Subject = searchPreviewItem[XmlElementNames.Subject];
            }

            if (searchPreviewItem[XmlElementNames.Preview]) {
                previewItem.Preview = searchPreviewItem[XmlElementNames.Preview];
            }

            if (searchPreviewItem[XmlElementNames.Size]) {
                previewItem.Size = Convert.toNumber(searchPreviewItem[XmlElementNames.Size]);
            }

            if (searchPreviewItem[XmlElementNames.Importance]) {
                previewItem.Importance = Importance[<string>searchPreviewItem[XmlElementNames.Importance]];
            }

            if (searchPreviewItem[XmlElementNames.Read]) {
                previewItem.Read = Convert.toBool(searchPreviewItem[XmlElementNames.Read]);
            }

            if (searchPreviewItem[XmlElementNames.HasAttachment]) {
                previewItem.HasAttachment = Convert.toBool(searchPreviewItem[XmlElementNames.HasAttachment]);
            }

            if (searchPreviewItem[XmlElementNames.ExtendedProperties]) {
                previewItem.ExtendedProperties = this.LoadExtendedPropertiesXmlJsObject(searchPreviewItem[XmlElementNames.ExtendedProperties], service);
            }

            previewItems.push(previewItem);
        }
        return previewItems.length === 0 ? null : previewItems;
    }
}

/**
 * Represents search preview item.
 * 
 * @sealed
 */
export class SearchPreviewItem {

    /**
     * Item id
     */
    Id: ItemId = null;

    /**
     * Mailbox
     */
    Mailbox: PreviewItemMailbox = null;

    /**
     * Parent item id
     */
    ParentId: ItemId = null;

    /**
     * Item Class
     */
    ItemClass: string = null;

    /**
     * Unique hash
     */
    UniqueHash: string = null;

    /**
     * Sort Value
     */
    SortValue: string = null;

    /**
     * OWA Link
     */
    OwaLink: string = null;

    /**
     * Sender
     */
    Sender: string = null;

    /**
     * To recipients
     */
    ToRecipients: string[] = null;

    /**
     * Cc recipients
     */
    CcRecipients: string[] = null;

    /**
     * Bcc recipients
     */
    BccRecipients: string[] = null;

    /**
     * Created Time
     */
    CreatedTime: DateTime = null;

    /**
     * Received Time 
     */
    ReceivedTime: DateTime = null;

    /**
     * Sent Time
     */
    SentTime: DateTime = null;

    /**
     * Subject
     */
    Subject: string = null;

    /**
     * Item size
     */
    Size: number = 0;

    /**
     * Preview
     */
    Preview: string = null;

    /**
     * Importance
     */
    Importance: Importance = Importance.Low;

    /**
     * Read
     */
    Read: boolean = false;

    /**
     * Has attachment
     */
    HasAttachment: boolean = false;

    /**
     * Extended properties
     */
    ExtendedProperties: ExtendedPropertyCollection = null;
}

/**
 * Search refiner item
 */
export class SearchRefinerItem {

    /**
     * Refiner name
     */
    Name: string = null;

    /**
     * Refiner value
     */
    Value: string = null;

    /**
     * Refiner count
     */
    Count: number = 0;

    /**
     * Refiner token, essentially comprises of an operator (i.e. ':' or '>') plus the refiner value The caller such as Sharepoint can simply append this to refiner name for query refinement
     */
    Token: string = null;

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     * @return  {SearchRefinerItem}
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService): SearchRefinerItem {
        let sri: SearchRefinerItem = new SearchRefinerItem();
        sri.Name = jsObject[XmlElementNames.Name];
        sri.Value = jsObject[XmlElementNames.Value];
        sri.Count = Convert.toNumber(jsObject[XmlElementNames.Count]);
        sri.Token = jsObject[XmlElementNames.Token];
        return sri;
    }
}

/**
 * Represents set hold on mailboxes parameters.
 * 
 * @sealed
 */
export class SetHoldOnMailboxesParameters {

	/**
	 * Action type
	 */
	ActionType: HoldAction = HoldAction.Create;

	/**
	 * Hold id
	 */
	HoldId: string = null;

	/**
	 * Query
	 */
	Query: string = null;

	/**
	 * Collection of mailboxes
	 */
	Mailboxes: string[] = null;

	/**
	 * Query language
	 */
	Language: string = null;

	/**
	 * In-place hold identity
	 */
	InPlaceHoldIdentity: string = null;

	/**
     * Item hold period
     * *The text value can be "Unlimited" or the string value of any Timespan value.*
	 * 
	 * per github issue #120 
     */
    ItemHoldPeriod: string = null;
	
	/**
	 * Include Non Indexable Items
	 * 
	 * per github issue #120 
	 */
	IncludeNonIndexableItems: boolean = null;

	/**
	 * Perform deduplication
	 * 
	 * per github issue #120 
	 */
	PerformDeduplication: boolean = null;
}
/**
 * Interface IDiscoveryVersionable.
 * This interface will be used to store versioning information on the request
 *
 */
export interface IDiscoveryVersionable {

    /**
     * Gets or sets the server version.
     * 
     * @value The server version.
     */
    ServerVersion: number;//long
}

/**
 * Class Feature
 */
export class SchemaChange {

    /**
     * Gets the minimum server version.
     * 
     * @value The minimum server version. 
     */
    MinimumServerVersion: number = 0;//private set;l long

    /**
     * Initializes a new instance of the **SchemaChange** class.
     *
     * @param   {number}   serverVersion   The server version.
     */
    constructor(serverVersion: number);
    /**
     * Initializes a new instance of the **SchemaChange** class.
     *
     * @param   {string}   serverBuild   The server build.
     */
    constructor(serverBuild: string);
    constructor(serverVersionOrserverBuild: number | string) {
        if (typeof serverVersionOrserverBuild === 'number')
            this.MinimumServerVersion = serverVersionOrserverBuild;

        if (typeof serverVersionOrserverBuild === 'string') {
            let version = serverVersionOrserverBuild.split(".");
            let major = Convert.toNumber(version[0]) || 0;
            let minor = Convert.toNumber(version[1]) || 0;
            let build = Convert.toNumber(version[2]) || 0;
            let revision = Convert.toNumber(version[3]) || 0;

            this.MinimumServerVersion = (build & 0x7FFF) |
                ((minor & 0x3F) << 16) |
                ((major & 0x3F) << 22) |
                0x70008000;
            //                        System. Version Version = new Version(serverBuild);
            //
            //                        this.MinimumServerVersion = (version.Build & 0x7FFF) |
            //                                            ((version.Minor & 0x3F) << 16) |
            //                                            ((version.Major & 0x3F) << 22) |
            //                                            0x70008000;
        }
    }

    /**
     * Determines whether the specified versionable is compatible.
     *
     * @param   {IDiscoveryVersionable}   versionable   The versionable.
     * @return  {boolean}                 *true* if the specified versionable is compatible; otherwise, *false*.
     */
    IsCompatible(versionable: IDiscoveryVersionable): boolean {
        // note: when ServerVersion is not set(i.e., => 0), we ignore compatible check on the client side. It will eventually fail server side schema check if incompatible
        return versionable.ServerVersion == 0 || versionable.ServerVersion >= this.MinimumServerVersion;
    }
}

/**
 * Class DiscoverySchemaChanges
 * This class is a catalog of schema changes in discovery with the minimum server version in which they were introduced When making a schema change
 * - First make the server side changes and check them in
 * - Create SchemaChange() entry here for the change and the version at which it was checked int
 * - In the request
 *  - Implement IDiscoveryVersionable
 *  - In the Validate method verify if any new schema parameters are compatible if not error out
 *  - In the WriteXml method downgrade the schema based on compatability checks
 * Eg, SearchMailboxesRequest.cs
 *
 * @static
 */
export class DiscoverySchemaChanges {
    /**
     * Gets the search mailboxes extended data.
     * 
     * @value The search mailboxes extended data.
     */
    static SearchMailboxesExtendedData: SchemaChange = new SchemaChange("15.0.730.0");;

    /**
     * Gets the search mailboxes additional search scopes.
     * 
     * The search mailboxes additional search scopes.
     */
    static SearchMailboxesAdditionalSearchScopes: SchemaChange = new SchemaChange("15.0.730.0");;
}

/**
 * Represents information about an attendee for which to request availability information.
 * 
 * @sealed
 */
export class AttendeeInfo implements ISelfValidate {

    /**
     * Gets or sets the SMTP address of this attendee.
     */
    SmtpAddress: string = null;

    /** 
     * Gets or sets the type of this attendee.
     */
    AttendeeType: MeetingAttendeeType = MeetingAttendeeType.Required;

    /**
     * Gets or sets a value indicating whether times when this attendee is not available should be returned.
     */
    ExcludeConflicts: boolean = false;

    /**
     * Initializes a new instance of the **AttendeeInfo** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **AttendeeInfo** class.
     *
     * @param   {string}    smtpAddress        The SMTP address of the attendee.
     */
    constructor(smtpAddress: string);
    /**
     * Initializes a new instance of the **AttendeeInfo** class.
     *
     * @param   {string}                smtpAddress        The SMTP address of the attendee.
     * @param   {MeetingAttendeeType}   attendeeType       The yype of the attendee.
     * @param   {boolean}               excludeConflicts   Indicates whether times when this attendee is not available should be returned.
     */
    constructor(smtpAddress: string, attendeeType: MeetingAttendeeType, excludeConflicts: boolean);
    constructor(smtpAddress: string = null, attendeeType: MeetingAttendeeType = MeetingAttendeeType.Required, excludeConflicts: boolean = false) {
        this.SmtpAddress = smtpAddress;
        this.AttendeeType = attendeeType;
        this.ExcludeConflicts = excludeConflicts;
    }

    /**
     * Validates this instance.
     * 
     * ISelfValidate.Validate
     */
    Validate(): void {
        EwsUtilities.ValidateParam(this.SmtpAddress, "SmtpAddress");
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MailboxData);

        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Email);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Address, this.SmtpAddress);
        writer.WriteEndElement(); // Email

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.AttendeeType,
            MeetingAttendeeType[this.AttendeeType]);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.ExcludeConflicts,
            this.ExcludeConflicts);

        writer.WriteEndElement(); // MailboxData
    }
}
export class AvailabilityOptions {
    private mergedFreeBusyInterval: number = 30;
    private requestedFreeBusyView: FreeBusyViewType = FreeBusyViewType.Detailed;
    private goodSuggestionThreshold: number = 25;
    private maximumSuggestionsPerDay: number = 10;
    private maximumNonWorkHoursSuggestionsPerDay: number = 0;
    private meetingDuration: number = 60;
    private minimumSuggestionQuality: SuggestionQuality = SuggestionQuality.Fair;
    private detailedSuggestionsWindow: TimeWindow = null;
    private currentMeetingTime: DateTime = null;
    private globalObjectId: string = null;

    get MergedFreeBusyInterval(): number {
        return this.mergedFreeBusyInterval;
    }
    set MergedFreeBusyInterval(value: number) {
        if (value < 5 || value > 1440) {
            throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "MergedFreeBusyInterval", 5, 1440));//ArgumentException
        }
        this.mergedFreeBusyInterval = value;
    }
    get RequestedFreeBusyView(): FreeBusyViewType {
        return this.requestedFreeBusyView;
    }
    set RequestedFreeBusyView(value: FreeBusyViewType) {
        this.requestedFreeBusyView = value;
    }
    get GoodSuggestionThreshold(): number {
        return this.goodSuggestionThreshold;
    }
    set GoodSuggestionThreshold(value: number) {
        if (value < 1 || value > 49) {
            throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "GoodSuggestionThreshold", 1, 49));//ArgumentException
        }
        this.goodSuggestionThreshold = value;
    }
    get MaximumSuggestionsPerDay(): number {
        return this.maximumSuggestionsPerDay;
    }
    set MaximumSuggestionsPerDay(value: number) {
        if (value < 0 || value > 48) {
            throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "MaximumSuggestionsPerDay", 0, 48));//ArgumentException
        }
        this.maximumSuggestionsPerDay = value;
    }
    get MaximumNonWorkHoursSuggestionsPerDay(): number {
        return this.maximumNonWorkHoursSuggestionsPerDay;
    }
    set MaximumNonWorkHoursSuggestionsPerDay(value: number) {
        if (value < 0 || value > 48) {
            throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "MaximumNonWorkHoursSuggestionsPerDay", 0, 48));//ArgumentException
        }
        this.maximumNonWorkHoursSuggestionsPerDay = value;
    }
    get MeetingDuration(): number {
        return this.meetingDuration;
    }
    set MeetingDuration(value: number) {
        if (value < 30 || value > 1440) {
            throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "MeetingDuration", 30, 1440));//ArgumentException
        }
        this.meetingDuration = value;
    }
    get MinimumSuggestionQuality(): SuggestionQuality {
        return this.minimumSuggestionQuality;
    }
    set MinimumSuggestionQuality(value: SuggestionQuality) {
        this.minimumSuggestionQuality = value;
    }
    get DetailedSuggestionsWindow(): TimeWindow {
        return this.detailedSuggestionsWindow;
    }
    set DetailedSuggestionsWindow(value: TimeWindow) {
        this.detailedSuggestionsWindow = value;
    }
    get CurrentMeetingTime(): DateTime {
        return this.currentMeetingTime;
    }
    set CurrentMeetingTime(value: DateTime) {
        this.currentMeetingTime = value;
    }
    get GlobalObjectId(): string {
        return this.globalObjectId;
    }
    set GlobalObjectId(value: string) {
        this.globalObjectId = value;
    }
    Validate(timeWindow: TimeSpan): void {
        if (TimeSpan.FromMinutes(this.MergedFreeBusyInterval) > timeWindow) {
            throw new Error(Strings.MergedFreeBusyIntervalMustBeSmallerThanTimeWindow);//, "MergedFreeBusyInterval");//ArgumentException
        }

        EwsUtilities.ValidateParamAllowNull(this.DetailedSuggestionsWindow, "DetailedSuggestionsWindow");
    }
    /** @internal */
    WriteToXml(writer: EwsServiceXmlWriter, request: GetUserAvailabilityRequest): void {
        if (request.IsFreeBusyViewRequested) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.FreeBusyViewOptions);

            request.TimeWindow.WriteToXmlUnscopedDatesOnly(writer, XmlElementNames.TimeWindow);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.MergedFreeBusyIntervalInMinutes,
                this.MergedFreeBusyInterval);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.RequestedView,
                FreeBusyViewType[this.RequestedFreeBusyView]);

            writer.WriteEndElement(); // FreeBusyViewOptions
        }

        if (request.IsSuggestionsViewRequested) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.SuggestionsViewOptions);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.GoodThreshold,
                this.GoodSuggestionThreshold);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.MaximumResultsByDay,
                this.MaximumSuggestionsPerDay);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.MaximumNonWorkHourResultsByDay,
                this.MaximumNonWorkHoursSuggestionsPerDay);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.MeetingDurationInMinutes,
                this.MeetingDuration);

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.MinimumSuggestionQuality,
                SuggestionQuality[this.MinimumSuggestionQuality]);

            var timeWindowToSerialize: TimeWindow = this.DetailedSuggestionsWindow === null ?
                request.TimeWindow :
                this.DetailedSuggestionsWindow;

            timeWindowToSerialize.WriteToXmlUnscopedDatesOnly(writer, XmlElementNames.DetailedSuggestionsWindow);

            if (this.CurrentMeetingTime !== null) {
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.CurrentMeetingTime,
                    this.CurrentMeetingTime);
            }

            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.GlobalObjectId,
                this.GlobalObjectId);

            writer.WriteEndElement(); // SuggestionsViewOptions
        }
    }
}


export class GetUserAvailabilityResults {
    private attendeesAvailability: ServiceResponseCollection<AttendeeAvailability> = null;
    private suggestionsResponse: SuggestionsResponse = null;
    get SuggestionsResponse(): SuggestionsResponse {
        return this.suggestionsResponse;
    }
    set SuggestionsResponse(value: SuggestionsResponse) {
        this.suggestionsResponse = value;
    }
    get AttendeesAvailability(): ServiceResponseCollection<AttendeeAvailability> {
        return this.attendeesAvailability;
    }
    set AttendeesAvailability(value: ServiceResponseCollection<AttendeeAvailability>) {
        this.attendeesAvailability = value;
    }
    get Suggestions(): Suggestion[] {
        if (this.suggestionsResponse === null) {
            return null;
        }
        this.suggestionsResponse.ThrowIfNecessary();
        return this.suggestionsResponse.Suggestions;
    }
}

export class LegacyAvailabilityTimeZone extends ComplexProperty {
    private bias: TimeSpan = TimeSpan.Zero;
    private standardTime: LegacyAvailabilityTimeZoneTime;
    private daylightTime: LegacyAvailabilityTimeZoneTime;

    constructor();
    constructor(timeZoneInfo: TimeZoneInfo);
    constructor(timeZoneInfo: TimeZoneInfo = null) {
        super();
        //ref: skipping due to only called when server is 2007 sp1, 10 years later, may be not many cases to handle. 
        
        // if (timeZoneInfo && arguments.length === 1) {

        //     // Availability uses the opposite sign for the bias, e.g. if TimeZoneInfo.BaseUtcOffset = 480 than
        //     // SerializedTimeZone.Bias must be -480.
        //     this.bias = TimeSpan.FromMilliseconds(-timeZoneInfo.BaseUtcOffset.TotalMilliseconds);

        //     // To convert TimeZoneInfo into SerializableTimeZone, we need two time changes: one to Standard
        //     // time, the other to Daylight time. TimeZoneInfo holds a list of adjustment rules that represent
        //     // the different rules that govern time changes over the years. We need to grab one of those rules
        //     // to initialize this instance.
        //     let adjustmentRules: TimeZoneInfo.AdjustmentRule[] = timeZoneInfo.GetAdjustmentRules();

        //     if (adjustmentRules.length == 0) {
        //         // If there are no adjustment rules (which is the case for UTC), we have to come up with two
        //         // dummy time changes which both have a delta of zero and happen at two hard coded dates. This
        //         // simulates a time zone in which there are no time changes.
        //         this.daylightTime = new LegacyAvailabilityTimeZoneTime();
        //         this.daylightTime.Delta = TimeSpan.Zero;
        //         this.daylightTime.DayOrder = 1;
        //         this.daylightTime.DayOfTheWeek = DayOfTheWeek.Sunday;
        //         this.daylightTime.Month = 10;
        //         this.daylightTime.TimeOfDay = TimeSpan.FromHours(2);
        //         this.daylightTime.Year = 0;

        //         this.standardTime = new LegacyAvailabilityTimeZoneTime();
        //         this.standardTime.Delta = TimeSpan.Zero;
        //         this.standardTime.DayOrder = 1;
        //         this.standardTime.DayOfTheWeek = DayOfTheWeek.Sunday;
        //         this.standardTime.Month = 3;
        //         this.standardTime.TimeOfDay = TimeSpan.FromHours(2);
        //         this.daylightTime.Year = 0;
        //     }
        //     else {
        //         // When there is at least one adjustment rule, we need to grab the last one which is the
        //         // one that currently applies (TimeZoneInfo stores adjustment rules sorted from oldest to
        //         // most recent).
        //         let currentRule: TimeZoneInfo.AdjustmentRule = adjustmentRules[adjustmentRules.length - 1];

        //         this.standardTime = new LegacyAvailabilityTimeZoneTime(currentRule.DaylightTransitionEnd, TimeSpan.Zero);

        //         // Again, TimeZoneInfo and SerializableTime use opposite signs for bias.
        //         this.daylightTime = new LegacyAvailabilityTimeZoneTime(currentRule.DaylightTransitionStart, TimeSpan.FromMilliseconds(-currentRule.DaylightDelta.TotalMilliseconds));

        //     }
        // }
    }
    ToTimeZoneInfo(): TimeZoneInfo {
        if (this.daylightTime.HasTransitionTime &&
            this.standardTime.HasTransitionTime) {
            let adjustmentRule: TimeZoneInfo.AdjustmentRule = TimeZoneInfo.AdjustmentRule.CreateAdjustmentRule(
                DateTime.MinValue.Date,
                DateTime.MaxValue.Date,
                TimeSpan.FromMilliseconds(-this.daylightTime.Delta.TotalMilliseconds),
                this.daylightTime.ToTransitionTime(),
                this.standardTime.ToTransitionTime());

            return TimeZoneInfo.CreateCustomTimeZone(
                Guid.NewGuid().ToString(),
                TimeSpan.FromMilliseconds(-this.bias.TotalMilliseconds),
                "Custom time zone",
                "Standard time",
                "Daylight time",
                [adjustmentRule]);
        }
        else {
            // Create no DST time zone
            return TimeZoneInfo.CreateCustomTimeZone(
                Guid.NewGuid().ToString(),
                TimeSpan.FromMilliseconds(-this.bias.TotalMilliseconds),
                "Custom time zone",
                "Standard time");
        }
    }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.Bias:
                    this.bias = TimeSpan.FromMinutes(Number(jsonProperty[key]));
                    break;
                case XmlElementNames.StandardTime:
                    this.standardTime = new LegacyAvailabilityTimeZoneTime();
                    this.standardTime.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                case XmlElementNames.DaylightTime:
                    this.daylightTime = new LegacyAvailabilityTimeZoneTime();
                    this.daylightTime.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                default:
                    break;
            }
        }
    }
    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Bias,
            this.bias.TotalMinutes);

        this.standardTime.WriteToXml(writer, XmlElementNames.StandardTime);
        this.daylightTime.WriteToXml(writer, XmlElementNames.DaylightTime);
    }
}

export class LegacyAvailabilityTimeZoneTime extends ComplexProperty {
    get HasTransitionTime(): boolean { return this.Month >= 1 && this.Month <= 12; }
    Delta: TimeSpan = TimeSpan.Zero /*System.TimeSpan*/;
    TimeOfDay: TimeSpan = TimeSpan.Zero /*System.TimeSpan*/;
    DayOrder: number = 0;
    Month: number = 0;
    DayOfTheWeek: DayOfTheWeek = DayOfTheWeek.Sunday;
    Year: number = 0;
    // private delta: TimeSpan /*System.TimeSpan*/; //backing property not needed
    // private year: number;
    // private month: number;
    // private dayOrder: number;
    // private dayOfTheWeek: DayOfTheWeek;
    // private timeOfDay: TimeSpan /*System.TimeSpan*/;

    constructor() {
        super()
    }

    ToTransitionTime(): TimeZoneInfo.TransitionTime { 
        if (this.Year == 0)
            {
                return TimeZoneInfo.TransitionTime.CreateFloatingDateRule(
                    new DateTime(
                        DateTime.MinValue.Year,
                        DateTime.MinValue.Month,
                        DateTime.MinValue.Day,
                        this.TimeOfDay.Hours,
                        this.TimeOfDay.Minutes,
                        this.TimeOfDay.Seconds),
                    this.Month,
                    this.DayOrder,
                    EwsUtilities.EwsToSystemDayOfWeek(this.DayOfTheWeek));
            }
            else
            {
                return TimeZoneInfo.TransitionTime.CreateFixedDateRule(
                    new DateTime(this.TimeOfDay.TotalMilliseconds),
                    this.Month,
                    this.DayOrder);
            }
    }

    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.Bias:
                    this.Delta = TimeSpan.FromMinutes(Number(jsonProperty[key]));
                    break;
                case XmlElementNames.Time:
                    this.TimeOfDay = new TimeSpan(jsonProperty[key]);// momentjs taks care of parsing TimeSpan.Parse(jsonProperty[key]);
                    break;
                case XmlElementNames.DayOrder:
                    this.DayOrder = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.DayOfWeek:
                    this.DayOfTheWeek = <DayOfTheWeek><any>DayOfTheWeek[jsonProperty[key]];
                    break;
                case XmlElementNames.Month:
                    this.Month = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.Year:
                    this.Year = Number(jsonProperty[key]);
                    break;
                default:
                    break;
            }
        }
    }

    /**@internal */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Bias,
            this.Delta.TotalMinutes);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Time,
            EwsUtilities.TimeSpanToXSTime(this.TimeOfDay));

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.DayOrder,
            this.DayOrder);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Month,
            this.Month);

        // Only write DayOfWeek if this is a recurring time change
        if (this.Year == 0) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.DayOfWeek,
                DayOfTheWeek[this.DayOfTheWeek]);  // needs to be string
        }

        // Only emit year if it's non zero, otherwise AS returns "Request is invalid"
        if (this.Year != 0) {
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.Year,
                this.Year);
        }
    }
}

/**
 * Represents an Out of Office response.
 */
export class OofReply {

    private culture: string = ''; //todo: implement CultureInfo //  CultureInfo.CurrentCulture.Name;
    private message: string = null;
    
    /**
     * Gets or sets the culture of the reply.
     */
    get Culture(): string {
        return this.culture;
    }
    set Culture(value: string) {
        this.culture = value;
    }
    
    /**
     * Gets or sets the culture of the reply.
     */
    get Message(): string {
        return this.message;
    }
    set Message(value: string) {
        this.message = value;
    }

    /**
     * Initializes a new instance of the **OofReply** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **OofReply** class.
     *
     * @param   {string}   message   The reply message.
     */
    constructor(message: string);
    constructor(message: string = null) {
        this.message = message;
    }

    /**
     * @internal Loads from xmlJsObject.
     *
     * @param   {any}   jsObject   The xmlJsObject object.
     * @param   {ExchangeService}   service      The service.
     */
    LoadFromXmlJsObject(jsonObject: any, service: ExchangeService): void {
        if (jsonObject["xml:lang"]) {
            this.culture = jsonObject["xml:lang"];
        }
        this.message = jsonObject[XmlElementNames.Message];
    }

    /**
     * Obtains a string representation of the reply.
     *
     * @return  {string}      A string containing the reply message.
     */
    ToString(): string { return this.Message; }
    toString(): string { return this.Message; }

    /**
     * @internal Writes an empty OofReply to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    static WriteEmptyReplyToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void {
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);
        writer.WriteEndElement(); // xmlElementName
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void {
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);

        if (this.Culture != null) {
            writer.WriteAttributeValue(
                "xml",
                "lang",
                this.Culture);
        }

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.Message,
            this.Message);

        writer.WriteEndElement(); // xmlElementName
    }
}

/**
 * Represents a time period.
 * 
 * @sealed
 */
export class TimeWindow implements ISelfValidate {

    /**
     * Gets or sets the start date and time.
     */
    StartTime: DateTime;

    /**
     * Gets or sets the end date and time.
     */
    EndTime: DateTime;

    /**
     * @internal Gets the duration.
     */
    get Duration(): TimeSpan {
        return this.StartTime.Difference(this.EndTime);
    }

    /**
     * @internal Initializes a new instance of the **TimeWindow** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **TimeWindow** class.
     *
     * @param   {DateTime}   startTime   The start date and time.
     * @param   {DateTime}   endTime     The end date and time.
     */
    constructor(startTime: DateTime, endTime: DateTime);
    constructor(startTime: DateTime = null, endTime: DateTime = null) {
        this.StartTime = startTime;
        this.EndTime = endTime;
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsonObject: any, service: ExchangeService): void {
        this.StartTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsonObject[XmlElementNames.StartTime]);
        this.EndTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsonObject[XmlElementNames.EndTime]);
    }

    /**
     * Validates this instance.
     * 
     * ISelfValidate.Validate
     */
    Validate(): void {
        if (this.StartTime.CompareTo(this.EndTime) >= 0) {
            throw new ArgumentException(Strings.TimeWindowStartTimeMustBeGreaterThanEndTime);
        }
    }

    /**
     * Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     * @param   {any}                   startTime        The start time.
     * @param   {any}                   endTime          The end time.
     */
    private static WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string, startTime: any, endTime: any): void {
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.StartTime,
            startTime);

        writer.WriteElementValue(
            XmlNamespace.Types,
            XmlElementNames.EndTime,
            endTime);

        writer.WriteEndElement(); // xmlElementName
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void {
        TimeWindow.WriteToXml(
            writer,
            xmlElementName,
            this.StartTime,
            this.EndTime);
    }

    /**
     * @internal Writes to XML without scoping the dates and without emitting times.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXmlUnscopedDatesOnly(writer: EwsServiceXmlWriter, xmlElementName: string): void {
        const DateOnlyFormat: string = "YYYY-MM-DDT00:00:00";

        TimeWindow.WriteToXml(
            writer,
            xmlElementName,
            this.StartTime.Format(DateOnlyFormat),// CultureInfo.InvariantCulture),
            this.EndTime.Format(DateOnlyFormat)// CultureInfo.InvariantCulture));
        );
    }
}



/**
 * Represents the base class for Id expressed in a specific format.
 */
export abstract class AlternateIdBase implements ISelfValidate {//IJsonSerializable

    /**
     * Gets or sets the format in which the Id in expressed.
     */
    Format: IdFormat;

    /**
     * Initializes a new instance of the **AlternateIdBase** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **AlternateIdBase** class.
     *
     * @param   {IdFormat}   format   The format.
     */
    constructor(format: IdFormat);
    constructor(format: IdFormat = IdFormat.EwsLegacyId) {
        this.Format = format;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    abstract GetXmlElementName(): string;

    /**
     * @internal Validate this instance.
     */
    InternalValidate(): void { }

    /**
     * @internal Loads the attributes from Xml JsObject.
     *
     * @param   {any}   responseObject   The response object.
     */
    LoadAttributesFromXmlJsObject(responseObject: any): void {
        this.Format = IdFormat[<string>responseObject[XmlAttributeNames.Format]];
    }

    /**
     * Validate this instance.
     * ISelfValidate.Validate
     * 
     */
    Validate(): void {
        this.InternalValidate();
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.Format, IdFormat[this.Format]);
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, this.GetXmlElementName());

        this.WriteAttributesToXml(writer);

        writer.WriteEndElement(); // this.GetXmlElementName()
    }
}

/**
 * Represents an Id expressed in a specific format.
 */
export class AlternateId extends AlternateIdBase {

    /**
     * @internal Name of schema type used for AlternateId.
     */
    static SchemaTypeName: string = "AlternateIdType";

    /**
     * Gets or sets the Id.
     */
    UniqueId: string = null;

    /**
     * Gets or sets the mailbox to which the Id belongs.
     */
    Mailbox: string = null;

    /**
     * Gets or sets the type (primary or archive) mailbox to which the Id belongs.
     */
    IsArchive: boolean = false;

    /**
     * Initializes a new instance of the **AlternateId** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **AlternateId** class.
     *
     * @param   {IdFormat}  format      The format the Id is expressed in.
     * @param   {string}    id          The Id.
     * @param   {string}    mailbox     The SMTP address of the mailbox that the Id belongs to.
     */
    constructor(format: IdFormat, id: string, mailbox: string);
    /**
     * Initializes a new instance of the **AlternateId** class.
     *
     * @param   {IdFormat}  format      The format the Id is expressed in.
     * @param   {string}    id          The Id.
     * @param   {string}    mailbox     The SMTP address of the mailbox that the Id belongs to.
     * @param   {boolean}   isArchive   Primary (false) or archive (true) mailbox.
     */
    constructor(format: IdFormat, id: string, mailbox: string, isArchive: boolean);
    constructor(format: IdFormat = IdFormat.EwsLegacyId, id: string = null, mailbox: string = null, isArchive: boolean = false) {
        super(format);
        this.UniqueId = id;
        this.Mailbox = mailbox;
        this.IsArchive = isArchive;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.AlternateId;
    }

    /**
     * @internal Validate this instance.
     */
    InternalValidate(): void {
        EwsUtilities.ValidateParam(this.Mailbox, "mailbox");
    }

    /**
     * @internal Loads the attributes from Xml JsObject.
     *
     * @param   {any}   responseObject   The response object.
     */
    LoadAttributesFromXmlJsObject(responseObject: any): void {
        super.LoadAttributesFromXmlJsObject(responseObject);

        this.UniqueId = responseObject[XmlAttributeNames.Id];
        this.Mailbox = responseObject[XmlAttributeNames.Mailbox];

        if (responseObject[XmlAttributeNames.IsArchive]) {

            this.IsArchive = Convert.toBool(responseObject[XmlAttributeNames.IsArchive]);
        }
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        writer.WriteAttributeValue(XmlAttributeNames.Id, this.UniqueId);
        writer.WriteAttributeValue(XmlAttributeNames.Mailbox, this.Mailbox);

        // this is optional attribute will default false so we will write
        // it only if it is true
        if (this.IsArchive) {
            writer.WriteAttributeValue(XmlAttributeNames.IsArchive, true);
        }
    }
}

/**
 * Represents the Id of a public folder expressed in a specific format.
 */
export class AlternatePublicFolderId extends AlternateIdBase {

    /**
     * @internal Name of schema type used for AlternatePublicFolderId element.
     */
    static SchemaTypeName: string = "AlternatePublicFolderIdType";

    /**
     * The Id of the public folder.
     */
    FolderId: string = null;

    /**
     * Initializes a new instance of **AlternatePublicFolderId** class.
     */
    constructor();
    /**
     * Initializes a new instance of **AlternatePublicFolderId** class.
     *
     * @param   {IdFormat}   format     The format in which the public folder Id is expressed.
     * @param   {string}   folderId   The Id of the public folder.
     */
    constructor(format: IdFormat, folderId: string);
    constructor(format: IdFormat = IdFormat.EwsLegacyId, folderId: string = null) {
        super(format);
        this.FolderId = folderId;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.AlternatePublicFolderId;
    }

    /**
     * @internal Loads the attributes from Xml JsObject.
     *
     * @param   {any}   responseObject   The response object.
     */
    LoadAttributesFromXmlJsObject(responseObject: any): void {
        super.LoadAttributesFromXmlJsObject(responseObject);

        this.FolderId = responseObject[XmlAttributeNames.FolderId];
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        writer.WriteAttributeValue(XmlAttributeNames.FolderId, this.FolderId);
    }
}

/**
 * Represents the Id of a public folder item expressed in a specific format.
 */
export class AlternatePublicFolderItemId extends AlternatePublicFolderId {

    /**
     * @internal Schema type associated with AlternatePublicFolderItemId.
     */
    static SchemaTypeName: string = "AlternatePublicFolderItemIdType";

    /**
     * Item id.
     */
    private itemId: string;

    /**
     * The Id of the public folder item.
     */
    public get ItemId(): string {
        return this.itemId;
    }
    public set ItemId(v: string) {
        this.itemId = v;
    }

    /**
     * Initializes a new instance of the **AlternatePublicFolderItemId** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **AlternatePublicFolderItemId** class.
     *
     * @param   {IdFormat}  format     The format in which the public folder item Id is expressed.
     * @param   {string}    folderId   The Id of the parent public folder of the public folder item.
     * @param   {string}    itemId     The Id of the public folder item.
     */
    constructor(format: IdFormat, folderId: string, itemId: string);
    constructor(format: IdFormat = IdFormat.EwsLegacyId, folderId: string = null, itemId: string = null) {
        super(format, folderId);
        this.itemId = itemId;
    }

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.AlternatePublicFolderItemId;
    }

    /**
     * @internal Loads the attributes from Xml JsObject.
     *
     * @param   {any}   responseObject   The response object.
     */
    LoadAttributesFromXmlJsObject(responseObject: any): void {
        super.LoadAttributesFromXmlJsObject(responseObject);

        this.itemId = responseObject[XmlAttributeNames.ItemId];
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        super.WriteAttributesToXml(writer);

        writer.WriteAttributeValue(XmlAttributeNames.ItemId, this.ItemId);
    }
}

/**
 * Represents the results of an action performed on a calendar item or meeting message, such as accepting, tentatively accepting or declining a meeting request.
 * 
 * @sealed
 */
export class CalendarActionResults {
	
	/**
 	 * Gets the meeting that was accepted, tentatively accepted or declined.
	 *
 	 * Remark - When a meeting is accepted or tentatively accepted via an Appointment object,
     * EWS recreates the meeting, and Appointment represents that new version.
     * When a meeting is accepted or tentatively accepted via a MeetingRequest object,
     * EWS creates an associated meeting in the attendee's calendar and Appointment
     * represents that meeting.
     * When declining a meeting via an Appointment object, EWS moves the appointment to
     * the attendee's Deleted Items folder and Appointment represents that moved copy.
     * When declining a meeting via a MeetingRequest object, EWS creates an associated
     * meeting in the attendee's Deleted Items folder, and Appointment represents that
     * meeting.
     * When a meeting is declined via either an Appointment or a MeetingRequest object
     * from the Deleted Items folder, Appointment is null.
 	 */
	get Appointment(): Appointment { return this.appointment; }
	
	/**
	 * Gets the meeting request that was moved to the Deleted Items folder as a result of an attendee accepting, tentatively accepting or declining a meeting request. If the meeting request is accepted, tentatively accepted or declined from the Deleted Items folder, it is permanently deleted and MeetingRequest is null.
	 *
	 */
	get MeetingRequest(): MeetingRequest { return this.meetingRequest; }
	
	/**
	 * Gets the copy of the response that is sent to the organizer of a meeting when the meeting is accepted, tentatively accepted or declined by an attendee. MeetingResponse is null if the attendee chose not to send a response.
	 *
	 */
	get MeetingResponse(): MeetingResponse { return this.meetingResponse; }
	
	/**
	 * Gets the copy of the meeting cancellation message sent by the organizer to the attendees of a meeting when the meeting is cancelled.
	 *
	 */
	get MeetingCancellation(): MeetingCancellation { return this.meetingCancellation; }
	
	private appointment: Appointment;
	private meetingRequest: MeetingRequest;
	private meetingResponse: MeetingResponse;
	private meetingCancellation: MeetingCancellation;

	/**
	 * @internal Initializes a new instance of the **CalendarActionResults** class.
	 *
	 * @param   {Item[]}   items   Collection of items that were created or modified as a result of a calendar action.
	 */	
	constructor(items: Item[]) {
		this.appointment = EwsUtilities.FindFirstItemOfType<Appointment>(items, TypeContainer.Appointment);
		this.meetingRequest = EwsUtilities.FindFirstItemOfType<MeetingRequest>(items, TypeContainer.MeetingRequest);
		this.meetingResponse = EwsUtilities.FindFirstItemOfType<MeetingResponse>(items, TypeContainer.MeetingResponse);
		this.meetingCancellation = EwsUtilities.FindFirstItemOfType<MeetingCancellation>(items, TypeContainer.MeetingCancellation);
	}
}

/**
 * @internal ConversationAction class that represents ConversationActionType in the request XML.
 * This class really is meant for representing single ConversationAction that needs to be taken on a conversation.
 */
export class ConversationAction {//IJsonSerializable

    /**
     * @internal Gets or sets conversation action
     */
    Action: ConversationActionType = ConversationActionType.AlwaysCategorize;

    /**
     * @internal Gets or sets conversation id
     */
    ConversationId: ConversationId = null;

    /**
     * @internal Gets or sets ProcessRightAway
     */
    ProcessRightAway: boolean = false;

    /**
     * @internal Gets or set conversation categories for Always Categorize action
     */
    Categories: StringList = null;

    /**
     * @internal Gets or sets Enable Always Delete value for Always Delete action
     */
    EnableAlwaysDelete: boolean = false;

    /**
     * @internal Gets or sets the IsRead state. :Nullable
     */
    IsRead: boolean = null; //Nullable

    /**
     * @internal Gets or sets the SuppressReadReceipts flag.
     */
    SuppressReadReceipts: boolean = null; //Nullable

    /**
     * @internal Gets or sets the Deletion mode.
     */
    DeleteType: DeleteMode = null; //Nullable

    /**
     * @internal Gets or sets the flag.
     */
    Flag: Flag = null;

    /**
     * @internal ConversationLastSyncTime is used in one time action to determine the items on which to take the action.
     */
    ConversationLastSyncTime: DateTime = null; //Nullable

    /**
     * @internal Gets or sets folder id ContextFolder
     */
    ContextFolderId: FolderIdWrapper = null;

    /**
     * @internal Gets or sets folder id for Move action
     */
    DestinationFolderId: FolderIdWrapper = null;

    /**
     * @internal Gets or sets the retention policy type.
     */
    RetentionPolicyType: RetentionType = null; //Nullable

    /**
     * @internal Gets or sets the retention policy tag id.
     */
    RetentionPolicyTagId: Guid = null; //Nullable

    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetXmlElementName(): string {
        return XmlElementNames.ApplyConversationAction;
    }

    /**
     * @internal Validate request.
     */
    Validate(): void {
        EwsUtilities.ValidateParam(this.ConversationId, "conversationId");
    }

    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(
            XmlNamespace.Types,
            XmlElementNames.ConversationAction);
        try {
            let actionValue: string = StringHelper.Empty;
            switch (this.Action) {
                case ConversationActionType.AlwaysCategorize:
                    actionValue = XmlElementNames.AlwaysCategorize;
                    break;
                case ConversationActionType.AlwaysDelete:
                    actionValue = XmlElementNames.AlwaysDelete;
                    break;
                case ConversationActionType.AlwaysMove:
                    actionValue = XmlElementNames.AlwaysMove;
                    break;
                case ConversationActionType.Delete:
                    actionValue = XmlElementNames.Delete;
                    break;
                case ConversationActionType.Copy:
                    actionValue = XmlElementNames.Copy;
                    break;
                case ConversationActionType.Move:
                    actionValue = XmlElementNames.Move;
                    break;
                case ConversationActionType.SetReadState:
                    actionValue = XmlElementNames.SetReadState;
                    break;
                case ConversationActionType.SetRetentionPolicy:
                    actionValue = XmlElementNames.SetRetentionPolicy;
                    break;
                case ConversationActionType.Flag:
                    actionValue = XmlElementNames.Flag;
                    break;
                default:
                    throw new ArgumentException("ConversationAction");
            }

            // Emit the action element
            writer.WriteElementValue(
                XmlNamespace.Types,
                XmlElementNames.Action,
                actionValue);

            // Emit the conversation id element
            this.ConversationId.WriteToXml(
                writer,
                XmlElementNames.ConversationId,
                XmlNamespace.Types
            );

            if (this.Action == ConversationActionType.AlwaysCategorize ||
                this.Action == ConversationActionType.AlwaysDelete ||
                this.Action == ConversationActionType.AlwaysMove) {
                // Emit the ProcessRightAway element
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.ProcessRightAway,
                    EwsUtilities.BoolToXSBool(this.ProcessRightAway));
            }

            if (this.Action == ConversationActionType.AlwaysCategorize) {
                // Emit the categories element
                if (this.Categories != null && this.Categories.Count > 0) {
                    this.Categories.WriteToXml(
                        writer,
                        XmlElementNames.Categories,
                        XmlNamespace.Types);
                }
            }
            else if (this.Action == ConversationActionType.AlwaysDelete) {
                // Emit the EnableAlwaysDelete element
                writer.WriteElementValue(
                    XmlNamespace.Types,
                    XmlElementNames.EnableAlwaysDelete,
                    EwsUtilities.BoolToXSBool(this.EnableAlwaysDelete));
            }
            else if (this.Action == ConversationActionType.AlwaysMove) {
                // Emit the Move Folder Id
                if (this.DestinationFolderId != null) {
                    writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.DestinationFolderId);
                    this.DestinationFolderId.WriteToXml(writer);
                    writer.WriteEndElement();
                }
            }
            else {
                if (this.ContextFolderId != null) {
                    writer.WriteStartElement(
                        XmlNamespace.Types,
                        XmlElementNames.ContextFolderId);

                    this.ContextFolderId.WriteToXml(writer);

                    writer.WriteEndElement();
                }

                if (this.ConversationLastSyncTime) {
                    writer.WriteElementValue(
                        XmlNamespace.Types,
                        XmlElementNames.ConversationLastSyncTime,
                        this.ConversationLastSyncTime);
                }

                if (this.Action == ConversationActionType.Copy) {
                    EwsLogging.Assert(
                        this.DestinationFolderId != null,
                        "ApplyconversationActionRequest",
                        "DestinationFolderId should be set when performing copy action");

                    writer.WriteStartElement(
                        XmlNamespace.Types,
                        XmlElementNames.DestinationFolderId);
                    this.DestinationFolderId.WriteToXml(writer);
                    writer.WriteEndElement();
                }
                else if (this.Action == ConversationActionType.Move) {
                    EwsLogging.Assert(
                        this.DestinationFolderId != null,
                        "ApplyconversationActionRequest",
                        "DestinationFolderId should be set when performing move action");

                    writer.WriteStartElement(
                        XmlNamespace.Types,
                        XmlElementNames.DestinationFolderId);
                    this.DestinationFolderId.WriteToXml(writer);
                    writer.WriteEndElement();
                }
                else if (this.Action == ConversationActionType.Delete) {
                    EwsLogging.Assert(
                        this.DeleteType != null,
                        "ApplyconversationActionRequest",
                        "DeleteType should be specified when deleting a conversation.");

                    writer.WriteElementValue(
                        XmlNamespace.Types,
                        XmlElementNames.DeleteType,
                        DeleteMode[this.DeleteType]);
                }
                else if (this.Action == ConversationActionType.SetReadState) {
                    EwsLogging.Assert(
                        this.IsRead != null,
                        "ApplyconversationActionRequest",
                        "IsRead should be specified when marking/unmarking a conversation as read.");

                    writer.WriteElementValue(
                        XmlNamespace.Types,
                        XmlElementNames.IsRead,
                        this.IsRead);

                    if (hasValue(this.SuppressReadReceipts)) {
                        writer.WriteElementValue(
                            XmlNamespace.Types,
                            XmlElementNames.SuppressReadReceipts,
                            this.SuppressReadReceipts);
                    }
                }
                else if (this.Action == ConversationActionType.SetRetentionPolicy) {
                    EwsLogging.Assert(
                        this.RetentionPolicyType != null,
                        "ApplyconversationActionRequest",
                        "RetentionPolicyType should be specified when setting a retention policy on a conversation.");

                    writer.WriteElementValue(
                        XmlNamespace.Types,
                        XmlElementNames.RetentionPolicyType,
                        RetentionType[this.RetentionPolicyType]);

                    if (this.RetentionPolicyTagId) {
                        writer.WriteElementValue(
                            XmlNamespace.Types,
                            XmlElementNames.RetentionPolicyTagId,
                            this.RetentionPolicyTagId.ToString());
                    }
                }
                else if (this.Action == ConversationActionType.Flag) {
                    EwsLogging.Assert(
                        this.Flag != null,
                        "ApplyconversationActionRequest",
                        "Flag should be specified when flagging conversation items.");

                    writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Flag);
                    this.Flag.WriteElementsToXml(writer);
                    writer.WriteEndElement();
                }
            }
        }
        finally {
            writer.WriteEndElement();
        }
    }
}

/**
 * Represents the results of a GetDelegates operation.
 * 
 * @sealed
 */
export class DelegateInformation {

	private delegateUserResponses: DelegateUserResponse[];
	private meetingReqestsDeliveryScope: MeetingRequestsDeliveryScope = MeetingRequestsDeliveryScope.DelegatesOnly;

	/**
	 * Gets a list of responses for each of the delegate users concerned by the operation.
	 */
	get DelegateUserResponses(): DelegateUserResponse[] {
		return this.delegateUserResponses;
	}

	/**
	 * Gets a value indicating if and how meeting requests are delivered to delegates.
	 */
	get MeetingRequestsDeliveryScope(): MeetingRequestsDeliveryScope {
		return this.meetingReqestsDeliveryScope;
	}

	/**
	 * @internal Initializes a **DelegateInformation** object
	 *
	 * @param   {DelegateUserResponse[]}   		delegateUserResponses         List of DelegateUserResponses from a GetDelegates request
	 * @param   {MeetingRequestsDeliveryScope}	meetingReqestsDeliveryScope   MeetingRequestsDeliveryScope from a GetDelegates request.
	 */
	constructor(delegateUserResponses: DelegateUserResponse[], meetingReqestsDeliveryScope: MeetingRequestsDeliveryScope) {
		this.delegateUserResponses = delegateUserResponses || [];
		this.meetingReqestsDeliveryScope = meetingReqestsDeliveryScope;
	}
}


//no change needed
export interface ComplexPropertyChangedDelegate {
    (complexProperty: ComplexProperty): void;
}
//no change needed
export interface GetObjectInstanceDelegate<T> {
    (service: ExchangeService, xmlElementName: string): T;
}

export interface CustomXmlSerializationDelegate {
    (writer: any /*System.Xml.XmlWriter*/): any;
}
//class CustomXmlSerializationDelegate extends System.MulticastDelegate {
//    //BeginInvoke(writer: System.Xml.XmlWriter, callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
//    //EndInvoke(result: System.IAsyncResult): any{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
//    //Invoke(writer: System.Xml.XmlWriter): any{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
//}

export interface ResponseHeadersCapturedHandler {
    (responseHeaders: any /*System.Net.WebHeaderCollection*/): any;
}
//class ResponseHeadersCapturedHandler extends System.MulticastDelegate {
//    //BeginInvoke(responseHeaders: System.Net.WebHeaderCollection, callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
//    //EndInvoke(result: System.IAsyncResult): any{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
//    //Invoke(responseHeaders: System.Net.WebHeaderCollection): any{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
//}


export interface ServiceObjectChangedDelegate {
    (serviceObject: ServiceObject): void;
}
//class ServiceObjectChangedDelegate extends System.MulticastDelegate {
//    //BeginInvoke(serviceObject: ServiceObject, callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
//    //EndInvoke(result: System.IAsyncResult): any{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
//    //Invoke(serviceObject: ServiceObject): any{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
//}


export interface PropertyBagChangedDelegate {
    (): void;
}
//class PropertyBagChangedDelegate extends System.MulticastDelegate {
//    //BeginInvoke(callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
//    //EndInvoke(result: System.IAsyncResult): any{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
//    //Invoke(): any{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
//}





////// ---- do not belong here, need to have some place for them.


export interface GetPropertyDefinitionCallback {
    (version: ExchangeVersion): PropertyDefinition;
}
export interface CreateComplexPropertyDelegate<TComplexProperty extends ComplexProperty> {
    (): TComplexProperty;
}
    //class GetPropertyDefinitionCallback extends System.MulticastDelegate {
    //    //BeginInvoke(version: ExchangeVersion, callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
    //    //EndInvoke(result: System.IAsyncResult): PropertyDefinition{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
    //    //Invoke(version: ExchangeVersion): PropertyDefinition{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
    //}

    //class CreateComplexPropertyDelegate<TComplexProperty> extends System.MulticastDelegate {
    //    //BeginInvoke(callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
    //    //EndInvoke(result: System.IAsyncResult): TComplexProperty{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
    //    //Invoke(): TComplexProperty{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
    //}


export interface CreateServiceObjectWithServiceParam {
    (srv: ExchangeService): any;
}

export interface CreateServiceObjectWithAttachmentParam {
    (itemAttachment: ItemAttachment, isNew: boolean): any
}

    //class CreateServiceObjectWithAttachmentParam extends System.MulticastDelegate {
    //    BeginInvoke(itemAttachment: ItemAttachment, isNew: boolean, callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
    //    EndInvoke(result: System.IAsyncResult): any{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
    //    Invoke(itemAttachment: ItemAttachment, isNew: boolean): any{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
    //}
    //class CreateServiceObjectWithServiceParam extends System.MulticastDelegate {
    //    BeginInvoke(srv: ExchangeService, callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
    //    EndInvoke(result: System.IAsyncResult): any{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
    //    Invoke(srv: ExchangeService): any{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
    //}

export class EwsTraceListener {
	private writer: any /*System.IO.TextWriter*/;
	Trace(traceType: string, traceMessage: string): void{ throw new Error("EwsTraceListener.ts - Trace : Not implemented.");}
}






			

/**
 * Represents the results of an ExpandGroup operation.
 * 
 * @sealed
 */
export class ExpandGroupResults implements IEnumerable<EmailAddress> {

	/**
	 * True, if all members are returned.
	 * EWS always returns true on ExpandDL, i.e. all members are returned. 
	 */
	private includesAllMembers: boolean = false;

	/**
	 * DL members.
	 */
	private members: EmailAddress[] = [];

	/**
	 * Gets the number of members that were returned by the ExpandGroup operation. 
	 * Count might be less than the total number of members in the group, in which case the value of the IncludesAllMembers is false.
	 */
	get Count(): number {
		return this.members.length;
	}

	/**
	 * Gets a value indicating whether all the members of the group have been returned by ExpandGroup.
	 */
	get IncludesAllMembers(): boolean {
		return this.includesAllMembers;
	}

	/**
	 * Gets the members of the expanded group.
	 */
	get Members(): EmailAddress[] {
		return this.members;
	}

	/**
	 * @internal Initializes a new instance of the **ExpandGroupResults** class.
	 */
	constructor() {
	}

	/**
     *  Returns an enumerator that iterates through the collection. this case this.members
     */
	GetEnumerator(): EmailAddress[] {
		return this.members;
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
	LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {

		var dlResponse = jsObject[XmlElementNames.DLExpansion];
		var mailboxes = EwsServiceJsonReader.ReadAsArray(dlResponse, XmlElementNames.Mailbox);
		this.includesAllMembers = Convert.toBool(dlResponse[XmlAttributeNames.IncludesLastItemInRange]);
		var mailboxCount = Convert.toNumber(dlResponse[XmlAttributeNames.TotalItemsInView]);

		for (var mailbox of mailboxes) {
			var emailAddress = new EmailAddress();
			emailAddress.LoadFromXmlJsObject(mailbox, service);
			this.members.push(emailAddress);
		}
	}
}

/**
 * @internal Represents a list a abstracted folder Ids.
 */
export class FolderIdWrapperList implements IEnumerable<AbstractFolderIdWrapper> {

    /**
     * List of AbstractFolderIdWrapper.
     */
    private ids: AbstractFolderIdWrapper[] = [];

    /**
     * Gets the id count.
     * 
     * @value   The count.
     */
    get Count(): number {
        return this.ids.length;
    }

    /**
     * @internal Gets the **AbstractFolderIdWrapper** at the specified index.
     *
     * @param   {}   index   the index
     */
    _getItem(index: number): AbstractFolderIdWrapper {
        return this.ids[index];
    }

    /**
     * @internal Adds the specified folder.
     *
     * @param   {Folder}   folder   The folder.
     */
    Add(folder: Folder): void;
    /**
     * @internal Adds the specified folder id.
     *
     * @param   {FolderId}   folderId   The folder id.
     */
    Add(folderId: FolderId): void;
    /** @internal this is to shim add method with easy use within file/module. */
    Add(folderOrId: Folder | FolderId): void;
    Add(folderOrId: Folder | FolderId): void {

        if (folderOrId instanceof Folder)
            this.ids.push(new FolderWrapper(folderOrId))
        else if (folderOrId instanceof FolderId)
            this.ids.push(new FolderIdWrapper(folderOrId));
        else
            throw new Error("FolderIdWrapperList.ts - Add - should not be seeing this.");
    }

    /**
     * Adds the range.
     *
     * @param   {Folder[]}   folders   The folders.
     */
    AddRange(folders: Folder[]): void;
    /**
     * Adds the range of folder ids.
     *
     * @param   {FolderId[]}   folderIds   The folder ids.
     */
    AddRange(folderIds: FolderId[]): void;
    AddRange(foldersOrIds: Folder[] | FolderId[]): void {
        if (foldersOrIds != null) {
            for (var folderOrId of foldersOrIds) {
                this.Add(folderOrId);
            }
        }
    }

    /**
     *  Returns an enumerator that iterates through the collection. this case this.ids
     */
    GetEnumerator(): AbstractFolderIdWrapper[] {
        return this.ids;
    }

    /**
     * @internal Validates list of folderIds against a specified request version.
     *
     * @param   {ExchangeVersion}   version   The version.
     */
    Validate(version: ExchangeVersion): void {
        for (var folderIdWrapper of this.ids) {
            //var folderIdWrapper: AbstractFolderIdWrapper = item;
            folderIdWrapper.Validate(version);
        }
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          ewsNamesapce     The ews namesapce.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, ewsNamesapce: XmlNamespace, xmlElementName: string): void {
        if (this.Count > 0) {
            writer.WriteStartElement(ewsNamesapce, xmlElementName);

            for (var folderIdWrapper of this.ids) {
                //var folderIdWrapper: AbstractFolderIdWrapper = item;
                folderIdWrapper.WriteToXml(writer);
            }

            writer.WriteEndElement();
        }
    }
}
//import ExchangeService = require("../Core/ExchangeService");
//			
// class HangingTraceStream extends System.IO.Stream {
//	CanRead: boolean;
//	CanSeek: boolean;
//	CanWrite: boolean;
//	Length: number;
//	Position: number;
//	private underlyingStream: any /*System.IO.Stream*/;
//	private service: ExchangeService;
//	private responseCopy: any /*System.IO.MemoryStream*/;
//	Flush(): void{ throw new Error("HangingTraceStream.ts - Flush : Not implemented.");}
//	Read(buffer: any /*System.Byte[]*/, offset: number, count: number): number{ throw new Error("HangingTraceStream.ts - Read : Not implemented.");}
//	Seek(offset: number, origin: any /*System.IO.SeekOrigin*/): number{ throw new Error("HangingTraceStream.ts - Seek : Not implemented.");}
//	SetLength(value: number): void{ throw new Error("HangingTraceStream.ts - SetLength : Not implemented.");}
//	SetResponseCopy(responseCopy: any /*System.IO.MemoryStream*/): void{ throw new Error("HangingTraceStream.ts - SetResponseCopy : Not implemented.");}
//	Write(buffer: any /*System.Byte[]*/, offset: number, count: number): void{ throw new Error("HangingTraceStream.ts - Write : Not implemented.");}
//}
//export = HangingTraceStream;





			
    //todo: should be done
export class ImpersonatedUserId {
        IdType: ConnectingIdType;
        Id: string;
        //private idType: ConnectingIdType;
        //private id: string;

        constructor(idType?: ConnectingIdType, id?: string) {
            this.IdType = idType;
            this.Id = id;
        }

        /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter): void {
            if (!this.Id || this.Id === "") {
                throw new Error("Id property must be set before serialization");// ArgumentException(Strings.IdPropertyMustBeSet);
            }

            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ExchangeImpersonation);
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ConnectingSID);

            // For 2007 SP1, use PrimarySmtpAddress for type SmtpAddress
            var connectingIdTypeLocalName =
                (this.IdType == ConnectingIdType.SmtpAddress) && (writer.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1)
                    ? XmlElementNames.PrimarySmtpAddress
                    : ConnectingIdType[this.IdType];

            writer.WriteElementValue(
                XmlNamespace.Types,
                connectingIdTypeLocalName,
                this.Id);

            writer.WriteEndElement(); // ConnectingSID
            writer.WriteEndElement(); // ExchangeImpersonation
        }
    }

/**
 * @internal Represents a list a abstracted item Ids.
 */
export class ItemIdWrapperList implements IEnumerable<AbstractItemIdWrapper>{

    /**
     * List of ItemIdWrapper
     */
    private itemIds: AbstractItemIdWrapper[] = [];

    /**
     * @internal Gets the count.
     * 
     * @value   The count.
     */
    get Count(): number {
        return this.itemIds.length;
    }

    /**
     * @internal Initializes a new instance of the **ItemIdWrapperList** class.
     */
    constructor() {
    }

    /**
     * Gets the *Item* at the specified index.
     *
     * @param   {number}   index   the index
     */
    _getItem(index: number): Item {
        return this.itemIds[index].GetItem();
    }

    /**
     * @internal Adds the specified item id.
     *
     * @param   {ItemId}   itemId   The item id.
     */
    Add(itemId: ItemId): void;
    /**
     * @internal Adds the specified item.
     *
     * @param   {Item}   item   The item.
     */
    Add(item: Item): void;
    /**this is to shim add method with easy use within file/module. */
    Add(itemOrId: Item | ItemId): void;
    Add(itemOrId: Item | ItemId): void {
        if (itemOrId instanceof Item)
            this.itemIds.push(new ItemWrapper(itemOrId))
        else if (itemOrId instanceof ItemId)
            this.itemIds.push(new ItemIdWrapper(itemOrId));
        else
            throw new Error("FolderIdWrapperList.ts - Add - should not be seeing this.");
    }

    /**
     * @internal Adds the range.
     *
     * @param   {ItemId}   itemIds   The item ids.
     */
    AddRange(itemIds: ItemId[]): void;
    /**
     * @internal Adds the range.
     *
     * @param   {Item[]}   items   The items.
     */
    AddRange(items: Item[]): void;
    AddRange(itemsOrIds: Item[] | ItemId[]): void {
        if (itemsOrIds != null) {
            for (var itemOrId of itemsOrIds) {
                this.Add(itemOrId);
            }
        }
    }

    /**
     *  Returns an enumerator that iterates through the collection. this case this.itemIds
     */
    GetEnumerator(): AbstractItemIdWrapper[] {
        return this.itemIds;
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          ewsNamesapce     The ews namesapce.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, ewsNamesapce: XmlNamespace, xmlElementName: string): void {
        if (this.Count > 0) {
            writer.WriteStartElement(ewsNamesapce, xmlElementName);

            for (var itemIdWrapper of this.itemIds) {
                itemIdWrapper.WriteToXml(writer);
            }

            writer.WriteEndElement();
        }
    }
}
//todo: json not implemented, should be done otherwise
export class ManagementRoles {
    private userRoles: string[];
    private applicationRoles: string[];

    constructor(userRoles?: string[], applicationRoles?: string[]) {
        if (userRoles) {
            this.userRoles = userRoles;
        }

        if (applicationRoles) {
            this.applicationRoles = applicationRoles;
        }
    }
    //ToJsonObject(): Microsoft.Exchange.WebServices.Data.JsonObject { throw new Error("ManagementRoles.ts - ToJsonObject : Not implemented."); }
    /**@internal */
    WriteRolesToXml(writer: EwsServiceXmlWriter, roles: string[], elementName: string): void {
        if (roles && roles.length > 0) {
            writer.WriteStartElement(XmlNamespace.Types, elementName);

            for (var role of roles) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Role, role);
            }

            writer.WriteEndElement();
        }
    }
    /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ManagementRole);
        this.WriteRolesToXml(writer, this.userRoles, XmlElementNames.UserRoles);
        this.WriteRolesToXml(writer, this.applicationRoles, XmlElementNames.ApplicationRoles);
        writer.WriteEndElement();
    }
}
export type MapiTypeConverterMap = Dictionary<MapiPropertyType, MapiTypeConverterMapEntry>;
export class MapiTypeConverter {
    private static UtcDataTimeStyles: DateTimeStyles = DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal;
    static get MapiTypeConverterMap(): MapiTypeConverterMap { return MapiTypeConverter.mapiTypeConverterMap.Member; }
    private static mapiTypeConverterMap: LazyMember<MapiTypeConverterMap> = new LazyMember<MapiTypeConverterMap>(() => {

        var map: MapiTypeConverterMap = new Dictionary<MapiPropertyType, MapiTypeConverterMapEntry>((k) => k.toString());
        map.Add(
            MapiPropertyType.ApplicationTime,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //double
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString()                 //ConvertToString 
                ));

        map.Add(
            MapiPropertyType.ApplicationTimeArray,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //double
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString(),                //ConvertToString
                true                                //IsArray
                ));

        var byteConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.byteArray,                                      //byte[]
            (s) => StringHelper.IsNullOrEmpty(s) ? null : Convert.FromBase64String(s),  //Parse
            (o) => Convert.ToBase64String(<number[]>o)                                  //ConvertToString
            );

        map.Add(
            MapiPropertyType.Binary,
            byteConverter);

        var byteArrayConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.byteArray,                                      //byte[]
            (s) => StringHelper.IsNullOrEmpty(s) ? null : Convert.FromBase64String(s),  //Parse
            (o) => Convert.ToBase64String(<number[]>o),                                 //ConvertToString
            true                                                                        //IsArray
            );

        map.Add(
            MapiPropertyType.BinaryArray,
            byteArrayConverter);

        var boolConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.boolean,
            (s) => Convert.toBool(s),                           //Parse
            (o) => (<boolean>o).toString().toLowerCase()        //ConvertToString
            );

        map.Add(
            MapiPropertyType.Boolean,
            boolConverter);

        var clsidConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.guid,
            (s) => new Guid(s),             //Parse
            (o) => (<Guid>o).ToString()     //ConvertToString
            );

        map.Add(
            MapiPropertyType.CLSID,
            clsidConverter);

        var clsidArrayConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.guid,
            (s) => new Guid(s),             //Parse
            (o) => (<Guid>o).ToString(),    //ConvertToString
            true                            //IsArray
            );

        map.Add(
            MapiPropertyType.CLSIDArray,
            clsidArrayConverter);

        map.Add(
            MapiPropertyType.Currency,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //Int64
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString()                 //ConvertToString 
                ));

        map.Add(
            MapiPropertyType.CurrencyArray,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //Int64
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString(),                //ConvertToString
                true                                //IsArray
                ));

        map.Add(
            MapiPropertyType.Double,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //double
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString()                 //ConvertToString 
                ));

        map.Add(
            MapiPropertyType.DoubleArray,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //double
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString(),                //ConvertToString
                true                                //IsArray
                ));

        map.Add(
            MapiPropertyType.Error,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //Int32
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString()                 //ConvertToString 
                ));

        map.Add(
            MapiPropertyType.Float,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //float
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString()                 //ConvertToString 
                ));

        map.Add(
            MapiPropertyType.FloatArray,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //float
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString(),                //ConvertToString
                true                                //IsArray
                ));

        map.Add(
            MapiPropertyType.Integer,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number,                 //Int32
                (s) => MapiTypeConverter.ParseMapiIntegerValue(s),  //Parse
                (o) => o.toString()                                 //ConvertToString 
                ));

        map.Add(
            MapiPropertyType.IntegerArray,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //Int32
                (s) => Convert.toNumber(s),         //Parse //ref: check if latest ews managed api code changes this to same as Integer property type above
                (o) => o.toString(),                //ConvertToString
                true                                //IsArray
                ));

        map.Add(
            MapiPropertyType.Long,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //Int64
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString()                 //ConvertToString 
                ));

        map.Add(
            MapiPropertyType.LongArray,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //Int64
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString(),                //ConvertToString
                true                                //IsArray
                ));

        var objectConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.string,
            (s) => s,               //Parse
            (o) => o.toString()     //ConvertToString
            );

        map.Add(
            MapiPropertyType.Object,
            objectConverter);

        var objectArrayConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.string,
            (s) => s,               //Parse
            (o) => o.toString(),    //ConvertToString
            true                    //IsArray
            );

        map.Add(
            MapiPropertyType.ObjectArray,
            objectArrayConverter);

        map.Add(
            MapiPropertyType.Short,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //short
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString()                 //ConvertToString 
                ));

        map.Add(
            MapiPropertyType.ShortArray,
            new MapiTypeConverterMapEntry(
                MapiTypeConverterTypeSystem.number, //short
                (s) => Convert.toNumber(s),         //Parse
                (o) => o.toString(),                //ConvertToString
                true                                //IsArray
                ));

        var stringConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.string,
            (s) => s,               //Parse
            (o) => o.toString()     //ConvertToString
            );

        map.Add(
            MapiPropertyType.String,
            stringConverter);

        var stringArrayConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.string,
            (s) => s,               //Parse
            (o) => o.toString(),    //ConvertToString
            true                    //IsArray
            );

        map.Add(
            MapiPropertyType.StringArray,
            stringArrayConverter);

        var sysTimeConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.DateTime,
            (s) => DateTime.Parse(s),                               //Parse //ref: UtcDataTimeStyles not used, always utc, timezone not implemented
            (o) => EwsUtilities.DateTimeToXSDateTime(<DateTime>o)   //ConvertToString
            );


        map.Add(
            MapiPropertyType.SystemTime,
            sysTimeConverter);

        var sysTimeArrayConverter = new MapiTypeConverterMapEntry(
            MapiTypeConverterTypeSystem.DateTime,
            (s) => DateTime.Parse(s),                               //Parse //ref: UtcDataTimeStyles not used, always utc, timezone not implemented
            (o) => EwsUtilities.DateTimeToXSDateTime(<DateTime>o),  //ConvertToString
            true                                                    //IsArray
            );

        map.Add(
            MapiPropertyType.SystemTimeArray,
            sysTimeArrayConverter);

        return map;
    });
    static ChangeType(mapiType: MapiPropertyType, value: any): any {
        EwsUtilities.ValidateParam(value, "value");
        return MapiTypeConverter.MapiTypeConverterMap.get(mapiType).ChangeType(value);
    }
    static ConvertToString(mapiPropType: MapiPropertyType, value: any): string {
        return (value === null || value === undefined)
            ? StringHelper.Empty
            : MapiTypeConverter.MapiTypeConverterMap.get(mapiPropType).ConvertToString(value);
    }
    static ConvertToValue(mapiPropType: MapiPropertyType, stringValue: string): any;
    static ConvertToValue(mapiPropType: MapiPropertyType, strings: string[]): any[];
    static ConvertToValue(mapiPropType: MapiPropertyType, strings: string | string[]): any|any[] {
        if (typeof strings === 'string') {
            return MapiTypeConverter.MapiTypeConverterMap.get(mapiPropType).ConvertToValue(strings);
        }
        else if (Array.isArray(strings)) {
            EwsUtilities.ValidateParam(strings, "strings");
            var typeConverter: MapiTypeConverterMapEntry = MapiTypeConverter.MapiTypeConverterMap.get(mapiPropType);
            var array: any[] = [];// = Array.CreateInstance(typeConverter.Type, strings.length);

            var index: number = 0;
            for (var stringValue of strings) {
                var value: any = typeConverter.ConvertToValueOrDefault(stringValue);
                array.push(value);
            }
            return array;
        }
        throw new ArgumentException("parameter not in correct type");
    }
    static IsArrayType(mapiType: MapiPropertyType): boolean { return MapiTypeConverter.MapiTypeConverterMap.get(mapiType).IsArray; }
    static ParseMapiIntegerValue(s: string): any {
        var num = Convert.toNumber(s);
        if (num === NaN) {
            return s;
        }
        return num;
    }
}   
export class MapiTypeConverterMapEntry {
    Parse: (string) => any = null;
    ConvertToString: (any) => string = null;
    Type: MapiTypeConverterTypeSystem = MapiTypeConverterTypeSystem.boolean;
    IsArray: boolean = false;
    get DefaultValue(): any { return MapiTypeConverterMapEntry.defaultValueMap.Member.get(this.Type); }
    private static defaultValueMap: LazyMember<DictionaryWithNumericKey<any>> = new LazyMember<DictionaryWithNumericKey<any>>(() => {
        var map: DictionaryWithNumericKey<any> = new DictionaryWithNumericKey();

        map.Add(MapiTypeConverterTypeSystem.boolean, false);
        map.Add(MapiTypeConverterTypeSystem.byteArray, null);
        map.Add(MapiTypeConverterTypeSystem.number, 0);
        map.Add(MapiTypeConverterTypeSystem.DateTime, DateTime.MinValue);
        map.Add(MapiTypeConverterTypeSystem.guid, Guid.Empty);
        map.Add(MapiTypeConverterTypeSystem.string, null);

        return map;
    });

    constructor(type: MapiTypeConverterTypeSystem, parseMethod: (str: string) => any, convertToStringMethod: (obj: any) => string, isArray = false) {
        EwsLogging.Assert(
            MapiTypeConverterMapEntry.defaultValueMap.Member.containsKey(type),
            "MapiTypeConverterMapEntry ctor",
            StringHelper.Format("No default value entry for type {0}", MapiTypeConverterTypeSystem[type]));

        this.Type = type;
        this.ConvertToString = convertToStringMethod;
        this.Parse = parseMethod;
        this.IsArray = isArray;
    }
    ChangeType(value: any): any {
        var sourcetype = typeof value;
        if (sourcetype === typeof null) {
            try {
                sourcetype = (<any>value.constructor).name;
            }
            catch (ex) { }
        }
        EwsLogging.Assert(false, "MapiTypeConverterMapEntry.ChangeType",
            StringHelper.Format("Not Implemented to convert type from one to another. instance Type: {0}, source Type: {1}", MapiTypeConverterTypeSystem[this.Type], sourcetype));
        
        return value;
    }
    ConvertToValue(stringValue: string): any {
        try {
            return this.Parse(stringValue);
        } catch (ex) {
            throw new ServiceXmlDeserializationException(
                StringHelper.Format(
                    Strings.ValueCannotBeConverted,
                    stringValue,
                    this.Type),
                ex);
        }
    }
    ConvertToValueOrDefault(stringValue: string): any { return StringHelper.IsNullOrEmpty(stringValue) ? this.DefaultValue : this.ConvertToValue(stringValue); }
    ValidateValueAsArray(value: any): void {
        var array = <any[]>value;
        if (array == null) {
            throw new ArgumentException(
                StringHelper.Format(
                    Strings.IncompatibleTypeForArray,
                    value.GetType(),
                    this.Type));
        }
        else if (ArrayHelper.Rank(array) != 1) {
            throw new ArgumentException(Strings.ArrayMustHaveSingleDimension);
        }
        else if (array.length == 0) {
            throw new ArgumentException(Strings.ArrayMustHaveAtLeastOneElement);
        }
        // else if (array.GetType().GetElementType() != this.Type)
        // {
        //     throw new ArgumentException(
        //         StringHelper.Format(
        //             Strings.IncompatibleTypeForArray,
        //             value.GetType(),
        //             this.Type));
        // }
    }
    //private static checkType(array:any[]){}
}


/**
 * Represents a mobile phone.
 * 
 * @sealed
 */
export class MobilePhone implements ISelfValidate {

    /**
     * Name of the mobile phone.
     */
    private name: string;

    /**
     * Phone number of the mobile phone.
     */
    private phoneNumber: string;

    /**
     * Gets or sets the name associated with this mobile phone.
     */
    get Name(): string {
        return this.name;
    }
    set Name(value: string) {
        this.name = value;
    }

    /**
     * Gets or sets the number of this mobile phone.
     */
    get PhoneNumber(): string {
        return this.phoneNumber;
    }
    set PhoneNumber(value: string) {
        this.phoneNumber = value;
    }

    /**
     * Initializes a new instance of the **MobilePhone** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **MobilePhone** class.
     *
     * @param   {string}   name          The name associated with the mobile phone.
     * @param   {string}   phoneNumber   The mobile phone number.
     */
    constructor(name: string, phoneNumber: string);
    constructor(name: string = null, phoneNumber: string = null) {
        this.name = name;
        this.phoneNumber = phoneNumber;
    }

    /**
     * Validates this instance.
     * ISelfValidate.Validate
     */
    Validate(): void {
        if (StringHelper.IsNullOrEmpty(this.PhoneNumber)) {
            throw new ServiceValidationException("PhoneNumber cannot be empty.");
        }
    };
}
export class NameResolution {

    private owner: NameResolutionCollection = null;
    private mailbox: EmailAddress = new EmailAddress();
    private contact: Contact = null;
    get Mailbox(): EmailAddress {
        return this.mailbox;
    }
    get Contact(): Contact {
        return this.contact;
    }
    constructor(owner: NameResolutionCollection) {
        EwsLogging.Assert(owner !== null, "NameResolution.ctor", "owner is null.");
        this.owner = owner;
    }
    LoadFromJson(jsonProperty: any, service: ExchangeService): void { throw new Error("NameResolution.ts - LoadFromJson : Not implemented."); }
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.Mailbox:
                    this.mailbox.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                case XmlElementNames.Contact:
                    this.contact = new Contact(this.owner.Session);
                    this.contact.LoadFromXmlJsObject(jsonProperty[key], service, true, PropertySet.FirstClassProperties, false);
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * Represents a list of suggested name resolutions.
 * 
 * @sealed
 */
export class NameResolutionCollection implements IEnumerable<NameResolution> {

    private service: ExchangeService = null;
    private includesAllResolutions: boolean = false;
    private items: NameResolution[] = [];

    /**
     * @internal Gets the session.
     * 
     * @value   The Session.
     */
    get Session(): ExchangeService {
        return this.service;
    }

    /**
     * Gets the total number of elements in the list.
     */
    get Count(): number {
        return this.items.length;
    }

    /**
     * Gets a value indicating whether more suggested resolutions are available. ResolveName only returns a maximum of 100 name resolutions. 
     * When IncludesAllResolutions is false, there were more than 100 matching names on the server. To narrow the search, provide a more precise name to ResolveName. 
     */
    get IncludesAllResolutions(): boolean {
        return this.includesAllResolutions;
    }

    /**
     * @internal Initializes a new instance of the **NameResolutionCollection** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    constructor(service: ExchangeService) {
        EwsLogging.Assert(service !== null, "NameResolutionSet.ctor", "service is null.");
        this.service = service;
    }

    /**
     * Gets the name resolution at the specified index.
     *
     * @param   {number}   index    The index of the name resolution to get.
     * @return  {NameResolution}    The name resolution at the speicfied index.
     */
    _getItem(index: number): NameResolution {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        return this.items[index];
    }

    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    GetEnumerator(): NameResolution[] {
        return this.items
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsonProperty: any, service: ExchangeService): void {
        var totalItemsInView: number;
        var resolutions: any[];
        for (var key in jsonProperty) {
            switch (key) {
                case XmlAttributeNames.TotalItemsInView:
                    totalItemsInView = Convert.toNumber(jsonProperty[key]);
                    break;
                case XmlAttributeNames.IncludesLastItemInRange:
                    this.includesAllResolutions = Convert.toBool(jsonProperty[key]);
                    break;

                // This label only exists for Json objects.  The XML doesn't have a "Resolutions"
                // element.  
                // This was necessary becaue of the lack of attributes in JSON
                //
                case XmlElementNames.Resolution:
                    resolutions = EwsServiceJsonReader.ReadAsArray(jsonProperty, key);
                    for (var resolution of resolutions) {
                        var nameResolution: NameResolution = new NameResolution(this);
                        nameResolution.LoadFromXmlJsObject(resolution, service);
                        this.items.push(nameResolution);
                    }
                    break;
                default:
                    break;
            }
        }
    }
}
//todo: should be done
/** @internal */
export class PrivilegedUserId {
    IdType: ConnectingIdType;
    Id: string;
    LogonType: PrivilegedLogonType;
    BudgetType: PrivilegedUserIdBudgetType;
    //private logonType: PrivilegedLogonType;
    //private idType: ConnectingIdType;
    //private id: string;
    //private budgetType: PrivilegedUserIdBudgetType;
    constructor(openType?: PrivilegedLogonType, idType?: ConnectingIdType, id?: string) {
        this.LogonType = openType;
        this.IdType = idType;
        this.Id = id;
    }
    WriteToXml(writer: EwsServiceXmlWriter, requestedServerVersion: ExchangeVersion): void {

        if (this.Id == null || this.Id === undefined || this.Id === "") {
            throw new Error("id can not be null");
        }

        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.OpenAsAdminOrSystemService);
        writer.WriteAttributeString(XmlElementNames.LogonType, PrivilegedLogonType[this.LogonType]);
        if (requestedServerVersion >= ExchangeVersion.Exchange2013 && this.BudgetType) {
            writer.WriteAttributeString(XmlElementNames.BudgetType, PrivilegedUserIdBudgetType[this.BudgetType]);
        }

        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ConnectingSID);
        writer.WriteElementValue(XmlNamespace.Types, ConnectingIdType[this.IdType], this.Id);
        writer.WriteEndElement(); // ConnectingSID
        writer.WriteEndElement(); // OpenAsAdminOrSystemService
    }
}

/**
 * Represents SoapFault details. 
 * 
 * /remarks/    ews-javascript-api -> removing internal modifier to, this class will be used to pass on to error delegate of promise instead of Exceptions. 
 * 
 * /remarks/    ews-javascript-api -> 0.9 - Extending from Error object to avoid BlueBird errors when promise is rejected without and Error object 
 * /remarks/    ews-javascript-api -> 0.9 - extending from Exception which looks like Error to BlueBird. can not extend from Error. Typescript 1.8+ can not extend builtin objects property, it swallows inheriting properties see  https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
 */
export class SoapFaultDetails extends Exception {

    private faultCode: string = null;
    private faultString: string = null;
    private faultActor: string = null;

    /**
     * Response code returned by EWS requests. 
     * Default to InternalServerError.
     */
    private responseCode: ServiceError = ServiceError.ErrorInternalServerError;

    /**
     * Message text of the error.
     */
    message: string ; //not private to comply with Error object // ref: message is initialized in Exception class

    /**
     * This is returned by Availability requests.
     */
    private errorCode: ServiceError = ServiceError.NoError;

    /**
     * This is returned by UM requests. It's the name of the exception that was raised.
     */
    private exceptionType: string = null;

    /**
     * When a schema validation error is returned, this is the line number in the request where the error occurred.
     */
    private lineNumber: number = 0;

    /**
     * When a schema validation error is returned, this is the offset into the line of the request where the error occurred.
     */
    private positionWithinLine: number = 0;

    /**
     * Dictionary of key/value pairs from the MessageXml node in the fault. Usually empty but there are a few cases where SOAP faults may include MessageXml details (e.g. CASOverBudgetException includes BackoffTime value).
     */
    private errorDetails: Dictionary<string, string> = new DictionaryWithStringKey<string>();

    /**
     * @internal Gets or sets the SOAP fault code.
     * 
     * @value   The SOAP fault code.
     */
    get FaultCode(): string {
        return this.faultCode;
    }
    set FaultCode(value: string) {
        this.faultCode = value;
    }

    /**
     * @internal Gets or sets the SOAP fault string.
     * 
     * @value   The fault string.
     */
    get FaultString(): string {
        return this.faultString;
    }
    set FaultString(value: string) {
        this.faultString = value;
    }

    /**
     * @internal Gets or sets the SOAP fault actor.
     * 
     * @value   The fault actor.
     */
    get FaultActor(): string {
        return this.faultActor;
    }
    set FaultActor(value: string) {
        this.faultActor = value;
    }

    /**
     * @internal Gets or sets the response code.
     * 
     * @value   The response code.
     */
    get ResponseCode(): ServiceError {
        return this.responseCode;
    }
    set ResponseCode(value: ServiceError) {
        this.responseCode = value;
    }

    /**
     * @internal Gets or sets the message.
     * 
     * @value   The message.
     */
    get Message(): string {
        return this.message;
    }
    set Message(value: string) {
        this.message = value;
    }

    /**
     * @internal Gets or sets the error code.
     * 
     * @value   The error code.
     */
    get ErrorCode(): ServiceError {
        return this.errorCode;
    }
    set ErrorCode(value: ServiceError) {
        this.errorCode = value;
    }

    /**
     * @internal Gets or sets the type of the exception.
     * 
     * @value   The type of the exception.
     */
    get ExceptionType(): string {
        return this.exceptionType;
    }
    set ExceptionType(value: string) {
        this.exceptionType = value;
    }

    /**
     * @internal Gets or sets the line number.
     * 
     * @value   The line number.
     */
    get LineNumber(): number {
        return this.lineNumber;
    }
    set LineNumber(value: number) {
        this.lineNumber = value;
    }

    /**
     * @internal Gets or sets the position within line.
     * 
     * @value   The position within line.
     */
    get PositionWithinLine(): number {
        return this.positionWithinLine;
    }
    set PositionWithinLine(value: number) {
        this.positionWithinLine = value;
    }

    /**
     * @internal Gets or sets the error details dictionary.
     * 
     * @value   The error details dictionary.
     */
    get ErrorDetails(): Dictionary<string, string> {
        return this.errorDetails;
    }
    set ErrorDetails(value: Dictionary<string, string>) {
        this.errorDetails = value;
    }

    /**
     * Exception generated based on ExchangeService parsing
     * Exception property to carry this to caller.
     */
    Exception: Exception;

    /**
     * ews-javascript-api specific: HTTP status code 
     */
    HttpStatusCode = 200;

    // /**
    //  * @private Initializes a new instance of the **SoapFaultDetails** class.
    //  */
    // // constructor() {
    // //     super();
    // // }

    /**
     * @internal Parses the soap:Fault content.
     *
     * @param   {any}   jsObject        The converted Xml JsObject.
     * @return  {SoapFaultDetails}      SOAP fault details.
     */
    static Parse(jsObject: any): SoapFaultDetails {
        var soapFaultDetails = new SoapFaultDetails();

        for (let key in jsObject) {

            switch (key) {
                case XmlElementNames.SOAPFaultCodeElementName:
                    soapFaultDetails.FaultCode = jsObject[key];
                    break;
                case XmlElementNames.SOAPFaultStringElementName:
                    soapFaultDetails.FaultString = jsObject[key];
                    break;
                case XmlElementNames.SOAPFaultActorElementName:
                    soapFaultDetails.FaultActor = jsObject[key];
                    break;
                case XmlElementNames.SOAPDetailElementName:
                    soapFaultDetails.ParseDetailNode(jsObject[key]);
                    break;
                default:
                    break;
            }
        }

        return soapFaultDetails;
    }

    /**
     * Parses the detail node.
     *
     * @param   {any}   jsObject   The detail node.
     */
    private ParseDetailNode(jsObject: any): void {
        for (let key in jsObject) {

            switch (key) {
                case XmlElementNames.EwsResponseCodeElementName:
                    // ServiceError couldn't be mapped to enum value, treat as an ISE
                    this.ResponseCode = ServiceError[<string>jsObject[key]] || ServiceError.ErrorInternalServerError;;
                    break;
                case XmlElementNames.EwsMessageElementName:
                    this.Message = jsObject[key];
                    break;
                case XmlElementNames.EwsLineElementName:
                    this.LineNumber = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.EwsPositionElementName:
                    this.PositionWithinLine = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.EwsErrorCodeElementName:
                    // ServiceError couldn't be mapped to enum value, treat as an ISE
                    this.ErrorCode = ServiceError[<string>jsObject[key]] || ServiceError.ErrorInternalServerError;
                    break;
                case XmlElementNames.EwsExceptionTypeElementName:
                    this.ExceptionType = jsObject[key];
                    break;
                case XmlElementNames.MessageXml:
                    this.ParseMessageXml(jsObject[key]);
                    break;
                default:
                    // Ignore any other details
                    break;
            }
        }
    }

    /**
     * Parses the message XML.
     *
     * @param   {any}   jsObject   The message Xml object.
     */
    private ParseMessageXml(jsObject: any): void {
        for (var key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }
            switch (key) {
                case XmlElementNames.Value:
                    let values = EwsServiceJsonReader.ReadAsArray(jsObject, key);
                    values.forEach((value, index) => {
                        let name = value[XmlAttributeNames.Name];
                        if (name) {
                            if (this.ErrorDetails.containsKey(name)) {
                                name = name + " - " + (index + 1)
                            }
                            this.errorDetails.Add(name, value[key]);
                        }
                    });
                case XmlElementNames.EwsLineElementName:
                case "LineNumber":
                    this.LineNumber = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.EwsPositionElementName:
                case "LinePosition":
                    this.PositionWithinLine = Convert.toNumber(jsObject[key]);
                    break;
                default:
                    if (typeof jsObject[key] === "string") {
                        this.errorDetails.addUpdate(key, jsObject[key])
                    }
                    EwsLogging.Assert(false, "SoapFaultDetails.ParseMessageXml", "Element: " + key + " - Please report example of this operation to ews-javascript-api repo to improve SoapFault parsing");
                    break;
            }
        }
    }
}

/**
 * @internal Represents a time.
 * @sealed
 */
export class Time {

	private hours: number = 0;
	private minutes: number = 0;
	private seconds: number = 0;

	/**
	 * @internal Gets or sets the hours.
	 */
	get Hours(): number {
		return this.hours;
	}
	set Hours(value: number) {
		if (value >= 0 && value < 24) {
			this.hours = value;
			return;
		}
		throw new ArgumentException(Strings.HourMustBeBetween0And23);
	}

	/**
	 * @internal Gets or sets the minutes.
	 */
	get Minutes(): number {
		return this.minutes;
	}
	set Minutes(value: number) {
		if (value >= 0 && value < 60) {
			this.minutes = value;
			return;
		}
		throw new ArgumentException(Strings.MinuteMustBeBetween0And59);
	}

	/**
	 * @internal Gets or sets the seconds.
	 */
	get Seconds(): number {
		return this.seconds;
	}
	set Seconds(value: number) {
		if (value >= 0 && value < 60) {
			this.seconds = value;
			return;
		}
		throw new ArgumentException(Strings.SecondMustBeBetween0And59);
	}

	/**
	 * @internal Initializes a new instance of **Time** class.
	 */
	constructor();
	/**
	 * @internal Initializes a new instance of **Time** class.
	 * @param   {number}   minutes   The minutes.
	 */
	constructor(minutes: number);
	/**
	 * @internal Initializes a new instance of **Time** class.
	 * @param   {DateTime}   dateTime   The DateTime to extract the time part of.
	 */
	constructor(dateTime: DateTime);
	/**
	 * @internal Initializes a new instance of **Time** class.
	 *
	 * @param   {number}   hours     The hours.
	 * @param   {number}   minutes   The minutes.
	 * @param   {number}   seconds   The seconds.
	 */
	constructor(hours: number, minutes: number, seconds: number);
	constructor(minutesOrDateTimeOrHours?: number | DateTime, minutes?: number, seconds?: number) {
		if (arguments.length === 1) {
			if (typeof minutesOrDateTimeOrHours === 'number') {
				if (minutes < 0 || minutes >= 1440) {
					throw new ArgumentException(
						Strings.MinutesMustBeBetween0And1439,
						"minutes");
				}

				this.Hours = minutesOrDateTimeOrHours / 60;
				this.Minutes = minutesOrDateTimeOrHours % 60;
				this.Seconds = 0;
			}
			else {
				this.Hours = minutesOrDateTimeOrHours.Hour;
				this.Minutes = minutesOrDateTimeOrHours.Minute;
				this.Seconds = minutesOrDateTimeOrHours.Second;
			}
		}
		if (arguments.length === 3) {
			this.Hours = <number>minutesOrDateTimeOrHours;
			this.Minutes = minutes;
			this.Seconds = seconds;
		}
	}

	/**
	 * @internal Converts the time into a number of minutes since 12:00AM.
	 *
	 * @return  {number}      The number of minutes since 12:00AM the time represents.
	 */
	ConvertToMinutes(): number {
		return this.Minutes + (this.Hours * 60);
	}

	/**
	 * @internal Convert Time to XML Schema time.
	 *
	 * @return  {string}      String in XML Schema time format.
	 */
	ToXSTime(): string {
		return StringHelper.Format(
			"{0:00}:{1:00}:{2:00}",
			this.Hours,
			this.Minutes,
			this.Seconds);
	}
}

export type base64String = string;

/**
 * Represents an object that can be used to store user-defined configuration settings.
 */
export class UserConfiguration {//IJsonSerializable

    private static ObjectVersion: ExchangeVersion = ExchangeVersion.Exchange2010;

    // For consistency with ServiceObject behavior, access to ItemId is permitted for a new object.
    private static PropertiesAvailableForNewObject: UserConfigurationProperties = UserConfigurationProperties.BinaryData | UserConfigurationProperties.Dictionary | UserConfigurationProperties.XmlData;

    private static NoProperties: UserConfigurationProperties = <UserConfigurationProperties>0;

    // TODO: Consider using SimplePropertyBag class to store XmlData & BinaryData property values.
    private service: ExchangeService;
    private name: string;
    private parentFolderId: FolderId = null;
    private itemId: ItemId = null;
    private dictionary: UserConfigurationDictionary = null;
    private xmlData: base64String = null;//System.Byte[]; //info: base64 encoded value
    private binaryData: base64String = null;//System.Byte[];
    private propertiesAvailableForAccess: UserConfigurationProperties = UserConfigurationProperties.Id;
    private updatedProperties: UserConfigurationProperties = UserConfigurationProperties.Id;

    /**
     * Indicates whether changes trigger an update or create operation.
     */
    private isNew: boolean = false;

    /**
     * Gets the name of the user configuration.
     * internal set
     */
    get Name(): string {
        return this.name;
    }
    set Name(value: string) {
        this.name = value;
    }

    /**
     * Gets the Id of the folder containing the user configuration.
     * internal set
     */
    get ParentFolderId(): FolderId {
        return this.parentFolderId;
    }
    set ParentFolderId(value: FolderId) {
        this.parentFolderId = value;
    }

    /**
     * Gets the Id of the user configuration.
     */
    get ItemId(): ItemId {
        return this.itemId;
    }

    /**
     * Gets the dictionary of the user configuration.
     */
    get Dictionary(): UserConfigurationDictionary {
        return this.dictionary;
    }

    /**
     * Gets or sets the xml data of the user configuration.
     * ### base64 encoded value, not the memory stream or byte[]
     */
    get XmlData(): base64String {//System.Byte[];
        this.ValidatePropertyAccess(UserConfigurationProperties.XmlData);
        return this.xmlData;
    }
    set XmlData(value: base64String) {
        this.xmlData = value;
        this.MarkPropertyForUpdate(UserConfigurationProperties.XmlData);
    }

    /**
     *  Gets or sets the binary data of the user configuration.
     * ### base64 encoded value, not the memory stream or byte[]
     */
    get BinaryData(): base64String {//System.Byte[];
        this.ValidatePropertyAccess(UserConfigurationProperties.BinaryData);

        return this.binaryData;
    }
    set BinaryData(value: base64String) {
        this.binaryData = value;
        this.MarkPropertyForUpdate(UserConfigurationProperties.BinaryData);
    }

    /**
     * Gets a value indicating whether this user configuration has been modified.
     */
    get IsDirty(): boolean {
        return (this.updatedProperties != UserConfiguration.NoProperties) || this.dictionary.IsDirty;
    }


    /**
     * Initializes a new instance of **UserConfiguration** class.
     *
     * @param   {ExchangeService}   service               The service to which the user configuration is bound.
     */
    constructor(service: ExchangeService);
    /**
     * @internal Initializes a new instance of **UserConfiguration** class.
     *
     * @param   {ExchangeService}               service               The service to which the user configuration is bound.
     * @param   {UserConfigurationProperties}   requestedProperties   The properties requested for this user configuration.
     */
    constructor(service: ExchangeService, requestedProperties: UserConfigurationProperties);
    constructor(service: ExchangeService, requestedProperties: UserConfigurationProperties = UserConfiguration.PropertiesAvailableForNewObject) {

        EwsUtilities.ValidateParam(service, "service");

        if (service.RequestedServerVersion < UserConfiguration.ObjectVersion) {
            throw new ServiceVersionException(
                StringHelper.Format(
                    Strings.ObjectTypeIncompatibleWithRequestVersion,
                    "UserConfiguration",
                    ExchangeVersion[UserConfiguration.ObjectVersion]));
        }

        this.service = service;
        this.isNew = true;

        this.InitializeProperties(requestedProperties);
    }

    /**
     * Binds to an existing user configuration and loads the specified properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}               service          The service to which the user configuration is bound.
     * @param   {string}                        name             The name of the user configuration.
     * @param   {FolderId}                      parentFolderId   The Id of the folder containing the user configuration.
     * @param   {UserConfigurationProperties}   properties       The properties to load.
     * @return  {Promise<UserConfiguration>}   A user configuration Instance   :Promise.
     */
    public static Bind(service: ExchangeService, name: string, parentFolderId: FolderId, properties: UserConfigurationProperties): Promise<UserConfiguration>;
    /**
     * Binds to an existing user configuration and loads the specified properties.
     * Calling this method results in a call to EWS.
     *
     * @param   {ExchangeService}               service             The service to which the user configuration is bound.
     * @param   {string}                        name                The name of the user configuration.
     * @param   {parentFolderName}              parentFolderName    The name of the folder containing the user configuration.
     * @param   {UserConfigurationProperties}   properties          The properties to load.
     * @return  {Promise<UserConfiguration>}   A user configuration Instance   :Promise.
     */
    public static Bind(service: ExchangeService, name: string, parentFolderName: WellKnownFolderName, properties: UserConfigurationProperties): Promise<UserConfiguration>;
    public static Bind(service: ExchangeService, name: string, parentFolderIdOrName: FolderId | WellKnownFolderName, properties: UserConfigurationProperties): Promise<UserConfiguration> {
        let parentFolderId: FolderId = parentFolderIdOrName as FolderId;
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderId = new FolderId(parentFolderIdOrName);
        }

        return service.GetUserConfiguration(
            name,
            parentFolderId,
            properties).then((result: UserConfiguration) => {
                result.isNew = false;
                return result;
            });
    }

    /**
     * Deletes the user configuration. 
     * Calling this method results in a call to EWS.
     * @return  {Promise<void>}    :Promise.
     */
    Delete(): Promise<void> {
        if (this.isNew) {
            Promise.reject(new InvalidOperationException(Strings.DeleteInvalidForUnsavedUserConfiguration));
        }
        else {
            return this.service.DeleteUserConfiguration(this.name, this.parentFolderId);
        }
    }

    /**
     * Gets the base64 property value.
     *
     * @param   {base64String}   bytes   The bytes.
     * @return  {string}         [description]
     */
    private GetBase64PropertyValue(bytes: base64String/*System.Byte[]*/): string { throw new Error("UserConfiguration.ts - GetBase64PropertyValue : Not implemented."); }

    /**
     * Initializes properties.
     *
     * /remarks/    InitializeProperties is called in 3 cases:
     * .  Create new object:  From the UserConfiguration constructor.
     * .  Bind to existing object:  Again from the constructor.  The constructor is called eventually by the GetUserConfiguration request.
     * .  Refresh properties:  From the Load method.
     * 
     * @param   {UserConfigurationProperties}   requestedProperties   The properties requested for this UserConfiguration.
     */
    private InitializeProperties(requestedProperties: UserConfigurationProperties): void {
        this.itemId = null;
        this.dictionary = new UserConfigurationDictionary();
        this.xmlData = null;
        this.binaryData = null;
        this.propertiesAvailableForAccess = requestedProperties;

        this.ResetIsDirty();
    }

    /**
     * Determines whether the specified property was updated.
     *
     * @param   {UserConfigurationProperties}   property   property to evaluate.
     * @return  {boolean}                       Boolean indicating whether to send the property Xml.
     */
    private IsPropertyUpdated(property: UserConfigurationProperties): boolean {
        let isPropertyDirty: boolean = false;
        let isPropertyEmpty: boolean = false;

        switch (property) {
            case UserConfigurationProperties.Dictionary:
                isPropertyDirty = this.Dictionary.IsDirty;
                isPropertyEmpty = this.Dictionary.Count == 0;
                break;
            case UserConfigurationProperties.XmlData:
                isPropertyDirty = (property & this.updatedProperties) == property;
                isPropertyEmpty = (this.xmlData == null) || (this.xmlData.length == 0);
                break;
            case UserConfigurationProperties.BinaryData:
                isPropertyDirty = (property & this.updatedProperties) == property;
                isPropertyEmpty = (this.binaryData == null) || (this.binaryData.length == 0);
                break;
            default:
                EwsLogging.Assert(
                    false,
                    "UserConfiguration.IsPropertyUpdated",
                    "property not supported: " + EnumHelper.ToString(UserConfigurationProperties, property));
                break;
        }

        // Consider the property updated, if it's been modified, and either 
        //    . there's a value or 
        //    . there's no value but the operation is update.
        return isPropertyDirty && ((!isPropertyEmpty) || (!this.isNew));
    }

    /**
     * Loads the specified properties on the user configuration. 
     * Calling this method results in a call to EWS.
     * @return  {Promise<void>}    :Promise.
     */
    Load(properties: UserConfigurationProperties): Promise<void> {
        this.InitializeProperties(properties);

        return this.service.LoadPropertiesForUserConfiguration(this, properties);
    }

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        for (let key in jsObject) {
            switch (key) {
                case XmlElementNames.UserConfigurationName:
                    let userConfigName: string = jsObject[key];
                    let responseName: string = userConfigName[XmlAttributeNames.Name];

                    EwsLogging.Assert(
                        StringHelper.Compare(this.name, responseName, /** StringComparison.Ordinal*/ false) == 0,
                        "UserConfiguration.LoadFromXmlJsObject",
                        "UserConfigurationName does not match: Expected: " + this.name + " Name in response: " + responseName);

                    break;

                case XmlElementNames.ItemId:
                    this.itemId = new ItemId();
                    this.itemId.LoadFromXmlJsObject(jsObject[key], service);
                    break;

                case XmlElementNames.Dictionary:
                    (this.dictionary).CreateFromXMLJsObjectCollection(jsObject[key], service);
                    break;

                case XmlElementNames.XmlData:
                    this.xmlData = jsObject[key]; //Convert.FromBase64String(jsObject.ReadAsString(key)); //info: no need to convert, using base64 as is
                    break;

                case XmlElementNames.BinaryData:
                    this.binaryData = jsObject[key]; //Convert.FromBase64String(jsObject.ReadAsString(key)); //info: no need to convert, using base64 as is
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Adds the passed property to updatedProperties.
     *
     * @param   {UserConfigurationProperties}   property   Property to update.
     */
    private MarkPropertyForUpdate(property: UserConfigurationProperties): void {
        this.updatedProperties |= property;
        this.propertiesAvailableForAccess |= property;
    }

    /**
     * Resets flags to indicate that properties haven't been modified.
     */
    private ResetIsDirty(): void {
        this.updatedProperties = UserConfiguration.NoProperties;
        this.dictionary.IsDirty = false;
    }

    /**
     * Saves the user configuration. Calling this method results in a call to EWS.
     *
     * @param   {string}                name             The name of the user configuration.
     * @param   {WellKnownFolderName}   parentFolderName   The Id of the folder in which to save the user configuration.
     * @return  {Promise<void>}        :Promise.
     */
    Save(name: string, parentFolderName: WellKnownFolderName): Promise<void>;
    /**
     * Saves the user configuration. Calling this method results in a call to EWS.
     *
     * @param   {string}        name             The name of the user configuration.
     * @param   {FolderId}      parentFolderId   The Id of the folder in which to save the user configuration.
     * @return  {Promise<void>}                 :Promise.
     */
    Save(name: string, parentFolderId: FolderId): Promise<void>;
    Save(name: string, parentFolderIdOrName: FolderId | WellKnownFolderName): Promise<void> {
        let parentFolderId: FolderId = parentFolderIdOrName as FolderId;
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderId = new FolderId(parentFolderIdOrName);
        }

        EwsUtilities.ValidateParam(name, "name");
        EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");

        parentFolderId.Validate(this.service.RequestedServerVersion);

        if (!this.isNew) {
            throw new InvalidOperationException(Strings.CannotSaveNotNewUserConfiguration);
        }

        this.parentFolderId = parentFolderId;
        this.name = name;

        return this.service.CreateUserConfiguration(this).then(() => {
            this.isNew = false;
            this.ResetIsDirty();
        });
    }

    /**
     * Updates the user configuration by applying local changes to the Exchange server.
     * Calling this method results in a call to EWS.
     * @return  {Promise<void>}    :Promise.
     */
    Update(): Promise<void> {
        if (this.isNew) {
            Promise.reject(new InvalidOperationException(Strings.CannotUpdateNewUserConfiguration));
        }

        if (this.IsPropertyUpdated(UserConfigurationProperties.BinaryData) ||
            this.IsPropertyUpdated(UserConfigurationProperties.Dictionary) ||
            this.IsPropertyUpdated(UserConfigurationProperties.XmlData)) {
            return this.service.UpdateUserConfiguration(this).then(() => {
                this.ResetIsDirty();
            });
        } else {
            this.ResetIsDirty();
            return Promise.resolve();
        }
    }

    /**
     * Determines whether the specified property may be accessed.
     *
     * @param   {UserConfigurationProperties}   property   Property to access.
     */
    ValidatePropertyAccess(property: UserConfigurationProperties): void {
        if ((property & this.propertiesAvailableForAccess) != property) {
            throw new PropertyException(Strings.MustLoadOrAssignPropertyBeforeAccess, EnumHelper.ToString(UserConfigurationProperties, property));
        }
    }

    /**
     * Writes the BinaryData property to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    private WriteBinaryDataToXml(writer: EwsServiceXmlWriter): void {
        EwsLogging.Assert(
            writer != null,
            "UserConfiguration.WriteBinaryDataToXml",
            "writer is null");

        UserConfiguration.WriteByteArrayToXml(
            writer,
            this.binaryData,
            XmlElementNames.BinaryData);
    }

    /**
     * Writes a byte array to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {base64String}          byteArray        Byte array to write #base64 string.
     * @param   {string}                xmlElementName   Name of the Xml element.
     */
    private static WriteByteArrayToXml(writer: EwsServiceXmlWriter, byteArray: base64String/*System.Byte[]*/, xmlElementName: string): void {
        EwsLogging.Assert(
            writer != null,
            "UserConfiguration.WriteByteArrayToXml",
            "writer is null");
        EwsLogging.Assert(
            xmlElementName != null,
            "UserConfiguration.WriteByteArrayToXml",
            "xmlElementName is null");

        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);

        if (byteArray != null && byteArray.length > 0) {
            //writer.WriteValue(Convert.ToBase64String(byteArray), xmlElementName); //info: no need to convert to string, it is already base 64 encoded string
            writer.WriteValue(byteArray, xmlElementName);
        }

        writer.WriteEndElement();
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          xmlNamespace     The XML namespace.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlNamespace: XmlNamespace, xmlElementName: string): void {
        EwsLogging.Assert(
            writer != null,
            "UserConfiguration.WriteToXml",
            "writer is null");
        EwsLogging.Assert(
            xmlElementName != null,
            "UserConfiguration.WriteToXml",
            "xmlElementName is null");

        writer.WriteStartElement(xmlNamespace, xmlElementName);

        // Write the UserConfigurationName element
        UserConfiguration.WriteUserConfigurationNameToXml(
            writer,
            XmlNamespace.Types,
            this.name,
            this.parentFolderId);

        // Write the Dictionary element
        if (this.IsPropertyUpdated(UserConfigurationProperties.Dictionary)) {
            this.dictionary.WriteToXml(writer, XmlElementNames.Dictionary);
        }

        // Write the XmlData element
        if (this.IsPropertyUpdated(UserConfigurationProperties.XmlData)) {
            this.WriteXmlDataToXml(writer);
        }

        // Write the BinaryData element
        if (this.IsPropertyUpdated(UserConfigurationProperties.BinaryData)) {
            this.WriteBinaryDataToXml(writer);
        }

        writer.WriteEndElement();
    }

    /**
     * @internal Writes to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          xmlNamespace     The XML namespace.
     * @param   {string}                name             The user configuration name.
     * @param   {FolderId}              parentFolderId   The Id of the folder containing the user configuration.
     */
    static WriteUserConfigurationNameToXml(writer: EwsServiceXmlWriter, xmlNamespace: XmlNamespace, name: string, parentFolderId: FolderId): void {
        EwsLogging.Assert(
            writer != null,
            "UserConfiguration.WriteUserConfigurationNameToXml",
            "writer is null");
        EwsLogging.Assert(
            name != null,
            "UserConfiguration.WriteUserConfigurationNameToXml",
            "name is null");
        EwsLogging.Assert(
            parentFolderId != null,
            "UserConfiguration.WriteUserConfigurationNameToXml",
            "parentFolderId is null");

        writer.WriteStartElement(xmlNamespace, XmlElementNames.UserConfigurationName);

        writer.WriteAttributeValue(XmlAttributeNames.Name, name);

        parentFolderId.WriteToXml(writer);

        writer.WriteEndElement();
    }

    /**
     * Writes the XmlData property to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    private WriteXmlDataToXml(writer: EwsServiceXmlWriter): void {
        EwsLogging.Assert(
            writer != null,
            "UserConfiguration.WriteXmlDataToXml",
            "writer is null");

        UserConfiguration.WriteByteArrayToXml(
            writer,
            this.xmlData,
            XmlElementNames.XmlData);
    }
}
export class AbstractFolderIdWrapper { //IJsonSerializable
    GetFolder(): Folder { return null; }
    //InternalToJson(service: ExchangeService): void { throw new Error("AbstractFolderIdWrapper.ts - InternalToJson : Not implemented."); }
    //object IJsonSerializable.ToJson(ExchangeService service)
    //{
    //      return this.InternalToJson(service);
    //}
    Validate(version: ExchangeVersion): void { /*throw new Error("Not implemented.");*/ }
    /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter): void { throw new Error("AbstractFolderIdWrapper.ts - WriteToXml - abstract; must implemented."); }
}

export class FolderIdWrapper extends AbstractFolderIdWrapper {
    private folderId: FolderId;

    constructor(folderId: FolderId) {
        super();
        EwsLogging.Assert(
            folderId != null,
            "FolderIdWrapper.ctor",
            "folderId is null");

        this.folderId = folderId;
    }

    //InternalToJson(service: ExchangeService): any{ throw new Error("FolderIdWrapper.ts - InternalToJson : Not implemented.");}
    Validate(version: ExchangeVersion): void { this.folderId.Validate(version); }
    /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter): void { this.folderId.WriteToXml(writer); }
}

export class FolderWrapper extends AbstractFolderIdWrapper {
    private folder: Folder;

    constructor(folder: Folder) {
        super();
        EwsLogging.Assert(
            folder != null,
            "FolderWrapper.ctor",
            "folder is null");
        EwsLogging.Assert(
            !folder.IsNew,
            "FolderWrapper.ctor",
            "folder does not have an Id");

        this.folder = folder;
    }

    GetFolder(): Folder { return this.folder; }
    //InternalToJson(service: ExchangeService): void{ throw new Error("FolderWrapper.ts - InternalToJson : Not implemented.");}
    /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter): void { this.folder.Id.WriteToXml(writer); }
}
export class AbstractItemIdWrapper {//IJsonSerializable
    GetItem(): Item { return null;}
    IternalToJson(service: ExchangeService): any { throw new Error("AbstractItemIdWrapper.ts - IternalToJson : Not implemented."); }
    /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter): void {}
}

export class ItemIdWrapper extends AbstractItemIdWrapper {
    private itemId: ItemId;
    constructor(itemId: ItemId) {
        super();
        EwsLogging.Assert(
            itemId != null,
            "ItemIdWrapper.ctor",
            "itemId is null");

        this.itemId = itemId;
    }
    IternalToJson(service: ExchangeService): any { throw new Error("ItemIdWrapper.ts - IternalToJson : Not implemented."); }
    /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter): void {this.itemId.WriteToXml(writer);}
}
export class ItemWrapper extends AbstractItemIdWrapper {
    private item: Item;
    constructor(item: Item) {
        super();
        EwsLogging.Assert(
            item != null,
            "ItemWrapper.ctor",
            "item is null");
        EwsLogging.Assert(
            !item.IsNew,
            "ItemWrapper.ctor",
            "item does not have an Id");

        this.item = item;
    }
    GetItem(): Item { return this.item; }
    IternalToJson(service: ExchangeService): any { throw new Error("ItemWrapper.ts - IternalToJson : Not implemented."); }
    /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter): void { this.item.Id.WriteToXml(writer) }
}

/**
 * Represents a collection of notification events.
 */
export class GetEventsResults {

	/**
	 * Map XML element name to notification event type.
	 * 
	 * /remarks/ 	If you add a new notification event type, you'll need to add a new entry to the dictionary here.
	 */
	private static xmlElementNameToEventTypeMap: LazyMember<Dictionary<string, EventType>> = new LazyMember<Dictionary<string, EventType>>(() => {
		var dictionary: Dictionary<string, EventType> = new DictionaryWithStringKey<EventType>();
		dictionary.Add("CopiedEvent", EventType.Copied);
		dictionary.Add("CreatedEvent", EventType.Created);
		dictionary.Add("DeletedEvent", EventType.Deleted);
		dictionary.Add("ModifiedEvent", EventType.Modified);
		dictionary.Add("MovedEvent", EventType.Moved);
		dictionary.Add("NewMailEvent", EventType.NewMail);
		dictionary.Add("StatusEvent", EventType.Status);
		dictionary.Add("FreeBusyChangedEvent", EventType.FreeBusyChanged);
		return dictionary;
	});

	/**
	 * Gets the XML element name to event type mapping.
	 * 
	 * @value	The XML element name to event type mapping.
	 */
	static get XmlElementNameToEventTypeMap(): Dictionary<string, EventType> {
		return GetEventsResults.xmlElementNameToEventTypeMap.Member;
	}

	/**
	 * Watermark in event.
	 */
	private newWatermark: string = null;

	/**
	 * Subscription id.
	 */
	private subscriptionId: string = null;

	/**
	 * Previous watermark.
	 */
	private previousWatermark: string = null;

	/**
	 * True if more events available for this subscription.
	 */
	private moreEventsAvailable: boolean = false;

	/**
	 * Collection of notification events.
	 */
	private events: NotificationEvent[] = [];

	/**
	 * @internal Gets the Id of the subscription the collection is associated with.
	 */
	get SubscriptionId(): string {
		return this.subscriptionId;
	}

	/**
	 * @internal Gets the subscription's previous watermark.
	 */
	get PreviousWatermark(): string {
		return this.previousWatermark;
	}

	/**
	 * @internal Gets the subscription's new watermark.
	 */
	get NewWatermark(): string {
		return this.newWatermark;
	}

	/**
	 * @internal Gets a value indicating whether more events are available on the Exchange server.
	 */
	get MoreEventsAvailable(): boolean {
		return this.moreEventsAvailable;
	}

	/**
	 * Gets the collection of folder events.
	 * 
	 * @value	The folder events.
	 */
	get FolderEvents(): FolderEvent[] {
		return ArrayHelper.OfType<NotificationEvent, FolderEvent>(this.events, (item) => item instanceof FolderEvent);
	}

	/**
	 * Gets the collection of item events.
	 * 
	 * @value	The item events.
	 */
	get ItemEvents(): ItemEvent[] {
		return ArrayHelper.OfType<NotificationEvent, ItemEvent>(this.events, (item) => item instanceof ItemEvent);
	}

	/**
	 * Gets the collection of all events.
	 * 
	 * @value	The events.
	 */
	get AllEvents(): NotificationEvent[] {
		return this.events;
	}

	/**
	 * @internal Initializes a new instance of the **GetEventsResults** class.
	 */
	constructor() {
	}

	/**
     * Loads the events from XML.
     *
     * @param   {any[]}               jsEventsArray         The json events array.
     * @param   {string}     		  xmlElementName		Name of the element.    
     * @param   {ExchangeService}     service               The service.    
     */
	private LoadEventsFromXmlJsObject(jsEventsArray: any[], eventElementName: string, service: ExchangeService): void {
		for (let jsEvent of jsEventsArray) {
			this.newWatermark = jsEvent[XmlElementNames.Watermark];
			let eventType: EventType = GetEventsResults.XmlElementNameToEventTypeMap.get(eventElementName);

			if (eventType == EventType.Status) {
				continue;
			}

			let timeStamp: DateTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsEvent[XmlElementNames.TimeStamp]);
			let notificationEvent: NotificationEvent;

			if (jsEvent[XmlElementNames.FolderId]) {
				notificationEvent = new FolderEvent(eventType, timeStamp);
			}
			else {
				notificationEvent = new ItemEvent(eventType, timeStamp);
			}

			notificationEvent.LoadFromXmlJsObject(jsEvent, service);

			this.events.push(notificationEvent);
		}
	}

	/**
     * @internal Loads from XML.
     *
     * @param   {any}                 eventsResponse         The events response Object converted from XML.
     * @param   {ExchangeService}     service                The service.    
     */
	LoadFromXmlJsObject(eventsResponse: any, service: ExchangeService): void {
		let response = eventsResponse;
		if (eventsResponse[XmlElementNames.Notification]) {
			response = eventsResponse[XmlElementNames.Notification];
		}
		for (let key in response) {
			switch (key) {
				case XmlElementNames.SubscriptionId:
					this.subscriptionId = response[key];
					break;
				case XmlElementNames.PreviousWatermark:
					this.previousWatermark = response[key];
					break;
				case XmlElementNames.MoreEvents:
					this.moreEventsAvailable = Convert.toBool(response[key]);
					break;
				default:
					if (GetEventsResults.XmlElementNameToEventTypeMap.containsKey(key)) {
						this.LoadEventsFromXmlJsObject(EwsServiceJsonReader.ReadAsArray(response, key), key, service);
					}
					break;
			}
		}
	}
}

/**
 * @internal Represents a collection of notification events.
 * 
 * @sealed
 */
export class GetStreamingEventsResults {

	/**
	 * Collection of notification events.
	 */
	private events: NotificationGroup[] = [];

	/**
	 * @internal Gets the notification collection.
	 * 
	 * @value	The notification collection.
	 */
	get Notifications(): NotificationGroup[] { return this.events; }

	/**
	 * @internal Initializes a new instance of the **GetStreamingEventsResults** class.
	 */
	constructor() {
	}

	/**
     * Loads the events from XML.
     *
     * @param   {any[]}               	jsEventsArray         	The json events array.
     * @param   {string}     		  	xmlElementName			Name of the element.    
     * @param   {NotificationGroup}		notifications			Collection of notifications.    
     * @param   {ExchangeService}     	service               	The service.    
     */
	private LoadNotificationEventFromXmlJsObject(jsEventsArray: any[], eventElementName: string, notifications: NotificationGroup, service: ExchangeService): void {
		for (let jsEvent of jsEventsArray) {
			let eventType: EventType = GetEventsResults.XmlElementNameToEventTypeMap.get(eventElementName);

			if (eventType == EventType.Status) {
				continue;
			}

			let timeStamp: DateTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsEvent[XmlElementNames.TimeStamp]);
			let notificationEvent: NotificationEvent;

			if (jsEvent[XmlElementNames.FolderId]) {
				notificationEvent = new FolderEvent(eventType, timeStamp);
			}
			else {
				notificationEvent = new ItemEvent(eventType, timeStamp);
			}

			notificationEvent.LoadFromXmlJsObject(jsEvent, service);

			notifications.Events.push(notificationEvent);
		}
	}

	/**
     * @internal Loads from XML.
     *
     * @param   {any}                 eventsResponse         The events response Object converted from XML.
     * @param   {ExchangeService}     service                The service.    
     */
	LoadFromXmlJsObject(eventsResponse: any, service: ExchangeService): void {

		let streamingNotifications: any[] = EwsServiceJsonReader.ReadAsArray(eventsResponse, XmlElementNames.Notification)
		for (let streamingNotification of streamingNotifications) {

			let notifications: NotificationGroup = new NotificationGroup();
			notifications.SubscriptionId = streamingNotification[XmlElementNames.SubscriptionId];
			notifications.Events = [];

			this.events.push(notifications);

			for (let key in streamingNotification) {
				switch (key) {
					default:
						if (GetEventsResults.XmlElementNameToEventTypeMap.containsKey(key)) {
							this.LoadNotificationEventFromXmlJsObject(EwsServiceJsonReader.ReadAsArray(streamingNotification, key), key, notifications, service);
						}
						break;
				}
			}
		}
	}
}

/**
 * Provides data to a StreamingSubscriptionConnection's OnNotificationEvent event.
 */
export class NotificationEventArgs {//extends System.EventArgs {

	/**
	 * Gets the subscription for which notifications have been received.
	 * 
	 * internal set
	 */
	Subscription: StreamingSubscription;

	/**
	 * Gets the events that were received.
	 * 
	 * internal set
	 */
	Events: NotificationEvent[];

	/**
	 * @internal Initializes a new instance of the **NotificationEventArgs** class.
	 *
	 * @param   {StreamingSubscription}   	subscription   The subscription for which notifications have been received.
	 * @param   {NotificationEvent[]}   	events         The events that were received.
	 */
	constructor(subscription: StreamingSubscription, events: NotificationEvent[]) {
		this.Events = events;
		this.Subscription = subscription;
	}
}

/**
 * @internal Structure to track a subscription and its associated notification events.
 */
export class NotificationGroup {

    /**
     * @internal Subscription Id
     */
    SubscriptionId: string = null;

    /**
     * @internal Events in the response associated with the subscription id.
     */
    Events: NotificationEvent[] = [];
}

/**
 * Represents a connection to an ongoing stream of events.
 * 
 * @sealed
 */
export class StreamingSubscriptionConnection {

	/**
	 * Mapping of streaming id to subscriptions currently on the connection.
	 */
	private subscriptions: Dictionary<string, StreamingSubscription> = new DictionaryWithStringKey<StreamingSubscription>();

	/**
	 * connection lifetime, in minutes
	 */
	private connectionTimeout: number = 0;

	/**
	 * ExchangeService instance used to make the EWS call.
	 */
	private session: ExchangeService = null;

	/**
	 * Value indicating whether the class is disposed.
	 */
	private isDisposed: boolean = false;

	/**
	 * Currently used instance of a GetStreamingEventsRequest connected to EWS.
	 */
	private currentHangingRequest: GetStreamingEventsRequest = null;

	/**
	 * Lock object
	 */
	private lockObject: { isLocked: boolean } = { isLocked: false };

	/**
	 * Occurs when notifications are received from the server.
	 */
	OnNotificationEvent: NotificationEventDelegate[] = [];

	/**
	 * Occurs when a subscription encounters an error.
	 */
	OnSubscriptionError: SubscriptionErrorDelegate[] = [];

	/**
	 * Occurs when a streaming subscription connection is disconnected from the server.
	 */
	OnDisconnect: SubscriptionErrorDelegate[] = [];

	/**
	 * Occurs when a streaming subscription connection gets headers from the server.
	 */
	OnResponseHeader: ResponseHeaderDelegate[] = [];

	/**
	 * Getting the current subscriptions in this connection.
	 */
	get CurrentSubscriptions(): StreamingSubscription[] {
		var list: StreamingSubscription[] = [];

		//while (this.lockObject.isLocked) { }; //todo: implement blocking and non blocking multi threading when available.

		//this.lockObject.isLocked = true;

		//try {
		ArrayHelper.AddRange(list, this.subscriptions.Values);
		// } finally {
		// 	this.lockObject.isLocked = false;
		// }

		return list;
	}

	/**
	 * Gets a value indicating whether this connection is opened
	 */
	get IsOpen(): boolean {
		this.ThrowIfDisposed();
		if (this.currentHangingRequest == null) {
			return false
		}
		else {
			return this.currentHangingRequest.IsConnected;
		}
	}


	/**
	 * Initializes a new instance of the **StreamingSubscriptionConnection** class.
	 *
	 * @param   {ExchangeService}   		service         The ExchangeService instance this connection uses to connect to the server.
	 * @param   {number}   					lifetime        The maximum time, in minutes, the connection will remain open. Lifetime must be between 1 and 30.
	 */
	constructor(service: ExchangeService, lifetime: number);
	/**
	 * Initializes a new instance of the **StreamingSubscriptionConnection** class.
	 *
	 * @param   {ExchangeService}   		service         The ExchangeService instance this connection uses to connect to the server.
	 * @param   {StreamingSubscription[]}   subscriptions   The streaming subscriptions this connection is receiving events for.
	 * @param   {number}   					lifetime        The maximum time, in minutes, the connection will remain open. Lifetime must be between 1 and 30.
	 */
	constructor(service: ExchangeService, subscriptions: StreamingSubscription[], lifetime: number);
	constructor(service: ExchangeService, lifetimeOrSubscriptions: number | StreamingSubscription[], lifetime?: number) {
		EwsUtilities.ValidateParam(service, "service");
		EwsUtilities.ValidateClassVersion(
			service,
			ExchangeVersion.Exchange2010_SP1,
			"StreamingSubscriptionConnection");

		let argsLength = arguments.length;
		let lifeTime: number = argsLength === 2 ? <number>lifetimeOrSubscriptions : lifetime;

		if (lifeTime < 1 || lifeTime > 30) {
			throw new ArgumentOutOfRangeException("lifetime");
		}

		this.session = service;
		this.connectionTimeout = lifeTime;

		if (argsLength === 3) {
			let subscriptions: StreamingSubscription[] = <StreamingSubscription[]>lifetimeOrSubscriptions;
			EwsUtilities.ValidateParamCollection(subscriptions, "subscriptions");
			subscriptions.forEach((subscription: StreamingSubscription) => {
				this.subscriptions.Add(subscription.Id, subscription);
			})
		}
	}

	/**
	 * Adds a subscription to this connection.
	 *
	 * @param   {StreamingSubscription}   subscription   The subscription to add.
	 */
	AddSubscription(subscription: StreamingSubscription): void {
		this.ThrowIfDisposed();

		EwsUtilities.ValidateParam(subscription, "subscription");

		this.ValidateConnectionState(false, Strings.CannotAddSubscriptionToLiveConnection);

		//while (this.lockObject.isLocked) { }; //todo: implement blocking and non blocking multi threading when available.

		//this.lockObject.isLocked = true;

		//try {
		if (!this.subscriptions.containsKey(subscription.Id)) {
			this.subscriptions.Add(subscription.Id, subscription);
		}
		// } finally {
		// 	this.lockObject.isLocked = false;
		// }
	}

	/**
	 * Closes this connection so it stops receiving events from the server.
	 * This terminates a long-standing call to EWS.
	 * 
	 * @exception	{InvalidOperationException}		Thrown when Close is called while not connected.
	 */
	Close(): void {
		//todo: implement blocking and non blocking multi threading when available.
		//lock(this.lockObject) {
		this.ThrowIfDisposed();

		this.ValidateConnectionState(true, Strings.CannotCallDisconnectWithNoLiveConnection);

		// Further down in the stack, this will result in a call to our OnRequestDisconnect event handler,
		// doing the necessary cleanup.
		this.currentHangingRequest.Disconnect();
		//}
	}

	/**
	 * Frees resources associated with this StreamingSubscriptionConnection.
	 */
	Dispose(): void;
	/**
	 * @private Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
	 *
	 * @param   {boolean}   suppressFinalizer   Value indicating whether to suppress the garbage collector's finalizer..
	 */
	Dispose(suppressFinalizer: boolean): void;
	Dispose(suppressFinalizer: boolean = false): void {
		if (suppressFinalizer) {
			//GC.SuppressFinalize(this);
		}

		//todo: implement blocking and non blocking multi threading when available.
		//lock(this.lockObject) {
		if (!this.isDisposed) {
			if (this.currentHangingRequest != null) {
				this.currentHangingRequest = null;
			}

			this.subscriptions = null;
			this.session = null;

			this.isDisposed = true;
		}
		//}
	}

	/**
	 * Handles the service response object.
	 *
	 * @param   {any}   response   The response.
	 */
	private HandleServiceResponseObject(response: any): void {
		let gseResponse: GetStreamingEventsResponse = response as GetStreamingEventsResponse;

		if (!(gseResponse instanceof GetStreamingEventsResponse)) {
			throw new ArgumentException();
		}
		else {
			if (gseResponse.Result == ServiceResult.Success || gseResponse.Result == ServiceResult.Warning) {
				if (gseResponse.Results.Notifications.length > 0) {
					// We got notifications; dole them out.
					this.IssueNotificationEvents(gseResponse);
				}
				else {
					//// This was just a heartbeat, nothing to do here.
				}
			}
			else if (gseResponse.Result == ServiceResult.Error) {
				if (gseResponse.ErrorSubscriptionIds == null ||
					gseResponse.ErrorSubscriptionIds.length == 0) {
					// General error
					this.IssueGeneralFailure(gseResponse);
				}
				else {
					// subscription-specific errors
					this.IssueSubscriptionFailures(gseResponse);
				}
			}
		}
	}

	/**
	 * Internal helper method called when the request disconnects.
	 *
	 * @param   {Exception}   ex   The exception that caused the disconnection. May be null.
	 */
	private InternalOnDisconnect(ex: Exception): void {
		this.currentHangingRequest = null;

		if (this.OnDisconnect && ArrayHelper.isArray(this.OnDisconnect)) {
			try {
				this.OnDisconnect.forEach((onDisconnect) => { onDisconnect(this, new SubscriptionErrorEventArgs(null, ex)) });
			}
			catch (e) { }
		}
	}

	/**
	 * Internal helper method called when the request receives headers.
	 *
	 * @param   {any}   headers   The headerf from server.
	 */
	private InternalOnResponseHeader(headers: any): void {
		if (this.OnResponseHeader && ArrayHelper.isArray(this.OnResponseHeader)) {
			try {
				this.OnResponseHeader.forEach((onHeader) => { onHeader(headers) });
			}
			catch (e) { }
		}
	}

	/**
	 * Issues the general failure.
	 *
	 * @param   {GetStreamingEventsResponse}   gseResponse   The GetStreamingEvents response.
	 */
	private IssueGeneralFailure(gseResponse: GetStreamingEventsResponse): void {
		let eventArgs: SubscriptionErrorEventArgs = new SubscriptionErrorEventArgs(
			null,
			new ServiceResponseException(gseResponse));

		if (this.OnSubscriptionError && ArrayHelper.isArray(this.OnSubscriptionError)) {
			try {
				this.OnSubscriptionError.forEach((OnSubscriptionError) => { OnSubscriptionError(this, eventArgs) });
			}
			catch (e) { }
		}
	}

	/**
	 * Issues the notification events.
	 *
	 * @param   {GetStreamingEventsResponse}   gseResponse   The GetStreamingEvents response.
	 */
	private IssueNotificationEvents(gseResponse: GetStreamingEventsResponse): void {

		for (let events of gseResponse.Results.Notifications) {
			let subscription: StreamingSubscription = null;

			//todo: implement blocking and non blocking multi threading when available.
			//lock(this.lockObject) {
			// Client can do any good or bad things in the below event handler
			if (this.subscriptions != null && this.subscriptions.containsKey(events.SubscriptionId)) {
				subscription = this.subscriptions.get(events.SubscriptionId);
			}
			//}

			if (subscription != null) {
				let eventArgs: NotificationEventArgs = new NotificationEventArgs(
					subscription,
					events.Events);

				if (this.OnNotificationEvent && ArrayHelper.isArray(this.OnNotificationEvent)) {
					try {
						this.OnNotificationEvent.forEach((OnNotificationEvent) => { OnNotificationEvent(this, eventArgs) });
					}
					catch (e) { }
				}
			}
		}
	}

	/**
	 * Issues the subscription failures.
	 *
	 * @param   {GetStreamingEventsResponse}   gseResponse   The GetStreamingEvents response.
	 */
	private IssueSubscriptionFailures(gseResponse: GetStreamingEventsResponse): void {
		let exception: ServiceResponseException = new ServiceResponseException(gseResponse);

		for (let id of gseResponse.ErrorSubscriptionIds) {
			let subscription: StreamingSubscription = null;

			//todo: implement blocking and non blocking multi threading when available.
			//lock(this.lockObject) {
			// Client can do any good or bad things in the below event handler
			if (this.subscriptions != null && this.subscriptions.containsKey(id)) {
				subscription = this.subscriptions.get(id);
			}
			//}

			if (subscription != null) {
				let eventArgs: SubscriptionErrorEventArgs = new SubscriptionErrorEventArgs(
					subscription,
					exception);

				if (this.OnSubscriptionError && ArrayHelper.isArray(this.OnSubscriptionError)) {
					try {
						this.OnSubscriptionError.forEach((OnSubscriptionError) => { OnSubscriptionError(this, eventArgs) });
					}
					catch (e) { }
				}
			}

			if (gseResponse.ErrorCode != ServiceError.ErrorMissedNotificationEvents) {
				// Client can do any good or bad things in the above event handler
				//todo: implement blocking and non blocking multi threading when available.
				//lock(this.lockObject) {
				if (this.subscriptions != null && this.subscriptions.containsKey(id)) {
					// We are no longer servicing the subscription.
					this.subscriptions.remove(id);
				}
				//}
			}
		}
	}

	/**
	 * Called when the request is disconnected.
	 *
	 * @param   {any}   								sender   The sender.
	 * @param   {HangingRequestDisconnectEventArgs}   	args     The  instance containing the event data.
	 */
	private OnRequestDisconnect(sender: any, args: HangingRequestDisconnectEventArgs): void {
		this.InternalOnDisconnect(args.Exception);
	}

	/**
	 * Opens this connection so it starts receiving events from the server.
	 * This results in a long-standing call to EWS.
	 * 
	 * @exception	{InvalidOperationException}		Thrown when Open is called while connected.
	 */
	Open(): Promise<void> {
		//todo: implement blocking and non blocking multi threading when available.		
		//lock(this.lockObject) {
		this.ThrowIfDisposed();

		this.ValidateConnectionState(false, Strings.CannotCallConnectDuringLiveConnection);

		if (this.subscriptions.Count == 0) {
			throw new ServiceLocalException(Strings.NoSubscriptionsOnConnection);
		}

		this.currentHangingRequest = new GetStreamingEventsRequest(
			this.session,
			this.HandleServiceResponseObject.bind(this),
			this.subscriptions.Keys,
			this.connectionTimeout);

		this.currentHangingRequest.OnDisconnect.push(this.OnRequestDisconnect.bind(this)); //todo: fix if needed multiple instance new HangingServiceRequestBase.HangingRequestDisconnectHandler(this.OnRequestDisconnect)
		this.currentHangingRequest.OnResponseHeader = this.InternalOnResponseHeader.bind(this); //todo: fix if needed multiple instance new HangingServiceRequestBase.HangingRequestDisconnectHandler(this.OnRequestDisconnect)

		return this.currentHangingRequest.InternalExecute();
		//}
	}

	/**
	 * Removes the specified streaming subscription from the connection.
	 *
	 * @param   {StreamingSubscription}   subscription   The subscription to remove.
	 */
	RemoveSubscription(subscription: StreamingSubscription): void {

		this.ThrowIfDisposed();

		EwsUtilities.ValidateParam(subscription, "subscription");

		this.ValidateConnectionState(false, Strings.CannotRemoveSubscriptionFromLiveConnection);

		//while (this.lockObject.isLocked) { }; //todo: implement blocking and non blocking multi threading when available.

		//this.lockObject.isLocked = true;

		//try {
		this.subscriptions.remove(subscription.Id);
		// } finally {
		// 	this.lockObject.isLocked = false;
		// }
	}

	/**
	 * Throws if disposed.
	 */
	ThrowIfDisposed(): void {
		if (this.isDisposed) {
			throw new Error("ObjectDisposedException - StreamingSubscriptionConnection"); //ObjectDisposedException
		}
	}

	/**
	 * Validates the state of the connection.
	 *
	 * @param   {boolean}   isConnectedExpected   Value indicating whether we expect to be currently connected.
	 * @param   {string}   	errorMessage          The error message.
	 */
	ValidateConnectionState(isConnectedExpected: boolean, errorMessage: string): void {
		if ((isConnectedExpected && !this.IsOpen) ||
			(!isConnectedExpected && this.IsOpen)) {
			throw new ServiceLocalException(errorMessage);
		}
	}
}

/**
 * Represents a delegate that is invoked when notifications are received from the server
 *
 * @param   {any}   					sender   The StreamingSubscriptionConnection instance that received the events.
 * @param   {NotificationEventArgs}   	args     The event data.
 */
export interface NotificationEventDelegate {
	(sender: any, args: NotificationEventArgs): void;
}

/**
 * Represents a delegate that is invoked when an error occurs within a streaming subscription connection.
 *
 * @param   {any}   						sender   The StreamingSubscriptionConnection instance within which the error occurred.
 * @param   {SubscriptionErrorEventArgs}   	args     The event data.
 */
export interface SubscriptionErrorDelegate {
	(sender: any, args: SubscriptionErrorEventArgs): void;
}

/**
 * Represents a delegate that is invoked when an error occurs within a streaming subscription connection.
 *
 * @param   {any}   						sender   The StreamingSubscriptionConnection instance within which the error occurred.
 * @param   {SubscriptionErrorEventArgs}   	args     The event data.
 */
export interface ResponseHeaderDelegate {
	(header: any): void;
}

/**
 * Provides data to a StreamingSubscriptionConnection's OnSubscriptionError and OnDisconnect events.
 */
export class SubscriptionErrorEventArgs /*extends System.EventArgs*/ {

	/**
	 * Gets the subscription for which an error occurred. If Subscription is null, the error applies to the entire connection.
	 * 
	 * internal set
	 */
	Subscription: StreamingSubscription;

	/**
	 * Gets the exception representing the error. If Exception is null, the connection was cleanly closed by the server.
	 * 
	 * internal set
	 */
	Exception: Exception;

	/**
	 * @internal Initializes a new instance of the **SubscriptionErrorEventArgs** class.
	 *
	 * @param   {StreamingSubscription}   	subscription   The subscription for which an error occurred. If subscription is null, the error applies to the entire connection.
	 * @param   {Exception}   				exception      The exception representing the error. If exception is null, the connection was cleanly closed by the server.
	 */
	constructor(subscription: StreamingSubscription, exception: Exception) {
		this.Subscription = subscription;
		this.Exception = exception;
	}
}

/**
 * Represents an event as exposed by push and pull notifications. 
 */
export abstract class NotificationEvent {

	/**
	 * Type of this event.
	 */
	private eventType: EventType = EventType.Status;

	/**
	 * Date and time when the event occurred.
	 */
	private timestamp: DateTime = null;

	/**
	 * Id of parent folder of the item or folder this event applies to.
	 */
	private parentFolderId: FolderId = null;

	/**
	 * Id of the old prarent foldero of the item or folder this event applies to. 
	 * This property is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied. 
	 * For all other event types, oldParentFolderId will be null.
	 */
	private oldParentFolderId: FolderId = null;

	/**
	 * Gets the type of this event.
	 */
	get EventType(): EventType {
		return this.eventType;
	}

	/**
	 * Gets the date and time when the event occurred.
	 */
	get TimeStamp(): DateTime {
		return this.timestamp;
	}

	/**
	 * Gets the Id of the parent folder of the item or folder this event applie to.
	 */
	get ParentFolderId(): FolderId {
		return this.parentFolderId;
	}
	set ParentFolderId(value: FolderId) {
		this.parentFolderId = value;
	}

	/**
	 * Gets the Id of the old parent folder of the item or folder this event applies to. 
	 * OldParentFolderId is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied. 
	 * For all other event types, OldParentFolderId is null.
	 */
	get OldParentFolderId(): FolderId {
		return this.oldParentFolderId;
	}
	set OldParentFolderId(value: FolderId) {
		this.oldParentFolderId = value;
	}

	/**
	 * @internal Initializes a new instance of the **NotificationEvent** class.
	 *
	 * @param   {EventType}		eventType   Type of the event.
	 * @param   {DateTime}   	timestamp   The event timestamp.
	 */
	constructor(eventType: EventType, timestamp: DateTime) {
		this.eventType = eventType;
		this.timestamp = timestamp;
	}

	/**
     * @internal Loads this NotificationEvent from XML.
     *
     * @param   {any}                 jsEvent                Json Object converted from XML.
     * @param   {ExchangeService}     service                The service.    
     */
    abstract LoadFromXmlJsObject(jsEvent: any, service: ExchangeService): void;
}

/**
 * Represents an event that applies to a folder.
 */
export class FolderEvent extends NotificationEvent {

	private folderId: FolderId = null;
	private oldFolderId: FolderId = null;

	/**
	 * The new number of unread messages. This is is only meaningful when EventType is equal to EventType.Modified. For all other event types, it's null.
	 */
	private unreadCount: number = null;

	/**
	 * Gets the Id of the folder this event applies to.
	 */
	get FolderId(): FolderId {
		return this.folderId;
	}
	
	/**
	 * Gets the Id of the folder that was moved or copied. OldFolderId is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied. For all other event types, OldFolderId is null.
	 */
	get OldFolderId(): FolderId {
		return this.oldFolderId;
	}
	
	/**
	 * Gets the new number of unread messages. This is is only meaningful when EventType is equal to EventType.Modified. For all other event types, UnreadCount is null.
	 */
	get UnreadCount(): number {
		return this.unreadCount;
	}

	/**
	 * @internal Initializes a new instance of the **FolderEvent** class.
	 *
	 * @param   {EventType}		eventType   Type of the event.
	 * @param   {DateTime}   	timestamp   The event timestamp.
	 */
	constructor(eventType: EventType, timestamp: DateTime) {
		super(eventType, timestamp);
	}

	/**
     * @internal Loads from XML.
     *
     * @param   {any}                 jsEvent                Json Object converted from XML.
     * @param   {ExchangeService}     service                The service.    
     */
    LoadFromXmlJsObject(jsEvent: any, service: ExchangeService): void {
		this.folderId = new FolderId();
		this.folderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.FolderId], service);

		this.ParentFolderId = new FolderId();
		this.ParentFolderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.ParentFolderId], service);

		switch (this.EventType) {
			case EventType.Moved:
			case EventType.Copied:

				this.oldFolderId = new FolderId();
				this.oldFolderId.LoadFromXmlJsObject(jsEvent[JsonNames.OldFolderId], service);

				this.OldParentFolderId = new FolderId();
				this.OldParentFolderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.OldParentFolderId], service);
				break;

			case EventType.Modified:
				if (jsEvent[XmlElementNames.UnreadCount]) {
					this.unreadCount = Convert.toNumber(jsEvent[XmlElementNames.UnreadCount]);
				}
				break;

			default:
				break;
		}
	}
}

/**
 * Represents an event that applies to an item.
 */
export class ItemEvent extends NotificationEvent {

	/**
	 * Id of the item this event applies to.
	 */
	private itemId: ItemId = null;

	/**
	 * Id of the item that moved or copied. This is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied. 
	 * For all other event types, it's null.
	 */
	private oldItemId: ItemId = null;

	/**
	 * Gets the Id of the item this event applies to.
	 */
	get ItemId(): ItemId {
		return this.itemId;
	}

	/**
	 * Gets the Id of the item that was moved or copied. OldItemId is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied. 
	 * For all other event types, OldItemId is null.
	 */
	get OldItemId(): ItemId {
		return this.oldItemId;
	}

	/**
	 * @internal Initializes a new instance of the **FolderEvent** class.
	 *
	 * @param   {EventType}		eventType   Type of the event.
	 * @param   {DateTime}   	timestamp   The event timestamp.
	 */
	constructor(eventType: EventType, timestamp: DateTime) {
		super(eventType, timestamp);
	}

	/**
     * @internal Loads from XML.
     *
     * @param   {any}                 jsEvent                Json Object converted from XML.
     * @param   {ExchangeService}     service                The service.    
     */
    LoadFromXmlJsObject(jsEvent: any, service: ExchangeService): void {
		this.itemId = new ItemId();
		this.itemId.LoadFromXmlJsObject(jsEvent[XmlElementNames.ItemId], service);

		this.ParentFolderId = new FolderId();
		this.ParentFolderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.ParentFolderId], service);

		switch (this.EventType) {
			case EventType.Moved:
			case EventType.Copied:

				this.oldItemId = new ItemId();
				this.oldItemId.LoadFromXmlJsObject(jsEvent[JsonNames.OldItemId], service);

				this.OldParentFolderId = new FolderId();
				this.OldParentFolderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.OldParentFolderId], service);
				break;

			default:
				break;
		}
	}
}

/**
 * Represents the base class for event subscriptions.
 */
export abstract class SubscriptionBase {

	protected service: ExchangeService = null;
	private id: string = null;
	private watermark: string = null;

	/**
	 * Gets the session.
	 * 
	 * @value The session.
	 */
	get Service(): ExchangeService {
		return this.service;
	}

	/**
	 * Gets the Id of the subscription.
	 * 
	 * internal set
	 */
	get Id(): string {
		return this.id;
	}
	set Id(value: string) {
		this.id = value;
	}

	/**
	 * Gets the latest watermark of the subscription. Watermark is always null for streaming subscriptions.
	 * 
	 * internal set
	 */
	get Watermark(): string {
		return this.watermark;
	}
	set Watermark(value: string) {
		this.watermark = value;
	}

	/**
	 * Gets whether or not this subscription uses watermarks.
	 */
	protected get UsesWatermark(): boolean {
		return true;
	}

	/**
	 * @internal Initializes a new instance of the **SubscriptionBase** class.
	 *
	 * @param   {ExchangeService}   service     The service.
	 */
	constructor(service: ExchangeService);
	/**
	 * @internal Initializes a new instance of the **SubscriptionBase** class.
	 *
	 * @param   {ExchangeService}   service     The service.
	 * @param   {string}   			id          The id.
	 */
	constructor(service: ExchangeService, id: string);
	/**
	 * @internal Initializes a new instance of the **SubscriptionBase** class.
	 *
	 * @param   {ExchangeService}   service     The service.
	 * @param   {string}   			id          The id.
	 * @param   {string}   			watermark   The watermark.
	 */
	constructor(service: ExchangeService, id: string, watermark: string);
	constructor(service: ExchangeService, id: string = null, watermark: string = null) {
		EwsUtilities.ValidateParam(service, "service");
		this.service = service;
		if (arguments.length >= 2) {
			EwsUtilities.ValidateParam(id, "id");
		}
		this.id = id;
		this.watermark = watermark;
	}

	/**
     * @internal Loads from XML.
     *
     * @param   {any}                 jsObject               Json Object converted from XML.
     * @param   {ExchangeService}     service                The service.    
     */
	LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		this.id = jsObject[XmlElementNames.SubscriptionId];

		if (this.UsesWatermark) {
			this.watermark = jsObject[XmlElementNames.Watermark];
		}
	}
}


/**
 * Represents a pull subscription.
 * 
 * @sealed
 */
export class PullSubscription extends SubscriptionBase {

	private moreEventsAvailable: boolean = null;
	
	/**
	 * Gets a value indicating whether more events are available on the server.
	 * MoreEventsAvailable is undefined (null) until GetEvents is called.
	 */
	get MoreEventsAvailable(): boolean {
		return this.moreEventsAvailable;
	}

	/**
	 * @internal Initializes a new instance of the **PullSubscription** class.
	 *
	 * @param   {ExchangeService}   service     The service.
	 */
    constructor(service: ExchangeService) {
        super(service);
    }

	/**
	 * Obtains a collection of events that occurred on the subscribed folders since the point in time defined by the Watermark property. When GetEvents succeeds, Watermark is updated.
	 *
	 * @return  {Promise<GetEventsResults>}      Returns a collection of events that occurred since the last watermark	:Promise.
	 */
	GetEvents(): Promise<GetEventsResults> {
		return this.Service.GetEvents(this.Id, this.Watermark).then((results: GetEventsResults) => {

            this.Watermark = results.NewWatermark;
            this.moreEventsAvailable = results.MoreEventsAvailable;

            return results;
		});
	}

	/**
	 * Unsubscribes from the pull subscription.
	 */
	Unsubscribe(): Promise<void> { return this.Service.Unsubscribe(this.Id); }
}

/**
 * Represents a push subscriptions.
 * 
 * @sealed
 */
export class PushSubscription extends SubscriptionBase {

    /**
	 * @internal Initializes a new instance of the **PushSubscription** class.
	 *
	 * @param   {ExchangeService}   service     The service.
	 */
    constructor(service: ExchangeService) {
        super(service);
    }
}

/**
 * Represents a streaming subscription.
 * 
 * @sealed
 */
export class StreamingSubscription extends SubscriptionBase {

	/**
	 * Gets the service used to create this subscription.
	 */
	get Service(): ExchangeService {
		return this.service;
	}
	/**
	 * Gets a value indicating whether this subscription uses watermarks.
	 */
	protected get UsesWatermark(): boolean {
		return false;
	}

	/**
	 * @internal Initializes a new instance of the **StreamingSubscription** class.
	 *
	 * @param   {ExchangeService}   service     The service.
	 */
	constructor(service: ExchangeService) {
		super(service);
		this.service = service;
	}

	/**
	 * Unsubscribes from the streaming subscription.
	 */
	Unsubscribe(): Promise<void> { return this.Service.Unsubscribe(this.Id); }
}

/**
 * Represents the base search filter class. Use descendant search filter classes such as SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection to define search filters.
 */
export abstract class SearchFilter extends ComplexProperty {

    /**
     * Initializes a new instance of the **SearchFilter** class.
     */
    constructor() {
        super();
    }

    /**
     * Gets the search filter instance.
     * 
     * @param {string} localName Name of the local.
     * @returns {SearchFilter} 
     */
    static GetSearchFilterInstance(localName: string): SearchFilter {
        let searchFilter: SearchFilter;
        switch (localName) {
            case XmlElementNames.Exists:
                searchFilter = new SearchFilter.Exists();
                break;
            case XmlElementNames.Contains:
                searchFilter = new SearchFilter.ContainsSubstring();
                break;
            case XmlElementNames.Excludes:
                searchFilter = new SearchFilter.ExcludesBitmask();
                break;
            case XmlElementNames.Not:
                searchFilter = new SearchFilter.Not();
                break;
            case XmlElementNames.And:
                searchFilter = new SearchFilter.SearchFilterCollection(LogicalOperator.And);
                break;
            case XmlElementNames.Or:
                searchFilter = new SearchFilter.SearchFilterCollection(LogicalOperator.Or);
                break;
            case XmlElementNames.IsEqualTo:
                searchFilter = new SearchFilter.IsEqualTo();
                break;
            case XmlElementNames.IsNotEqualTo:
                searchFilter = new SearchFilter.IsNotEqualTo();
                break;
            case XmlElementNames.IsGreaterThan:
                searchFilter = new SearchFilter.IsGreaterThan();
                break;
            case XmlElementNames.IsGreaterThanOrEqualTo:
                searchFilter = new SearchFilter.IsGreaterThanOrEqualTo();
                break;
            case XmlElementNames.IsLessThan:
                searchFilter = new SearchFilter.IsLessThan();
                break;
            case XmlElementNames.IsLessThanOrEqualTo:
                searchFilter = new SearchFilter.IsLessThanOrEqualTo();
                break;
            default:
                searchFilter = null;
                break;
        }
        return searchFilter;
    }

    /**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    abstract GetXmlElementName(): string;

    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}               jsObject                Json Object converted from XML.
     * @param   {ExchangeService}   service                 The service.    
     * @param   {string}            typeName                 type name, when provided prevent call for type name check.    
	 * @return  {SearchFilter}      SearchFilter instance.
     */
    static LoadFromXmlJsObject(jsObject: any, service: ExchangeService, typeName: string = null): SearchFilter {
        if (!typeName) {
            typeName = TypeSystem.GetJsObjectTypeName(jsObject);
        }
        let searchFilter: SearchFilter = SearchFilter.GetSearchFilterInstance(jsObject.ReadTypeString());

        if (searchFilter != null) {
            searchFilter.LoadFromXmlJsObject(jsObject, service);
        }

        return searchFilter;
    }

    /**
     * @internal Writes to XML.
     * 
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        super.WriteToXml(writer, this.GetXmlElementName());
    }
}

export module SearchFilter {
    export var ContainsSubstring: IContainsSubstring;
    export var ExcludesBitmask: IExcludesBitmask;
    export var Exists: IExists;
    export var IsEqualTo: IIsEqualTo;
    export var IsGreaterThan: IIsGreaterThan;
    export var IsGreaterThanOrEqualTo: IIsGreaterThanOrEqualTo;
    export var IsLessThan: IIsLessThan;
    export var IsLessThanOrEqualTo: IIsLessThanOrEqualTo;
    export var IsNotEqualTo: IIsNotEqualTo;
    export var Not: INot;
    export var PropertyBasedFilter: IPropertyBasedFilter;
    export var RelationalFilter: IRelationalFilter;
    export var SearchFilterCollection: ISearchFilterCollection;
}

/**
 * Represents a search filter that negates another. Applications can use NotFilter to define conditions such as "NOT(other filter)".
 */
export class Not extends SearchFilter {

	private searchFilter: SearchFilter;

	/**
	 * Gets or sets the search filter to negate. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
	 */
	get SearchFilter(): SearchFilter {
		return this.searchFilter;
	}
	set SearchFilter(value: SearchFilter) {
		if (this.searchFilter !== null) {
			ArrayHelper.RemoveEntry(this.searchFilter.OnChange, this.SearchFilterChanged);
		}
		this.SetFieldValue<SearchFilter>({ getValue: () => this.searchFilter, setValue: (updateValue) => { this.searchFilter = updateValue } }, value);

		if (this.searchFilter !== null) {
			this.searchFilter.OnChange.push(this.SearchFilterChanged.bind(this));
		}
	}

	/**
	 * Initializes a new instance of the **Not** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **Not** class.
	 *
	 * @param   {SearchFilter}   searchFilter   The search filter to negate. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
	 */
	constructor(searchFilter: SearchFilter);
	constructor(searchFilter: SearchFilter = null) {
		super();
		this.searchFilter = searchFilter;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.Not; }

	/**
	 * @internal Validate instance.
	 */
	InternalValidate(): void {
		if (this.searchFilter == null) {
			throw new ServiceValidationException(Strings.SearchFilterMustBeSet);
		}
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		this.searchFilter = SearchFilter.LoadFromXmlJsObject(jsObject, service);
	}

	/**
	 * Gets or sets the search filter to negate. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
	 */
	SearchFilterChanged(complexProperty: ComplexProperty): void { this.Changed(); }

	/**
	 * @internal Writes the elements to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void { this.SearchFilter.WriteToXml(writer); }
}

export interface INot {
	new (): Not;
	new (searchFilter: SearchFilter): Not;
}

/**
 * Represents a collection of search filters linked by a logical operator. Applications can use SearchFilterCollection to define complex search filters such as "Condition1 AND Condition2".
 */
export class SearchFilterCollection extends SearchFilter implements IEnumerable<SearchFilter> {

	private searchFilters: SearchFilter[] = [];
	private logicalOperator: LogicalOperator = LogicalOperator.And;

	/**
	 * Gets the total number of search filters in the collection.
	 */
	get Count(): number {
		return this.searchFilters.length;
	}

	/**
	 * Gets or sets the logical operator that links the serach filters in this collection.
	 */
	get LogicalOperator(): LogicalOperator {
		return this.logicalOperator;
	}
	set LogicalOperator(value: LogicalOperator) {
		this.logicalOperator = value;
	}

	/**
	 * Initializes a new instance of the **SearchFilterCollection** class. The LogicalOperator property is initialized to LogicalOperator.And.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **SearchFilterCollection** class.
	 *
	 * @param   {LogicalOperator}   logicalOperator   The logical operator used to initialize the collection.
	 */
	constructor(logicalOperator: LogicalOperator);
	/**
	 * Initializes a new instance of the **SearchFilterCollection** class.
	 *
	 * @param   {LogicalOperator}   logicalOperator   The logical operator used to initialize the collection.
	 * @param   {SearchFilter[]}   	searchFilters     The search filters to add to the collection.
	 */
	constructor(logicalOperator: LogicalOperator, searchFilters: SearchFilter[]);
	/**
	 * Initializes a new instance of the **SearchFilterCollection** class.
	 *
	 * @param   {LogicalOperator}   logicalOperator   The logical operator used to initialize the collection.
	 * @param   {...SearchFilter[]}   	...searchFilters     The search filters to add to the collection.
	 */
	constructor(logicalOperator: LogicalOperator, ...searchFilters: SearchFilter[]);
	constructor(logicalOperator?: LogicalOperator, _searchFilters?: SearchFilter[] | SearchFilter) {
		super();
		var searchFilters: SearchFilter[] = [];
		if (arguments.length <= 2) {
			if (ArrayHelper.isArray(_searchFilters)) {
				searchFilters = _searchFilters;
			}
			else if (typeof SearchFilter[<any>_searchFilters] !== 'undefined') {
				searchFilters.push(arguments[1]);
			}
		}
		else {
			for (var _i = 1; _i < arguments.length; _i++) {
				searchFilters[_i - 1] = arguments[_i];
			}
		}

		this.logicalOperator = logicalOperator || this.logicalOperator;
		this.AddRange(searchFilters);
	}

	/**
	 * Gets or sets the search filter at the specified index.
	 *
	 * @param   {number}   index   The zero-based index of the search filter to get or set.
	 * @return  {SearchFilter}           The search filter at the specified index.
	 */
	_getItem(index: number): SearchFilter { // c# this indexer
		if (index < 0 || index >= this.Count) {
			throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
		}
		return this.searchFilters[index];
	}

	/**
	 * Gets or sets the search filter at the specified index.
	 *
	 * @param   {number}   index   The zero-based index of the search filter to get or set.
	 * @return  {SearchFilter}           The search filter at the specified index.
	 */
	_setItem(index: number, value: SearchFilter): void {
		if (index < 0 || index >= this.Count) {
			throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
		}
		this.searchFilters[index] = value;
	}

	/**
	 * Adds a search filter of any type to the collection.
	 *
	 * @param   {SearchFilter}   searchFilter   The search filter to add. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
	 */
	Add(searchFilter: SearchFilter): void {
		if (searchFilter == null) {
			throw new ArgumentNullException("searchFilter");
		}

		searchFilter.OnChange.push(this.SearchFilterChanged.bind(this));
		this.searchFilters.push(searchFilter);
		this.Changed();
	}

	/**
	 * Adds multiple search filters to the collection.
	 *
	 * @param   {SearchFilter[]}   searchFilters   The search filters to add. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
	 */
	AddRange(searchFilters: SearchFilter[]): void {
		if (searchFilters == null) {
			throw new ArgumentNullException("searchFilters");
		}

		for (let searchFilter of searchFilters) {
			searchFilter.OnChange.push(this.SearchFilterChanged.bind(this));
		}
		ArrayHelper.AddRange(this.searchFilters, searchFilters);
		this.Changed();
	}

	/**
	 * Clears the collection.
	 */
	Clear(): void {
		if (this.Count > 0) {
			for (let searchFilter of this.searchFilters) {
				ArrayHelper.RemoveEntry(searchFilter.OnChange, this.SearchFilterChanged)
				//searchFilter.OnChange -= this.SearchFilterChanged;
			}
			this.searchFilters.splice(0);
			this.Changed();
		}
	}

	/**
	 * Determines whether a specific search filter is in the collection.
	 *
	 * @param   {SearchFilter} 	searchFilter   The search filter to locate in the collection.
	 * @return  {boolean}		True is the search filter was found in the collection, false otherwise.
	 */
	Contains(searchFilter: SearchFilter): boolean {
		return this.searchFilters.indexOf(searchFilter) >= 0;
	}

	/**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
	GetEnumerator(): SearchFilter[] {
		return this.searchFilters;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
	GetXmlElementName(): string { return LogicalOperator[this.LogicalOperator]; }

	/**
	 * @internal Validate instance.
	 */
	InternalValidate(): void {
		for (let i = 0; i < this.Count; i++) {
			try {
				this._getItem(i).InternalValidate();
			}
			catch (e) {
				if (e instanceof ServiceValidationException) {
					throw new ServiceValidationException(StringHelper.Format(Strings.SearchFilterAtIndexIsInvalid, i), e);
				}
			}
		}
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.    
     */
	LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		for (var key in jsObject) {
			if (key.indexOf("__") === 0) continue;
			let filter = SearchFilter.LoadFromXmlJsObject(jsObject[key], service, key);
			if (filter) {
				this.Add(filter);
			}
		}
	}

	/**
	 * Removes a search filter from the collection.
	 *
	 * @param   {SearchFilter}   searchFilter   The search filter to remove.
	 */
	Remove(searchFilter: SearchFilter): void {
		if (searchFilter == null) {
			throw new ArgumentNullException("searchFilter");
		}

		if (this.Contains(searchFilter)) {
			ArrayHelper.RemoveEntry(searchFilter.OnChange, this.SearchFilterChanged);
			ArrayHelper.RemoveEntry(this.searchFilters, searchFilter);
			this.Changed();
		}
	}

	/**
	 * Removes the search filter at the specified index from the collection.
	 *
	 * @param   {number}   index   The zero-based index of the search filter to remove.
	 */
	RemoveAt(index: number): void {
		if (index < 0 || index >= this.Count) {
			throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
		}

		ArrayHelper.RemoveEntry(this._getItem(index).OnChange, this.SearchFilterChanged);
		this.searchFilters.splice(index, 1);
		this.Changed();
	}

	/**
	 * A search filter has changed.
	 *
	 * @param   {ComplexProperty}   complexProperty   The complex property.
	 */
	private SearchFilterChanged(complexProperty: ComplexProperty): void { this.Changed(); }

	/**
	 * @internal Writes the elements to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		for (let searchFilter of this.searchFilters) {
			searchFilter.WriteToXml(writer);
		}
	}

	/**
	 * @internal Writes to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteToXml(writer: EwsServiceXmlWriter): void {
		// If there is only one filter in the collection, which developers tend to do,
		// we need to not emit the collection and instead only emit the one filter within
		// the collection. This is to work around the fact that EWS does not allow filter
		// collections that have less than two elements.
		if (this.Count == 1) {
			this._getItem(0).WriteToXml(writer);
		}
		else {
			super.WriteToXml(writer);
		}
	}
}

export interface ISearchFilterCollection {
	new (): SearchFilterCollection;
	new (logicalOperator: LogicalOperator): SearchFilterCollection;
	new (logicalOperator: LogicalOperator, searchFilters: SearchFilter[]): SearchFilterCollection;
}

export abstract class PropertyBasedFilter extends SearchFilter {

	private propertyDefinition: PropertyDefinitionBase = null;

	/**
	 * Gets or sets the definition of the property that is involved in the search filter. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 */
	get PropertyDefinition(): PropertyDefinitionBase {
		return this.propertyDefinition;
	}
	set PropertyDefinition(value: PropertyDefinitionBase) {
		this.SetFieldValue<PropertyDefinitionBase>({ getValue: () => this.propertyDefinition, setValue: (updateValue) => { this.propertyDefinition = updateValue } }, value);
	}

	/**
	 * @internal Initializes a new instance of the **PropertyBasedFilter** class.˝
	 */
	constructor();
	/**
	 * @internal Initializes a new instance of the **PropertyBasedFilter** class.
	 *
	 * @param   {PropertyDefinitionBase}   propertyDefinition   The property definition.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase);
	constructor(propertyDefinition?: PropertyDefinitionBase) {
		super();
		if (arguments.length === 1) {
			this.propertyDefinition = propertyDefinition;
		}
	}

	/**
	 * @internal Validate instance.
	 */
	InternalValidate(): void {
		if (this.propertyDefinition == null) {
			throw new ServiceValidationException(Strings.PropertyDefinitionPropertyMustBeSet);
		}
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		this.PropertyDefinition = PropertyDefinitionBase.LoadFromXmlJsObject(jsObject);
	}

	/**
	 * @internal Writes the elements to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void { this.PropertyDefinition.WriteToXml(writer); }
}

export interface IPropertyBasedFilter {
	new (): PropertyBasedFilter;
	new (propertyDefinition: PropertyDefinitionBase): PropertyBasedFilter;
}

/**
 * Represents a search filter that checks for the presence of a substring inside a text property. Applications can use ContainsSubstring to define conditions such as "Field CONTAINS Value" or "Field IS PREFIXED WITH Value".
 */
export class ContainsSubstring extends PropertyBasedFilter {

	private containmentMode: ContainmentMode; // = ContainmentMode.Substring;
	private comparisonMode: ComparisonMode; // = ComparisonMode.IgnoreCase;
	private value: string; // = null;

	/**
	 * Gets or sets the containment mode.
	 */
	get ContainmentMode(): ContainmentMode {
		return this.containmentMode;
	}
	set ContainmentMode(value: ContainmentMode) {
		this.SetFieldValue<ContainmentMode>({ getValue: () => this.containmentMode, setValue: (updateValue) => { this.containmentMode = updateValue } }, value);
	}

	/**
	 * Gets or sets the comparison mode.
	 */
	get ComparisonMode(): ComparisonMode {
		return this.comparisonMode;
	}
	set ComparisonMode(value: ComparisonMode) {
		this.SetFieldValue<ComparisonMode>({ getValue: () => this.comparisonMode, setValue: (updateValue) => { this.comparisonMode = updateValue } }, value);
	}

	/**
	 * Gets or sets the value to compare the specified property with.
	 */
	get Value(): string {
		return this.value;
	}
	set Value(value: string) {
		this.SetFieldValue<string>({ getValue: () => this.value, setValue: (updateValue) => { this.value = updateValue } }, value);
	}

	/**
	 * Initializes a new instance of the **ContainsSubstring** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **ContainsSubstring** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {string}   					value                The value to compare with.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, value: string);
	/**
	 * Initializes a new instance of the **ContainsSubstring** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {string}   					value                The value to compare with.
	 * @param   {ContainmentMode}   		containmentMode      The containment mode.
	 * @param   {ComparisonMode}   			comparisonMode       The comparison mode.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, value: string, containmentMode: ContainmentMode, comparisonMode: ComparisonMode);
	constructor(propertyDefinition: PropertyDefinitionBase = null, value: string = null, containmentMode: ContainmentMode = ContainmentMode.Substring, comparisonMode: ComparisonMode = ComparisonMode.IgnoreCase) {
		arguments.length === 0 ? super() : super(propertyDefinition);
		this.value = value;
		this.containmentMode = containmentMode;
		this.comparisonMode = comparisonMode;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
	GetXmlElementName(): string { return XmlElementNames.Contains; }

	/**
	 * @internal Validate instance.
	 */
	InternalValidate(): void {
		super.InternalValidate();

		if (StringHelper.IsNullOrEmpty(this.value)) {
			throw new ServiceValidationException(Strings.ValuePropertyMustBeSet);
		}
	}

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		super.LoadFromXmlJsObject(jsObject, service);

		this.value = jsObject[XmlElementNames.Constant][XmlElementNames.Value];
		this.containmentMode = ContainmentMode[<string>jsObject[XmlAttributeNames.ContainmentMode]];
		this.comparisonMode = ComparisonMode[<string>jsObject[XmlAttributeNames.ContainmentComparison]];
	}

	/**
	 * @internal Writes the attributes to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
		super.WriteAttributesToXml(writer);

		writer.WriteAttributeValue(XmlAttributeNames.ContainmentMode, ContainmentMode[this.ContainmentMode]);
		writer.WriteAttributeValue(XmlAttributeNames.ContainmentComparison, ComparisonMode[this.ComparisonMode]);
	}

	/**
	 * @internal Writes the elements to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		super.WriteElementsToXml(writer);

		writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Constant);
		writer.WriteAttributeValue(XmlAttributeNames.Value, this.Value);
		writer.WriteEndElement(); // Constant
	}
}

export interface IContainsSubstring {
	new (): ContainsSubstring;
	new (propertyDefinition: PropertyDefinitionBase, value: string): ContainsSubstring;
	new (propertyDefinition: PropertyDefinitionBase, value: string, containmentMode: ContainmentMode, comparisonMode: ComparisonMode): ContainsSubstring;
}

/**
 * Represents a bitmask exclusion search filter. Applications can use ExcludesBitExcludesBitmaskFilter to define conditions such as "(OrdinalField and 0x0010) != 0x0010"
 */
export class ExcludesBitmask extends PropertyBasedFilter {

	private bitmask: number;

	/**
	 * Gets or sets the bitmask to compare the property with.
	 */
	get Bitmask(): number {
		return this.bitmask;
	}
	set Bitmask(value: number) {
		this.SetFieldValue<number>({ getValue: () => this.bitmask, setValue: (updateValue) => { this.bitmask = updateValue } }, value);
	}

	/**
	 * Initializes a new instance of the **ExcludesBitmask** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **ExcludesBitmask** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {number}   					bitmask              The bitmask to compare with.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, bitmask: number);
	constructor(propertyDefinition?: PropertyDefinitionBase, bitmask: number = 0) {
		arguments.length === 0 ? super() : super(propertyDefinition);
		this.bitmask = bitmask;
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.Excludes; }

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}               jsObject                Json Object converted from XML.
     * @param   {ExchangeService}   service                 The service.    
     * @param   {string}            typeName                 type name, when provided prevent call for type name check.    
	 * @return  {SearchFilter}      SearchFilter instance.
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
		super.LoadFromXmlJsObject(jsObject, service);

		this.bitmask = Convert.toInt(jsObject[XmlElementNames.Bitmask][XmlElementNames.Value]);
	}

	/**
	 * @internal Writes the elements to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteElementsToXml(writer: EwsServiceXmlWriter): void {
		super.WriteElementsToXml(writer);

		writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Bitmask);
		writer.WriteAttributeValue(XmlAttributeNames.Value, this.Bitmask);
		writer.WriteEndElement(); // Bitmask
	}
}

export interface IExcludesBitmask {
	new (): ExcludesBitmask;
	new (propertyDefinition: PropertyDefinitionBase, bitmask: number): ExcludesBitmask;
}

/**
 * Represents a search filter checking if a field is set. Applications can use ExistsFilter to define conditions such as "Field IS SET".
 */
export class Exists extends PropertyBasedFilter {

	/**
	 * Initializes a new instance of the **Exists** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **Exists** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property to check the existence of. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 */
	constructor(propertyDefinition: PropertyDefinitionBase);
	constructor(propertyDefinition?: PropertyDefinitionBase) {
		arguments.length === 0 ? super() : super(propertyDefinition);
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.Exists; }
}

export interface IExists {
	new (): Exists;
	new (propertyDefinition: PropertyDefinitionBase): Exists;
}

/**
 * Represents the base class for relational filters (for example, IsEqualTo, IsGreaterThan or IsLessThanOrEqualTo).
 */
export abstract class RelationalFilter extends PropertyBasedFilter {

    private otherPropertyDefinition: PropertyDefinitionBase;
    private value: any;

    /**
     * Gets or sets the definition of the property to compare with. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.) 
     * The OtherPropertyDefinition and Value properties are mutually exclusive; setting one resets the other to null.
     */
    get OtherPropertyDefinition(): PropertyDefinitionBase {
        return this.otherPropertyDefinition;
    }
    set OtherPropertyDefinition(value: PropertyDefinitionBase) {
        this.SetFieldValue<PropertyDefinitionBase>({ getValue: () => this.otherPropertyDefinition, setValue: (updateValue) => { this.otherPropertyDefinition = updateValue } }, value);
        this.value = null;
    }

    /**
     * Gets or sets the value to compare with. The Value and OtherPropertyDefinition properties are mutually exclusive; setting one resets the other to null.
     */
    get Value(): any {
        return this.value;
    }
    set Value(value: any) {
        this.SetFieldValue<any>({ getValue: () => this.value, setValue: (updateValue) => { this.value = updateValue } }, value);
        this.otherPropertyDefinition = null;
    }

    /**
	 * Initializes a new instance of the **RelationalFilter** class.
	 */
    constructor();
	/**
	 * Initializes a new instance of the **RelationalFilter** class.
	 *
	 * @param   {PropertyDefinitionBase}   propertyDefinition        The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {PropertyDefinitionBase}   otherPropertyDefinition   The definition of the property to compare with. Property definitions are available on schema classes (EmailMessageSchema, AppointmentSchema, etc.)
	 */
    constructor(propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase);
	/**
	 * Initializes a new instance of the **RelationalFilter** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {any}   					value                The value to compare the property with.
	 */
    constructor(propertyDefinition: PropertyDefinitionBase, value: any);
    constructor(propertyDefinition: PropertyDefinitionBase = null, otherPropertyDefinitionOrValue: any | PropertyDefinitionBase = null) {
        arguments.length === 0 ? super() : super(propertyDefinition);
        if (arguments.length === 0) {
            return;
        }

        if (otherPropertyDefinitionOrValue instanceof PropertyDefinitionBase) {
            this.otherPropertyDefinition = otherPropertyDefinitionOrValue;
        }
        else {
            this.value = otherPropertyDefinitionOrValue;
        }
    }

	/**
	 * @internal Validate instance.
	 */
    InternalValidate(): void {
        super.InternalValidate();

        if (this.otherPropertyDefinition == null && this.value == null) {
            throw new ServiceValidationException(Strings.EqualityComparisonFilterIsInvalid);
        }
        else if (this.value != null) {
            // All common value types (String, Int32, DateTime, ...) implement IConvertible.
            // Value types that don't implement IConvertible must implement ISearchStringProvider 
            // in order to be used in a search filter.
            if (!(TypeSystem.IsGenericType(this.value) || (typeof this.value.GetSearchString === 'function'))) // checking - ISearchStringProvider
            {
                throw new ServiceValidationException(
                    StringHelper.Format(Strings.SearchFilterComparisonValueTypeIsNotSupported, (<any>this.constructor).name));
            }
        }
    }

	/**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.    
     */
    LoadFromXmlJsObject(jsObject: any, service: ExchangeService): void {
        super.LoadFromXmlJsObject(jsObject, service);

        let jsonFieldUriOrConstant = jsObject[XmlElementNames.FieldURIOrConstant];

        if (TypeSystem.GetJsObjectTypeName(jsonFieldUriOrConstant) == XmlElementNames.Constant) {
            this.value = jsonFieldUriOrConstant[XmlElementNames.Value];
        }
        else {
            this.otherPropertyDefinition = PropertyDefinitionBase.LoadFromXmlJsObject(jsObject);
        }
    }

	/**
	 * @internal Writes the elements to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteElementsToXml(writer: EwsServiceXmlWriter): void {
        super.WriteElementsToXml(writer);

        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.FieldURIOrConstant);

        if (this.Value != null) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Constant);
            writer.WriteAttributeValue(XmlAttributeNames.Value, true /* alwaysWriteEmptyString */, this.Value);
            writer.WriteEndElement(); // Constant
        }
        else {
            this.OtherPropertyDefinition.WriteToXml(writer);
        }

        writer.WriteEndElement(); // FieldURIOrConstant
    }
}

export interface IRelationalFilter {
    new (): RelationalFilter;
    new (propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase): RelationalFilter;
    new (propertyDefinition: PropertyDefinitionBase, value: any): RelationalFilter;
}

/**
 * Represents a search filter that checks if a property is equal to a given value or other property.
 */
export class IsEqualTo extends RelationalFilter {

	/**
	 * Initializes a new instance of the **IsEqualTo** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **IsEqualTo** class.
	 *
	 * @param   {PropertyDefinitionBase}   propertyDefinition        The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {PropertyDefinitionBase}   otherPropertyDefinition   The definition of the property to compare with. Property definitions are available on schema classes (EmailMessageSchema, AppointmentSchema, etc.)
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase);
	/**
	 * Initializes a new instance of the **IsEqualTo** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {any}   					value                The value to compare the property with.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, value: any);
	constructor(propertyDefinition?: PropertyDefinitionBase, otherPropertyDefinitionOrValue?: any | PropertyDefinitionBase) {
		arguments.length === 0 ? super() : super(propertyDefinition, otherPropertyDefinitionOrValue);
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.IsEqualTo; }
}

export interface IIsEqualTo {
	new (): IsEqualTo;
	new (propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase):IsEqualTo;
	new (propertyDefinition: PropertyDefinitionBase, value: any): IsEqualTo;
}

/**
 * Represents a search filter that checks if a property is greater than a given value or other property.
 */
export class IsGreaterThan extends RelationalFilter {

	/**
	 * Initializes a new instance of the **IsGreaterThan** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **IsGreaterThan** class.
	 *
	 * @param   {PropertyDefinitionBase}   propertyDefinition        The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {PropertyDefinitionBase}   otherPropertyDefinition   The definition of the property to compare with. Property definitions are available on schema classes (EmailMessageSchema, AppointmentSchema, etc.)
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase);
	/**
	 * Initializes a new instance of the **IsGreaterThan** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {any}   					value                The value to compare the property with.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, value: any);
	constructor(propertyDefinition?: PropertyDefinitionBase, otherPropertyDefinitionOrValue?: any | PropertyDefinitionBase) {
		arguments.length === 0 ? super() : super(propertyDefinition, otherPropertyDefinitionOrValue);
	}


	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.IsGreaterThan; }
}

export interface IIsGreaterThan {
	new (): IsGreaterThan;
	new (propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase):IsGreaterThan;
	new (propertyDefinition: PropertyDefinitionBase, value: any): IsGreaterThan;
}

/**
 * Represents a search filter that checks if a property is greater than or equal to a given value or other property.
 */
export class IsGreaterThanOrEqualTo extends RelationalFilter {

	/**
	 * Initializes a new instance of the **IsGreaterThanOrEqualTo** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **IsGreaterThanOrEqualTo** class.
	 *
	 * @param   {PropertyDefinitionBase}   propertyDefinition        The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {PropertyDefinitionBase}   otherPropertyDefinition   The definition of the property to compare with. Property definitions are available on schema classes (EmailMessageSchema, AppointmentSchema, etc.)
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase);
	/**
	 * Initializes a new instance of the **IsGreaterThanOrEqualTo** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {any}   					value                The value to compare the property with.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, value: any);
	constructor(propertyDefinition?: PropertyDefinitionBase, otherPropertyDefinitionOrValue?: any | PropertyDefinitionBase) {
		arguments.length === 0 ? super() : super(propertyDefinition, otherPropertyDefinitionOrValue);
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.IsGreaterThanOrEqualTo;}
}

export interface IIsGreaterThanOrEqualTo {
	new (): IsGreaterThanOrEqualTo;
	new (propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase):IsGreaterThanOrEqualTo;
	new (propertyDefinition: PropertyDefinitionBase, value: any): IsGreaterThanOrEqualTo;
}

/**
 * Represents a search filter that checks if a property is less than a given value or other property.
 */
export class IsLessThan extends RelationalFilter {

	/**
	 * Initializes a new instance of the **IsLessThan** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **IsLessThan** class.
	 *
	 * @param   {PropertyDefinitionBase}   propertyDefinition        The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {PropertyDefinitionBase}   otherPropertyDefinition   The definition of the property to compare with. Property definitions are available on schema classes (EmailMessageSchema, AppointmentSchema, etc.)
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase);
	/**
	 * Initializes a new instance of the **IsLessThan** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {any}   					value                The value to compare the property with.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, value: any);
	constructor(propertyDefinition?: PropertyDefinitionBase, otherPropertyDefinitionOrValue?: any | PropertyDefinitionBase) {
		arguments.length === 0 ? super() : super(propertyDefinition, otherPropertyDefinitionOrValue);
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.IsLessThan; }
}

export interface IIsLessThan {
	new (): IsLessThan;
	new (propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase):IsLessThan;
	new (propertyDefinition: PropertyDefinitionBase, value: any): IsLessThan;
}

/**
 * Represents a search filter that checks if a property is less than or equal to a given value or other property.
 */
export class IsLessThanOrEqualTo extends RelationalFilter {

	/**
	 * Initializes a new instance of the **IsLessThanOrEqualTo** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **IsLessThanOrEqualTo** class.
	 *
	 * @param   {PropertyDefinitionBase}   propertyDefinition        The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {PropertyDefinitionBase}   otherPropertyDefinition   The definition of the property to compare with. Property definitions are available on schema classes (EmailMessageSchema, AppointmentSchema, etc.)
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase);
	/**
	 * Initializes a new instance of the **IsLessThanOrEqualTo** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {any}   					value                The value to compare the property with.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, value: any);
	constructor(propertyDefinition?: PropertyDefinitionBase, otherPropertyDefinitionOrValue?: any | PropertyDefinitionBase) {
		arguments.length === 0 ? super() : super(propertyDefinition, otherPropertyDefinitionOrValue);
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.IsLessThanOrEqualTo; }
}

export interface IIsLessThanOrEqualTo {
	new (): IsLessThanOrEqualTo;
	new (propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase):IsLessThanOrEqualTo;
	new (propertyDefinition: PropertyDefinitionBase, value: any): IsLessThanOrEqualTo;
}

/**
 * Represents a search filter that checks if a property is not equal to a given value or other property.
 */
export class IsNotEqualTo extends RelationalFilter {

	/**
	 * Initializes a new instance of the **IsNotEqualTo** class.
	 */
	constructor();
	/**
	 * Initializes a new instance of the **IsNotEqualTo** class.
	 *
	 * @param   {PropertyDefinitionBase}   propertyDefinition        The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {PropertyDefinitionBase}   otherPropertyDefinition   The definition of the property to compare with. Property definitions are available on schema classes (EmailMessageSchema, AppointmentSchema, etc.)
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase);
	/**
	 * Initializes a new instance of the **IsNotEqualTo** class.
	 *
	 * @param   {PropertyDefinitionBase}   	propertyDefinition   The definition of the property that is being compared. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
	 * @param   {any}   					value                The value to compare the property with.
	 */
	constructor(propertyDefinition: PropertyDefinitionBase, value: any);
	constructor(propertyDefinition?: PropertyDefinitionBase, otherPropertyDefinitionOrValue?: any | PropertyDefinitionBase) {
		arguments.length === 0 ? super() : super(propertyDefinition, otherPropertyDefinitionOrValue);
	}

	/**
	 * @internal Gets the name of the XML element.
	 *
	 * @return  {string}      XML element name.
	 */
    GetXmlElementName(): string { return XmlElementNames.IsNotEqualTo; }
}

export interface IIsNotEqualTo {
	new (): IsNotEqualTo;
	new (propertyDefinition: PropertyDefinitionBase, otherPropertyDefinition: PropertyDefinitionBase): IsNotEqualTo;
	new (propertyDefinition: PropertyDefinitionBase, value: any): IsNotEqualTo;
}
SearchFilter.ContainsSubstring = ContainsSubstring;
SearchFilter.ExcludesBitmask = ExcludesBitmask;
SearchFilter.Exists = Exists;
SearchFilter.IsEqualTo = IsEqualTo;
SearchFilter.IsGreaterThan = IsGreaterThan;
SearchFilter.IsGreaterThanOrEqualTo = IsGreaterThanOrEqualTo;
SearchFilter.IsLessThan = IsLessThan;
SearchFilter.IsLessThanOrEqualTo = IsLessThanOrEqualTo;
SearchFilter.IsNotEqualTo = IsNotEqualTo;
SearchFilter.Not = Not;
SearchFilter.PropertyBasedFilter = <any>PropertyBasedFilter;
SearchFilter.RelationalFilter = <any>RelationalFilter;
SearchFilter.SearchFilterCollection = SearchFilterCollection;

/**
 * Represents the base view class for search operations.
 */
export abstract class ViewBase {

    private propertySet: PropertySet = null;

    /**
     * Gets or sets the property set. PropertySet determines which properties will be loaded on found items. If PropertySet is null, all first class properties are loaded on found items.
     */
    get PropertySet(): PropertySet {
        return this.propertySet;
    }
    set PropertySet(value: PropertySet) {
        this.propertySet = value;
    }

    /**
     * @internal Initializes a new instance of the **ViewBase** class.
     */
    constructor() {
    }

    /**
     * @internal Gets the maximum number of items or folders the search operation should return.
     *
     * @return  {number?}      The maximum number of items or folders that should be returned by the search operation.
     */
    abstract GetMaxEntriesReturned(): number;

    /**
     * @internal Gets the property set or the default.
     *
     * @return  {PropertySet}      PropertySet
     */
    GetPropertySetOrDefault(): PropertySet { return this.PropertySet || PropertySet.FirstClassProperties; }

    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    GetServiceObjectType(): ServiceObjectType { throw new Error("abstract - ViewBase.ts - GetServiceObjectType : Not implemented."); }

    /**
     * @internal Gets the name of the view XML element.
     *
     * @return  {string}      XML element name.
     */
    abstract GetViewXmlElementName(): string;

    /**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    InternalValidate(request: ServiceRequestBase): void {
        if (this.PropertySet !== null && typeof this.PropertySet !== 'undefined') {
            this.PropertySet.InternalValidate();
            this.PropertySet.ValidateForRequest(request, true /*summaryPropertiesOnly*/);
        }
    }

    /**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    abstract InternalWriteSearchSettingsToXml(writer: EwsServiceXmlWriter, groupBy: Grouping): void;

    /**
	 * @internal Writes this view to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    InternalWriteViewToXml(writer: EwsServiceXmlWriter): void {
        var maxEntriesReturned = this.GetMaxEntriesReturned();
        if (!isNaN(maxEntriesReturned)) {
            writer.WriteAttributeValue(XmlAttributeNames.MaxEntriesReturned, maxEntriesReturned);
        }
    }

    /**
	 * @internal Writes the attributes to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    abstract WriteAttributesToXml(writer: EwsServiceXmlWriter): void;

    /**
	 * @internal Writes OrderBy property to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    abstract WriteOrderByToXml(writer: EwsServiceXmlWriter): void;

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    WriteToXml(writer: EwsServiceXmlWriter, groupBy: Grouping): void {
        this.GetPropertySetOrDefault().WriteToXml(writer, this.GetServiceObjectType());
        writer.WriteStartElement(XmlNamespace.Messages, this.GetViewXmlElementName());
        this.InternalWriteViewToXml(writer);
        writer.WriteEndElement(); // this.GetViewXmlElementName()
        this.InternalWriteSearchSettingsToXml(writer, groupBy);
    }
}

/**
 * Represents a date range view of appointments in calendar folder search operations.
 */
export class CalendarView extends ViewBase {
    
    private traversal: ItemTraversal = ItemTraversal.Shallow;
    private maxItemsReturned: number = null;
    private startDate: DateTime = null;
    private endDate: DateTime = null;

    /**
     * Gets or sets the start date.
     */
    get StartDate(): DateTime {
        return this.startDate;
    }
    set StartDate(value: DateTime) {
        this.startDate = value;
    }

    /**
     * Gets or sets the end date.
     */
    get EndDate(): DateTime {
        return this.endDate;
    }
    set EndDate(value: DateTime) {
        this.endDate = value;
    }

    /**
     * The maximum number of items the search operation should return.
     */
    get MaxItemsReturned(): number {
        return this.maxItemsReturned;
    }
    set MaxItemsReturned(value: number) {
        if (value !== null && value <= 0) {
            throw new ArgumentException(Strings.ValueMustBeGreaterThanZero);
        }
        this.maxItemsReturned = value;
    }

    /**
     * Gets or sets the search traversal mode. Defaults to ItemTraversal.Shallow.
     */
    get Traversal(): ItemTraversal {
        return this.traversal;
    }
    set Traversal(value: ItemTraversal) {
        this.traversal = value;
    }

    /**
     * Initializes a new instance of CalendarView.
     *
     * @param   {DateTime}  startDate          The start date.
     * @param   {DateTime}  endDate            The end date.
     */
    constructor(startDate: DateTime, endDate: DateTime);
    /**
     * Initializes a new instance of CalendarView.
     *
     * @param   {DateTime}  startDate          The start date.
     * @param   {DateTime}  endDate            The end date.
     * @param   {number}    maxItemsReturned   The maximum number of items the search operation should return.
     */
    constructor(startDate: DateTime, endDate: DateTime, maxItemsReturned: number);
    constructor(startDate: DateTime, endDate: DateTime, maxItemsReturned: number = null) {
        super();
        this.startDate = startDate;
        this.endDate = endDate;
        this.MaxItemsReturned = maxItemsReturned;
    }

    /**
     * @internal Gets the maximum number of items or folders the search operation should return.
     *
     * @return  {number}      The maximum number of items the search operation should return.
     */
    GetMaxEntriesReturned(): number { return this.MaxItemsReturned; }

    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    GetServiceObjectType(): ServiceObjectType { return ServiceObjectType.Item; }

    /**
     * @internal Gets the name of the view XML element.
     *
     * @return  {string}      XML element name.
     */
    GetViewXmlElementName(): string { return XmlElementNames.CalendarView; }

    /**
     * @internal Validate instance.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    InternalValidate(request: ServiceRequestBase): void {
        super.InternalValidate(request);

        if (this.endDate < this.StartDate) {
            throw new ServiceValidationException(Strings.EndDateMustBeGreaterThanStartDate);
        }
    }

    /**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    InternalWriteSearchSettingsToXml(writer: EwsServiceXmlWriter, groupBy: Grouping): void { /* No search settings for calendar views. */ }

    /**
     * @internal Write to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternalWriteViewToXml(writer: EwsServiceXmlWriter): void {
        super.InternalWriteViewToXml(writer);

        writer.WriteAttributeValue(XmlAttributeNames.StartDate, this.StartDate);
        writer.WriteAttributeValue(XmlAttributeNames.EndDate, this.EndDate);
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void { writer.WriteAttributeValue(XmlAttributeNames.Traversal, ItemTraversal[this.Traversal]); }

    /**
     * @internal Writes OrderBy property to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer
     */
    WriteOrderByToXml(writer: EwsServiceXmlWriter): void { /* No OrderBy for calendar views. */ }
}

/**
 * Represents the view settings in a folder search operation.
 * 
 * @sealed
 */
export class SeekToConditionItemView extends ViewBase {

	private pageSize: number = null;
	private traversal: ItemTraversal = ItemTraversal.Shallow;
	private condition: SearchFilter = null;
	private offsetBasePoint: OffsetBasePoint = OffsetBasePoint.Beginning;
	private orderBy: OrderByCollection = new OrderByCollection();
	private serviceObjType: ServiceObjectType = ServiceObjectType.Folder;

	/**
	 * The maximum number of items or folders the search operation should return.
	 */
	get PageSize(): number {
		return this.pageSize;
	}
	set PageSize(value: number) {
		if (value <= 0) {
			throw new ArgumentException(Strings.ValueMustBeGreaterThanZero);
		}
		this.pageSize = value;
	}

	/**
	 * Gets or sets the base point of the offset.
	 */
	get OffsetBasePoint(): OffsetBasePoint {
		return this.offsetBasePoint;
	}
	set OffsetBasePoint(value: OffsetBasePoint) {
		this.offsetBasePoint = value;
	}

	/**
	 * Gets or sets the condition for seek. 
	 * Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection. 
	 * If SearchFilter is null, no search filters are applied.
	 */
	get Condition(): SearchFilter {
		return this.condition;
	}
	set Condition(value: SearchFilter) {
		if (value === null) {
			throw new ArgumentNullException("Condition");
		}
		this.condition = value;
	}

	/**
	 * Gets or sets the search traversal mode. Defaults to ItemTraversal.Shallow.
	 */
	get Traversal(): ItemTraversal {
		return this.traversal;
	}
	set Traversal(value: ItemTraversal) {
		this.traversal = value;
	}

	/**
	 * Gets the properties against which the returned items should be ordered.
	 */
	get OrderBy(): OrderByCollection {
		return this.orderBy;
	}

	/**
	 * Initializes a new instance of the **SeekToConditionItemView** class.
	 *
	 * @param   {SearchFilter}	condition         Condition to be used when seeking.
	 * @param   {number}		pageSize          The maximum number of elements the search operation should return.
	 */
	constructor(condition: SearchFilter, pageSize: number);
	/**
	 * Initializes a new instance of the **SeekToConditionItemView** class.
	 *
	 * @param   {SearchFilter}   	condition         Condition to be used when seeking.
	 * @param   {number}   			pageSize          The maximum number of elements the search operation should return.
	 * @param   {OffsetBasePoint}   offsetBasePoint   The base point of the offset.
	 */
	constructor(condition: SearchFilter, pageSize: number, offsetBasePoint: OffsetBasePoint);
	constructor(condition: SearchFilter, pageSize: number, offsetBasePoint: OffsetBasePoint = OffsetBasePoint.Beginning) {
		super();
		this.condition = condition;
		this.pageSize = pageSize;
		this.serviceObjType = ServiceObjectType.Item;
		this.offsetBasePoint = offsetBasePoint;
	}

	/**
     * @internal Gets the maximum number of items or folders the search operation should return.
     *
     * @return  {number?}      The maximum number of items or folders that should be returned by the search operation.
     */
    GetMaxEntriesReturned(): number {
		return this.PageSize;
	}

	/**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    GetServiceObjectType(): ServiceObjectType {
		return this.serviceObjType;
	}

	/**
     * @internal Gets the name of the view XML element.
     *
     * @return  {string}      XML element name.
     */
    GetViewXmlElementName(): string {
		return XmlElementNames.SeekToConditionPageItemView;
	}

	/**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    InternalValidate(request: ServiceRequestBase): void {
		super.InternalValidate(request);
	}

	/**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    InternalWriteSearchSettingsToXml(writer: EwsServiceXmlWriter, groupBy: Grouping): void {
		if (groupBy != null) {
			groupBy.WriteToXml(writer);
		}
	}

	/**
	 * @internal Writes this view to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    InternalWriteViewToXml(writer: EwsServiceXmlWriter): void {
		super.InternalWriteViewToXml(writer);

		writer.WriteAttributeValue(XmlAttributeNames.BasePoint, this.OffsetBasePoint);

		if (this.Condition != null) {
			writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Condition);
			this.Condition.WriteToXml(writer);
			writer.WriteEndElement(); // Restriction
		}
	}

	/**
     * @internal Sets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      Service object type
     */
    SetServiceObjectType(objType: ServiceObjectType): void {
		this.serviceObjType = objType;
	}

	/**
	 * @internal Writes the attributes to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
		if (this.serviceObjType == ServiceObjectType.Item) {
			writer.WriteAttributeValue(XmlAttributeNames.Traversal, this.Traversal);
		}
	}

	/**
	 * @internal Writes OrderBy property to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteOrderByToXml(writer: EwsServiceXmlWriter): void {
		this.orderBy.WriteToXml(writer, XmlElementNames.SortOrder);
	}

	/**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    WriteToXml(writer: EwsServiceXmlWriter, groupBy: Grouping): void {
		if (this.serviceObjType == ServiceObjectType.Item) {
			this.GetPropertySetOrDefault().WriteToXml(writer, this.GetServiceObjectType());
		}

		writer.WriteStartElement(XmlNamespace.Messages, this.GetViewXmlElementName());

		this.InternalWriteViewToXml(writer);

		writer.WriteEndElement(); // this.GetViewXmlElementName()
	}
}

/**
 * Represents a view settings that support paging in a search operation.
 */
export abstract class PagedView extends ViewBase { //abstract

    private pageSize: number = 0;
    private offsetBasePoint: OffsetBasePoint = OffsetBasePoint.Beginning;
    private offset: number = 0;

    /**
     * The maximum number of items or folders the search operation should return.
     */
    get PageSize(): number { return this.pageSize; }
    set PageSize(value) {
        if (value <= 0) {
            throw new Error(Strings.ValueMustBeGreaterThanZero);
        }
        this.pageSize = value;
    }

    /**
     * Gets or sets the base point of the offset.
     */
    get OffsetBasePoint(): OffsetBasePoint {
        return this.offsetBasePoint;
    }
    set OffsetBasePoint(value: OffsetBasePoint) {
        this.offsetBasePoint = value;
    }

    /**
     * Gets or sets the offset.
     */
    get Offset(): number { return this.offset; }
    set Offset(value) {
        if (value >= 0) {
            this.offset = value;
        }
        else {
            throw new Error(Strings.OffsetMustBeGreaterThanZero);
        }
    };

    /**
     * Initializes a new instance of the **PagedView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     */
    constructor(pageSize: number);
    /**
     * Initializes a new instance of the **PagedView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     * @param   {number}   offset            The offset of the view from the base point.
     */
    constructor(pageSize: number, offset: number);
    /**
     * Initializes a new instance of the **PagedView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     * @param   {number}   offset            The offset of the view from the base point.
     * @param   {number}   offsetBasePoint   The base point of the offset.
     */
    constructor(pageSize: number, offset: number, offsetBasePoint: OffsetBasePoint);
    constructor(pageSize: number, offset: number = 0, offsetBasePoint: OffsetBasePoint = OffsetBasePoint.Beginning) {
        super();
        this.pageSize = pageSize;
        this.Offset = offset;
        this.OffsetBasePoint = offsetBasePoint;
    }

    /**
     * @internal Gets the maximum number of items or folders the search operation should return.
     *
     * @return  {number?}      The maximum number of items or folders that should be returned by the search operation.
     */
    GetMaxEntriesReturned(): number { return this.PageSize; }

    /**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    InternalValidate(request: ServiceRequestBase): void { super.InternalValidate(request); }

    /**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    InternalWriteSearchSettingsToXml(writer: EwsServiceXmlWriter, groupBy: Grouping): void {
        if (groupBy !== null && typeof groupBy !== 'undefined') {
            groupBy.WriteToXml(writer);
        }
    }

    /**
	 * @internal Writes this view to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    InternalWriteViewToXml(writer: EwsServiceXmlWriter): void {
        super.InternalWriteViewToXml(writer);
        writer.WriteAttributeValue(XmlAttributeNames.Offset, this.Offset);
        writer.WriteAttributeValue(XmlAttributeNames.BasePoint, OffsetBasePoint[this.OffsetBasePoint]);
    }

    /**
	 * @internal Writes OrderBy property to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteOrderByToXml(writer: EwsServiceXmlWriter): void {
        /* No order by for paged view*/
    }
}

/**
 * Represents the view settings in a folder search operation.
 * 
 * @sealed
 */
export class ConversationIndexedItemView extends PagedView {

	private orderBy: OrderByCollection = new OrderByCollection();
	private traversal: ConversationQueryTraversal = null;
	private viewFilter: ViewFilter = null;

	/**
	 * Gets the properties against which the returned items should be ordered.
	 */
	get OrderBy(): OrderByCollection {
		return this.orderBy;
	}

	/**
	 * Gets or sets the conversation query traversal mode. 
	 * 
	 * @Nullable
	 */
	get Traversal(): ConversationQueryTraversal {
		return this.traversal;
	}
	set Traversal(value: ConversationQueryTraversal) {
		this.traversal = value;
	}

	/**
	 * Gets or sets the view filter. 
	 * 
	 * @Nullable
	 */
	get ViewFilter(): ViewFilter {
		return this.viewFilter;
	}
	set ViewFilter(value: ViewFilter) {
		this.viewFilter = value;
	}

	/**
     * Initializes a new instance of the **ItemView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     */
	constructor(pageSize: number);
    /**
     * Initializes a new instance of the **ItemView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     * @param   {number}   offset            The offset of the view from the base point.
     */
	constructor(pageSize: number, offset: number);
    /**
     * Initializes a new instance of the **ItemView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     * @param   {number}   offset            The offset of the view from the base point.
     * @param   {number}   offsetBasePoint   The base point of the offset.
     */
	constructor(pageSize: number, offset: number, offsetBasePoint: OffsetBasePoint);
	constructor(pageSize: number, offset: number = 0, offsetBasePoint: OffsetBasePoint = OffsetBasePoint.Beginning) {
		super(pageSize, offset, offsetBasePoint);
	}

	/**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
	GetServiceObjectType(): ServiceObjectType {
		return ServiceObjectType.Conversation;
	}

	/**
     * @internal Gets the name of the view XML element.
     *
     * @return  {type}      XML element name.
     */
	GetViewXmlElementName(): string {
		return XmlElementNames.IndexedPageItemView;
	}

	/**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
	InternalValidate(request: ServiceRequestBase): void {
		super.InternalValidate(request);

		if (hasValue(this.Traversal)) {
			EwsUtilities.ValidateEnumVersionValue(ConversationQueryTraversal, this.traversal, request.Service.RequestedServerVersion, "ConversationQueryTraversal");
		}

		if (this.ViewFilter) {
			EwsUtilities.ValidateEnumVersionValue(ViewFilter, this.viewFilter, request.Service.RequestedServerVersion, "ViewFilter");
		}
	}

	/**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
	InternalWriteSearchSettingsToXml(writer: EwsServiceXmlWriter, groupBy: Grouping): void {
		super.InternalWriteSearchSettingsToXml(writer, groupBy);
	}

	/**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
	WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
		if (hasValue(this.Traversal)) {
			writer.WriteAttributeValue(XmlAttributeNames.Traversal, ConversationQueryTraversal[this.Traversal]);
		}

		if (this.ViewFilter) {
			writer.WriteAttributeValue(XmlAttributeNames.ViewFilter, ViewFilter[this.ViewFilter]);
		}
	}

	/**
	 * @internal Writes OrderBy property to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
	WriteOrderByToXml(writer: EwsServiceXmlWriter): void {
		this.orderBy.WriteToXml(writer, XmlElementNames.SortOrder);
	}

	/**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
	WriteToXml(writer: EwsServiceXmlWriter, groupBy: Grouping): void {
		writer.WriteStartElement(XmlNamespace.Messages, this.GetViewXmlElementName());

		this.InternalWriteViewToXml(writer);

		writer.WriteEndElement(); // this.GetViewXmlElementName()
	}
}

/**
 * Represents the view settings in a folder search operation.
 *
 * @sealed
 */
export class FolderView extends PagedView {

    private traversal: FolderTraversal = FolderTraversal.Shallow;

    /**
     * Gets or sets the search traversal mode. Defaults to FolderTraversal.Shallow.     *
     */
    get Traversal(): FolderTraversal {
        return this.traversal;
    }
    set Traversal(value: FolderTraversal) {
        this.traversal = value;
    }

    /**
     * Initializes a new instance of the **FolderView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     */
    constructor(pageSize: number);
    /**
     * Initializes a new instance of the **FolderView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     * @param   {number}   offset            The offset of the view from the base point.
     */
    constructor(pageSize: number, offset: number);
    /**
     * Initializes a new instance of the **FolderView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     * @param   {number}   offset            The offset of the view from the base point.
     * @param   {number}   offsetBasePoint   The base point of the offset.
     */
    constructor(pageSize: number, offset: number, offsetBasePoint: OffsetBasePoint);
    constructor(pageSize: number, offset: number = 0, offsetBasePoint: OffsetBasePoint = OffsetBasePoint.Beginning) {
        super(pageSize, offset, offsetBasePoint);
    }

    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    GetServiceObjectType(): ServiceObjectType { return ServiceObjectType.Folder; }

    /**
     * @internal Gets the name of the view XML element.
     *
     * @return  {type}      XML element name.
     */
    GetViewXmlElementName(): string { return XmlElementNames.IndexedPageFolderView; }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void { writer.WriteAttributeValue(XmlAttributeNames.Traversal, FolderTraversal[this.Traversal]); }
}

/**
 * Represents the view settings in a folder search operation.
 * 
 * @sealed
 */
export class ItemView extends PagedView {

    private traversal: ItemTraversal = ItemTraversal.Shallow;
    private orderBy: OrderByCollection = new OrderByCollection();

    /**
     * Gets or sets the search traversal mode. Defaults to ItemTraversal.Shallow.
     */
    get Traversal(): ItemTraversal {
        return this.traversal;
    }
    set Traversal(value: ItemTraversal) {
        this.traversal = value;
    }

    /**
     * Gets the properties against which the returned items should be ordered.
     */
    get OrderBy(): OrderByCollection { return this.orderBy; }

    /**
     * Initializes a new instance of the **ItemView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     */
    constructor(pageSize: number);
    /**
     * Initializes a new instance of the **ItemView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     * @param   {number}   offset            The offset of the view from the base point.
     */
    constructor(pageSize: number, offset: number);
    /**
     * Initializes a new instance of the **ItemView** class.
     *
     * @param   {number}   pageSize          The maximum number of elements the search operation should return.
     * @param   {number}   offset            The offset of the view from the base point.
     * @param   {number}   offsetBasePoint   The base point of the offset.
     */
    constructor(pageSize: number, offset: number, offsetBasePoint: OffsetBasePoint);
    constructor(pageSize: number, offset: number = 0, offsetBasePoint: OffsetBasePoint = OffsetBasePoint.Beginning) {
        super(pageSize, offset, offsetBasePoint);
    }

    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    GetServiceObjectType(): ServiceObjectType { return ServiceObjectType.Item; }

    /**
     * @internal Gets the name of the view XML element.
     *
     * @return  {type}      XML element name.
     */
    GetViewXmlElementName(): string { return XmlElementNames.IndexedPageItemView; }

    /**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    InternalValidate(request: ServiceRequestBase): void {
        super.InternalValidate(request);
        EwsUtilities.ValidateEnumVersionValue(ItemTraversal, this.Traversal, request.Service.RequestedServerVersion, "ItemTraversal");
    }

    /**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    InternalWriteSearchSettingsToXml(writer: EwsServiceXmlWriter, groupBy: Grouping): void {
        super.InternalWriteSearchSettingsToXml(writer, groupBy);
    }

    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteAttributeValue(XmlAttributeNames.Traversal, ItemTraversal[this.Traversal]);
    }

    /**
	 * @internal Writes OrderBy property to XML.
	 *
	 * @param   {EwsServiceXmlWriter}   writer   The writer.
	 */
    WriteOrderByToXml(writer: EwsServiceXmlWriter): void {
        this.orderBy.WriteToXml(writer, XmlElementNames.SortOrder);
    }
}

/**
 * Represents the results of an conversation search operation.
 * 
 * @sealed
 */
export class FindConversationResults {

	/**
	 * Gets a collection containing the conversations that were found by the search operation.
	 */
	Conversations: Conversation[] = [];

	/**
	 * Gets a collection containing the HighlightTerms that were returned by the search operation.
	 */
	HighlightTerms: HighlightTerm[] = [];

	/**
	 * Gets the total count of conversations in view.
	 */
	TotalCount: number = null;

	/**
	 * Gets the indexed offset of the first conversation by the search operation.
	 */
	IndexedOffset: number = null;

	/**
	 * @internal Initializes a new instance of the **FindConversationResults** class.
	 */
	constructor() {
	}
}


/**
 * Represents the results of a folder search operation.
 * 
 * @sealed
 */
export class FindFoldersResults implements IEnumerable<Folder>  {

    private totalCount: number = 0;
    private nextPageOffset: number = null;
    private moreAvailable: boolean = false;
    private folders: Folder[] = [];

    /**
     * Gets the total number of folders matching the search criteria available in the searched folder. 
     */
    get TotalCount(): number {
        return this.totalCount;
    }
    set TotalCount(value: number) {
        this.totalCount = value;
    }

    /**
     * Gets the offset that should be used with FolderView to retrieve the next page of folders in a FindFolders operation.
     */
    get NextPageOffset(): number {
        return this.nextPageOffset;
    }
    set NextPageOffset(value: number) {
        this.nextPageOffset = value;
    }

    /**
     * Gets a value indicating whether more folders matching the search criteria.
     */
    get MoreAvailable(): boolean {
        return this.moreAvailable;
    }
    set MoreAvailable(value: boolean) {
        this.moreAvailable = value;
    }

    /**
     * Gets a collection containing the folders that were found by the search operation.
     */
    get Folders(): Folder[] {
        return this.folders;
    }

    /**
     * @internal Initializes a new instance of the **FindFoldersResults** class.
     *
     */
    constructor() { }

    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    GetEnumerator(): Folder[] {
        return this.folders;
    }
}

/**
 * Represents the results of an item search operation.
 * 
 * @sealed
 * @type    {TItem}  Item type
 */
export class FindItemsResults<TItem extends Item> { //IEnumerable<TItem>

    private totalCount: number = 0;
    private nextPageOffset: number = null;
    private moreAvailable: boolean = false;
    private items: TItem[] = [];
    private highlightTerms: HighlightTerm[] = [];

    /**
     * Gets the total number of items matching the search criteria available in the searched folder.
     */
    get TotalCount(): number {
        return this.totalCount;
    }
    set TotalCount(value: number) {
        this.totalCount = value;
    }

    /**
     * Gets the offset that should be used with ItemView to retrieve the next page of items in a FindItems operation.
     */
    get NextPageOffset(): number {
        return this.nextPageOffset;
    }
    set NextPageOffset(value: number) {
        this.nextPageOffset = value;
    }

    /**
     * Gets a value indicating whether more items matching the search criteria are available in the searched folder. 
     */
    get MoreAvailable(): boolean {
        return this.moreAvailable;
    }
    set MoreAvailable(value: boolean) {
        this.moreAvailable = value;
    }

    /**
     * Gets a collection containing the items that were found by the search operation.
     */
    get Items(): TItem[] {
        return this.items;
    }

    /**
     * Gets a collection containing the highlight terms that were found by the search operation.
     */
    get HighlightTerms(): HighlightTerm[] {
        return this.highlightTerms;
    }

    /**
     * @internal Initializes a new instance of the **FindItemsResults<T>** class.
     */
    constructor() {
    }

    //GetEnumerator(): any { throw new Error("FindItemsResults.ts - GetEnumerator : Not implemented."); }
}

/**
 * Represents the results of an item search operation.
 * 
 * @sealed
 * @type    {TItem} The type of item returned by the search operation.
 */
export class GroupedFindItemsResults<TItem extends Item> {    //: IEnumerable<ItemGroup<TItem>>

    private totalCount: number = 0;
    private nextPageOffset: number = null;
    private moreAvailable: boolean = false;

    /**
     * List of ItemGroups.
     */
    private itemGroups: ItemGroup<TItem>[] = [];

    /**
     * Gets the total number of items matching the search criteria available in the searched folder.
     */
    get TotalCount(): number {
        return this.totalCount;
    }
    set TotalCount(value: number) {
        this.totalCount = value;
    }

    /**
     * Gets the offset that should be used with ItemView to retrieve the next page of items in a FindItems operation.
     */
    get NextPageOffset(): number {
        return this.nextPageOffset;
    }
    set NextPageOffset(value: number) {
        this.nextPageOffset = value;
    }

    /**
     * Gets a value indicating whether more items corresponding to the search criteria are available in the searched folder. 
     */
    get MoreAvailable(): boolean {
        return this.moreAvailable;
    }
    set MoreAvailable(value: boolean) {
        this.moreAvailable = value;
    }

    /**
     * Gets the item groups returned by the search operation.
     */
    get ItemGroups(): ItemGroup<TItem>[] {
        return this.itemGroups;
    }

    /**
     * @internal Initializes a new instance of the **GroupedFindItemsResults<TItem>** class.
     */
    constructor() {
    }

    GetEnumerator(): any { throw new Error("GroupedFindItemsResults.ts - GetEnumerator : Not implemented."); }
}

/**
 * Represents grouping options in item search operations.
 * 
 * @sealed
 */
export class Grouping implements ISelfValidate { //:IJsonSerializable

    /**
     * Gets or sets the sort direction.
     */
    SortDirection: SortDirection = SortDirection.Ascending;

    /**
     * Gets or sets the property to group on.
     */
    GroupOn: PropertyDefinitionBase = null;

    /**
     * Gets or sets the property to aggregate on.
     */
    AggregateOn: PropertyDefinitionBase = null;

    /**
     * Gets or sets the types of aggregate to calculate.
     */
    AggregateType: AggregateType = AggregateType.Minimum;

    /** no need for setter getter */
    // private sortDirection: SortDirection = SortDirection.Ascending;
    // private groupOn: PropertyDefinitionBase;
    // private aggregateOn: PropertyDefinitionBase;
    // private aggregateType: AggregateType;

    /**
     * Initializes a new instance of the **Grouping** class.
     */
    constructor();
    /**
     * Initializes a new instance of the **Grouping** class.
     *
     * @param   {PropertyDefinitionBase}   groupOn         The property to group on.
     * @param   {SortDirection}   sortDirection   The sort direction.
     * @param   {PropertyDefinitionBase}   aggregateOn     The property to aggregate on.
     * @param   {AggregateType}   aggregateType   The type of aggregate to calculate.
     */
    constructor(groupOn: PropertyDefinitionBase, sortDirection: SortDirection, aggregateOn: PropertyDefinitionBase, aggregateType: AggregateType);
    constructor(
        groupOn?: PropertyDefinitionBase,
        sortDirection?: SortDirection,
        aggregateOn?: PropertyDefinitionBase,
        aggregateType?: AggregateType) {
        if (arguments.length > 0 && arguments.length < 4) {
            throw new Error("Grouping.ts - ctor: incorrect number of parameters for constructor call");
        }
        EwsUtilities.ValidateParam(groupOn, "groupOn");
        EwsUtilities.ValidateParam(aggregateOn, "aggregateOn");

        this.GroupOn = groupOn;
        this.SortDirection = sortDirection;
        this.AggregateOn = aggregateOn;
        this.AggregateType = aggregateType;
    }

    /**
     * Validates this grouping.
     */
    private InternalValidate(): void {
        EwsUtilities.ValidateParam(this.GroupOn, "GroupOn");
        EwsUtilities.ValidateParam(this.AggregateOn, "AggregateOn");
    }

    /**
     * Implements ISelfValidate.Validate. Validates this grouping.
     */
    Validate(): void {
        this.InternalValidate();
    }
    
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WriteToXml(writer: EwsServiceXmlWriter): void {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.GroupBy);
        writer.WriteAttributeValue(XmlAttributeNames.Order, SortDirection[this.SortDirection]);

        this.GroupOn.WriteToXml(writer);

        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AggregateOn);
        writer.WriteAttributeValue(XmlAttributeNames.Aggregate, AggregateType[this.AggregateType]);

        this.AggregateOn.WriteToXml(writer);

        writer.WriteEndElement(); // AggregateOn

        writer.WriteEndElement(); // GroupBy
    }
}
export class ItemGroup<TItem extends Item> {
    GroupIndex: string;
    Items: TItem[] = [];//System.Collections.ObjectModel.Collection<TItem>;
    constructor(groupIndex: string, items: TItem[]) {
        EwsLogging.Assert(
            items != null,
            "ItemGroup.ctor",
            "items is null");

        this.GroupIndex = groupIndex;
        this.Items = items; //new Collection<TItem>(items);
    }
}

export type PropertyDefinitionSortDirectionPair = KeyValuePair<PropertyDefinitionBase, SortDirection>;

/**
 * Represents an ordered collection of property definitions qualified with a sort direction.
 * 
 * @sealed
 */
export class OrderByCollection implements IEnumerable<PropertyDefinitionSortDirectionPair> {  //: IJsonSerializable

    private propDefSortOrderPairList: PropertyDefinitionSortDirectionPair[];

    /**
     * Gets the number of elements contained in the collection.
     */
    get Count(): number {
        return this.propDefSortOrderPairList.length;
    }

    /**
     * @internal Initializes a new instance of the **OrderByCollection** class.
     */
    constructor() {
        this.propDefSortOrderPairList = [];
    }

    /**
     * Gets the element at the specified index from the collection.
     *
     * @param   {number}   index   Index.
     */
    _getItem(index: number): PropertyDefinitionSortDirectionPair {
        return this.propDefSortOrderPairList[index];
    }

    /**
     * Adds the specified property definition / sort direction pair to the collection.
     *
     * @param   {PropertyDefinitionBase}    propertyDefinition   The property definition.
     * @param   {SortDirection}             sortDirection        The sort direction.
     */
    Add(propertyDefinition: PropertyDefinitionBase, sortDirection: SortDirection): void {
        if (this.Contains(propertyDefinition)) {
            throw new ServiceLocalException(StringHelper.Format(Strings.PropertyAlreadyExistsInOrderByCollection, propertyDefinition.GetPrintableName()));
        }

        this.propDefSortOrderPairList.push({ key: propertyDefinition, value: sortDirection }); //new PropertyDefinitionSortDirectionPair() not seamless in javascript
    }

    /**
     * Removes all elements from the collection.
     */
    Clear(): void {
        this.propDefSortOrderPairList.splice(0);
    }

    /**
     * @internal Determines whether the collection contains the specified property definition.
     *
     * @param   {PropertyDefinitionBase}   propertyDefinition   The property definition.
     * @return  {boolean}   True if the collection contains the specified property definition; otherwise, false.
     */
    Contains(propertyDefinition: PropertyDefinitionBase): boolean {
        this.propDefSortOrderPairList.forEach((pair, index) => {
            //debugger;// check if equality works or need to use any property
            if (pair.key === propertyDefinition)
                return true;
        });
        return false;
    }

    /**
     *  Returns an enumerator that iterates through the collection. this case this.propDefSortOrderPairList
     */
    GetEnumerator(): PropertyDefinitionSortDirectionPair[] {
        return this.propDefSortOrderPairList;
    }

    /**
     * @internal Removes the specified property definition from the collection.
     *
     * @param   {PropertyDefinitionBase}   propertyDefinition   The property definition.
     * @return  {boolean}   True if the property definition is successfully removed; otherwise, false
     */
    Remove(propertyDefinition: PropertyDefinitionBase): boolean {
        var oldCount = this.Count;
        this.propDefSortOrderPairList = this.propDefSortOrderPairList.filter((value) => { return value.key !== propertyDefinition; });
        return oldCount > this.Count;
    }

    /**
     * @internal Removes the element at the specified index from the collection.
     *
     * @param   {number}   index   The index.
     */
    RemoveAt(index: number): void {
        this.propDefSortOrderPairList.splice(index, 1);
    }

    /**
     * Tries to get the value for a property definition in the collection.
     *
     * @param   {PropertyDefinitionBase}    propertyDefinition   The property definition.
     * @param   {IOutParam<SortDirection>}  sortDirection        The sort direction.
     * @return  {boolean}                   True if collection contains property definition, otherwise false.
     */
    TryGetValue(propertyDefinition: PropertyDefinitionBase, sortDirection: IOutParam<SortDirection>): boolean {
        for (var pair of this.propDefSortOrderPairList) {
            if (pair.key == propertyDefinition) { //possible bug - log at Github
                sortDirection.outValue = pair.value;
                return true;
            }
        }

        sortDirection.outValue = SortDirection.Ascending;        // out parameter has to be set to some value.
        return false;
    }

    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void {
        if (this.Count > 0) {
            writer.WriteStartElement(XmlNamespace.Messages, xmlElementName);

            for (var keyValuePair of this.propDefSortOrderPairList) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.FieldOrder);

                writer.WriteAttributeValue(XmlAttributeNames.Order, keyValuePair.value);
                keyValuePair.key.WriteToXml(writer);

                writer.WriteEndElement(); // FieldOrder
            }
            writer.WriteEndElement();
        }
    }
}
			
// class SafeXmlDocument extends System.Xml.XmlDocument {
//	private settings: any /*System.Xml.XmlReaderSettings*/;
//	Load(inStream: any /*System.IO.Stream*/): void{ throw new Error("SafeXmlDocument.ts - Load : Not implemented.");}
//	//Load(filename: string): void{ throw new Error("SafeXmlDocument.ts - Load : Not implemented.");}
//	//Load(txtReader: any /*System.IO.TextReader*/): void{ throw new Error("SafeXmlDocument.ts - Load : Not implemented.");}
//	//Load(reader: any /*System.Xml.XmlReader*/): void{ throw new Error("SafeXmlDocument.ts - Load : Not implemented.");}
//	LoadXml(xml: string): void{ throw new Error("SafeXmlDocument.ts - LoadXml : Not implemented.");}
//}





			
export class SafeXmlFactory {
	private static defaultSettings: any /*System.Xml.XmlReaderSettings*/;
	CreateSafeXmlTextReader(stream: any /*System.IO.Stream*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(xmlFragment: string, fragType: any /*System.Xml.XmlNodeType*/, context: any /*System.Xml.XmlParserContext*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(url: string, input: any /*System.IO.TextReader*/, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(url: string, input: any /*System.IO.Stream*/, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(input: any /*System.IO.TextReader*/, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(url: string, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(xmlFragment: any /*System.IO.Stream*/, fragType: any /*System.Xml.XmlNodeType*/, context: any /*System.Xml.XmlParserContext*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(url: string, input: any /*System.IO.Stream*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(input: any /*System.IO.Stream*/, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(input: any /*System.IO.TextReader*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(url: string): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	//CreateSafeXmlTextReader(url: string, input: any /*System.IO.TextReader*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
	CreateXPathDocument(uri: string, space: any /*System.Xml.XmlSpace*/): any /*System.Xml.XPath.XPathDocument*/{ throw new Error("SafeXmlFactory.ts - CreateXPathDocument : Not implemented.");}
	//CreateXPathDocument(stream: any /*System.IO.Stream*/): any /*System.Xml.XPath.XPathDocument*/{ throw new Error("SafeXmlFactory.ts - CreateXPathDocument : Not implemented.");}
	//CreateXPathDocument(uri: string): any /*System.Xml.XPath.XPathDocument*/{ throw new Error("SafeXmlFactory.ts - CreateXPathDocument : Not implemented.");}
	//CreateXPathDocument(textReader: any /*System.IO.TextReader*/): any /*System.Xml.XPath.XPathDocument*/{ throw new Error("SafeXmlFactory.ts - CreateXPathDocument : Not implemented.");}
	//CreateXPathDocument(reader: any /*System.Xml.XmlReader*/): any /*System.Xml.XPath.XPathDocument*/{ throw new Error("SafeXmlFactory.ts - CreateXPathDocument : Not implemented.");}
	//CreateXPathDocument(reader: any /*System.Xml.XmlReader*/, space: any /*System.Xml.XmlSpace*/): any /*System.Xml.XPath.XPathDocument*/{ throw new Error("SafeXmlFactory.ts - CreateXPathDocument : Not implemented.");}
}






			
			
// class SafeXmlSchema extends System.Xml.Schema.XmlSchema {
//	private static defaultSettings: any /*System.Xml.XmlReaderSettings*/;
//	Read(stream: any /*System.IO.Stream*/, validationEventHandler: any /*System.Xml.Schema.ValidationEventHandler*/): any /*System.Xml.Schema.XmlSchema*/{ throw new Error("SafeXmlSchema.ts - Read : Not implemented.");}
//	//Read(reader: any /*System.IO.TextReader*/, validationEventHandler: any /*System.Xml.Schema.ValidationEventHandler*/): any /*System.Xml.Schema.XmlSchema*/{ throw new Error("SafeXmlSchema.ts - Read : Not implemented.");}
//	//Read(reader: any /*System.Xml.XmlReader*/, validationEventHandler: any /*System.Xml.Schema.ValidationEventHandler*/): any /*System.Xml.Schema.XmlSchema*/{ throw new Error("SafeXmlSchema.ts - Read : Not implemented.");}
//}
//export = SafeXmlSchema;





			
export class SecurityTimestamp {
	static DefaultTimestampValidityDurationString: string = "00:05:00";
	static DefaultFormat: string = "yyyy-MM-ddTHH:mm:ss.fffZ";
	CreationTimeUtc: Date;
	ExpiryTimeUtc: Date;
	Id: string;
	DigestAlgorithm: string;
	private id: string;
	private digestAlgorithm: string;
	private digest: any /*System.Byte[]*/;
	private computedCreationTimeUtc: any[] /*System.Char[]*/;
	private computedExpiryTimeUtc: any[] /*System.Char[]*/;
	private creationTimeUtc: Date;
	private expiryTimeUtc: Date;
	static DefaultTimestampValidityDuration: any /*System.TimeSpan*/;
	static DefaultTimeToLive: any /*System.TimeSpan*/;
	GetCreationTimeChars(): any[] /*System.Char[]*/ { throw new Error("SecurityTimestamp.ts - GetCreationTimeChars : Not implemented."); }
	GetDigest(): any /*System.Byte[]*/ { throw new Error("SecurityTimestamp.ts - GetDigest : Not implemented."); }
	GetExpiryTimeChars(): any[] /*System.Char[]*/ { throw new Error("SecurityTimestamp.ts - GetExpiryTimeChars : Not implemented."); }
	ToChars(utcTime: Date): any[] /*System.Char[]*/ { throw new Error("SecurityTimestamp.ts - ToChars : Not implemented."); }
	//ToChars(n: number, buffer: any[] /*System.Char[]*/, offset: number /*System.Int32&*/, count: number): void{ throw new Error("SecurityTimestamp.ts - ToChars : Not implemented.");}
	ToString(): string { throw new Error("SecurityTimestamp.ts - ToString : Not implemented."); }
}






			
			
// class XmlDtdException extends System.Xml.XmlException {
//	Message: string;
//}
//export = XmlDtdException;





			

/**
 * Represents a change as returned by a synchronization operation.
 */
export abstract class Change {

	/**
	 * The type of change.
	 */
	private changeType: ChangeType = ChangeType.Create;

	/**
	 * The service object the change applies to.
	 */
	private serviceObject: ServiceObject = null;

	/**
	 * The Id of the service object the change applies to.
	 */
	private id: ServiceId = null;

	/**
	 * Gets the type of the change.
	 */
	get ChangeType(): ChangeType {
		return this.changeType;
	}
	set ChangeType(value: ChangeType) {
		this.changeType = value;
	}

	/**
	 * @internal Gets or sets the service object the change applies to.
	 */
	get ServiceObject(): ServiceObject {
		return this.serviceObject;
	}
	set ServiceObject(value: ServiceObject) {
		this.serviceObject = value;
	}

	/**
	 * @internal Gets or sets the Id of the service object the change applies to.
	 */
	get Id(): ServiceId {
		return this.ServiceObject != null ? this.ServiceObject.GetId() : this.id;
	}
	set Id(value: ServiceId) {
		this.id = value;
	}

	/**
	 * @internal Initializes a new instance of **Change** class.
	 */
	constructor() {
	}

	/**
	 * @internal Creates an Id of the appropriate class.
	 *
	 * @return  {ServiceId}      A ServiceId.
	 */
	abstract CreateId(): ServiceId;
}

/**
 * Represents a collection of changes as returned by a synchronization operation.
 *
 * @sealed
 * @typeparam	{TChange}	Type representing the type of change (e.g. FolderChange or ItemChange)
 */
export class ChangeCollection<TChange extends Change> implements IEnumerable<TChange>{

	___typeGenerics: string[] = ["Change"];

	private changes: TChange[] = [];
	private syncState: string = null;
	private moreChangesAvailable: boolean = false;

	/**
	 * Gets the number of changes in the collection.
	 */
	get Count(): number {
		return this.changes.length;
	}

	/**
	 * Gets the SyncState blob returned by a synchronization operation.
	 */
	get SyncState(): string {
		return this.syncState;
	}
	set SyncState(value: string) {
		this.syncState = value;
	}

	/**
	 * Gets a value indicating whether the there are more changes to be synchronized from the server.
	 */
	get MoreChangesAvailable(): boolean {
		return this.moreChangesAvailable;
	}
	set MoreChangesAvailable(value: boolean) {
		this.moreChangesAvailable = value;
	}

	/**
	 * @internal Initializes a new instance of the **ChangeCollection<TChange>** class. 
	 */
	constructor() {
	}

	/**
     * Gets an individual change from the change collection.
     *
     * @param   {number}   index   Zero-based index.
     * @return  {TChange}		An single change.
     */
	_getItem(index: number): TChange {
		if (index < 0 || index >= this.Count) {
			throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
		}
		return this.changes[index];
	}

	/**
	 * @internal Adds the specified change.
	 *
	 * @param   {TChange}   change   The change.
	 */
	Add(change: TChange): void {
		EwsLogging.Assert(
			change != null,
			"ChangeList.Add",
			"change is null");

		this.changes.push(change);
	}

	/**
     *  Returns an enumerator that iterates through the collection. this case this.changes
     */
	GetEnumerator(): TChange[] {
		return this.changes;
	}
}

/**
 * Represents a change on a folder as returned by a synchronization operation.
 * 
 * @sealed
 */
export class FolderChange extends Change {

	/**
	 * Gets the folder the change applies to. Folder is null when ChangeType is equal to ChangeType.Delete. In that case, use the FolderId property to retrieve the Id of the folder that was deleted.
	 */
	get Folder(): Folder {
		return <Folder>this.ServiceObject;
	}

	/**
	 * Gets the Id of the folder the change applies to.
	 */
	get FolderId(): FolderId {
		return <FolderId>this.Id;
	}

	/**
	 * @internal Initializes a new instance of **FolderChange** class.
	 */
	constructor() {
		super();
	}

	/**
	 * @internal Creates an FolderId instance.
	 *
	 * @return  {ServiceId}      A FolderId.
	 */
	CreateId(): ServiceId { 
		return new FolderId();
	}
}

/**
 * Represents a change on an item as returned by a synchronization operation.
 * 
 * @sealed
 */
export class ItemChange extends Change {

	private isRead: boolean = false;

	/**
	 * Gets the item the change applies to. Item is null when ChangeType is equal to either ChangeType.Delete or ChangeType.ReadFlagChange. In those cases, use the ItemId property to retrieve the Id of the item that was deleted or whose IsRead property changed.
	 */
	get Item(): Item {
		return <Item>this.ServiceObject;
	}

	/**
	 * Gets the IsRead property for the item that the change applies to. IsRead is only valid when ChangeType is equal to ChangeType.ReadFlagChange.
	 */
	get IsRead(): boolean {
		return this.isRead;
	}
	set IsRead(value: boolean) {
		this.isRead = value;
	}

	/**
	 * Gets the Id of the item the change applies to.
	 */
	get ItemId(): ItemId {
		return <ItemId>this.Id;
	}

	/**
	 * @internal Initializes a new instance of **ItemChange** class.
	 */
	constructor() {
		super()
	}

	/**
	 * @internal Creates an ItemId instance.
	 *
	 * @return  {ServiceId}      A ItemId.
	 */
	CreateId(): ServiceId {
		return new ItemId();
	}
}
export class PhoneCall extends ComplexProperty {
    private static SuccessfulResponseText: string = "OK";
    private static SuccessfulResponseCode: number = 200;
    State: PhoneCallState;
    ConnectionFailureCause: ConnectionFailureCause;
    SIPResponseText: string;
    SIPResponseCode: number;
    private service: ExchangeService;
    private state: PhoneCallState;
    private connectionFailureCause: ConnectionFailureCause;
    private sipResponseText: string;
    private sipResponseCode: number;
    private id: PhoneCallId;
    Disconnect(): any { throw new Error("PhoneCall.ts - Disconnect : Not implemented."); }
    LoadFromJson(jsonProperty: JsonObject, service: ExchangeService): any { throw new Error("PhoneCall.ts - LoadFromJson : Not implemented."); }
    Refresh(): any { throw new Error("PhoneCall.ts - Refresh : Not implemented."); }
    /**@internal */
    ReadElementsFromXmlJsObject(reader: EwsServiceXmlReader): boolean { throw new Error("PhoneCall.ts - TryReadElementFromXmlJsObject : Not implemented."); }
}


//}



export class PhoneCallId extends ComplexProperty {
    Id: string;
    private id: string;
    InternalToJson(service: ExchangeService): any { throw new Error("PhoneCallId.ts - InternalToJson : Not implemented."); }
    LoadFromJson(jsonProperty: JsonObject, service: ExchangeService): any { throw new Error("PhoneCallId.ts - LoadFromJson : Not implemented."); }
    /**@internal */
    ReadAttributesFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("PhoneCallId.ts - ReadAttributesFromXml : Not implemented."); }
    /**@internal */
    WriteAttributesToXml(writer: EwsServiceXmlWriter): any { throw new Error("PhoneCallId.ts - WriteAttributesToXml : Not implemented."); }
    /**@internal */
    WriteToXml(writer: EwsServiceXmlWriter): any { throw new Error("PhoneCallId.ts - WriteToXml : Not implemented."); }
}


//}



export class UnifiedMessaging {
    private service: ExchangeService;
    constructor(service:ExchangeService){
        this.service = service;
    }
    DisconnectPhoneCall(id: PhoneCallId): any { throw new Error("UnifiedMessaging.ts - DisconnectPhoneCall : Not implemented."); }
    GetPhoneCallInformation(id: PhoneCallId): PhoneCall { throw new Error("UnifiedMessaging.ts - GetPhoneCallInformation : Not implemented."); }
    PlayOnPhone(itemId: ItemId, dialString: string): PhoneCall { throw new Error("UnifiedMessaging.ts - PlayOnPhone : Not implemented."); }
}



TypeContainer.ServiceObject = ServiceObject;
TypeContainer.Folder = Folder;
TypeContainer.CalendarFolder = CalendarFolder;
TypeContainer.ContactsFolder = ContactsFolder;
TypeContainer.SearchFolder = SearchFolder;
TypeContainer.TasksFolder = TasksFolder;
TypeContainer.Item = Item;
TypeContainer.Appointment = Appointment;
TypeContainer.MeetingRequest = MeetingRequest;
TypeContainer.MeetingResponse = MeetingResponse;
TypeContainer.MeetingCancellation = MeetingCancellation;
TypeContainer.ItemAttachment = ItemAttachment;
TypeContainer.ItemAttachmentOf = ItemAttachmentOf
TypeContainer.ExchangeService = ExchangeService;
TypeContainer.IndexedPropertyDefinition = IndexedPropertyDefinition;
TypeContainer.ExtendedPropertyDefinition = ExtendedPropertyDefinition;
